{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./shells/lib/source/worker.js","webpack:///(webpack)/buildin/global.js","webpack:///./build/runtime/particle-execution-context.js","webpack:///./build/platform/assert-web.js","webpack:///./build/runtime/api-channel.js","webpack:///./build/runtime/particle-spec.js","webpack:///./build/runtime/modality.js","webpack:///./build/runtime/recipe/type-checker.js","webpack:///./build/runtime/type.js","webpack:///./build/runtime/interface-info.js","webpack:///./build/runtime/manifest-ast-nodes.js","webpack:///./build/runtime/flags.js","webpack:///./build/runtime/slot-info.js","webpack:///./build/runtime/synthetic-types.js","webpack:///./build/runtime/type-variable-info.js","webpack:///./build/runtime/schema.js","webpack:///./build/runtime/entity.js","webpack:///./build/runtime/reference.js","webpack:///./build/runtime/handle.js","webpack:///./build/runtime/arc-exceptions.js","webpack:///./build/runtime/storage-proxy.js","webpack:///./build/platform/sourcemapped-stacktrace-node.js","webpack:///./build/runtime/storage/crdt-collection-model.js","webpack:///./build/runtime/id.js","webpack:///./build/runtime/random.js","webpack:///./build/runtime/symbols.js","webpack:///./build/runtime/storageNG/handle.js","webpack:///./build/runtime/crdt/crdt-collection.js","webpack:///./build/runtime/crdt/crdt.js","webpack:///./build/runtime/crdt/crdt-singleton.js","webpack:///./build/runtime/storageNG/storage-proxy.js","webpack:///./build/runtime/storageNG/store.js","webpack:///./build/runtime/storageNG/drivers/driver-factory.js","webpack:///./build/runtime/storageNG/store-interface.js","webpack:///./build/runtime/storageNG/direct-store.js","webpack:///./build/runtime/util.js","webpack:///./build/runtime/storageNG/reference-mode-store.js","webpack:///./build/runtime/storageNG/backing-store.js","webpack:///./build/runtime/crdt/crdt-entity.js","webpack:///./build/runtime/storageNG/unified-store.js","webpack:///./build/runtime/recipe/comparable.js","webpack:///./build/runtime/storageNG/reference-mode-storage-key.js","webpack:///./build/runtime/storageNG/storage-key.js","webpack:///./build/runtime/crdt/crdt-count.js","webpack:///./build/runtime/particle-check.js","webpack:///./build/runtime/particle-claim.js","webpack:///./build/runtime/slot-proxy.js","webpack:///./build/runtime/wasm.js","webpack:///./build/runtime/particle.js","webpack:///./build/runtime/bimap.js","webpack:///./build/platform/loader.js","webpack:///./build/platform/loader-web.js","webpack:///./build/platform/logs-factory.js","webpack:///./build/platform/log-web.js","webpack:///./build/platform/loader-base.js","webpack:///./build/platform/fetch-web.js","webpack:///./build/runtime/converters/jsonldToManifest.js","webpack:///./build/runtime/dom-particle.js","webpack:///./modalities/dom/components/xen/xen-state.js","webpack:///./build/runtime/dom-particle-base.js","webpack:///./build/runtime/transformation-dom-particle.js","webpack:///./build/runtime/multiplexer-dom-particle.js","webpack:///./build/runtime/ui-particle.js","webpack:///./build/runtime/ui-particle-base.js","webpack:///./build/runtime/ui-multiplexer-particle.js","webpack:///./build/runtime/ui-transformation-particle.js","webpack:///./build/runtime/html.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8F;AACjC;AACJ;;AAEzD;AACA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;AACA,MAAM,qGAAwB,aAAa,uDAAE,iBAAiB,gEAAW,mBAAmB,gEAAM;AAClG;;;;;;;;ACxBA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACH;AACD;AACH;AAC6B;AACK;AACtB;AACJ;AACjB;AAC5B;AACP;AACA;AACA;AACA,6BAA6B,uEAAqB;AAClD;AACA;AACA;AACA,yCAAyC,4DAAY;AACrD;AACA,oBAAoB,+CAAK;AACzB,+BAA+B,wEAAc;AAC7C;AACA,uBAAuB,8DAAY;AACnC;AACA;AACA;AACA,oBAAoB,+CAAK;AACzB,gCAAgC,wEAAc;AAC9C;AACA;AACA,4BAA4B,8DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAK;AACzB,gCAAgC,wEAAc;AAC9C;AACA;AACA,4BAA4B,8DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAS;AACnD;AACA;AACA;AACA,gBAAgB,sEAAM,qEAAqE,mBAAmB,QAAQ,SAAS;AAC/H;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAgB,EAAE,wDAAwD;AAC7G;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,aAAa;AACb;AACA,0GAA0G;AAC1G;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA,4BAA4B,gEAAa;AACzC;AACA,SAAS;AACT,+BAA+B,0BAA0B;AACzD,iCAAiC,8DAAY;AAC7C;AACA;AACA,sCAAsC,wEAAc;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA,4BAA4B,sDAAa;AACzC;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAY;AACpB,6BAA6B,qDAAY;AACzC,QAAQ,qDAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;;ACjWA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sC;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,mCAAmC,oCAAoC;AACvE;AACmD;AACD;AACjB;AACyB;AACP;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,gBAAgB,YAAY,sBAAsB,eAAe;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC,YAAY,UAAU,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC,cAAc;AACrE;AACA;AACA;AACA;AACA,0DAA0D,gCAAgC;AAC1F;AACA;AACA,0DAA0D,iCAAiC;AAC3F;AACA;AACA;AACA;AACA;AACA,0DAA0D,+DAA+D;AACzH;AACA;AACA,0DAA0D,gEAAgE;AAC1H;AACA;AACA,0DAA0D,8CAA8C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM,0BAA0B,sGAAsG,GAAG,GAAG;AACpJ;AACA,QAAQ,uEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB;AACA,YAAY,uEAAsB;AAClC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB;AACA;AACA;AACA,YAAY,sEAAM;AAClB,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM,kDAAkD,MAAM;AACtE;AACA;AACA;AACA,QAAQ,sEAAM,qCAAqC,GAAG;AACtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yCAAyC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,qCAAqC;AACrC,qDAAqD;AACrD,6CAA6C;AAC7C,qCAAqC;AACrC,wCAAwC;AACxC,oCAAoC;AACpC,wBAAwB;AACxB,kEAAkE;AAClE,oCAAoC;AACpC,0EAA0E;AAC1E,yCAAyC;AACzC,4DAA4D;AAC5D,gDAAgD;AAChD,sDAAsD;AACtD,2FAA2F;AAC3F;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,2DAA2D,6CAAI;AAC/D;AACA;AACA,8FAA8F,8DAAY;AAC1G;AACA;AACA,qEAAqE,8DAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,6CAAI;AAChF;AACA;AACA;AACA;AACA;AACA,4EAA4E,6CAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,+BAA+B;AAC/B,uCAAuC;AACvC,wCAAwC;AACxC,iCAAiC;AACjC,oCAAoC;AACpC,kDAAkD;AAClD,8CAA8C;AAC9C,qDAAqD;AACrD,sDAAsD;AACtD,8DAA8D;AAC9D,uDAAuD;AACvD,kDAAkD;AAClD,yCAAyC;AACzC,oDAAoD;AACpD,6CAA6C;AAC7C,8BAA8B;AAC9B,iDAAiD;AACjD,2CAA2C;AAC3C,gDAAgD;AAChD,yCAAyC;AACzC;AACA,iDAAiD;AACjD,4FAA4F;AAC5F,0CAA0C;AAC1C,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,6CAAI;AAC1E;AACA;AACA;AACA;AACA;AACA,4EAA4E,6CAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAmB;AAC5C;AACA;AACA;AACA;AACwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;ACpmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACV;AACc;AACG;AACR;AACQ;AACvB;AACgB;AACnD;AACA,yBAAyB,6CAAI,QAAQ,6CAAI;AACzC;AACA;AACA,yBAAyB,6CAAI;AAC7B;AACO,iBAAiB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAW,eAAe,OAAO,GAAG,6CAA6C;AAChG;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,yBAAyB;AAC/C,qBAAqB,mBAAmB;AACxC;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC,qDAAQ,0BAA0B,qDAAQ;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAM;AAC9C,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU,0CAA0C,gBAAgB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uHAAuH;AACtI,sCAAsC,0DAA0D,OAAO,8HAA8H;AACrO;AACA,gBAAgB;AAChB;AACA;AACA,aAAa,uHAAuH;AACpI,wCAAwC,0DAA0D,OAAO,qJAAqJ;AAC9P;AACA,iCAAiC,oIAAoI;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM,+GAA+G,EAAE;AACnI,SAAS;AACT;AACA;AACA;AACA,QAAQ,sEAAM;AACd,8CAA8C,wBAAwB,OAAO,sCAAsC;AACnH;AACA,eAAe,sDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU,EAAE,MAAM;AAC9C;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D,gBAAgB,+CAAK;AACrB;AACA,gCAAgC,OAAO,EAAE,qBAAqB,EAAE,iCAAiC,GAAG,2BAA2B,GAAG,gBAAgB,EAAE,KAAK;AACzJ;AACA;AACA,qEAAqE,sFAAuC,8CAA8C;AAC1J,gCAAgC,OAAO,EAAE,gBAAgB,IAAI,IAAI,EAAE,2BAA2B,EAAE,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,yBAAyB;AACrF,4DAA4D,yBAAyB;AACrF,oEAAoE,EAAE;AACtE;AACA;AACA,gBAAgB,+CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE;AACtD;AACA,gCAAgC,OAAO,EAAE,iBAAiB;AAC1D;AACA,oCAAoC,OAAO,eAAe,aAAa;AACvE;AACA;AACA,oCAAoC,OAAO,WAAW,OAAO;AAC7D;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,UAAU,GAAG,wBAAwB;AACpE;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA,6CAA6C,OAAO;AACpD;AACA,4DAA4D,EAAE,qBAAqB;AACnF;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,oDAAoD,EAAE;AACtD;AACA,gCAAgC,OAAO,EAAE,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,wCAAwC,QAAQ,KAAK,WAAW;AAChE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,iBAAiB;AAC7F;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA,sFAAsF,iBAAiB;AACvG;AACA,sCAAsC,8EAAmB;AACzD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,WAAW;AAC/F;AACA;AACA;AACA;AACA,gFAAgF,WAAW;AAC3F;AACA;AACA;AACA,4EAA4E,WAAW,kBAAkB,iBAAiB;AAC1H;AACA;AACA,6FAA6F,WAAW;AACxG;AACA,uCAAuC,sEAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA,yCAAyC,sEAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;AClcA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;ACjEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuI;AAChI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6CAAI;AACnD,qCAAqC,qDAAY;AACjD,yCAAyC,qDAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAa,6BAA6B,sDAAa;AACjG;AACA;AACA;AACA;AACA,uBAAuB,sDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D,6DAA6D,6CAAI;AACjE,2CAA2C,qDAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAY;AAC3C,uDAAuD,uDAAc;AACrE,kEAAkE,uDAAc;AAChF;AACA,4DAA4D,0DAAiB;AAC7E,kEAAkE,0DAAiB;AACnF;AACA;AACA,kEAAkE,sDAAa;AAC/E;AACA,+BAA+B,6CAAI;AACnC;AACA,qDAAqD,qDAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sCAAsC,6CAAI;AAC1C;AACA,gCAAgC,qDAAY;AAC5C;AACA;AACA,iCAAiC,qDAAY;AAC7C;AACA;AACA,gCAAgC,qDAAY,yBAAyB,qDAAY;AACjF;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA,gCAAgC,sDAAa,yBAAyB,sDAAa;AACnF;AACA;AACA;AACA;AACA,kCAAkC,mDAAU,4BAA4B,mDAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;ACpRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACV;AACK;AACY;AACV;AACU;AACF;AACiB;AACrC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAM;AAC5C;AACA,wCAAwC,uEAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAa;AACtD;AACA,oCAAoC,sDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA,4FAA4F,wBAAwB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,KAAK;AACrE;AACA;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,6DAAS;AACxB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAa;AAC5B;AACA;AACA,eAAe,oEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,wFAAwF,mBAAmB;AAC3G;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAsC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA,eAAe,uEAAc;AAC7B;AACA;AACA,eAAe,qEAAgB;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,GAAG,eAAe;AACrD;AACA;AACA;AACA;AACA,8BAA8B,EAAE,mBAAmB;AACnD;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,GAAG,eAAe;AACrD;AACA;AACA;AACA;AACA,8BAA8B,EAAE,mBAAmB;AACnD;AACA,sBAAsB,aAAa;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAO;AAC1B;AACA;AACA,gBAAgB;AAChB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gC;;;;;;;ACtuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACI;AACR;AACI;AAChB;AACnC;AACA,WAAW,6CAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAY;AACtC;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAK;AACrB,4BAA4B,qBAAqB,GAAG,kBAAkB,GAAG,sBAAsB;AAC/F;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA,+BAA+B,sFAAuC;AACtE;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAK;AACrB,4BAA4B,+BAA+B,EAAE,eAAe,GAAG,4BAA4B,EAAE,gBAAgB;AAC7H;AACA;AACA,+CAA+C,UAAU;AACzD,4BAA4B,QAAQ,EAAE,eAAe,GAAG,2BAA2B,GAAG,+BAA+B;AACrH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,EAAE;AACF,EAAE,8BAA8B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+DAA+D,wBAAwB,OAAO,oEAAoE;AAClK,uCAAuC,qCAAqC,OAAO,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB,OAAO,oFAAoF;AAClL,uCAAuC,qCAAqC,OAAO,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,sKAAsK;AAC5Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wJAAwJ;AAC/L;AACA,uCAAuC,qCAAqC,OAAO,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAW,eAAe,8BAA8B,GAAG,mCAAmC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAY,yBAAyB,6CAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAI;AAClC,4BAA4B,qDAAY;AACxC,qBAAqB,0EAA0E;AAC/F;AACA;AACA,mBAAmB,mEAAW,eAAe,aAAa,GAAG,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,+DAA+D;AACjL;AACA;AACA;AACA,gCAAgC,gHAAgH;AAChJ;AACA,oCAAoC,8FAA8F;AAClI,aAAa;AACb,SAAS;AACT;AACA,oFAAoF,4BAA4B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qDAAY;AAC/E;AACA;AACA,qBAAqB,mEAAW;AAChC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB,mEAAW,eAAe,2CAA2C,GAAG,yBAAyB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;AC/ZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA,4BAA4B,IAAI;AAChC;AACA,2BAA2B,IAAI,SAAS,IAAI;AAC5C;AACA,gCAAgC,IAAI;AACpC;AACA,gCAAgC,IAAI;AACpC;AACA,2BAA2B,IAAI;AAC/B;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;AACA,8C;;;;;;;ACjHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAA6D;AAC7F;AACA;AACA;AACA,gCAAgC,8DAA8D;AAC9F;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACtDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,qC;;;;;;;ACrBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACd;AACgC;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAQ,0BAA0B,iDAAQ;AACpF;AACA;AACA;AACA,0CAA0C,mDAAU,0BAA0B,mDAAU;AACxF,iCAAiC,iDAAM;AACvC;AACA;AACA;AACA,qCAAqC,mDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAQ,0BAA0B,iDAAQ;AACvF;AACA;AACA;AACA,6CAA6C,mDAAU,0BAA0B,mDAAU;AAC3F,iCAAiC,iDAAM;AACvC;AACA;AACA;AACA,wCAAwC,mDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAU,uBAAuB,mDAAU;AAC/E,uEAAuE,KAAK,OAAO,KAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAY;AAC/C,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,sEAAM;AACd;AACA,QAAQ,sEAAM;AACd;AACA;AACA,mCAAmC,qDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB,4CAA4C,qDAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB,4CAA4C,qDAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,6CAAI,iEAAiE,6CAAI;AAChJ;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;ACnMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACQ;AACM;AACM;AACtB;AAC5B;AACP,mEAAmE;AACnE,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC,qDAAqD;AACjH;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,+BAA+B,WAAW,4BAA4B,EAAE;AACxE;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC,2BAA2B,6CAAI,4BAA4B;AACvH;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAyC;AACpE;AACA,2BAA2B,uCAAuC;AAClE;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA,qDAAqD,UAAU,aAAa,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA,eAAe,iDAAM;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,wCAAwC,qEAAa;AACrD;AACA;AACA,wCAAwC,qEAAa;AACrD;AACA;AACA,qEAAqE,MAAM,WAAW,KAAK;AAC3F;AACA;AACA,wCAAwC,+DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAK;AACjB,sBAAsB,QAAQ,GAAG,KAAK;AACtC;AACA,kBAAkB,KAAK,IAAI,QAAQ;AACnC;AACA;AACA;AACA;AACA,kBAAkB,MAAM,EAAE,EAAE,qEAAqE;AACjG;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,kEAAkE,wBAAwB;AAC1F;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA,wCAAwC,KAAK,KAAK,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AClNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACG;AACX;AACY;AACP;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,oBAAoB,oBAAoB,OAAO,qBAAqB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAgB;AACrC;AACA;AACA,+CAA+C,mCAAmC;AAClF,mCAAmC,cAAc;AACjD;AACA;AACO;AACP;AACA,sEAAsE,KAAK,IAAI,sBAAsB;AACrG,kBAAkB,sBAAsB,EAAE,GAAG,kBAAkB,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAM;AACtB,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA,4CAA4C,4DAAgB;AAC5D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,KAAK;AAC9E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAgB;AAC7C,IAAI,sEAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB,aAAa,WAAW;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM,iBAAiB,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK,SAAS,eAAe,EAAE;AAClG,8BAA8B,MAAM,YAAY,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK,WAAW,gBAAgB,GAAG;AAClG,0BAA0B,MAAM,YAAY,eAAe;AAC3D;AACA;AACA;AACA,wDAAwD,KAAK,yBAAyB,MAAM;AAC5F;AACA;AACA,qEAAqE,KAAK;AAC1E,wBAAwB,gBAAgB,gBAAgB,MAAM;AAC9D;AACA;AACA;AACA;AACA,uEAAuE,KAAK,WAAW,gBAAgB,GAAG;AAC1G,kCAAkC,MAAM,aAAa,kBAAkB,YAAY,EAAE;AACrF;AACA,aAAa;AACb;AACA;AACA,mCAAmC,uDAAS;AAC5C,4DAA4D,KAAK,uBAAuB,MAAM;AAC9F;AACA,iBAAiB,mEAAW,eAAe,mBAAmB,GAAG,WAAW,sDAAa,0BAA0B;AACnH,4DAA4D,KAAK,eAAe,MAAM;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK,iBAAiB,MAAM;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,cAAc,KAAK,aAAa,YAAY;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAS,YAAY,sDAAa;AACzD;AACA;AACA,wDAAwD,KAAK,uBAAuB,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK,wBAAwB,MAAM;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AC1XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACJ;AACL;AACL;AACW;AACS;AACzD;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAgB;AAC7B,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAgB,EAAE,kEAAkE;AAC9G;AACA,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAgB,EAAE,sCAAsC;AAC/E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,KAAK,iDAAM,+BAA+B,MAAM,sDAAa,CAAC,iDAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACkB;AACnB;AACP;AACO;AACsD;AACnE;AACR;AACmB;AACI;AAC0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAM;AACV,WAAW,cAAc;AACzB;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gEAAa;AAC5D;AACA;AACA,+CAA+C,kEAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,yEAAyE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,8BAA8B,iDAAM;AACpC,iBAAiB,iDAAM;AACvB;AACA;AACA;AACA,sBAAsB,4DAAgB;AACtC;AACA;AACA,QAAQ,iDAAM,wBAAwB,yCAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,2CAA2C,yCAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAY;AAChD;AACA;AACA;AACA;AACA,wBAAwB,8DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAU;AAC/C;AACA;AACA,qCAAqC,sDAAa;AAClD,qCAAqC,uDAAS;AAC9C;AACA,yEAAyE,UAAU;AACnF;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA,iCAAiC,sDAAa;AAC9C,mBAAmB,8DAAY;AAC/B;AACA,iCAAiC,sDAAa;AAC9C,uBAAuB,uDAAS;AAChC;AACA,yEAAyE,UAAU;AACnF;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,4CAA4C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,uDAAc;AAC9C;AACA;AACA,qCAAqC,0DAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB,YAAY;AACZ,8BAA8B,yEAAc;AAC5C,QAAQ,sEAAM;AACd,eAAe,wEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AC/bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sBAAsB;AACjF;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6CAA6C,gBAAgB,wCAAwC,YAAY,yBAAyB,aAAa,IAAI,mBAAmB;AAC9K;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C,gBAAgB,iCAAiC,YAAY,eAAe,aAAa,IAAI,mBAAmB;AAC3J;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0C;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACwB;AACrB;AACd;AACiC;AACX;AACjC;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAc;AAC1C;AACA;AACA,4BAA4B,0DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAa;AACzB,YAAY,8FAAa;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM,mBAAmB,oDAAS;AAC1C,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA,oBAAoB,iBAAiB;AACrC;AACA,0CAA0C,QAAQ,iCAAiC,SAAS;AAC5F,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ,kCAAkC,gBAAgB;AACpG,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yCAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,qFAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uBAAuB;AAClG;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE;AAC1D;AACA,sDAAsD,iDAAiD;AACvG,oDAAoD,EAAE;AACtD,4BAA4B,WAAW,OAAO,qDAAqD;AACnG;AACA;AACA,oCAAoC,0CAA0C;AAC9E;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,kBAAkB;AAClB,gBAAgB;AAChB,oBAAoB,iBAAiB,GAAG;AACxC,uBAAuB;AACvB,2DAA2D;AAC3D,uBAAuB;AACvB;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,kEAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;ACvnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wD;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,GAAG,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA,8B;;;;;;;AC3GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kC;;;;;;;AC1BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB,IAAI,EAAE;AAC/E;AACO;AACP,mC;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACD;AACU;AACF;AACvB;AACR;AACU;AACc;AACL;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM,wBAAwB,yCAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,wBAAwB;AACxB;AACA;AACA,oDAAoD,gEAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,mDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4DAAgB;AACrD;AACA;AACA;AACA,aAAa,iDAAM;AACnB;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,wBAAwB,0EAAiB;AACzC;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB,0EAAiB;AACzC;AACA;AACA,wBAAwB,0EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA,wBAAwB;AACxB,wBAAwB,wEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kC;;;;;;;AC3QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACf;AAC/C;AACP;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA,sBAAsB,WAAW,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc,kEAAiB,iBAAiB,kEAAiB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAU;AAClC;AACA;AACA;AACA,wBAAwB,mDAAU;AAClC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAS,OAAO,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;AC3QA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACO;AACP,YAAY;AACZ;AACA,gC;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyE;AACA;AAClE;AACP;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA,8BAA8B,kEAAc;AAC5C;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA,wBAAwB,mDAAU;AAClC;AACA;AACA;AACA,YAAY,8DAAa;AACzB,6BAA6B,kEAAiB;AAC9C;AACA,YAAY,8DAAa;AACzB,6BAA6B,kEAAiB;AAC9C;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8E;AACvB;AACX;AACJ;AACM;AAC9C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAa;AACzB,YAAY,8FAAa;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kEAAe;AAClE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAgB;AACjC,iDAAiD,OAAO,0DAAgB,0CAA0C;AAClH;AACA;AACA,0BAA0B,uDAAS,sDAAsD,QAAQ;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,yDAAyD;AAC1H;AACA;AACA;AACA,iEAAiE,+BAA+B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,+BAA+B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iCAAiC;AAClG;AACA;AACA;AACA;AACA,0CAA0C,OAAO,0DAAgB,cAAc;AAC/E;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB,EAAE,EAAE,EAAE,mDAAU,YAAY;AACxE;AACA;AACA,uCAAuC,EAAE;AACzC;AACA,sCAAsC;AACtC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA,6BAA6B;AAC7B,kBAAkB;AAClB,oBAAoB;AACpB;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,kEAAe;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;AC7SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC6B;AAClC;AACe;AACb;AACwB;AACpB;AACtD;AACA;AACA;AACA;AACA;AACO,oBAAoB,8DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sFAAuB,GAAG,+DAAW,iBAAiB,+DAAW;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,iEAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAW;AACxC;AACA;AACA;AACA,KAAK,+DAAW,SAAS,4DAAW;AACpC,KAAK,+DAAW,gBAAgB,2EAAkB;AAClD;AACA,iC;;;;;;;ACxEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,wBAAwB;AACzB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA,uFAAuF;AACvF;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACI;AACS;AAChC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC,0BAA0B,+DAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAa;AACvC;AACA,sBAAsB,uDAAS,4CAA4C,mBAAmB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAU;AAChD;AACA;AACA,6BAA6B,OAAO,oEAAgB,oDAAoD;AACxG;AACA,aAAa;AACb;AACA,2CAA2C,wDAAU;AACrD;AACA;AACA,6BAA6B,OAAO,oEAAgB,qDAAqD;AACzG;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wDAAU;AACxD;AACA;AACA,6CAA6C,wDAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC,sDAAsD,OAAO,oEAAgB,gEAAgE;AAC7I;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA,8DAA8D,OAAO,oEAAgB,8BAA8B;AACnH;AACA;AACA;AACA,gCAAgC,aAAa,wDAAU;AACvD;AACA,gBAAgB,wDAAO;AACvB;AACA;AACA,iBAAiB,oEAAgB;AACjC,uBAAuB,2BAA2B;AAClD;AACA,gBAAgB,wDAAO;AACvB;AACA;AACA;AACA,0BAA0B,uDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAO,WAAW,OAAO,oEAAgB,oDAAoD;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;ACpQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD;AACA;AACA;AACO;AACP,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B;AACjC,gC;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4E;AACG;AACG;AAChC;AACE;AACJ;AAC0B;AACrC;AAC9B,kCAAkC,uEAAc;AACvD;AACO,iCAAiC,qEAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,+DAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,oCAAoC,8DAAY;AAChD;AACA;AACA,kBAAkB,+DAAW;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,uDAAc,KAAK,sDAAa;AAC1D;AACA;AACA,0BAA0B,sDAAa,KAAK,sDAAa;AACzD;AACA,sCAAsC,4DAAW;AACjD;AACA;AACA,kBAAkB,+DAAW;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAqD;AAClF;AACA;AACA,6BAA6B,+DAA+D;AAC5F;AACA;AACA,6BAA6B,wDAAwD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO,oEAAgB,uCAAuC;AAC9G,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,oEAAgB,uCAAuC;AACtG,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA,uBAAuB,oBAAoB;AAC3C,mDAAmD,OAAO,oEAAgB,8BAA8B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA,oCAAoC,OAAO,oEAAgB,cAAc;AACzE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,+EAA+E,OAAO,oEAAgB,oDAAoD;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC,uBAAuB,kBAAkB;AACzC;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA,6CAA6C,SAAS,uEAAuE;AAC7H;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,+BAA+B;AAC/B,0DAA0D,OAAO,oEAAgB,4BAA4B;AAC7G;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC,uBAAuB,oBAAoB;AAC3C,wEAAwE,OAAO,oEAAgB,8CAA8C;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI,uBAAuB,MAAM;AACxE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,oCAAoC,qEAAa;AACjD;AACA;AACA;AACA,qCAAqC,uEAAc;AACnD;AACA,+BAA+B,+DAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAO,0BAA0B,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAO,0BAA0B,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO,oEAAgB,4BAA4B;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0EAAiB;AACtC;AACA,qBAAqB,0EAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAgB;AACrC;AACA,qBAAqB,wEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D,qCAAqC,mCAAmC;AACxE,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;ACpmBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AAChD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAW,YAAY,gFAAgF;AACnI,wBAAwB;AACxB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuC;AACkB;AACF;AAChD;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,mDAAU;AACjF,uEAAuE,mDAAU;AACjF;AACA;AACA;AACA;AACA;AACA,yEAAyE,mDAAU;AACnF,yEAAyE,mDAAU;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAgB;AAC3D,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAgB;AAC3D,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qEAAiB;AAC5D,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,2CAA2C,qEAAiB;AAC5D,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,eAAe,aAAa,mDAAU,mCAAmC;AAC7F,8BAA8B,aAAa,mDAAU,mCAAmC;AACxF;AACA;AACA;AACA,4BAA4B,aAAa,mDAAU;AACnD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gDAAgD,iCAAiC,SAAS;AAC7I;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,mDAAmD,iDAAiD,gCAAgC,SAAS;AAC7I;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,2EAA2E,cAAc,mEAAgB,MAAM;AAC/G;AACA,2EAA2E,cAAc,mEAAgB,QAAQ;AACjH;AACA,4EAA4E,cAAc,qEAAiB,MAAM;AACjH;AACA,4EAA4E,cAAc,qEAAiB,SAAS;AACpH;AACA,qDAAqD,GAAG;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA,wBAAwB,eAAe,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACH;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC,+BAA+B,gBAAgB;AAC/C,gBAAgB,4BAA4B;AAC5C,gBAAgB,4BAA4B;AAC5C,sBAAsB,kCAAkC;AACxD,kBAAkB,8BAA8B;AAChD,uBAAuB,mCAAmC;AAC1D,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAc;AAC5B;AACA;AACA,cAAc,4EAAc;AAC5B;AACA;AACA,cAAc,4EAAc;AAC5B;AACA;AACA,cAAc,4EAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA,6BAA6B,qBAAqB;AAClD;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA,8BAA8B,+BAA+B,IAAI,aAAa;AAC9E;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA,qCAAqC,YAAY;AACjD;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAqD;AAC5F;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA,yC;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,IAAI,sEAAM;AACV,IAAI,sEAAM;AACV;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,sC;;;;;;;AC5DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACvC,sCAAsC,0DAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO,cAAc,OAAO;AACrE;AACA;AACA,8BAA8B,EAAE,MAAM,cAAc,EAAE,MAAM;AAC5D;AACA;AACA,kBAAkB,cAAc,IAAI,EAAE,iCAAiC,EAAE,gCAAgC;AACzG;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM,EAAE,IAAI,MAAM,MAAM,EAAE,IAAI,KAAK;AACzF;AACA,oEAAoE,IAAI;AACxE;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;ACrCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,GAAG;AACrD;AACA;AACA,uC;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AAC3C;AACP;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA,sBAAsB,WAAW,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAS;AACvC;AACA,mCAAmC;AACnC,8BAA8B,sCAAsC,EAAE;AACtE;AACA;AACA;AACA,8BAA8B,kDAAS;AACvC;AACA,kCAAkC;AAClC,8BAA8B,sCAAsC,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAS,qDAAqD,IAAI;AAC5F;AACA,+BAA+B;AAC/B,0BAA0B,uCAAuC,EAAE;AACnE;AACA,gBAAgB,eAAe,aAAa,mDAAU,sCAAsC,gBAAgB,aAAa,mDAAU,uCAAuC;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACP;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAoB;AACvD;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA,wBAAwB,aAAa,GAAG,mCAAmC;AAC3E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,UAAU;AACrH,mCAAmC,IAAI;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,EAAE,SAAS;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,qBAAqB;AAChG;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,cAAc,uBAAuB;AACnF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,cAAc,iBAAiB;AAC7E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA,qBAAqB,yBAAyB,aAAa,MAAM;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0C;;;;;;;ACzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB,GAAG,8BAA8B;AAC1E;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,EAAE,SAAS;AACzD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa;AAChF;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0C;;;;;;;ACrEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wCAAwC,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACd;AACM;AAC2B;AAC7B;AACD;AACY;AACjB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAc;AAC1C;AACA;AACA,4BAA4B,mDAAU;AACtC;AACA;AACA,4BAA4B,sDAAa;AACzC;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA,QAAQ,sEAAM,uBAAuB,mDAAU;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAM;AACtC,mEAAmE,OAAO;AAC1E;AACA,mBAAmB,iDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAS;AACtC,sEAAsE,IAAI;AAC1E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAc;AAC1C;AACA;AACA,4BAA4B,mDAAU;AACtC;AACA;AACA,4BAA4B,sDAAa;AACzC;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS,EAAE,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS,EAAE,kBAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,KAAK,kBAAkB,SAAS;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,IAAI,wBAAwB,SAAS;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,iBAAiB,SAAS;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,SAAS;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,UAAU,kBAAkB,GAAG,GAAG,WAAW;AAC9H;AACA,mBAAmB,uDAAS,EAAE,iBAAiB,MAAM,sDAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF,uBAAuB,gBAAgB;AACvC;AACA;AACA,qEAAqE,eAAe,GAAG,gBAAgB;AACvG,uBAAuB,YAAY,GAAG,YAAY;AAClD;AACA;AACA,gEAAgE,UAAU,GAAG,WAAW;AACxF,uBAAuB,YAAY,GAAG,YAAY;AAClD;AACA;AACA,uEAAuE,cAAc,QAAQ;AAC7F,uBAAuB,gBAAgB;AACvC;AACA,kDAAkD;AAClD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uDAAuD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+EAA+E;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC,EAAE;AAC5E,gDAAgD,4CAA4C,KAAK,IAAI,EAAE;AACvG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB,GAAG,gBAAgB;AACxE;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD,iDAAiD,EAAE;AACnD;AACA;AACA,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA,uCAAuC,iEAAiE,EAAE;AAC1G,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,qDAAQ;AAC1C;AACA;AACA,6BAA6B,+CAAK;AAClC;AACA;AACA;AACA,2BAA2B,+CAAK;AAChC;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA,kFAAkF,GAAG,kBAAkB,eAAe;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,eAAe;AACnE,sCAAsC,gEAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAM,KAAK,iDAAM;AAC/C;AACA,qCAAqC,iDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA,gC;;;;;;;ACvxBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACH;AACJ;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAU,4BAA4B,wDAAa;AAC3F;AACA,0DAA0D,sCAAsC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAM;AACrB;AACA;AACA,eAAe,iDAAM;AACrB;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,uDAAuD;AACvD,gCAAgC;AAChC;AACA,oC;;;;;;;ACnQA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;AAChC,kC;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACF;AAC9C,OAAO,OAAO,GAAG,oEAAW;AACrB,qBAAqB,0DAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,kBAAkB,KAAK;AACvD,yDAAyD,iCAAiC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,KAAK,KAAK,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;AC/EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE,iCAAiC;AAC1B;AACP;AACA;AACA;AACA,gDAAgD,8DAAU;AAC1D;AACA;AACA,wC;;;;;;;;ACrCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iCAAiC,iBAAiB,cAAc,0BAA0B,oBAAoB;AAC9G,2CAA2C,SAAS;AACpD;AACA,mC;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACF;AACsC;AACnB;AACR;AACO;AAC6B;AACN;AACzB;AACuB;AACpC;AACgB;AAC1D,OAAO,OAAO,GAAG,8EAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAK;AAC/B;AACA;AACA;AACA,gDAAgD,WAAW,IAAI,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAK;AAC/B;AACA;AACA;AACA,gDAAgD,WAAW,IAAI,eAAe,OAAO,IAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO,EAAE,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,eAAe,wFAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAM;AACd;AACA;AACA,YAAY,uEAAQ;AACpB;AACA,YAAY,iFAAW;AACvB,YAAY,mHAAsB;AAClC,YAAY,4HAAyB;AACrC;AACA,YAAY,8EAAU;AACtB,YAAY,gHAAqB;AACjC;AACA,8BAA8B,kEAAU;AACxC,4BAA4B,kEAAU;AACtC;AACA,uBAAuB,qEAAe;AACtC;AACA,gCAAgC,EAAE;AAClC,YAAY,4DAAI;AAChB,SAAS;AACT;AACA;AACA,eAAe,8EAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;ACpQA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AAC+B;AAC/B,qC;;;;;;;ACfA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA,uBAAuB,UAAU;AACjC;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK,GAAG,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AACxB;AACzD;AACA;AACA;AACA;AACO,0BAA0B,iGAAa,CAAC,qEAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA,0BAA0B,OAAO,GAAG,uBAAuB;AAC3D;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;ACzKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;;AAEsC;;;;;;;;AC7ItC;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AAC1B;AACzC;AACA;AACA;AACO,8BAA8B,qDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,iFAAiF,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS,wBAAwB,SAAS,aAAa,GAAG,WAAW;AACnI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,gBAAgB;AACzC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS,sBAAsB,qDAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAU,sBAAsB,wDAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAU,sBAAsB,wDAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAU,sBAAsB,wDAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;AClRA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACX;AACrC;AACA;AACA;AACA;AACA;AACO,wCAAwC,4DAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ,iDAAM,cAAc;AAChF;AACA;AACA,uD;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACD;AAC2B;AACxC;AAC9B,qCAAqC,yFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sCAAsC,QAAQ,MAAM;AAChG;AACA;AACA,yCAAyC,2BAA2B,MAAM,QAAQ;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,OAAO,GAAG,kEAAkE;AAC9F,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,MAAM;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,mCAAmC,GAAG,6DAA6D;AACvM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe,QAAQ,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM,6DAA6D,SAAS,sBAAsB,aAAa;AACvH,8BAA8B,0CAA0C,qBAAqB;AAC7F,uBAAuB,eAAe;AACtC;AACA;AACA,+BAA+B,OAAO;AACtC,2FAA2F,OAAO;AAClG;AACA;AACA;AACA,0DAA0D,EAAE,WAAW,cAAc,YAAY,EAAE,KAAK,cAAc;AACtH,aAAa;AACb,2BAA2B,YAAY,4DAA4D,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;ACpLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AAC1B;AACvD;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,iGAAa,CAAC,mEAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO,GAAG,uBAAuB;AAC3D;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACe;AACX;AACzC;AACA;AACA;AACO,6BAA6B,qDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAS;AACzC,gEAAgE,WAAW;AAC3E;AACA;AACA,wEAAwE,WAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAU;AAC1C,oEAAoE,WAAW;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,iDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAU;AAC1C,2EAA2E,WAAW;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAM;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAS,yBAAyB,qDAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;AChLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACyB;AACpE,oCAAoC,uFAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,OAAO,GAAG,kEAAkE;AAC9F,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gEAAgE;AAC9H;AACA,iDAAiD,kEAAkE;AACnH;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA,oCAAoC,kEAAkE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM,iBAAiB,mBAAmB;AAC5F;AACA;AACA,8DAA8D,kEAAkE;AAChI;AACA;AACA;AACA;AACA,sCAAsC,kEAAkE;AACxG;AACA;AACA;AACA;AACA,oEAAoE,kBAAkB;AACtF,iEAAiE,4DAA4D;AAC7H,gCAAgC;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,4DAA4D;AAC5F;AACA,aAAa;AACb;AACA;AACA,oCAAoC,kBAAkB;AACtD,+EAA+E,MAAM;AACrF;AACA;AACA;AACA,+BAA+B,8DAAY;AAC3C;AACA;AACA;AACA;AACA,eAAe,uCAAuC;AACtD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAsC,QAAQ,MAAM;AACpG;AACA;AACA;AACA,6CAA6C,2BAA2B,MAAM,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,+BAA+B,wBAAwB,uDAAuD,EAAE;AAChH;AACA;AACA;AACA;AACA;AACA,wFAAwF,mCAAmC,GAAG,6DAA6D;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;;;;AC/JA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACT;AACrC;AACA;AACA;AACO,uCAAuC,0DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ,iDAAM,cAAc;AAChF;AACA;AACA,sD;;;;;;;AClCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gC","file":"worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {ParticleExecutionContext} from '../../../build/runtime/particle-execution-context.js';\nimport {Id, IdGenerator} from '../../../build/runtime/id.js';\nimport {Loader} from '../../../build/platform/loader.js';\n\nself.onmessage = function(e) {\n  // immediately close message channel, this is one-time use\n  self.onmessage = null;\n  // snarf out scope data\n  const {id, base, logLevel} = e.data;\n  // TODO(sjmiles): happens too late for modules that immediately construct loggers, but\n  // soon enough for `log` injected into Particle.\n  global.logLevel = logLevel;\n  // construct execution context with scope data\n  new ParticleExecutionContext(e.ports[0], Id.fromString(id), IdGenerator.newSession(), new Loader(base));\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { PECInnerPort } from './api-channel.js';\nimport { unifiedHandleFor } from './handle.js';\nimport { SlotProxy } from './slot-proxy.js';\nimport { StorageProxy, StorageProxyScheduler } from './storage-proxy.js';\nimport { StorageProxy as StorageProxyNG } from './storageNG/storage-proxy.js';\nimport { WasmContainer, WasmParticle } from './wasm.js';\nimport { UserException } from './arc-exceptions.js';\nimport { Flags } from './flags.js';\nexport class ParticleExecutionContext {\n    constructor(port, pecId, idGenerator, loader) {\n        this.particles = new Map();\n        this.pendingLoads = [];\n        this.scheduler = new StorageProxyScheduler();\n        this.keyedProxies = {};\n        this.wasmContainers = {};\n        const pec = this;\n        this.apiPort = new class extends PECInnerPort {\n            onDefineHandle(identifier, type, name) {\n                if (Flags.useNewStorageStack) {\n                    return new StorageProxyNG(identifier, pec, type);\n                }\n                return StorageProxy.newProxy(identifier, type, this, pec, pec.scheduler, name);\n            }\n            onGetBackingStoreCallback(callback, type, name, id, storageKey) {\n                let proxy;\n                if (Flags.useNewStorageStack) {\n                    proxy = new StorageProxyNG(id, pec, type);\n                }\n                else {\n                    proxy = StorageProxy.newProxy(id, type, this, pec, pec.scheduler, name);\n                    proxy.storageKey = storageKey;\n                }\n                return [proxy, () => callback(proxy, storageKey)];\n            }\n            onCreateHandleCallback(callback, type, name, id) {\n                let proxy;\n                if (Flags.useNewStorageStack) {\n                    proxy = new StorageProxyNG(id, pec, type);\n                }\n                else {\n                    proxy = StorageProxy.newProxy(id, type, this, pec, pec.scheduler, name);\n                }\n                return [proxy, () => callback(proxy)];\n            }\n            onMapHandleCallback(callback, id) {\n                return [id, () => callback(id)];\n            }\n            onCreateSlotCallback(callback, hostedSlotId) {\n                return [hostedSlotId, () => callback(hostedSlotId)];\n            }\n            onInnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) {\n                transformationParticle.renderHostedSlot(transformationSlotName, hostedSlotId, content);\n            }\n            onStop() {\n                if (global['close']) {\n                    global['close']();\n                }\n            }\n            async onInstantiateParticle(id, spec, proxies) {\n                return pec.instantiateParticle(id, spec, proxies);\n            }\n            async onReinstantiateParticle(id, spec, proxies) {\n                assert(false, `Not implemented`);\n            }\n            async onReloadParticles(ids) {\n                return pec.reloadParticles(ids);\n            }\n            onSimpleCallback(callback, data) {\n                callback(data);\n            }\n            onConstructArcCallback(callback, arc) {\n                callback(arc);\n            }\n            onAwaitIdle(version) {\n                pec.idle.then(a => {\n                    // TODO: dom-particles update is async, this is a workaround to allow dom-particles to\n                    // update relevance, after handles are updated. Needs better idle signal.\n                    setTimeout(() => this.Idle(version, pec.relevance), 0);\n                });\n            }\n            onUIEvent(particle, slotName, event) {\n                particle.fireEvent(slotName, event);\n            }\n            onStartRender(particle, slotName, providedSlots, contentTypes) {\n                particle.addSlotProxy(new SlotProxy(this, particle, slotName, providedSlots));\n                particle.renderSlot(slotName, contentTypes);\n            }\n            onStopRender(particle, slotName) {\n                assert(particle.hasSlotProxy(slotName), `Stop render called for particle ${particle.spec.name} slot ${slotName} without start render being called.`);\n                particle.removeSlotProxy(slotName);\n            }\n        }(port);\n        this.pecId = pecId;\n        this.idGenerator = idGenerator;\n        this.loader = loader;\n        loader.setParticleExecutionContext(this);\n        /*\n         * This code ensures that the relevant types are known\n         * in the scope object, because otherwise we can't do\n         * particleSpec resolution, which is currently a necessary\n         * part of particle construction.\n         *\n         * Possibly we should eventually consider having particle\n         * specifications separated from particle classes - and\n         * only keeping type information on the arc side.\n         */\n    }\n    generateID() {\n        return this.idGenerator.newChildId(this.pecId).toString();\n    }\n    getStorageEndpoint(storageProxy) {\n        const pec = this;\n        let id;\n        return {\n            async onProxyMessage(message) {\n                message.id = await id;\n                return new Promise((resolve) => pec.apiPort.ProxyMessage(storageProxy, message, ret => resolve(ret)));\n            },\n            setCallback(callback) {\n                id = new Promise((resolve) => pec.apiPort.Register(storageProxy, x => storageProxy.onMessage(x), retId => resolve(retId)));\n            },\n            reportExceptionInHost(exception) {\n                pec.apiPort.ReportExceptionInHost(exception);\n            }\n        };\n    }\n    innerArcHandle(arcId, particleId) {\n        const pec = this;\n        return {\n            async createHandle(type, name, hostParticle) {\n                return new Promise((resolve, reject) => pec.apiPort.ArcCreateHandle(proxy => {\n                    const handle = unifiedHandleFor({ proxy, idGenerator: pec.idGenerator, name, particleId });\n                    resolve(handle);\n                    if (hostParticle) {\n                        proxy.register(hostParticle, handle);\n                    }\n                }, arcId, type, name));\n            },\n            async mapHandle(handle) {\n                return new Promise((resolve, reject) => pec.apiPort.ArcMapHandle(id => {\n                    resolve(id);\n                }, arcId, handle)); // recipe handle vs not?\n            },\n            async createSlot(transformationParticle, transformationSlotName, handleId) {\n                // handleId: the ID of a handle (returned by `createHandle` above) this slot is rendering; null - if not applicable.\n                // TODO: support multiple handle IDs.\n                return new Promise((resolve, reject) => pec.apiPort.ArcCreateSlot(hostedSlotId => resolve(hostedSlotId), arcId, transformationParticle, transformationSlotName, handleId));\n            },\n            async loadRecipe(recipe) {\n                // TODO: do we want to return a promise on completion?\n                return new Promise((resolve, reject) => pec.apiPort.ArcLoadRecipe(arcId, recipe, response => {\n                    if (response.error) {\n                        reject(response.error);\n                    }\n                    else {\n                        resolve(response);\n                    }\n                }));\n            }\n        };\n    }\n    getStorageProxy(storageKey, type) {\n        if (!this.keyedProxies[storageKey]) {\n            this.keyedProxies[storageKey] = new Promise((resolve, reject) => {\n                this.apiPort.GetBackingStore((proxy, storageKey) => {\n                    this.keyedProxies[storageKey] = proxy;\n                    resolve(proxy);\n                }, storageKey, type);\n            });\n        }\n        return this.keyedProxies[storageKey];\n    }\n    capabilities(hasInnerArcs) {\n        const cap = {\n            // TODO(sjmiles): experimental `services` impl\n            serviceRequest: (particle, args, callback) => {\n                this.apiPort.ServiceRequest(particle, args, callback);\n            },\n            // TODO(sjmiles): alternate render path via slotObserver (UiBroker)\n            output: (particle, content) => {\n                this.apiPort.Output(particle, content);\n            }\n        };\n        if (hasInnerArcs) {\n            // TODO: Particle doesn't have an id field; not sure if it needs one or innerArcHandle shouldn't have that arg.\n            cap.constructInnerArc = async (particle) => {\n                return new Promise((resolve, reject) => this.apiPort.ConstructInnerArc(arcId => resolve(this.innerArcHandle(arcId, undefined)), particle));\n            };\n        }\n        return cap;\n    }\n    // tslint:disable-next-line: no-any\n    async instantiateParticle(id, spec, proxies) {\n        let resolve;\n        const p = new Promise(res => resolve = res);\n        this.pendingLoads.push(p);\n        const particle = await this.createParticleFromSpec(id, spec);\n        const handleMap = new Map();\n        const registerList = [];\n        proxies.forEach((proxy, name) => {\n            this.createHandle(particle, spec, id, name, proxy, handleMap, registerList);\n        });\n        return [particle, async () => {\n                await this.assignHandle(particle, spec, id, handleMap, registerList, p);\n                resolve();\n            }];\n    }\n    async reloadParticles(ids) {\n        // Delete old particles' caches\n        ids.forEach(id => {\n            const oldParticle = this.particles.get(id);\n            if (oldParticle.spec.implBlobUrl)\n                delete oldParticle.spec.implBlobUrl;\n            if (oldParticle.spec.implFile.endsWith('.wasm') && this.wasmContainers[oldParticle.spec.implFile]) {\n                // For WASM particles the container will be re-instantiated along with all of the particles\n                this.wasmContainers[oldParticle.spec.implFile] = undefined;\n            }\n        });\n        const result = [];\n        // Go through the given array of particles one by one\n        for (const id of ids) {\n            let resolve;\n            const p = new Promise(res => resolve = res);\n            this.pendingLoads.push(p);\n            // Get the old particle\n            const oldParticle = this.particles.get(id);\n            // Create a new particle and replace the old one\n            const particle = await this.createParticleFromSpec(id, oldParticle.spec);\n            const handleMap = new Map();\n            const registerList = [];\n            // Create new handles and disable the handles of the old particles\n            oldParticle.handles.forEach((oldHandle) => {\n                this.createHandle(particle, oldParticle.spec, id, oldHandle.name, oldHandle.storage, handleMap, registerList);\n                oldHandle.disable(oldParticle);\n            });\n            result.push([particle, async () => {\n                    // Set the new handles to the new particle\n                    await this.assignHandle(particle, oldParticle.spec, id, handleMap, registerList, p);\n                    resolve();\n                    // Transfer the slot proxies from the old particle to the new one\n                    for (const name of oldParticle.getSlotNames()) {\n                        oldParticle.getSlot(name).rewire(particle);\n                    }\n                }]);\n        }\n        return result;\n    }\n    createHandle(particle, spec, id, name, proxy, handleMap, registerList) {\n        const connSpec = spec.handleConnectionMap.get(name);\n        const handle = unifiedHandleFor({\n            proxy,\n            idGenerator: this.idGenerator,\n            name,\n            particleId: id,\n            particle,\n            canRead: connSpec.isInput,\n            canWrite: connSpec.isOutput,\n        });\n        handleMap.set(name, handle);\n        // Defer registration of handles with proxies until after particles have a chance to\n        // configure them in setHandles.\n        registerList.push({ proxy, particle, handle });\n    }\n    async assignHandle(particle, spec, id, handleMap, registerList, p) {\n        await particle.callSetHandles(handleMap, err => {\n            const exc = new UserException(err, 'setHandles', id, spec.name);\n            this.apiPort.ReportExceptionInHost(exc);\n        });\n        registerList.forEach(({ proxy, particle, handle }) => {\n            if (proxy instanceof StorageProxy) {\n                proxy.register(particle, handle);\n            }\n            else if (proxy instanceof StorageProxyNG) {\n                proxy.registerHandle(handle);\n            }\n            else {\n                throw new Error('Expecting a StorageProxy');\n            }\n        });\n        const idx = this.pendingLoads.indexOf(p);\n        this.pendingLoads.splice(idx, 1);\n    }\n    async createParticleFromSpec(id, spec) {\n        let particle;\n        if (spec.implFile && spec.implFile.endsWith('.wasm')) {\n            particle = await this.loadWasmParticle(id, spec);\n            particle.setCapabilities(this.capabilities(false));\n        }\n        else {\n            const clazz = await this.loader.loadParticleClass(spec);\n            particle = new clazz();\n            particle.setCapabilities(this.capabilities(true));\n        }\n        this.particles.set(id, particle);\n        return particle;\n    }\n    async loadWasmParticle(id, spec) {\n        assert(spec.name.length > 0);\n        let container = this.wasmContainers[spec.implFile];\n        if (!container) {\n            const buffer = await this.loader.loadBinaryResource(spec.implFile);\n            if (!buffer || buffer.byteLength === 0) {\n                throw new Error(`Failed to load wasm binary '${spec.implFile}'`);\n            }\n            container = new WasmContainer(this, this.loader, this.apiPort);\n            await container.initialize(buffer);\n            this.wasmContainers[spec.implFile] = container;\n        }\n        // Particle constructor expects spec to be attached to the class object (and attaches it to\n        // the particle instance at that time).\n        WasmParticle.spec = spec;\n        const particle = new WasmParticle(id, container);\n        WasmParticle.spec = null;\n        return particle;\n    }\n    get relevance() {\n        const rMap = new Map();\n        this.particles.forEach(p => {\n            if (p.relevances.length === 0) {\n                return;\n            }\n            rMap.set(p, p.relevances);\n            p.relevances.length = 0; // truncate\n        });\n        return rMap;\n    }\n    get busy() {\n        if (this.pendingLoads.length > 0 || this.scheduler.busy) {\n            return true;\n        }\n        if ([...this.particles.values()].filter(particle => particle.busy).length > 0) {\n            return true;\n        }\n        return false;\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        const busyParticlePromises = [...this.particles.values()].filter(particle => particle.busy).map(async (particle) => particle.idle);\n        return Promise.all([this.scheduler.idle, ...this.pendingLoads, ...busyParticlePromises]).then(() => this.idle);\n    }\n}\n//# sourceMappingURL=particle-execution-context.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// tslint:disable-next-line: no-any\nexport function assert(test, message) {\n    if (!test) {\n        if (typeof window !== 'object') {\n            // tslint:disable-next-line: no-debugger\n            debugger; // eslint-disable-line no-debugger\n        }\n        throw new Error(message);\n    }\n}\n//# sourceMappingURL=assert-web.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { assert } from '../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { Type } from './type.js';\nimport { PropagatedException } from './arc-exceptions.js';\nimport { floatingPromiseToAudit } from './util.js';\nvar MappingType;\n(function (MappingType) {\n    MappingType[MappingType[\"Mapped\"] = 0] = \"Mapped\";\n    MappingType[MappingType[\"LocalMapped\"] = 1] = \"LocalMapped\";\n    MappingType[MappingType[\"RemoteMapped\"] = 2] = \"RemoteMapped\";\n    MappingType[MappingType[\"Direct\"] = 3] = \"Direct\";\n    MappingType[MappingType[\"ObjectMap\"] = 4] = \"ObjectMap\";\n    MappingType[MappingType[\"List\"] = 5] = \"List\";\n    MappingType[MappingType[\"ByLiteral\"] = 6] = \"ByLiteral\";\n})(MappingType || (MappingType = {}));\nconst targets = new Map();\nfunction setPropertyKey(target, propertyKey) {\n    let map = targets.get(target);\n    if (map == undefined) {\n        map = new Map();\n        targets.set(target, map);\n    }\n    let list = map.get(propertyKey);\n    if (list == undefined) {\n        list = [];\n        map.set(propertyKey, list);\n    }\n    return list;\n}\nfunction getPropertyKey(target, propertyKey, parameterIndex) {\n    const map = targets.get(target);\n    if (map) {\n        const list = map.get(propertyKey);\n        if (list) {\n            const result = list[parameterIndex];\n            if (result) {\n                return result;\n            }\n        }\n    }\n    throw new Error(`the target ${target}, propertyKey ${propertyKey} and parameterIndex ${parameterIndex} provided did not exist`);\n}\nfunction set(target, propertyKey, parameterIndex, info) {\n    const list = setPropertyKey(target, propertyKey);\n    list[parameterIndex] = info;\n}\nfunction Direct(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct });\n}\nfunction Mapped(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Mapped });\n}\nfunction ByLiteral(constructor) {\n    return (target, propertyKey, parameterIndex) => {\n        const info = { type: MappingType.ByLiteral, converter: constructor };\n        set(target.constructor, propertyKey, parameterIndex, info);\n    };\n}\nfunction ObjectMap(key, value) {\n    return (target, propertyKey, parameterIndex) => {\n        const info = { type: MappingType.ObjectMap, key: { type: key }, value: { type: value } };\n        set(target.constructor, propertyKey, parameterIndex, info);\n    };\n}\nfunction List(value) {\n    return (target, propertyKey, parameterIndex) => {\n        const info = { type: MappingType.List, value: { type: value } };\n        set(target.constructor, propertyKey, parameterIndex, info);\n    };\n}\nfunction LocalMapped(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.LocalMapped });\n}\nfunction RemoteMapped(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.RemoteMapped });\n}\nfunction NoArgs(target, propertyKey) {\n    setPropertyKey(target.constructor, propertyKey);\n}\nfunction RedundantInitializer(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, redundant: true });\n}\nfunction OverridingInitializer(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, overriding: true });\n}\nfunction Initializer(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true });\n}\nfunction Identifier(target, propertyKey, parameterIndex) {\n    getPropertyKey(target.constructor, propertyKey, parameterIndex).identifier = true;\n}\nfunction RemoteIgnore(target, propertyKey, parameterIndex) {\n    getPropertyKey(target.constructor, propertyKey, parameterIndex).ignore = true;\n}\nclass ThingMapper {\n    constructor(prefix) {\n        this._prefix = prefix;\n        this._nextIdentifier = 0;\n        this._idMap = new Map();\n        this._reverseIdMap = new Map();\n    }\n    _newIdentifier() {\n        return this._prefix + (this._nextIdentifier++);\n    }\n    createMappingForThing(thing, requestedId = undefined) {\n        assert(!this._reverseIdMap.has(thing));\n        let id;\n        if (requestedId) {\n            id = requestedId;\n        }\n        else if (thing.apiChannelMappingId) {\n            id = thing.apiChannelMappingId;\n        }\n        else {\n            id = this._newIdentifier();\n        }\n        assert(!this._idMap.has(id), `${requestedId ? 'requestedId' : (thing.apiChannelMappingId ? 'apiChannelMappingId' : 'newIdentifier()')} ${id} already in use`);\n        // TODO: Awaiting this promise causes tests to fail...\n        floatingPromiseToAudit(this.establishThingMapping(id, thing));\n        return id;\n    }\n    recreateMappingForThing(things) {\n        const ids = [];\n        things.forEach(thing => {\n            assert(this._reverseIdMap.has(thing));\n            const id = this._reverseIdMap.get(thing);\n            floatingPromiseToAudit(this.establishThingMapping(id, thing));\n            ids.push(id);\n        });\n        return ids;\n    }\n    maybeCreateMappingForThing(thing) {\n        if (this.hasMappingForThing(thing)) {\n            return this.identifierForThing(thing);\n        }\n        return this.createMappingForThing(thing);\n    }\n    async establishThingMapping(id, thing) {\n        let continuation;\n        if (!Array.isArray(id)) {\n            if (Array.isArray(thing)) {\n                [thing, continuation] = thing;\n            }\n            this._idMap.set(id, thing);\n        }\n        if (thing instanceof Promise) {\n            assert(continuation == null);\n            await this.establishThingMapping(id, await thing);\n        }\n        else if (Array.isArray(id)) {\n            assert(id.length === thing.length);\n            for (let i = 0; i < id.length; i++) {\n                await this.establishThingMapping(id[i], thing[i]);\n            }\n        }\n        else {\n            this._reverseIdMap.set(thing, id);\n            if (continuation) {\n                await continuation();\n            }\n        }\n    }\n    hasMappingForThing(thing) {\n        return this._reverseIdMap.has(thing);\n    }\n    identifierForThing(thing) {\n        assert(this._reverseIdMap.has(thing), `Missing thing [${thing}]`);\n        return this._reverseIdMap.get(thing);\n    }\n    thingForIdentifier(id) {\n        assert(this._idMap.has(id), `Missing id: ${id}`);\n        return this._idMap.get(id);\n    }\n}\nexport class APIPort {\n    constructor(messagePort, prefix) {\n        this._port = messagePort;\n        this._mapper = new ThingMapper(prefix);\n        this._port.onmessage = async (e) => this._processMessage(e);\n        this.inspector = null;\n        this.attachStack = false;\n        this.messageCount = 0;\n        this._testingHook();\n    }\n    // Overridden by unit tests.\n    _testingHook() {\n    }\n    close() {\n        this._port.close();\n    }\n    async _processMessage(e) {\n        assert(this['before' + e.data.messageType] !== undefined);\n        const count = this.messageCount++;\n        if (this.inspector) {\n            this.inspector.pecMessage('on' + e.data.messageType, e.data.messageBody, count, this.supportsExternalParticle() ? /* android */ 'a' : /* web */ 'w', this._port['pecId'], e.data.stack);\n        }\n        this['before' + e.data.messageType](e.data.messageBody);\n    }\n    async send(name, args) {\n        const call = { messageType: name, messageBody: args, stack: this.attachStack ? new Error().stack : undefined };\n        const count = this.messageCount++;\n        if (this.inspector) {\n            this.inspector.pecMessage(name, args, count, this.supportsExternalParticle() ? /* android */ 'a' : /* web */ 'w', this._port['pecId'] || '', new Error().stack || '');\n        }\n        await this._port.postMessage(call);\n    }\n    supportsExternalParticle() {\n        // TODO: improve heuristics.\n        return Object.getPrototypeOf(this._port.constructor).name === 'MessagePort';\n    }\n}\n// The horror. From https://davidwalsh.name/javascript-arguments\nfunction getArgs(func) {\n    // First match everything inside the function argument parens.\n    const args = func.toString().match(/.*?\\(([^)]*)\\)/)[1];\n    // Split the arguments string into an array comma delimited.\n    return args.split(',').map((arg) => {\n        // Ensure no inline comments are parsed and trim the whitespace.\n        return arg.replace(/\\/\\*.*\\*\\//, '').trim();\n        // Ensure no undefined values are added.\n    }).filter((arg) => arg);\n}\n// value is covariant with info, and errors will be found\n// at start of runtime.\n// tslint:disable-next-line: no-any\nfunction convert(info, value, mapper) {\n    if (info === undefined) {\n        return;\n    }\n    switch (info.type) {\n        case MappingType.Mapped:\n            return mapper.identifierForThing(value);\n        case MappingType.LocalMapped:\n            return mapper.maybeCreateMappingForThing(value);\n        case MappingType.RemoteMapped:\n            // This is on the local side, so we don't do anything here.\n            return value;\n        case MappingType.Direct:\n            return value;\n        case MappingType.ObjectMap: {\n            const r = {};\n            value.forEach((childvalue, key) => r[convert(info.key, key, mapper)] = convert(info.value, childvalue, mapper));\n            return r;\n        }\n        case MappingType.List:\n            return value.map(v => convert(info.value, v, mapper));\n        case MappingType.ByLiteral:\n            return value.toLiteral();\n        default:\n            throw new Error(`Can't yet send MappingType ${info.type}`);\n    }\n}\n// value is covariant with info, and errors will be found\n// at start of runtime.\n// tslint:disable-next-line: no-any\nfunction unconvert(info, value, mapper) {\n    if (info === undefined) {\n        return;\n    }\n    switch (info.type) {\n        case MappingType.Mapped:\n            return mapper.thingForIdentifier(value);\n        case MappingType.LocalMapped:\n            // This is on the remote side, so we don't do anything here.\n            return value;\n        case MappingType.RemoteMapped:\n            return mapper.thingForIdentifier(value);\n        case MappingType.Direct:\n            return value;\n        case MappingType.ObjectMap: {\n            const r = new Map();\n            for (const key of Object.keys(value)) {\n                r.set(unconvert(info.key, key, mapper), unconvert(info.value, value[key], mapper));\n            }\n            return r;\n        }\n        case MappingType.List:\n            return value.map(v => unconvert(info.value, v, mapper));\n        case MappingType.ByLiteral:\n            if (!info.converter) {\n                throw new Error(`Expected ${info.type} to have a converter but it doesn't`);\n            }\n            return info.converter.fromLiteral(value);\n        default:\n            throw new Error(`Can't yet recieve MappingType ${info.type}`);\n    }\n}\nfunction AutoConstruct(target) {\n    return (constructor) => {\n        const doConstruct = (me, other) => {\n            const functions = targets.get(me) || new Map();\n            for (const f of functions.keys()) {\n                const argNames = getArgs(me.prototype[f]);\n                const descriptor = functions.get(f) || [];\n                // If this descriptor is for an initializer, record that fact and we'll process it after\n                // the rest of the arguments.\n                const initializer = descriptor.findIndex(d => d.initializer || false);\n                // If this descriptor records that this argument is the identifier, record it\n                // as the requestedId for mapping below.\n                const requestedId = descriptor.findIndex(d => d.identifier || false);\n                /** @this APIPort */\n                const impl = async function (...args) {\n                    const messageBody = {};\n                    for (let i = 0; i < descriptor.length; i++) {\n                        if (i === initializer) {\n                            continue;\n                        }\n                        // Process this argument.\n                        messageBody[argNames[i]] = convert(descriptor[i], args[i], this._mapper);\n                    }\n                    // Process the initializer if present.\n                    if (initializer !== -1) {\n                        if (descriptor[initializer].redundant) {\n                            assert(requestedId === -1);\n                            messageBody['identifier'] = this._mapper.maybeCreateMappingForThing(args[initializer]);\n                        }\n                        else if (descriptor[initializer].overriding) {\n                            messageBody['identifier'] = this._mapper.recreateMappingForThing(args[initializer]);\n                        }\n                        else {\n                            messageBody['identifier'] = this._mapper.createMappingForThing(args[initializer], args[requestedId]);\n                        }\n                    }\n                    await this.send(f, messageBody);\n                };\n                /** @this APIPort */\n                const before = async function before(messageBody) {\n                    const args = [];\n                    const promises = [];\n                    for (let i = 0; i < descriptor.length; i++) {\n                        // If there's a requestedId then the receiving end won't expect to\n                        // see the identifier as well.\n                        if (i === initializer && (requestedId !== -1 || descriptor[i].ignore)) {\n                            continue;\n                        }\n                        const argName = i === initializer ? 'identifier' : argNames[i];\n                        const result = unconvert(descriptor[i], messageBody[argName], this._mapper);\n                        if (result instanceof Promise) {\n                            promises.push({ promise: result, position: args.length });\n                            args.push(() => unconvert(descriptor[i], messageBody[argName], this._mapper));\n                        }\n                        else {\n                            args.push(result);\n                        }\n                    }\n                    if (promises.length > 0) {\n                        await Promise.all(promises.map(async (a) => a.promise));\n                        promises.forEach(a => {\n                            args[a.position] = args[a.position]();\n                        });\n                    }\n                    const result = this['on' + f](...args);\n                    // If this message is an initializer, need to establish a mapping\n                    // with the result of processing the message.\n                    if (initializer > -1) {\n                        assert(messageBody['identifier']);\n                        await this._mapper.establishThingMapping(messageBody['identifier'], result);\n                    }\n                };\n                Object.defineProperty(me.prototype, f, {\n                    get() {\n                        return impl;\n                    }\n                });\n                Object.defineProperty(other.prototype, 'before' + f, {\n                    get() {\n                        return before;\n                    }\n                });\n            }\n        };\n        doConstruct(constructor, target);\n        doConstruct(target, constructor);\n    };\n}\nexport class PECOuterPort extends APIPort {\n    constructor(messagePort, arc) {\n        super(messagePort, 'o');\n        this.inspector = arc.inspector;\n        if (this.inspector) {\n            this.inspector.onceActive.then(() => this.DevToolsConnected(), e => console.error(e));\n        }\n    }\n    async _processMessage(e) {\n        // Modifying pec messages on the host side is a problem as they can be transmited to DevTools\n        // with a delay. If the object representing a message is modified, it appears as if a different\n        // messages travelled across the pec. We could have made a deep copy of the message object, but\n        // agreed that these objects should not be modified as a matter of principle. We are freezing\n        // them as a defensive measure. This has some performance penalty, so it could potentially be\n        // disabled in the future for production builds.\n        deepFreeze(e.data);\n        await super._processMessage(e);\n    }\n    Stop() { }\n    DefineHandle(store, type, name) { }\n    InstantiateParticle(particle, id, spec, stores) { }\n    ReinstantiateParticle(id, spec, stores) { }\n    ReloadParticles(particles, ids) { }\n    UIEvent(particle, slotName, event) { }\n    SimpleCallback(callback, data) { }\n    AwaitIdle(version) { }\n    StartRender(particle, slotName, providedSlots, contentTypes) { }\n    StopRender(particle, slotName) { }\n    GetBackingStoreCallback(store, callback, type, name, id, storageKey) { }\n    ConstructArcCallback(callback, arc) { }\n    CreateHandleCallback(handle, callback, type, name, id) { }\n    MapHandleCallback(newHandle, callback, id) { }\n    CreateSlotCallback(slot, callback, hostedSlotId) { }\n    InnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) { }\n    // We need an API call to tell the context side that DevTools has been connected, so it can start sending\n    // stack traces attached to the API calls made from that side.\n    DevToolsConnected() { }\n}\n__decorate([\n    NoArgs\n], PECOuterPort.prototype, \"Stop\", null);\n__decorate([\n    __param(0, RedundantInitializer), __param(1, ByLiteral(Type)), __param(2, Direct)\n], PECOuterPort.prototype, \"DefineHandle\", null);\n__decorate([\n    __param(0, Initializer), __param(1, Identifier), __param(1, Direct), __param(2, ByLiteral(ParticleSpec)), __param(3, ObjectMap(MappingType.Direct, MappingType.Mapped))\n], PECOuterPort.prototype, \"InstantiateParticle\", null);\n__decorate([\n    __param(0, Identifier), __param(0, Direct), __param(1, ByLiteral(ParticleSpec)), __param(2, ObjectMap(MappingType.Direct, MappingType.Mapped))\n], PECOuterPort.prototype, \"ReinstantiateParticle\", null);\n__decorate([\n    __param(0, OverridingInitializer), __param(1, List(MappingType.Direct))\n], PECOuterPort.prototype, \"ReloadParticles\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct)\n], PECOuterPort.prototype, \"UIEvent\", null);\n__decorate([\n    __param(0, RemoteMapped), __param(1, Direct)\n], PECOuterPort.prototype, \"SimpleCallback\", null);\n__decorate([\n    __param(0, Direct)\n], PECOuterPort.prototype, \"AwaitIdle\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, ObjectMap(MappingType.Direct, MappingType.Direct)), __param(3, List(MappingType.Direct))\n], PECOuterPort.prototype, \"StartRender\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct)\n], PECOuterPort.prototype, \"StopRender\", null);\n__decorate([\n    __param(0, Initializer), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct), __param(4, Identifier), __param(4, Direct), __param(5, Direct)\n], PECOuterPort.prototype, \"GetBackingStoreCallback\", null);\n__decorate([\n    __param(0, RemoteMapped), __param(1, LocalMapped)\n], PECOuterPort.prototype, \"ConstructArcCallback\", null);\n__decorate([\n    __param(0, Initializer), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct), __param(4, Identifier), __param(4, Direct)\n], PECOuterPort.prototype, \"CreateHandleCallback\", null);\n__decorate([\n    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)\n], PECOuterPort.prototype, \"MapHandleCallback\", null);\n__decorate([\n    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)\n], PECOuterPort.prototype, \"CreateSlotCallback\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct), __param(3, Direct)\n], PECOuterPort.prototype, \"InnerArcRender\", null);\n__decorate([\n    NoArgs\n], PECOuterPort.prototype, \"DevToolsConnected\", null);\nlet PECInnerPort = class PECInnerPort extends APIPort {\n    constructor(messagePort) {\n        super(messagePort, 'i');\n    }\n    Render(particle, slotName, content) { }\n    // TODO(sjmiles): alternate render path for slotObserver (UiBroker)\n    Output(particle, content) { }\n    InitializeProxy(handle, callback) { }\n    SynchronizeProxy(handle, callback) { }\n    HandleGet(handle, callback) { }\n    HandleToList(handle, callback) { }\n    HandleSet(handle, data, particleId, barrier) { }\n    HandleClear(handle, particleId, barrier) { }\n    HandleStore(handle, callback, data, particleId) { }\n    HandleRemove(handle, callback, data, particleId) { }\n    HandleRemoveMultiple(handle, callback, data, particleId) { }\n    HandleStream(handle, callback, pageSize, forward) { }\n    StreamCursorNext(handle, callback, cursorId) { }\n    StreamCursorClose(handle, cursorId) { }\n    Register(handle, messagesCallback, idCallback) { }\n    ProxyMessage(handle, message, callback) { }\n    Idle(version, relevance) { }\n    GetBackingStore(callback, storageKey, type) { }\n    ConstructInnerArc(callback, particle) { }\n    ArcCreateHandle(callback, arc, type, name) { }\n    ArcMapHandle(callback, arc, handle) { }\n    // TODO(sjmiles): experimental `services` impl\n    ServiceRequest(particle, content, callback) { }\n    ArcCreateSlot(callback, arc, transformationParticle, transformationSlotName, handleId) { }\n    ArcLoadRecipe(arc, recipe, callback) { }\n    ReportExceptionInHost(exception) { }\n    // To show stack traces for calls made inside the context, we need to capture the trace at the call point and\n    // send it along with the message. We only want to do this after a DevTools connection has been detected, which\n    // we can't directly detect inside a worker context, so the PECOuterPort will send an API message instead.\n    onDevToolsConnected() {\n        this.attachStack = true;\n    }\n};\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct)\n], PECInnerPort.prototype, \"Render\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct)\n], PECInnerPort.prototype, \"Output\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"InitializeProxy\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"SynchronizeProxy\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"HandleGet\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"HandleToList\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleSet\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct)\n], PECInnerPort.prototype, \"HandleClear\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleStore\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleRemove\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleRemoveMultiple\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleStream\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct)\n], PECInnerPort.prototype, \"StreamCursorNext\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct)\n], PECInnerPort.prototype, \"StreamCursorClose\", null);\n__decorate([\n    __param(0, Mapped),\n    __param(1, LocalMapped),\n    __param(2, LocalMapped)\n], PECInnerPort.prototype, \"Register\", null);\n__decorate([\n    __param(0, Mapped),\n    __param(1, Direct),\n    __param(2, LocalMapped)\n], PECInnerPort.prototype, \"ProxyMessage\", null);\n__decorate([\n    __param(0, Direct), __param(1, ObjectMap(MappingType.Mapped, MappingType.Direct))\n], PECInnerPort.prototype, \"Idle\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, Direct), __param(2, ByLiteral(Type))\n], PECInnerPort.prototype, \"GetBackingStore\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, Mapped)\n], PECInnerPort.prototype, \"ConstructInnerArc\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct)\n], PECInnerPort.prototype, \"ArcCreateHandle\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped)\n], PECInnerPort.prototype, \"ArcMapHandle\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, LocalMapped)\n], PECInnerPort.prototype, \"ServiceRequest\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped), __param(3, Direct), __param(4, Direct)\n], PECInnerPort.prototype, \"ArcCreateSlot\", null);\n__decorate([\n    __param(0, RemoteMapped), __param(1, Direct), __param(2, LocalMapped)\n], PECInnerPort.prototype, \"ArcLoadRecipe\", null);\n__decorate([\n    __param(0, ByLiteral(PropagatedException))\n], PECInnerPort.prototype, \"ReportExceptionInHost\", null);\nPECInnerPort = __decorate([\n    AutoConstruct(PECOuterPort)\n], PECInnerPort);\nexport { PECInnerPort };\nfunction deepFreeze(object) {\n    for (const name of Object.getOwnPropertyNames(object)) {\n        const value = object[name];\n        if (value && typeof value === 'object') {\n            deepFreeze(value);\n        }\n    }\n    Object.freeze(object);\n}\n//# sourceMappingURL=api-channel.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { Modality } from './modality.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { InterfaceType, SlotType, Type } from './type.js';\nimport { createCheck } from './particle-check.js';\nimport { createParticleClaim } from './particle-claim.js';\nimport { Flags } from './flags.js';\nimport * as AstNode from './manifest-ast-nodes.js';\nfunction asType(t) {\n    return (t instanceof Type) ? t : Type.fromLiteral(t);\n}\nfunction asTypeLiteral(t) {\n    return (t instanceof Type) ? t.toLiteral() : t;\n}\nexport function isRoot({ name, tags, id, type, fate }) {\n    const rootNames = [\n        'root',\n        'toproot',\n        'modal'\n    ];\n    if ((fate && fate !== '`slot') || (type && !type.slandleType())) {\n        // If this is a handle that is not a Slandle, it cannot be a root slot.\n        return false;\n    }\n    // Checks that, if the id exists, it starts with the root id prefx.\n    const prefix = 'rootslotid-';\n    if (id && id.lastIndexOf(prefix, 0) === 0) {\n        const rootName = id.substr(prefix.length);\n        if (rootNames.includes(rootName)) {\n            return true;\n        }\n    }\n    return rootNames.includes(name) || tags.some(tag => rootNames.includes(tag));\n}\nexport class HandleConnectionSpec {\n    constructor(rawData, typeVarMap) {\n        this.parentConnection = null;\n        this.rawData = rawData;\n        this.direction = rawData.direction;\n        this.name = rawData.name;\n        this.type = asType(rawData.type).mergeTypeVariablesByName(typeVarMap);\n        this.isOptional = rawData.isOptional;\n        this.tags = rawData.tags || [];\n        this.dependentConnections = [];\n    }\n    instantiateDependentConnections(particle, typeVarMap) {\n        for (const dependentArg of this.rawData.dependentConnections) {\n            const dependentConnection = particle.createConnection(dependentArg, typeVarMap);\n            dependentConnection.parentConnection = this;\n            this.dependentConnections.push(dependentConnection);\n        }\n    }\n    toSlotConnectionSpec() {\n        // TODO: Remove in SLANDLESv2\n        const slotType = this.type.slandleType();\n        if (!slotType) {\n            return undefined;\n        }\n        const isSet = this.type.isCollectionType();\n        const slotInfo = slotType.getSlot();\n        return {\n            name: this.name,\n            isOptional: this.isOptional,\n            direction: this.direction,\n            tags: this.tags,\n            dependentConnections: this.dependentConnections.map(conn => conn.toSlotConnectionSpec()),\n            // Fakes\n            isRequired: !this.isOptional,\n            isSet,\n            type: slotType,\n            handles: slotInfo.handle ? [slotInfo.handle] : [],\n            formFactor: slotInfo.formFactor,\n            provideSlotConnections: this.dependentConnections.map(conn => conn.toSlotConnectionSpec()),\n        };\n    }\n    get isInput() {\n        // TODO: we probably don't really want host to be here.\n        // TODO: do we want to consider any here?\n        return this.direction === 'in' || this.direction === 'inout' || this.direction === 'host';\n    }\n    get isOutput() {\n        // TODO: do we want to consider any here?\n        return this.direction === 'out' || this.direction === 'inout';\n    }\n    isCompatibleType(type) {\n        return TypeChecker.compareTypes({ type }, { type: this.type, direction: this.direction });\n    }\n}\nexport class ConsumeSlotConnectionSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired || false;\n        this.isSet = slotModel.isSet || false;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.handles = slotModel.handles || [];\n        this.provideSlotConnections = [];\n        if (!slotModel.provideSlotConnections) {\n            return;\n        }\n        slotModel.provideSlotConnections.forEach(ps => {\n            this.provideSlotConnections.push(new ProvideSlotConnectionSpec(ps));\n        });\n    }\n    // Getters to 'fake' being a Handle.\n    get isOptional() { return !this.isRequired; }\n    get direction() { return '`consume'; }\n    get type() {\n        //TODO(jopra): FIXME make the null handle optional.\n        const slotT = SlotType.make(this.formFactor, null);\n        if (this.isSet) {\n            return slotT.collectionOf();\n        }\n        return slotT;\n    }\n    get dependentConnections() { return this.provideSlotConnections; }\n}\nexport class ProvideSlotConnectionSpec extends ConsumeSlotConnectionSpec {\n    constructor(slotModel) {\n        super(slotModel);\n        this.check = slotModel.check;\n    }\n}\nexport class ParticleSpec {\n    constructor(model) {\n        this.model = model;\n        this.name = model.name;\n        this.verbs = model.verbs;\n        const typeVarMap = new Map();\n        this.handleConnectionMap = new Map();\n        model.args.forEach(arg => this.createConnection(arg, typeVarMap));\n        // initialize descriptions patterns.\n        model.description = model.description || {};\n        this.validateDescription(model.description);\n        this.pattern = model.description['pattern'];\n        this.handleConnectionMap.forEach((connectionSpec, name) => {\n            connectionSpec.pattern = model.description[name];\n        });\n        this.external = model.external;\n        this.implFile = model.implFile;\n        this.implBlobUrl = model.implBlobUrl;\n        this.modality = model.modality ? Modality.create(model.modality) : Modality.all;\n        this.slotConnections = new Map();\n        if (model.slotConnections) {\n            model.slotConnections.forEach(s => this.slotConnections.set(s.name, new ConsumeSlotConnectionSpec(s)));\n        }\n        // Verify provided slots use valid handle connection names.\n        this.slotConnections.forEach(slot => {\n            slot.provideSlotConnections.forEach(ps => {\n                ps.handles.forEach(v => assert(this.handleConnectionMap.has(v), 'Cannot provide slot for nonexistent handle constraint ' + v));\n            });\n        });\n        this.trustClaims = this.validateTrustClaims(model.trustClaims);\n        this.trustChecks = this.validateTrustChecks(model.trustChecks);\n    }\n    createConnection(arg, typeVarMap) {\n        const connection = new HandleConnectionSpec(arg, typeVarMap);\n        if (this.handleConnectionMap.get(connection.name)) {\n            throw new Error(`Particle Spec ${this.name} already has a handle connection named \"${connection.name}\".`);\n        }\n        this.handleConnectionMap.set(connection.name, connection);\n        connection.instantiateDependentConnections(this, typeVarMap);\n        return connection;\n    }\n    get handleConnections() {\n        return this.connections;\n    }\n    get connections() {\n        return [...this.handleConnectionMap.values()];\n    }\n    get inputs() {\n        return this.connections.filter(a => a.isInput);\n    }\n    get outputs() {\n        return this.connections.filter(a => a.isOutput);\n    }\n    isInput(param) {\n        const connection = this.handleConnectionMap.get(param);\n        return connection && connection.isInput;\n    }\n    isOutput(param) {\n        const connection = this.handleConnectionMap.get(param);\n        return connection && connection.isOutput;\n    }\n    getConnectionByName(name) {\n        return this.handleConnectionMap.get(name);\n    }\n    getSlotSpec(slotName) {\n        return this.slotConnections.get(slotName);\n    }\n    getSlandleSpec(slotName) {\n        const slot = this.slotConnections.get(slotName);\n        if (slot)\n            return slot;\n        const handleConn = this.handleConnectionMap.get(slotName);\n        return handleConn.toSlotConnectionSpec();\n    }\n    slandleConnectionNames() {\n        const slandleNames = this.handleConnections.filter(conn => conn.toSlotConnectionSpec()).map(conn => conn.name);\n        return [...this.slotConnections.keys(), ...slandleNames];\n    }\n    slotConnectionNames() {\n        return [...this.slotConnections.keys()];\n    }\n    get primaryVerb() {\n        return (this.verbs.length > 0) ? this.verbs[0] : undefined;\n    }\n    isCompatible(modality) {\n        return this.slandleConnectionNames().length === 0 || this.modality.intersection(modality).isResolved();\n    }\n    setImplBlobUrl(url) {\n        this.model.implBlobUrl = this.implBlobUrl = url;\n    }\n    toLiteral() {\n        const { args, name, verbs, description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks } = this.model;\n        const connectionToLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: asTypeLiteral(type), direction, name, isOptional, dependentConnections: dependentConnections.map(connectionToLiteral) });\n        const argsLiteral = args.map(a => connectionToLiteral(a));\n        return { args: argsLiteral, name, verbs, description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks };\n    }\n    static fromLiteral(literal) {\n        let { args, name, verbs, description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks } = literal;\n        const connectionFromLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: asType(type), direction, name, isOptional, dependentConnections: dependentConnections ? dependentConnections.map(connectionFromLiteral) : [] });\n        args = args.map(connectionFromLiteral);\n        return new ParticleSpec({ args, name, verbs: verbs || [], description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks });\n    }\n    // Note: this method shouldn't be called directly.\n    clone() {\n        return ParticleSpec.fromLiteral(this.toLiteral());\n    }\n    // Note: this method shouldn't be called directly (only as part of particle copying).\n    cloneWithResolutions(variableMap) {\n        const spec = this.clone();\n        this.handleConnectionMap.forEach((conn, name) => {\n            spec.handleConnectionMap.get(name).type = conn.type._cloneWithResolutions(variableMap);\n        });\n        return spec;\n    }\n    equals(other) {\n        return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());\n    }\n    validateDescription(description) {\n        Object.keys(description || []).forEach(d => {\n            assert(['kind', 'location', 'pattern'].includes(d) || this.handleConnectionMap.has(d), `Unexpected description for ${d}`);\n        });\n    }\n    toInterface() {\n        // TODO: wat do?\n        assert(!this.slotConnections.size, 'please implement slots toInterface');\n        const handles = this.model.args.map(({ type, name, direction }) => ({ type: asType(type), name, direction }));\n        const slots = [];\n        return InterfaceType.make(this.name, handles, slots);\n    }\n    toString() {\n        const results = [];\n        let verbs = '';\n        if (this.verbs.length > 0) {\n            verbs = ' ' + this.verbs.map(verb => `&${verb}`).join(' ');\n        }\n        let line = '';\n        if (this.external) {\n            line += 'external ';\n        }\n        line += `particle ${this.name}${verbs}`;\n        if (this.implFile) {\n            line += ` in '${this.implFile}'`;\n        }\n        results.push(line);\n        const indent = '  ';\n        const writeConnection = (connection, indent) => {\n            const tags = connection.tags.map((tag) => ` #${tag}`).join('');\n            if (Flags.defaultToPreSlandlesSyntax) {\n                // TODO: Remove post slandles syntax\n                results.push(`${indent}${connection.direction}${connection.isOptional ? '?' : ''} ${connection.type.toString()} ${connection.name}${tags}`);\n            }\n            else {\n                const dir = connection.direction === 'any' ? '' : `${AstNode.preSlandlesDirectionToDirection(connection.direction, connection.isOptional)} `;\n                results.push(`${indent}${connection.name}: ${dir}${connection.type.toString()}${tags}`);\n            }\n            for (const dependent of connection.dependentConnections) {\n                writeConnection(dependent, indent + '  ');\n            }\n        };\n        for (const connection of this.handleConnections) {\n            if (connection.parentConnection) {\n                continue;\n            }\n            writeConnection(connection, indent);\n        }\n        this.trustClaims.forEach(claim => results.push(`  ${claim.toManifestString()}`));\n        this.trustChecks.forEach(check => results.push(`  ${check.toManifestString()}`));\n        this.modality.names.forEach(a => results.push(`  modality ${a}`));\n        const slotToString = (s, direction, indent) => {\n            const tokens = [];\n            if (Flags.defaultToPreSlandlesSyntax) {\n                if (s.isRequired) {\n                    tokens.push('must');\n                }\n                tokens.push(direction);\n                if (s.isSet) {\n                    tokens.push('set of');\n                }\n                tokens.push(s.name);\n                if (s.tags.length > 0) {\n                    tokens.push(s.tags.map(a => `#${a}`).join(' '));\n                }\n                results.push(`${indent}${tokens.join(' ')}`);\n                if (s.formFactor) {\n                    results.push(`${indent}  formFactor ${s.formFactor}`);\n                }\n                for (const handle of s.handles) {\n                    results.push(`${indent}  handle ${handle}`);\n                }\n            }\n            else {\n                tokens.push(`${s.name}:`);\n                tokens.push(`${direction}s${s.isRequired ? '' : '?'}`);\n                const fieldSet = [];\n                // TODO(jopra): Move the formFactor and handle to the slot type information.\n                if (s.formFactor) {\n                    fieldSet.push(`formFactor: ${s.formFactor}`);\n                }\n                for (const handle of s.handles) {\n                    fieldSet.push(`handle: ${handle}`);\n                }\n                const fields = (fieldSet.length !== 0) ? ` {${fieldSet.join(', ')}}` : '';\n                if (s.isSet) {\n                    tokens.push(`[Slot${fields}]`);\n                }\n                else {\n                    tokens.push(`Slot${fields}`);\n                }\n                if (s.tags.length > 0) {\n                    tokens.push(s.tags.map(a => `#${a}`).join(' '));\n                }\n                results.push(`${indent}${tokens.join(' ')}`);\n            }\n            if (s.provideSlotConnections) {\n                // Provided slots.\n                s.provideSlotConnections.forEach(p => slotToString(p, 'provide', indent + '  '));\n            }\n        };\n        this.slotConnections.forEach(s => slotToString(s, 'consume', '  '));\n        // Description\n        if (this.pattern) {\n            results.push(`  description \\`${this.pattern}\\``);\n            this.handleConnectionMap.forEach(cs => {\n                if (cs.pattern) {\n                    results.push(`    ${cs.name} \\`${cs.pattern}\\``);\n                }\n            });\n        }\n        return results.join('\\n');\n    }\n    toManifestString() {\n        return this.toString();\n    }\n    validateTrustClaims(statements) {\n        const results = [];\n        if (statements) {\n            statements.forEach(statement => {\n                const handle = this.handleConnectionMap.get(statement.handle);\n                if (!handle) {\n                    throw new Error(`Can't make a claim on unknown handle ${statement.handle}.`);\n                }\n                if (!handle.isOutput) {\n                    throw new Error(`Can't make a claim on handle ${statement.handle} (not an output handle).`);\n                }\n                if (handle.claims) {\n                    throw new Error(`Can't make multiple claims on the same output (${statement.handle}).`);\n                }\n                const particleClaim = createParticleClaim(handle, statement, this.handleConnectionMap);\n                handle.claims = particleClaim.claims;\n                results.push(particleClaim);\n            });\n        }\n        return results;\n    }\n    validateTrustChecks(checks) {\n        const results = [];\n        if (checks) {\n            const providedSlotNames = this.getProvidedSlotsByName();\n            checks.forEach(check => {\n                switch (check.target.targetType) {\n                    case 'handle': {\n                        const handleName = check.target.name;\n                        const handle = this.handleConnectionMap.get(handleName);\n                        if (!handle) {\n                            throw new Error(`Can't make a check on unknown handle ${handleName}.`);\n                        }\n                        if (handle.direction === '`consume' || handle.direction === '`provide') {\n                            // Do slandles versions of slots checks and claims.\n                            if (handle.direction === '`consume') {\n                                throw new Error(`Can't make a check on handle ${handleName}. Can only make checks on input and provided handles.`);\n                            }\n                        }\n                        else if (!handle.isInput) {\n                            throw new Error(`Can't make a check on handle ${handleName} with direction ${handle.direction} (not an input handle).`);\n                        }\n                        if (handle.check) {\n                            throw new Error(`Can't make multiple checks on the same input (${handleName}).`);\n                        }\n                        handle.check = createCheck(handle, check, this.handleConnectionMap);\n                        results.push(handle.check);\n                        break;\n                    }\n                    case 'slot': {\n                        const slotName = check.target.name;\n                        const slotSpec = providedSlotNames.get(slotName);\n                        if (!slotSpec) {\n                            if (this.slotConnectionNames().includes(slotName)) {\n                                throw new Error(`Slot ${slotName} is a consumed slot. Can only make checks on provided slots.`);\n                            }\n                            else {\n                                throw new Error(`Can't make a check on unknown slot ${slotName}.`);\n                            }\n                        }\n                        slotSpec.check = createCheck(slotSpec, check, this.handleConnectionMap);\n                        results.push(slotSpec.check);\n                        break;\n                    }\n                    default:\n                        throw new Error('Unknown check target type.');\n                }\n            });\n        }\n        return results;\n    }\n    getProvidedSlotsByName() {\n        const result = new Map();\n        for (const consumeConnection of this.slotConnections.values()) {\n            for (const provideConnection of consumeConnection.provideSlotConnections) {\n                const name = provideConnection.name;\n                if (result.has(name)) {\n                    throw new Error(`Another slot with name '${name}' has already been provided by this particle.`);\n                }\n                result.set(name, provideConnection);\n            }\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=particle-spec.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nvar ModalityName;\n(function (ModalityName) {\n    ModalityName[\"Dom\"] = \"dom\";\n    ModalityName[\"DomTouch\"] = \"domTouch\";\n    ModalityName[\"Vr\"] = \"vr\";\n    ModalityName[\"Voice\"] = \"voice\";\n})(ModalityName || (ModalityName = {}));\nexport class Modality {\n    // `all` true means modality is non restricted and any modality is compatible.\n    // Otherwise, the `names` field in Modality contains the restrictive list of\n    // modalities (an empty list stands for no suitable modalities being available).\n    constructor(all, names = []) {\n        this.all = all;\n        this.names = names;\n    }\n    static create(names) {\n        assert(names != null);\n        return new Modality(false, names);\n    }\n    intersection(other) {\n        if (this.all && other.all) {\n            return new Modality(true, []);\n        }\n        if (this.all) {\n            return new Modality(false, other.names);\n        }\n        return new Modality(false, this.names.filter(name => other.all || other.names.includes(name)));\n    }\n    static intersection(modalities) {\n        return modalities.reduce((modality, total) => modality.intersection(total), Modality.all);\n    }\n    union(other) {\n        if (this.all || other.all) {\n            return Modality.all;\n        }\n        return new Modality(false, [...new Set(this.names.concat(other.names))]);\n    }\n    static union(modalities) {\n        return modalities.length === 0\n            ? Modality.all\n            : modalities.reduce((modality, total) => modality.union(total), Modality.create([]));\n    }\n    isResolved() {\n        return this.all || this.names.length > 0;\n    }\n    isCompatible(names) {\n        return this.intersection(Modality.create(names)).isResolved();\n    }\n    static get Name() { return ModalityName; }\n}\nModality.all = new Modality(true, []);\nModality.dom = new Modality(false, [Modality.Name.Dom]);\nModality.domTouch = new Modality(false, [Modality.Name.DomTouch]);\nModality.voice = new Modality(false, [Modality.Name.Voice]);\nModality.vr = new Modality(false, [Modality.Name.Vr]);\n//# sourceMappingURL=modality.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { BigCollectionType, CollectionType, EntityType, InterfaceType, ReferenceType, SlotType, Type, TypeVariable } from '../type.js';\nexport class TypeChecker {\n    // resolve a list of handleConnection types against a handle\n    // base type. This is the core type resolution mechanism, but should only\n    // be used when types can actually be associated with each other / constrained.\n    //\n    // By design this function is called exactly once per handle in a recipe during\n    // normalization, and should provide the same final answers regardless of the\n    // ordering of handles within that recipe\n    //\n    // NOTE: you probably don't want to call this function, if you think you\n    // do, talk to shans@.\n    static processTypeList(baseType, list) {\n        const newBaseType = TypeVariable.make('', null, null);\n        if (baseType) {\n            newBaseType.variable.resolution = baseType;\n        }\n        baseType = newBaseType;\n        const concreteTypes = [];\n        // baseType might be a variable (and is definitely a variable if no baseType was available).\n        // Some of the list might contain variables too.\n        // First attempt to merge all the variables into the baseType\n        //\n        // If the baseType is a variable then this results in a single place to manipulate the constraints\n        // of all the other connected variables at the same time.\n        for (const item of list) {\n            if (item.type.resolvedType().hasVariable) {\n                baseType = TypeChecker._tryMergeTypeVariable(baseType, item.type);\n                if (baseType == null) {\n                    return null;\n                }\n            }\n            else {\n                concreteTypes.push(item);\n            }\n        }\n        for (const item of concreteTypes) {\n            if (!TypeChecker._tryMergeConstraints(baseType, item)) {\n                return null;\n            }\n        }\n        const getResolution = (candidate) => {\n            if (!(candidate instanceof TypeVariable)) {\n                return candidate;\n            }\n            if (candidate.canReadSubset == null || candidate.canWriteSuperset == null) {\n                return candidate;\n            }\n            if (candidate.canReadSubset.isMoreSpecificThan(candidate.canWriteSuperset)) {\n                if (candidate.canWriteSuperset.isMoreSpecificThan(candidate.canReadSubset)) {\n                    candidate.variable.resolution = candidate.canReadSubset;\n                }\n                return candidate;\n            }\n            return null;\n        };\n        const candidate = baseType.resolvedType();\n        if (candidate.isCollectionType()) {\n            const resolution = getResolution(candidate.collectionType);\n            return (resolution !== null) ? resolution.collectionOf() : null;\n        }\n        if (candidate.isBigCollectionType()) {\n            const resolution = getResolution(candidate.bigCollectionType);\n            return (resolution !== null) ? resolution.bigCollectionOf() : null;\n        }\n        return getResolution(candidate);\n    }\n    static _tryMergeTypeVariable(base, onto) {\n        const [primitiveBase, primitiveOnto] = Type.unwrapPair(base.resolvedType(), onto.resolvedType());\n        if (primitiveBase instanceof TypeVariable) {\n            if (primitiveOnto instanceof TypeVariable) {\n                // base, onto both variables.\n                const result = primitiveBase.variable.maybeMergeConstraints(primitiveOnto.variable);\n                if (result === false) {\n                    return null;\n                }\n                primitiveOnto.variable.resolution = primitiveBase;\n            }\n            else {\n                // base variable, onto not.\n                if (!primitiveBase.variable.isValidResolutionCandidate(primitiveOnto).result) {\n                    return null;\n                }\n                primitiveBase.variable.resolution = primitiveOnto;\n            }\n            return base;\n        }\n        else if (primitiveOnto instanceof TypeVariable) {\n            // onto variable, base not.\n            if (!primitiveOnto.variable.isValidResolutionCandidate(primitiveBase).result) {\n                return null;\n            }\n            primitiveOnto.variable.resolution = primitiveBase;\n            return onto;\n        }\n        else if (primitiveBase instanceof InterfaceType && primitiveOnto instanceof InterfaceType) {\n            const result = primitiveBase.interfaceInfo.tryMergeTypeVariablesWith(primitiveOnto.interfaceInfo);\n            if (result == null) {\n                return null;\n            }\n            return new InterfaceType(result);\n        }\n        else if ((primitiveBase.isTypeContainer() && primitiveBase.hasVariable)\n            || (primitiveOnto.isTypeContainer() && primitiveOnto.hasVariable)) {\n            // Cannot merge [~a] with a type that is not a variable and not a collection.\n            return null;\n        }\n        throw new Error('tryMergeTypeVariable shouldn\\'t be called on two types without any type variables');\n    }\n    static _tryMergeConstraints(handleType, { type, direction }) {\n        let [primitiveHandleType, primitiveConnectionType] = Type.unwrapPair(handleType.resolvedType(), type.resolvedType());\n        if (primitiveHandleType instanceof TypeVariable) {\n            while (primitiveConnectionType.isTypeContainer()) {\n                if (primitiveHandleType.variable.resolution != null\n                    || primitiveHandleType.variable.canReadSubset != null\n                    || primitiveHandleType.variable.canWriteSuperset != null) {\n                    // Resolved and/or constrained variables can only represent Entities, not sets.\n                    return false;\n                }\n                // If this is an undifferentiated variable then we need to create structure to match against. That's\n                // allowed because this variable could represent anything, and it needs to represent this structure\n                // in order for type resolution to succeed.\n                const newVar = TypeVariable.make('a', null, null);\n                if (primitiveConnectionType instanceof CollectionType) {\n                    primitiveHandleType.variable.resolution = new CollectionType(newVar);\n                }\n                else if (primitiveConnectionType instanceof BigCollectionType) {\n                    primitiveHandleType.variable.resolution = new BigCollectionType(newVar);\n                }\n                else {\n                    primitiveHandleType.variable.resolution = new ReferenceType(newVar);\n                }\n                const unwrap = Type.unwrapPair(primitiveHandleType.resolvedType(), primitiveConnectionType);\n                [primitiveHandleType, primitiveConnectionType] = unwrap;\n                if (!(primitiveHandleType instanceof TypeVariable)) {\n                    // This should never happen, and the guard above is just here so we type-check.\n                    throw new TypeError('unwrapping a wrapped TypeVariable somehow didn\\'t become a TypeVariable');\n                }\n            }\n            if (direction === 'out' || direction === 'inout' || direction === '`provide') {\n                // the canReadSubset of the handle represents the maximal type that can be read from the\n                // handle, so we need to intersect out any type that is more specific than the maximal type\n                // that could be written.\n                if (!primitiveHandleType.variable.maybeMergeCanReadSubset(primitiveConnectionType.canWriteSuperset)) {\n                    return false;\n                }\n            }\n            if (direction === 'in' || direction === 'inout' || direction === '`consume') {\n                // the canWriteSuperset of the handle represents the maximum lower-bound type that is read from the handle,\n                // so we need to union it with the type that wants to be read here.\n                if (!primitiveHandleType.variable.maybeMergeCanWriteSuperset(primitiveConnectionType.canReadSubset)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (primitiveConnectionType.tag !== primitiveHandleType.tag) {\n                return false;\n            }\n            if (direction === 'out' || direction === 'inout') {\n                if (!TypeChecker._writeConstraintsApply(primitiveHandleType, primitiveConnectionType)) {\n                    return false;\n                }\n            }\n            if (direction === 'in' || direction === 'inout') {\n                if (!TypeChecker._readConstraintsApply(primitiveHandleType, primitiveConnectionType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _writeConstraintsApply(handleType, connectionType) {\n        // this connection wants to write to this handle. If the written type is\n        // more specific than the canReadSubset then it isn't violating the maximal type\n        // that can be read.\n        const writtenType = connectionType.canWriteSuperset;\n        if (writtenType == null || handleType.canReadSubset == null) {\n            return true;\n        }\n        if (writtenType.isMoreSpecificThan(handleType.canReadSubset)) {\n            return true;\n        }\n        return false;\n    }\n    static _readConstraintsApply(handleType, connectionType) {\n        // this connection wants to read from this handle. If the read type\n        // is less specific than the canWriteSuperset, then it isn't violating\n        // the maximum lower-bound read type.\n        const readType = connectionType.canReadSubset;\n        if (readType == null || handleType.canWriteSuperset == null) {\n            return true;\n        }\n        if (handleType.canWriteSuperset.isMoreSpecificThan(readType)) {\n            return true;\n        }\n        return false;\n    }\n    // Compare two types to see if they could be potentially resolved (in the absence of other\n    // information). This is used as a filter when selecting compatible handles or checking\n    // validity of recipes. This function returning true never implies that full type resolution\n    // will succeed, but if the function returns false for a pair of types that are associated\n    // then type resolution is guaranteed to fail.\n    //\n    // left, right: {type, direction, connection}\n    static compareTypes(left, right) {\n        const resolvedLeft = left.type.resolvedType();\n        const resolvedRight = right.type.resolvedType();\n        const [leftType, rightType] = Type.unwrapPair(resolvedLeft, resolvedRight);\n        // a variable is compatible with a set only if it is unconstrained.\n        if (leftType instanceof TypeVariable && rightType.isTypeContainer()) {\n            return !(leftType.variable.canReadSubset || leftType.variable.canWriteSuperset);\n        }\n        if (rightType instanceof TypeVariable && leftType.isTypeContainer()) {\n            return !(rightType.variable.canReadSubset || rightType.variable.canWriteSuperset);\n        }\n        if (leftType instanceof TypeVariable || rightType instanceof TypeVariable) {\n            // TODO: everything should use this, eventually. Need to implement the\n            // right functionality in Interfaces first, though.\n            return Type.canMergeConstraints(leftType, rightType);\n        }\n        if ((leftType === undefined) !== (rightType === undefined)) {\n            return false;\n        }\n        if (leftType === rightType) {\n            return true;\n        }\n        if (leftType.tag !== rightType.tag) {\n            return false;\n        }\n        if (leftType instanceof SlotType) {\n            return true;\n        }\n        // TODO: we need a generic way to evaluate type compatibility\n        //       interfaces + entities + etc\n        if (leftType instanceof InterfaceType && rightType instanceof InterfaceType) {\n            if (leftType.interfaceInfo.equals(rightType.interfaceInfo)) {\n                return true;\n            }\n        }\n        if (!(leftType instanceof EntityType) || !(rightType instanceof EntityType)) {\n            return false;\n        }\n        const leftIsSub = leftType.entitySchema.isMoreSpecificThan(rightType.entitySchema);\n        const leftIsSuper = rightType.entitySchema.isMoreSpecificThan(leftType.entitySchema);\n        if (leftIsSuper && leftIsSub) {\n            return true;\n        }\n        if (!leftIsSuper && !leftIsSub) {\n            return false;\n        }\n        const [superclass, subclass] = leftIsSuper ? [left, right] : [right, left];\n        // treat handle types as if they were 'inout' connections. Note that this\n        // guarantees that the handle's type will be preserved, and that the fact\n        // that the type comes from a handle rather than a connection will also\n        // be preserved.\n        const superDirection = superclass.direction || (superclass.connection ? superclass.connection.direction : 'inout');\n        const subDirection = subclass.direction || (subclass.connection ? subclass.connection.direction : 'inout');\n        if (superDirection === 'in') {\n            return true;\n        }\n        if (subDirection === 'out') {\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=type-checker.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { InterfaceInfo } from './interface-info.js';\nimport { SlotInfo } from './slot-info.js';\nimport { ArcInfo } from './synthetic-types.js';\nimport { TypeVariableInfo } from './type-variable-info.js';\nimport { CRDTCount } from './crdt/crdt-count.js';\nimport { CRDTCollection } from './crdt/crdt-collection.js';\nimport { CRDTSingleton } from './crdt/crdt-singleton.js';\nimport { CollectionHandle, SingletonHandle } from './storageNG/handle.js';\nimport { Schema } from './schema.js';\nexport class Type {\n    constructor(tag) {\n        this.tag = tag;\n    }\n    static fromLiteral(literal) {\n        switch (literal.tag) {\n            case 'Entity':\n                return new EntityType(Schema.fromLiteral(literal.data));\n            case 'TypeVariable':\n                return new TypeVariable(TypeVariableInfo.fromLiteral(literal.data));\n            case 'Collection':\n                return new CollectionType(Type.fromLiteral(literal.data));\n            case 'BigCollection':\n                return new BigCollectionType(Type.fromLiteral(literal.data));\n            case 'Relation':\n                return new RelationType(literal.data.map(t => Type.fromLiteral(t)));\n            case 'Interface':\n                return new InterfaceType(InterfaceInfo.fromLiteral(literal.data));\n            case 'Slot':\n                return new SlotType(SlotInfo.fromLiteral(literal.data));\n            case 'Reference':\n                return new ReferenceType(Type.fromLiteral(literal.data));\n            case 'Arc':\n                return new ArcType();\n            case 'Handle':\n                return new HandleType();\n            case 'Singleton':\n                return new SingletonType(Type.fromLiteral(literal.data));\n            default:\n                throw new Error(`fromLiteral: unknown type ${literal}`);\n        }\n    }\n    static unwrapPair(type1, type2) {\n        if (type1.tag === type2.tag) {\n            const contained1 = type1.getContainedType();\n            if (contained1 !== null) {\n                return Type.unwrapPair(contained1, type2.getContainedType());\n            }\n        }\n        return [type1, type2];\n    }\n    /** Tests whether two types' constraints are compatible with each other. */\n    static canMergeConstraints(type1, type2) {\n        return Type._canMergeCanReadSubset(type1, type2) && Type._canMergeCanWriteSuperset(type1, type2);\n    }\n    static _canMergeCanReadSubset(type1, type2) {\n        if (type1.canReadSubset && type2.canReadSubset) {\n            if (type1.canReadSubset.tag !== type2.canReadSubset.tag) {\n                return false;\n            }\n            if (type1.canReadSubset instanceof EntityType && type2.canReadSubset instanceof EntityType) {\n                return Schema.intersect(type1.canReadSubset.entitySchema, type2.canReadSubset.entitySchema) !== null;\n            }\n            throw new Error(`_canMergeCanReadSubset not implemented for types tagged with ${type1.canReadSubset.tag}`);\n        }\n        return true;\n    }\n    static _canMergeCanWriteSuperset(type1, type2) {\n        if (type1.canWriteSuperset && type2.canWriteSuperset) {\n            if (type1.canWriteSuperset.tag !== type2.canWriteSuperset.tag) {\n                return false;\n            }\n            if (type1.canWriteSuperset instanceof EntityType && type2.canWriteSuperset instanceof EntityType) {\n                return Schema.union(type1.canWriteSuperset.entitySchema, type2.canWriteSuperset.entitySchema) !== null;\n            }\n        }\n        return true;\n    }\n    isSlot() {\n        return this instanceof SlotType;\n    }\n    slandleType() {\n        if (this.isSlot()) {\n            return this;\n        }\n        if (this.isCollectionType() && this.collectionType.isSlot()) {\n            return this.collectionType;\n        }\n        return undefined;\n    }\n    // If you want to type-check fully, this is an improvement over just using\n    // this instanceof CollectionType,\n    // because instanceof doesn't propagate generic restrictions.\n    isCollectionType() {\n        return this instanceof CollectionType;\n    }\n    // If you want to type-check fully, this is an improvement over just using\n    // this instaneceof BigCollectionType,\n    // because instanceof doesn't propagate generic restrictions.\n    isBigCollectionType() {\n        return this instanceof BigCollectionType;\n    }\n    isResolved() {\n        // TODO: one of these should not exist.\n        return !this.hasUnresolvedVariable;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        return this;\n    }\n    _applyExistenceTypeTest(test) {\n        return test(this);\n    }\n    get hasVariable() {\n        return this._applyExistenceTypeTest(type => type instanceof TypeVariable);\n    }\n    get hasUnresolvedVariable() {\n        return this._applyExistenceTypeTest(type => type instanceof TypeVariable && !type.variable.isResolved());\n    }\n    getContainedType() {\n        return null;\n    }\n    isTypeContainer() {\n        return false;\n    }\n    get isReference() {\n        return false;\n    }\n    get isSingleton() {\n        return false;\n    }\n    get isEntity() {\n        return false;\n    }\n    collectionOf() {\n        return new CollectionType(this);\n    }\n    bigCollectionOf() {\n        return new BigCollectionType(this);\n    }\n    resolvedType() {\n        return this;\n    }\n    canEnsureResolved() {\n        return this.isResolved() || this._canEnsureResolved();\n    }\n    _canEnsureResolved() {\n        return true;\n    }\n    maybeEnsureResolved() {\n        return true;\n    }\n    get canWriteSuperset() {\n        throw new Error(`canWriteSuperset not implemented for ${this}`);\n    }\n    get canReadSubset() {\n        throw new Error(`canReadSubset not implemented for ${this}`);\n    }\n    isMoreSpecificThan(type) {\n        return this.tag === type.tag && this._isMoreSpecificThan(type);\n    }\n    _isMoreSpecificThan(type) {\n        throw new Error(`isMoreSpecificThan not implemented for ${this}`);\n    }\n    /**\n     * Clone a type object.\n     * When cloning multiple types, variables that were associated with the same name\n     * before cloning should still be associated after cloning. To maintain this\n     * property, create a Map() and pass it into all clone calls in the group.\n     */\n    clone(variableMap) {\n        return this.resolvedType()._clone(variableMap);\n    }\n    _clone(variableMap) {\n        return Type.fromLiteral(this.toLiteral());\n    }\n    /**\n     * Clone a type object, maintaining resolution information.\n     * This function SHOULD NOT BE USED at the type level. In order for type variable\n     * information to be maintained correctly, an entire context root needs to be\n     * cloned.\n     */\n    _cloneWithResolutions(variableMap) {\n        return Type.fromLiteral(this.toLiteral());\n    }\n    // TODO: is this the same as _applyExistenceTypeTest\n    hasProperty(property) {\n        return property(this) || this._hasProperty(property);\n    }\n    _hasProperty(property) {\n        return false;\n    }\n    toString(options = undefined) {\n        return this.tag;\n    }\n    getEntitySchema() {\n        return null;\n    }\n    toPrettyString() {\n        return null;\n    }\n    crdtInstanceConstructor() {\n        return null;\n    }\n    handleConstructor() {\n        return null;\n    }\n}\nexport class CountType extends Type {\n    constructor() {\n        super('Count');\n    }\n    toLiteral() {\n        return { tag: 'Count' };\n    }\n    crdtInstanceConstructor() {\n        return CRDTCount;\n    }\n}\nexport class SingletonType extends Type {\n    constructor(type) {\n        super('Singleton');\n        this.innerType = type;\n    }\n    toLiteral() {\n        return { tag: 'Singleton', data: this.innerType.toLiteral() };\n    }\n    getContainedType() {\n        return this.innerType;\n    }\n    crdtInstanceConstructor() {\n        return CRDTSingleton;\n    }\n    handleConstructor() {\n        return SingletonHandle;\n    }\n    get isSingleton() {\n        return true;\n    }\n    getEntitySchema() {\n        return this.innerType.getEntitySchema();\n    }\n    toString(options = undefined) {\n        return `![${this.innerType.toString(options)}]`;\n    }\n}\nexport class EntityType extends Type {\n    constructor(schema) {\n        super('Entity');\n        this.entitySchema = schema;\n    }\n    static make(names, fields, description) {\n        return new EntityType(new Schema(names, fields, description));\n    }\n    // These type identifier methods are being left in place for non-runtime code.\n    get isEntity() {\n        return true;\n    }\n    get canWriteSuperset() {\n        return this;\n    }\n    get canReadSubset() {\n        return this;\n    }\n    _isMoreSpecificThan(type) {\n        return this.entitySchema.isMoreSpecificThan(type.entitySchema);\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.entitySchema.toLiteral() };\n    }\n    toString(options = undefined) {\n        return this.entitySchema.toInlineSchemaString(options);\n    }\n    getEntitySchema() {\n        return this.entitySchema;\n    }\n    _cloneWithResolutions(variableMap) {\n        if (variableMap.has(this.entitySchema)) {\n            return variableMap.get(this.entitySchema);\n        }\n        const clonedEntityType = new EntityType(this.entitySchema);\n        variableMap.set(this.entitySchema, clonedEntityType);\n        return clonedEntityType;\n    }\n    toPrettyString() {\n        if (this.entitySchema.description.pattern) {\n            return this.entitySchema.description.pattern;\n        }\n        // Spit MyTypeFOO to My Type FOO\n        if (this.entitySchema.name) {\n            return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2')\n                .replace(/([A-Z][^A-Z])/g, ' $1')\n                .replace(/[\\s]+/g, ' ')\n                .trim();\n        }\n        return JSON.stringify(this.entitySchema.toLiteral());\n    }\n    crdtInstanceConstructor() {\n        return this.entitySchema.crdtConstructor();\n    }\n    handleConstructor() {\n        // Currently using SingletonHandle as the implementation for Entity handles.\n        // TODO: Make an EntityHandle class that uses the proper Entity CRDT.\n        throw new Error(`Entity handle not yet implemented - you probably want to use a SingletonType`);\n    }\n}\nexport class TypeVariable extends Type {\n    constructor(variable) {\n        super('TypeVariable');\n        this.variable = variable;\n    }\n    static make(name, canWriteSuperset, canReadSubset) {\n        return new TypeVariable(new TypeVariableInfo(name, canWriteSuperset, canReadSubset));\n    }\n    get isVariable() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const name = this.variable.name;\n        let variable = variableMap.get(name);\n        if (!variable) {\n            variable = this;\n            variableMap.set(name, this);\n        }\n        else if (variable instanceof TypeVariable) {\n            if (variable.variable.hasConstraint || this.variable.hasConstraint) {\n                const mergedConstraint = variable.variable.maybeMergeConstraints(this.variable);\n                if (!mergedConstraint) {\n                    throw new Error('could not merge type variables');\n                }\n            }\n        }\n        return variable;\n    }\n    resolvedType() {\n        return this.variable.resolution || this;\n    }\n    _canEnsureResolved() {\n        return this.variable.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.variable.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return this.variable.canWriteSuperset;\n    }\n    get canReadSubset() {\n        return this.variable.canReadSubset;\n    }\n    _clone(variableMap) {\n        const name = this.variable.name;\n        if (variableMap.has(name)) {\n            return new TypeVariable(variableMap.get(name));\n        }\n        else {\n            const newTypeVariable = TypeVariableInfo.fromLiteral(this.variable.toLiteral());\n            variableMap.set(name, newTypeVariable);\n            return new TypeVariable(newTypeVariable);\n        }\n    }\n    _cloneWithResolutions(variableMap) {\n        if (variableMap.has(this.variable)) {\n            return new TypeVariable(variableMap.get(this.variable));\n        }\n        else {\n            const newTypeVariable = TypeVariableInfo.fromLiteral(this.variable.toLiteralIgnoringResolutions());\n            if (this.variable.resolution) {\n                newTypeVariable._resolution = this.variable._resolution._cloneWithResolutions(variableMap);\n            }\n            if (this.variable._canReadSubset) {\n                newTypeVariable.canReadSubset = this.variable.canReadSubset._cloneWithResolutions(variableMap);\n            }\n            if (this.variable._canWriteSuperset) {\n                newTypeVariable.canWriteSuperset = this.variable.canWriteSuperset._cloneWithResolutions(variableMap);\n            }\n            variableMap.set(this.variable, newTypeVariable);\n            return new TypeVariable(newTypeVariable);\n        }\n    }\n    toLiteral() {\n        return this.variable.resolution ? this.variable.resolution.toLiteral()\n            : { tag: this.tag, data: this.variable.toLiteral() };\n    }\n    toString(options = undefined) {\n        return `~${this.variable.name}`;\n    }\n    getEntitySchema() {\n        return this.variable.isResolved() ? this.resolvedType().getEntitySchema() : null;\n    }\n    toPrettyString() {\n        return this.variable.isResolved() ? this.resolvedType().toPrettyString() : `[~${this.variable.name}]`;\n    }\n}\nexport class CollectionType extends Type {\n    constructor(collectionType) {\n        super('Collection');\n        this.collectionType = collectionType;\n    }\n    get isCollection() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const collectionType = this.collectionType;\n        const result = collectionType.mergeTypeVariablesByName(variableMap);\n        return (result === collectionType) ? this : result.collectionOf();\n    }\n    _applyExistenceTypeTest(test) {\n        return this.collectionType._applyExistenceTypeTest(test);\n    }\n    getContainedType() {\n        return this.collectionType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const collectionType = this.collectionType;\n        const resolvedCollectionType = collectionType.resolvedType();\n        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.collectionOf() : this;\n    }\n    _canEnsureResolved() {\n        return this.collectionType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.collectionType.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return InterfaceType.make(this.tag, [], []);\n    }\n    get canReadSubset() {\n        return InterfaceType.make(this.tag, [], []);\n    }\n    _clone(variableMap) {\n        const data = this.collectionType.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new CollectionType(this.collectionType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.collectionType.toLiteral() };\n    }\n    _hasProperty(property) {\n        return this.collectionType.hasProperty(property);\n    }\n    toString(options = undefined) {\n        return `[${this.collectionType.toString(options)}]`;\n    }\n    getEntitySchema() {\n        return this.collectionType.getEntitySchema();\n    }\n    toPrettyString() {\n        const entitySchema = this.getEntitySchema();\n        if (entitySchema && entitySchema.description.plural) {\n            return entitySchema.description.plural;\n        }\n        return `${this.collectionType.toPrettyString()} List`;\n    }\n    crdtInstanceConstructor() {\n        return CRDTCollection;\n    }\n    handleConstructor() {\n        return CollectionHandle;\n    }\n}\nexport class BigCollectionType extends Type {\n    constructor(bigCollectionType) {\n        super('BigCollection');\n        this.bigCollectionType = bigCollectionType;\n    }\n    get isBigCollection() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const collectionType = this.bigCollectionType;\n        const result = collectionType.mergeTypeVariablesByName(variableMap);\n        return (result === collectionType) ? this : result.bigCollectionOf();\n    }\n    _applyExistenceTypeTest(test) {\n        return this.bigCollectionType._applyExistenceTypeTest(test);\n    }\n    getContainedType() {\n        return this.bigCollectionType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const collectionType = this.bigCollectionType;\n        const resolvedCollectionType = collectionType.resolvedType();\n        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.bigCollectionOf() : this;\n    }\n    _canEnsureResolved() {\n        return this.bigCollectionType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.bigCollectionType.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return InterfaceType.make(this.tag, [], []);\n    }\n    get canReadSubset() {\n        return InterfaceType.make(this.tag, [], []);\n    }\n    _clone(variableMap) {\n        const data = this.bigCollectionType.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new BigCollectionType(this.bigCollectionType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.bigCollectionType.toLiteral() };\n    }\n    _hasProperty(property) {\n        return this.bigCollectionType.hasProperty(property);\n    }\n    toString(options = undefined) {\n        return `BigCollection<${this.bigCollectionType.toString(options)}>`;\n    }\n    getEntitySchema() {\n        return this.bigCollectionType.getEntitySchema();\n    }\n    toPrettyString() {\n        const entitySchema = this.getEntitySchema();\n        if (entitySchema && entitySchema.description.plural) {\n            return entitySchema.description.plural;\n        }\n        return `Collection of ${this.bigCollectionType.toPrettyString()}`;\n    }\n}\nexport class RelationType extends Type {\n    constructor(relation) {\n        super('Relation');\n        this.relationEntities = relation;\n    }\n    get isRelation() {\n        return true;\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.relationEntities.map(t => t.toLiteral()) };\n    }\n    toPrettyString() {\n        return JSON.stringify(this.relationEntities);\n    }\n}\nexport class InterfaceType extends Type {\n    constructor(iface) {\n        super('Interface');\n        this.interfaceInfo = iface;\n    }\n    static make(name, handleConnections, slots) {\n        return new InterfaceType(new InterfaceInfo(name, handleConnections, slots));\n    }\n    get isInterface() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const interfaceInfo = this.interfaceInfo.clone(new Map());\n        interfaceInfo.mergeTypeVariablesByName(variableMap);\n        // TODO: only build a new type when a variable is modified\n        return new InterfaceType(interfaceInfo);\n    }\n    _applyExistenceTypeTest(test) {\n        return this.interfaceInfo._applyExistenceTypeTest(test);\n    }\n    resolvedType() {\n        return new InterfaceType(this.interfaceInfo.resolvedType());\n    }\n    _canEnsureResolved() {\n        return this.interfaceInfo.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.interfaceInfo.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return new InterfaceType(this.interfaceInfo.canWriteSuperset);\n    }\n    get canReadSubset() {\n        return new InterfaceType(this.interfaceInfo.canReadSubset);\n    }\n    _isMoreSpecificThan(type) {\n        return this.interfaceInfo.isMoreSpecificThan(type.interfaceInfo);\n    }\n    _clone(variableMap) {\n        const data = this.interfaceInfo.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new InterfaceType(this.interfaceInfo._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.interfaceInfo.toLiteral() };\n    }\n    toString(options = undefined) {\n        return this.interfaceInfo.name;\n    }\n    toPrettyString() {\n        return this.interfaceInfo.toPrettyString();\n    }\n}\nexport class SlotType extends Type {\n    constructor(slot) {\n        super('Slot');\n        this.slot = slot;\n    }\n    static make(formFactor, handle) {\n        return new SlotType(new SlotInfo(formFactor, handle));\n    }\n    getSlot() {\n        return this.slot;\n    }\n    get canWriteSuperset() {\n        return this;\n    }\n    get canReadSubset() {\n        return this;\n    }\n    _isMoreSpecificThan(type) {\n        // TODO: formFactor checking, etc.\n        return true;\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.slot.toLiteral() };\n    }\n    toString(options = undefined) {\n        const fields = [];\n        for (const key of Object.keys(this.slot)) {\n            if (this.slot[key] !== undefined) {\n                fields.push(`${key}:${this.slot[key]}`);\n            }\n        }\n        let fieldsString = '';\n        if (fields.length !== 0) {\n            fieldsString = ` {${fields.join(', ')}}`;\n        }\n        return `Slot${fieldsString}`;\n    }\n    toPrettyString() {\n        const fields = [];\n        for (const key of Object.keys(this.slot)) {\n            if (this.slot[key] !== undefined) {\n                fields.push(`${key}:${this.slot[key]}`);\n            }\n        }\n        let fieldsString = '';\n        if (fields.length !== 0) {\n            fieldsString = ` {${fields.join(', ')}}`;\n        }\n        return `Slot${fieldsString}`;\n    }\n}\nexport class ReferenceType extends Type {\n    constructor(reference) {\n        super('Reference');\n        if (reference == null) {\n            throw new Error('invalid type! Reference types must include a referenced type declaration');\n        }\n        this.referredType = reference;\n    }\n    get isReference() {\n        return true;\n    }\n    getContainedType() {\n        return this.referredType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const referredType = this.referredType;\n        const resolvedReferredType = referredType.resolvedType();\n        return (referredType !== resolvedReferredType) ? new ReferenceType(resolvedReferredType) : this;\n    }\n    _canEnsureResolved() {\n        return this.referredType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.referredType.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        // TODO(cypher1): Possibly cannot write to references.\n        return this.referredType.canWriteSuperset;\n    }\n    get canReadSubset() {\n        return this.referredType.canReadSubset;\n    }\n    _clone(variableMap) {\n        const data = this.referredType.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new ReferenceType(this.referredType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.referredType.toLiteral() };\n    }\n    toString(options = undefined) {\n        return 'Reference<' + this.referredType.toString() + '>';\n    }\n    toPrettyString() {\n        return 'Reference to ' + this.referredType.toPrettyString();\n    }\n    getEntitySchema() {\n        return this.referredType.getEntitySchema();\n    }\n    crdtInstanceConstructor() {\n        return this.referredType.crdtInstanceConstructor();\n    }\n}\nexport class ArcType extends Type {\n    constructor() {\n        super('Arc');\n    }\n    get isArc() {\n        return true;\n    }\n    newInstance(arcId, serialization) {\n        return new ArcInfo(arcId, serialization);\n    }\n    toLiteral() {\n        return { tag: this.tag };\n    }\n}\nexport class HandleType extends Type {\n    constructor() {\n        super('Handle');\n    }\n    get isHandle() {\n        return true;\n    }\n    toLiteral() {\n        return { tag: this.tag };\n    }\n}\n//# sourceMappingURL=type.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Type, TypeVariable } from './type.js';\nimport * as AstNode from './manifest-ast-nodes.js';\nimport { Flags } from './flags.js';\nfunction _typeFromLiteral(member) {\n    return Type.fromLiteral(member);\n}\nfunction _typeVarOrStringFromLiteral(member) {\n    if (typeof member === 'object') {\n        return _typeFromLiteral(member);\n    }\n    return member;\n}\nfunction _HandleConnectionFromLiteral({ type, name, direction }) {\n    return {\n        type: type ? _typeFromLiteral(type) : undefined,\n        name: name ? _typeVarOrStringFromLiteral(name) : undefined,\n        direction: direction || 'any'\n    };\n}\nfunction _SlotFromLiteral({ name, direction, isRequired, isSet }) {\n    return {\n        name: name ? _typeVarOrStringFromLiteral(name) : undefined,\n        direction, isRequired, isSet\n    };\n}\nfunction _typeToLiteral(member) {\n    return member.toLiteral();\n}\nfunction _typeVarOrStringToLiteral(member) {\n    if (member instanceof TypeVariable) {\n        return member.toLiteral();\n    }\n    return member;\n}\nfunction _HandleConnectionToLiteral({ type, name, direction }) {\n    return {\n        type: type && _typeToLiteral(type),\n        name: name && _typeVarOrStringToLiteral(name),\n        direction\n    };\n}\nfunction _SlotToLiteral({ name, direction, isRequired, isSet }) {\n    return {\n        name: name && _typeVarOrStringToLiteral(name),\n        direction,\n        isRequired,\n        isSet\n    };\n}\nconst handleConnectionFields = ['type', 'name', 'direction'];\nconst slotFields = ['name', 'direction', 'isRequired', 'isSet'];\nexport class InterfaceInfo {\n    constructor(name, handleConnections, slots) {\n        assert(name);\n        assert(handleConnections !== undefined);\n        assert(slots !== undefined);\n        this.name = name;\n        this.handleConnections = handleConnections;\n        this.slots = slots;\n        this.typeVars = [];\n        for (const handleConnection of handleConnections) {\n            for (const field of handleConnectionFields) {\n                if (InterfaceInfo.isTypeVar(handleConnection[field])) {\n                    this.typeVars.push({ object: handleConnection, field });\n                }\n            }\n        }\n        for (const slot of slots) {\n            for (const field of slotFields) {\n                if (InterfaceInfo.isTypeVar(slot[field])) {\n                    this.typeVars.push({ object: slot, field });\n                }\n            }\n        }\n    }\n    toPrettyString() {\n        return 'InterfaceInfo';\n    }\n    mergeTypeVariablesByName(variableMap) {\n        this.typeVars.forEach(({ object, field }) => object[field] = object[field].mergeTypeVariablesByName(variableMap));\n    }\n    get canReadSubset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canReadSubset);\n    }\n    get canWriteSuperset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canWriteSuperset);\n    }\n    isMoreSpecificThan(other) {\n        if (this.handleConnections.length !== other.handleConnections.length ||\n            this.slots.length !== other.slots.length) {\n            return false;\n        }\n        // TODO: should probably confirm that handleConnections and slots actually match.\n        for (let i = 0; i < this.typeVars.length; i++) {\n            const thisTypeVar = this.typeVars[i];\n            const otherTypeVar = other.typeVars[i];\n            if (!thisTypeVar.object[thisTypeVar.field].isMoreSpecificThan(otherTypeVar.object[otherTypeVar.field])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _applyExistenceTypeTest(test) {\n        for (const typeRef of this.typeVars) {\n            if (test(typeRef.object[typeRef.field])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _handleConnectionsToManifestString() {\n        return this.handleConnections\n            .map(h => {\n            if (Flags.defaultToPreSlandlesSyntax) {\n                return `  ${h.direction || 'any'} ${h.type.toString()} ${h.name ? h.name : '*'}`;\n            }\n            else {\n                const parts = [];\n                if (h.name) {\n                    parts.push(`${h.name}:`);\n                }\n                if (h.direction !== undefined && h.direction !== 'any') {\n                    parts.push(AstNode.preSlandlesDirectionToDirection(h.direction));\n                }\n                parts.push(h.type.toString());\n                return `  ${parts.join(' ')}`;\n            }\n        }).join('\\n');\n    }\n    _slotsToManifestString() {\n        // TODO deal with isRequired\n        return this.slots\n            .map(slot => {\n            if (Flags.defaultToPreSlandlesSyntax) {\n                return `  ${slot.isRequired ? 'must ' : ''}${slot.direction} ${slot.isSet ? 'set of ' : ''}${slot.name || ''}`;\n            }\n            else {\n                const nameStr = slot.name ? `${slot.name}: ` : '';\n                return `  ${nameStr}${slot.direction}s${slot.isRequired ? '' : '?'} ${slot.isSet ? '[Slot]' : 'Slot'}`;\n            }\n        })\n            .join('\\n');\n    }\n    // TODO: Include name as a property of the interface and normalize this to just toString()\n    toString() {\n        return `interface ${this.name}\n${this._handleConnectionsToManifestString()}\n${this._slotsToManifestString()}`;\n    }\n    static fromLiteral(data) {\n        const handleConnections = data.handleConnections.map(_HandleConnectionFromLiteral);\n        const slots = data.slots.map(_SlotFromLiteral);\n        return new InterfaceInfo(data.name, handleConnections, slots);\n    }\n    toLiteral() {\n        const handleConnections = this.handleConnections.map(_HandleConnectionToLiteral);\n        const slots = this.slots.map(_SlotToLiteral);\n        return { name: this.name, handleConnections, slots };\n    }\n    clone(variableMap) {\n        const handleConnections = this.handleConnections.map(({ name, direction, type }) => ({ name, direction, type: type ? type.clone(variableMap) : undefined }));\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new InterfaceInfo(this.name, handleConnections, slots);\n    }\n    cloneWithResolutions(variableMap) {\n        return this._cloneWithResolutions(variableMap);\n    }\n    _cloneWithResolutions(variableMap) {\n        const handleConnections = this.handleConnections.map(({ name, direction, type }) => ({ name, direction, type: type ? type._cloneWithResolutions(variableMap) : undefined }));\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new InterfaceInfo(this.name, handleConnections, slots);\n    }\n    canEnsureResolved() {\n        for (const typeVar of this.typeVars) {\n            if (!typeVar.object[typeVar.field].canEnsureResolved()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    maybeEnsureResolved() {\n        for (const typeVar of this.typeVars) {\n            let variable = typeVar.object[typeVar.field];\n            variable = variable.clone(new Map());\n            if (!variable.maybeEnsureResolved())\n                return false;\n        }\n        for (const typeVar of this.typeVars) {\n            typeVar.object[typeVar.field].maybeEnsureResolved();\n        }\n        return true;\n    }\n    tryMergeTypeVariablesWith(other) {\n        // Type variable enabled slot matching will Just Work when we\n        // unify slots and handleConnections.\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return null;\n        }\n        if (other.handleConnections.length !== this.handleConnections.length) {\n            return null;\n        }\n        const handleConnections = new Set(this.handleConnections);\n        const otherHandleConnections = new Set(other.handleConnections);\n        const handleConnectionMap = new Map();\n        let sizeCheck = handleConnections.size;\n        while (handleConnections.size > 0) {\n            const handleConnectionMatches = [...handleConnections.values()].map(handleConnection => ({ handleConnection, match: [...otherHandleConnections.values()].filter(otherHandleConnection => this._equalHandleConnection(handleConnection, otherHandleConnection)) }));\n            for (const handleConnectionMatch of handleConnectionMatches) {\n                // no match!\n                if (handleConnectionMatch.match.length === 0) {\n                    return null;\n                }\n                if (handleConnectionMatch.match.length === 1) {\n                    handleConnectionMap.set(handleConnectionMatch.handleConnection, handleConnectionMatch.match[0]);\n                    otherHandleConnections.delete(handleConnectionMatch.match[0]);\n                    handleConnections.delete(handleConnectionMatch.handleConnection);\n                }\n            }\n            // no progress!\n            if (handleConnections.size === sizeCheck) {\n                return null;\n            }\n            sizeCheck = handleConnections.size;\n        }\n        const handleConnectionList = [];\n        for (const handleConnection of this.handleConnections) {\n            const otherHandleConnection = handleConnectionMap.get(handleConnection);\n            let resultType;\n            if (handleConnection.type.hasVariable || otherHandleConnection.type.hasVariable) {\n                resultType = TypeChecker._tryMergeTypeVariable(handleConnection.type, otherHandleConnection.type);\n                if (!resultType) {\n                    return null;\n                }\n            }\n            else {\n                resultType = handleConnection.type || otherHandleConnection.type;\n            }\n            handleConnectionList.push({ name: handleConnection.name || otherHandleConnection.name, direction: handleConnection.direction || otherHandleConnection.direction, type: resultType });\n        }\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new InterfaceInfo(this.name, handleConnectionList, slots);\n    }\n    resolvedType() {\n        return this._cloneAndUpdate(typeVar => typeVar.resolvedType());\n    }\n    equals(other) {\n        if (this.handleConnections.length !== other.handleConnections.length) {\n            return false;\n        }\n        // TODO: this isn't quite right as it doesn't deal with duplicates properly\n        if (!this._equalItems(other.handleConnections, this.handleConnections, this._equalHandleConnection)) {\n            return false;\n        }\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return false;\n        }\n        return true;\n    }\n    _equalHandleConnection(handleConnection, otherHandleConnection) {\n        return handleConnection.name === otherHandleConnection.name\n            && handleConnection.direction === otherHandleConnection.direction\n            && TypeChecker.compareTypes({ type: handleConnection.type }, { type: otherHandleConnection.type });\n    }\n    _equalSlot(slot, otherSlot) {\n        return slot.name === otherSlot.name && slot.direction === otherSlot.direction && slot.isRequired === otherSlot.isRequired && slot.isSet === otherSlot.isSet;\n    }\n    _equalItems(otherItems, items, compareItem) {\n        for (const otherItem of otherItems) {\n            let exists = false;\n            for (const item of items) {\n                if (compareItem(item, otherItem)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _cloneAndUpdate(update) {\n        const copy = this.clone(new Map());\n        copy.typeVars.forEach(typeVar => InterfaceInfo._updateTypeVar(typeVar, update));\n        return copy;\n    }\n    static _updateTypeVar(typeVar, update) {\n        typeVar.object[typeVar.field] = update(typeVar.object[typeVar.field]);\n    }\n    static isTypeVar(reference) {\n        return reference instanceof TypeVariable || reference instanceof Type && reference.hasVariable;\n    }\n    static mustMatch(reference) {\n        return !(reference == undefined || InterfaceInfo.isTypeVar(reference));\n    }\n    static handleConnectionsMatch(interfaceHandleConnection, particleHandleConnection) {\n        if (InterfaceInfo.mustMatch(interfaceHandleConnection.name) &&\n            interfaceHandleConnection.name !== particleHandleConnection.name) {\n            return false;\n        }\n        // TODO: FIXME direction subsetting?\n        if (InterfaceInfo.mustMatch(interfaceHandleConnection.direction)\n            && interfaceHandleConnection.direction !== 'any'\n            && particleHandleConnection.direction !== 'any'\n            && interfaceHandleConnection.direction !== particleHandleConnection.direction) {\n            return false;\n        }\n        if (interfaceHandleConnection.type == undefined) {\n            return true;\n        }\n        const [left, right] = Type.unwrapPair(interfaceHandleConnection.type, particleHandleConnection.type);\n        if (left instanceof TypeVariable) {\n            return [{ var: left, value: right, direction: interfaceHandleConnection.direction }];\n        }\n        else {\n            return TypeChecker.compareTypes({ type: left }, { type: right });\n        }\n    }\n    static slotsMatch(interfaceSlot, particleSlot) {\n        if (InterfaceInfo.mustMatch(interfaceSlot.name) &&\n            interfaceSlot.name !== particleSlot.name) {\n            return false;\n        }\n        if (InterfaceInfo.mustMatch(interfaceSlot.direction) &&\n            interfaceSlot.direction !== particleSlot.direction) {\n            return false;\n        }\n        if (InterfaceInfo.mustMatch(interfaceSlot.isRequired) &&\n            interfaceSlot.isRequired !== particleSlot.isRequired) {\n            return false;\n        }\n        if (InterfaceInfo.mustMatch(interfaceSlot.isSet) &&\n            interfaceSlot.isSet !== particleSlot.isSet) {\n            return false;\n        }\n        return true;\n    }\n    particleMatches(particleSpec) {\n        const interfaceInfo = this.cloneWithResolutions(new Map());\n        return interfaceInfo.restrictType(particleSpec) !== false;\n    }\n    restrictType(particleSpec) {\n        return this._restrictThis(particleSpec);\n    }\n    _restrictThis(particleSpec) {\n        const handleConnectionMatches = this.handleConnections.map(h => particleSpec.handleConnections.map(c => ({ match: c, result: InterfaceInfo.handleConnectionsMatch(h, c) }))\n            .filter(a => a.result !== false));\n        const particleSlots = [];\n        particleSpec.slotConnections.forEach(consumedSlot => {\n            particleSlots.push({ name: consumedSlot.name, direction: 'consume', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet });\n            consumedSlot.provideSlotConnections.forEach(providedSlot => {\n                particleSlots.push({ name: providedSlot.name, direction: 'provide', isRequired: false, isSet: providedSlot.isSet });\n            });\n        });\n        const slotsThatMatch = this.slots.map(slot => particleSlots.filter(particleSlot => InterfaceInfo.slotsMatch(slot, particleSlot)));\n        const slotMatches = slotsThatMatch.map(matchList => matchList.map(slot => ({ match: slot, result: true })));\n        // TODO: this probably doesn't deal with multiple match options.\n        function choose(list, exclusions) {\n            if (list.length === 0) {\n                return [];\n            }\n            const thisLevel = list.pop();\n            for (const connection of thisLevel) {\n                if (exclusions.includes(connection.match)) {\n                    continue;\n                }\n                const newExclusions = exclusions.slice();\n                newExclusions.push(connection.match);\n                const constraints = choose(list, newExclusions);\n                if (constraints !== false) {\n                    if (typeof connection.result === 'boolean') {\n                        return constraints;\n                    }\n                    return constraints.concat(connection.result);\n                }\n            }\n            return false;\n        }\n        const handleConnectionOptions = choose(handleConnectionMatches, []);\n        const slotOptions = choose(slotMatches, []);\n        if (handleConnectionOptions === false || slotOptions === false) {\n            return false;\n        }\n        for (const constraint of handleConnectionOptions) {\n            if (!constraint.var.variable.resolution) {\n                constraint.var.variable.resolution = constraint.value;\n            }\n            else if (constraint.var.variable.resolution instanceof TypeVariable) {\n                // TODO(shans): revisit how this should be done,\n                // consider reusing tryMergeTypeVariablesWith(other).\n                if (!TypeChecker.processTypeList(constraint.var, [{\n                        type: constraint.value, direction: constraint.direction\n                    }]))\n                    return false;\n            }\n            else {\n                if (!TypeChecker.compareTypes({ type: constraint.var.variable.resolution }, { type: constraint.value })) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=interface-info.js.map","/**\n * A base token interface for the `kind` and `location` entries. This creates\n * a TypeScript Discriminated Union for most tokens.\n */\nexport class BaseNode {\n}\nexport function isCollectionType(node) {\n    return node.kind === 'collection-type';\n}\nexport function isTypeVariable(node) {\n    return node.kind === 'variable-type';\n}\nexport function isSlotType(node) {\n    return node.kind === 'slot-type';\n}\nexport function slandleType(arg) {\n    if (isSlotType(arg.type)) {\n        return arg.type;\n    }\n    if (isCollectionType(arg.type) && isSlotType(arg.type.type)) {\n        return arg.type.type;\n    }\n    return undefined;\n}\nexport function preSlandlesDirectionToDirection(direction, isOptional = false) {\n    // TODO(jopra): Remove after syntax unification.\n    // Use switch for totality checking.\n    const opt = isOptional ? '?' : '';\n    switch (direction) {\n        case 'in':\n            return `reads${opt}`;\n        case 'out':\n            return `writes${opt}`;\n        case 'inout':\n            return `reads${opt} writes${opt}`;\n        case '`consume':\n            return `\\`consumes${opt}`;\n        case '`provide':\n            return `\\`provides${opt}`;\n        case 'host':\n            return `hosts${opt}`;\n        case 'any':\n            return `any${opt}`;\n        default:\n            // Catch nulls and unsafe values from javascript.\n            throw new Error(`Bad pre slandles direction ${direction}`);\n    }\n}\nexport function directionToPreSlandlesDirection(direction) {\n    // TODO(jopra): Remove after syntax unification.\n    // Use switch for totality checking.\n    switch (direction) {\n        case 'reads':\n            return 'in';\n        case 'writes':\n            return 'out';\n        case 'reads writes':\n            return 'inout';\n        case '`consumes':\n            return '`consume';\n        case '`provides':\n            return '`provide';\n        case 'hosts':\n            return 'host';\n        case 'any':\n            return 'any';\n        default:\n            // Catch nulls and unsafe values from javascript.\n            throw new Error(`Bad direction ${direction}`);\n    }\n}\nexport function arrowToDirection(arrow) {\n    // TODO(jopra): Remove after syntax unification.\n    // Use switch for totality checking.\n    switch (arrow) {\n        case '->':\n            return 'out';\n        case '<-':\n            return 'in';\n        case '<->':\n            return 'inout';\n        case '`consume':\n            return '`consume';\n        case '`provide':\n            return '`provide';\n        case '=':\n            return 'any';\n        default:\n            // Catch nulls and unsafe values from javascript.\n            throw new Error(`Bad arrow ${arrow}`);\n    }\n}\nexport function directionToArrow(dir) {\n    // TODO(jopra): Remove after syntax unification.\n    switch (dir) {\n        case 'in':\n            return '<-';\n        case 'out':\n            return '->';\n        case 'inout':\n            return '<->';\n        case 'host':\n            return '=';\n        case '`consume':\n            return '`consume';\n        case '`provide':\n            return '`provide';\n        case 'any':\n            return '=';\n        default:\n            throw new Error(`Unexpected direction ${dir}`);\n    }\n}\n//# sourceMappingURL=manifest-ast-nodes.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/** Arcs runtime flags. */\nclass FlagDefaults {\n}\nFlagDefaults.useNewStorageStack = false;\n// Enables the parsing of both pre and post slandles (unified) syntaxes.\n// Preslandles syntax is to be deprecated.\nFlagDefaults.parseBothSyntaxes = true;\n// Use pre slandles syntax for parsing and toString by default.\n// If parseBothSyntaxes is off, this will set which syntax is enabled.\nFlagDefaults.defaultToPreSlandlesSyntax = true;\nexport class Flags extends FlagDefaults {\n    /** Resets flags. To be called in test teardown methods. */\n    static reset() {\n        Object.assign(Flags, FlagDefaults);\n    }\n    // tslint:disable-next-line: no-any\n    static withPreSlandlesSyntax(f) {\n        return Flags.withFlags({ parseBothSyntaxes: false, defaultToPreSlandlesSyntax: true }, f);\n    }\n    // tslint:disable-next-line: no-any\n    static withPostSlandlesSyntax(f) {\n        return Flags.withFlags({ parseBothSyntaxes: false, defaultToPreSlandlesSyntax: false }, f);\n    }\n    // tslint:disable-next-line: no-any\n    static withNewStorageStack(f) {\n        return Flags.withFlags({ useNewStorageStack: true }, f);\n    }\n    // For testing with a different set of flags to the default.\n    // tslint:disable-next-line: no-any\n    static withFlags(flagsSettings, f) {\n        return async (...args) => {\n            Object.assign(Flags, flagsSettings);\n            let res;\n            try {\n                res = await f(...args);\n            }\n            finally {\n                Flags.reset();\n            }\n            return res;\n        };\n    }\n}\n/** Initialize flags to their default value */\nFlags.reset();\n//# sourceMappingURL=flags.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class SlotInfo {\n    constructor(formFactor, handle) {\n        this.formFactor = formFactor;\n        this.handle = handle;\n    }\n    toLiteral() {\n        return this;\n    }\n    static fromLiteral({ formFactor, handle }) {\n        return new SlotInfo(formFactor, handle);\n    }\n}\n//# sourceMappingURL=slot-info.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// Equivalent to an Entity with Schema { serialization Text }\nexport class ArcInfo {\n    constructor(arcId, serialization) {\n        this.id = arcId.toString();\n        // TODO: remove the import-removal hack when import statements no longer appear\n        // in serialized manifests, or deal with them correctly if they end up staying\n        this.serialization = serialization.replace(/\\bimport .*\\n/g, '');\n    }\n    // Retrieves the serialized string from a stored instance of ArcInfo.\n    static extractSerialization(data) {\n        return data.serialization.replace(/\\bimport .*\\n/g, '');\n    }\n}\nexport class ArcHandle {\n    constructor(id, storageKey, type, tags) {\n        this.id = id;\n        this.storageKey = storageKey;\n        this.type = type;\n        this.tags = tags;\n    }\n}\n//# sourceMappingURL=synthetic-types.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { Schema } from './schema.js';\nimport { EntityType, SlotType, Type, TypeVariable } from './type.js';\nexport class TypeVariableInfo {\n    constructor(name, canWriteSuperset, canReadSubset) {\n        this.name = name;\n        this._canWriteSuperset = canWriteSuperset;\n        this._canReadSubset = canReadSubset;\n        this._resolution = null;\n    }\n    /**\n     * Merge both the read subset (upper bound) and write superset (lower bound) constraints\n     * of two variables together. Use this when two separate type variables need to resolve\n     * to the same value.\n     */\n    maybeMergeConstraints(variable) {\n        if (!this.maybeMergeCanReadSubset(variable.canReadSubset)) {\n            return false;\n        }\n        return this.maybeMergeCanWriteSuperset(variable.canWriteSuperset);\n    }\n    /**\n     * Merge a type variable's read subset (upper bound) constraints into this variable.\n     * This is used to accumulate read constraints when resolving a handle's type.\n     */\n    maybeMergeCanReadSubset(constraint) {\n        if (constraint == null) {\n            return true;\n        }\n        if (this.canReadSubset == null) {\n            this.canReadSubset = constraint;\n            return true;\n        }\n        if (this.canReadSubset instanceof SlotType && constraint instanceof SlotType) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        if (this.canReadSubset instanceof EntityType && constraint instanceof EntityType) {\n            const mergedSchema = Schema.intersect(this.canReadSubset.entitySchema, constraint.entitySchema);\n            if (!mergedSchema) {\n                return false;\n            }\n            this.canReadSubset = new EntityType(mergedSchema);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * merge a type variable's write superset (lower bound) constraints into this variable.\n     * This is used to accumulate write constraints when resolving a handle's type.\n     */\n    maybeMergeCanWriteSuperset(constraint) {\n        if (constraint == null) {\n            return true;\n        }\n        if (this.canWriteSuperset == null) {\n            this.canWriteSuperset = constraint;\n            return true;\n        }\n        if (this.canWriteSuperset instanceof SlotType && constraint instanceof SlotType) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        if (this.canWriteSuperset instanceof EntityType && constraint instanceof EntityType) {\n            const mergedSchema = Schema.union(this.canWriteSuperset.entitySchema, constraint.entitySchema);\n            if (!mergedSchema) {\n                return false;\n            }\n            this.canWriteSuperset = new EntityType(mergedSchema);\n            return true;\n        }\n        return false;\n    }\n    isSatisfiedBy(type) {\n        const constraint = this._canWriteSuperset;\n        if (!constraint) {\n            return true;\n        }\n        if (!(constraint instanceof EntityType) || !(type instanceof EntityType)) {\n            throw new Error(`constraint checking not implemented for ${this} and ${type}`);\n        }\n        return type.getEntitySchema().isMoreSpecificThan(constraint.getEntitySchema());\n    }\n    get resolution() {\n        if (this._resolution) {\n            return this._resolution.resolvedType();\n        }\n        return null;\n    }\n    isValidResolutionCandidate(value) {\n        const elementType = value.resolvedType().getContainedType();\n        if (elementType instanceof TypeVariable && elementType.variable === this) {\n            return { result: false, detail: 'variable cannot resolve to collection of itself' };\n        }\n        return { result: true };\n    }\n    set resolution(value) {\n        assert(!this._resolution);\n        const isValid = this.isValidResolutionCandidate(value);\n        assert(isValid.result, isValid.detail);\n        let probe = value;\n        while (probe) {\n            if (!(probe instanceof TypeVariable)) {\n                break;\n            }\n            if (probe.variable === this) {\n                return;\n            }\n            probe = probe.variable.resolution;\n        }\n        this._resolution = value;\n        this._canWriteSuperset = null;\n        this._canReadSubset = null;\n    }\n    get canWriteSuperset() {\n        if (this._resolution) {\n            assert(!this._canWriteSuperset);\n            if (this._resolution instanceof TypeVariable) {\n                return this._resolution.variable.canWriteSuperset;\n            }\n            return null;\n        }\n        return this._canWriteSuperset;\n    }\n    set canWriteSuperset(value) {\n        assert(!this._resolution);\n        this._canWriteSuperset = value;\n    }\n    get canReadSubset() {\n        if (this._resolution) {\n            assert(!this._canReadSubset);\n            if (this._resolution instanceof TypeVariable) {\n                return this._resolution.variable.canReadSubset;\n            }\n            return null;\n        }\n        return this._canReadSubset;\n    }\n    set canReadSubset(value) {\n        assert(!this._resolution);\n        this._canReadSubset = value;\n    }\n    get hasConstraint() {\n        return this._canReadSubset !== null || this._canWriteSuperset !== null;\n    }\n    canEnsureResolved() {\n        if (this._resolution) {\n            return this._resolution.canEnsureResolved();\n        }\n        if (this._canWriteSuperset || this._canReadSubset) {\n            return true;\n        }\n        return false;\n    }\n    maybeEnsureResolved() {\n        if (this._resolution) {\n            return this._resolution.maybeEnsureResolved();\n        }\n        if (this._canWriteSuperset) {\n            this.resolution = this._canWriteSuperset;\n            return true;\n        }\n        if (this._canReadSubset) {\n            this.resolution = this._canReadSubset;\n            return true;\n        }\n        return false;\n    }\n    toLiteral() {\n        assert(this.resolution == null);\n        return this.toLiteralIgnoringResolutions();\n    }\n    toLiteralIgnoringResolutions() {\n        return {\n            name: this.name,\n            canWriteSuperset: this._canWriteSuperset && this._canWriteSuperset.toLiteral(),\n            canReadSubset: this._canReadSubset && this._canReadSubset.toLiteral()\n        };\n    }\n    static fromLiteral(data) {\n        return new TypeVariableInfo(data.name, data.canWriteSuperset ? Type.fromLiteral(data.canWriteSuperset) : null, data.canReadSubset ? Type.fromLiteral(data.canReadSubset) : null);\n    }\n    isResolved() {\n        return this._resolution && this._resolution.isResolved();\n    }\n}\n//# sourceMappingURL=type-variable-info.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Entity } from './entity.js';\nimport { EntityType, Type } from './type.js';\nimport { CRDTEntity } from './crdt/crdt-entity.js';\nimport { CRDTSingleton } from './crdt/crdt-singleton.js';\nimport { Flags } from './flags.js';\nexport class Schema {\n    // For convenience, primitive field types can be specified as {name: 'Type'}\n    // in `fields`; the constructor will convert these to the correct schema form.\n    // tslint:disable-next-line: no-any\n    constructor(names, fields, description) {\n        this.description = {};\n        this.names = names;\n        this.fields = {};\n        for (const [name, field] of Object.entries(fields)) {\n            if (typeof (field) === 'string') {\n                this.fields[name] = { kind: 'schema-primitive', type: field };\n            }\n            else {\n                this.fields[name] = field;\n            }\n        }\n        if (description) {\n            description.description.forEach(desc => this.description[desc.name] = desc.pattern || desc.patterns[0]);\n        }\n    }\n    toLiteral() {\n        const fields = {};\n        const updateField = field => {\n            if (field.kind === 'schema-reference') {\n                const schema = field.schema;\n                return { kind: 'schema-reference', schema: { kind: schema.kind, model: schema.model.toLiteral() } };\n            }\n            else if (field.kind === 'schema-collection') {\n                return { kind: 'schema-collection', schema: updateField(field.schema) };\n            }\n            else {\n                return field;\n            }\n        };\n        for (const key of Object.keys(this.fields)) {\n            fields[key] = updateField(this.fields[key]);\n        }\n        return { names: this.names, fields, description: this.description };\n    }\n    static fromLiteral(data = { fields: {}, names: [], description: {} }) {\n        const fields = {};\n        const updateField = field => {\n            if (field.kind === 'schema-reference') {\n                const schema = field.schema;\n                return { kind: 'schema-reference', schema: { kind: schema.kind, model: Type.fromLiteral(schema.model) } };\n            }\n            else if (field.kind === 'schema-collection') {\n                return { kind: 'schema-collection', schema: updateField(field.schema) };\n            }\n            else {\n                return field;\n            }\n        };\n        for (const key of Object.keys(data.fields)) {\n            fields[key] = updateField(data.fields[key]);\n        }\n        const result = new Schema(data.names, fields);\n        result.description = data.description || {};\n        return result;\n    }\n    // TODO(cypher1): This should only be an ident used in manifest parsing.\n    get name() {\n        return this.names[0];\n    }\n    static typesEqual(fieldType1, fieldType2) {\n        // TODO(cypher1): structural check instead of stringification.\n        return Schema._typeString(fieldType1) === Schema._typeString(fieldType2);\n    }\n    static _typeString(type) {\n        switch (type.kind) {\n            case 'schema-primitive':\n                return type.type;\n            case 'schema-union':\n                return `(${type.types.map(t => t.type).join(' or ')})`;\n            case 'schema-tuple':\n                return `(${type.types.map(t => t.type).join(', ')})`;\n            case 'schema-reference':\n                return `Reference<${Schema._typeString(type.schema)}>`;\n            case 'type-name':\n            case 'schema-inline':\n                return type.model.entitySchema.toInlineSchemaString();\n            case 'schema-collection':\n                return `[${Schema._typeString(type.schema)}]`;\n            default:\n                throw new Error(`Unknown type kind ${type.kind} in schema ${this.name}`);\n        }\n    }\n    static union(schema1, schema2) {\n        const names = [...new Set([...schema1.names, ...schema2.names])];\n        const fields = {};\n        for (const [field, type] of [...Object.entries(schema1.fields), ...Object.entries(schema2.fields)]) {\n            if (fields[field]) {\n                if (!Schema.typesEqual(fields[field], type)) {\n                    return null;\n                }\n            }\n            else {\n                fields[field] = type;\n            }\n        }\n        return new Schema(names, fields);\n    }\n    static intersect(schema1, schema2) {\n        const names = [...schema1.names].filter(name => schema2.names.includes(name));\n        const fields = {};\n        for (const [field, type] of Object.entries(schema1.fields)) {\n            const otherType = schema2.fields[field];\n            if (otherType && Schema.typesEqual(type, otherType)) {\n                fields[field] = type;\n            }\n        }\n        return new Schema(names, fields);\n    }\n    equals(otherSchema) {\n        // TODO(cypher1): Check equality without calling contains.\n        return this === otherSchema || (this.name === otherSchema.name\n            && this.isMoreSpecificThan(otherSchema)\n            && otherSchema.isMoreSpecificThan(this));\n    }\n    isMoreSpecificThan(otherSchema) {\n        const names = new Set(this.names);\n        for (const name of otherSchema.names) {\n            if (!names.has(name)) {\n                return false;\n            }\n        }\n        const fields = {};\n        for (const [name, type] of Object.entries(this.fields)) {\n            fields[name] = type;\n        }\n        for (const [name, type] of Object.entries(otherSchema.fields)) {\n            if (fields[name] == undefined) {\n                return false;\n            }\n            if (!Schema.typesEqual(fields[name], type)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    get type() {\n        return new EntityType(this);\n    }\n    entityClass(context = null) {\n        return Entity.createEntityClass(this, context);\n    }\n    crdtConstructor() {\n        const singletons = {};\n        const collections = {};\n        // TODO(shans) do this properly\n        for (const [field, { type }] of Object.entries(this.fields)) {\n            if (type === 'Text') {\n                singletons[field] = new CRDTSingleton();\n            }\n            else if (type === 'Number') {\n                singletons[field] = new CRDTSingleton();\n            }\n            else {\n                throw new Error(`Big Scary Exception: entity field ${field} of type ${type} doesn't yet have a CRDT mapping implemented`);\n            }\n        }\n        return class EntityCRDT extends CRDTEntity {\n            constructor() {\n                super(singletons, collections);\n            }\n        };\n    }\n    // TODO(jopra): Enforce that 'type' of a field is a Type.\n    // tslint:disable-next-line: no-any\n    static fieldToString([name, type]) {\n        const typeStr = Schema._typeString(type);\n        if (Flags.defaultToPreSlandlesSyntax) {\n            return `${typeStr} ${name}`;\n        }\n        return `${name}: ${typeStr}`;\n    }\n    toInlineSchemaString(options) {\n        const names = this.names.join(' ') || '*';\n        const fields = Object.entries(this.fields).map(Schema.fieldToString).join(', ');\n        return `${names} {${fields.length > 0 && options && options.hideFields ? '...' : fields}}`;\n    }\n    toManifestString() {\n        const results = [];\n        results.push(`schema ${this.names.join(' ')}`);\n        results.push(...Object.entries(this.fields).map(f => `  ${Schema.fieldToString(f)}`));\n        if (Object.keys(this.description).length > 0) {\n            results.push(`  description \\`${this.description.pattern}\\``);\n            for (const name of Object.keys(this.description)) {\n                if (name !== 'pattern') {\n                    results.push(`    ${name} \\`${this.description[name]}\\``);\n                }\n            }\n        }\n        return results.join('\\n');\n    }\n}\n//# sourceMappingURL=schema.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { ReferenceType, EntityType } from './type.js';\nimport { Reference } from './reference.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { SYMBOL_INTERNALS } from './symbols.js';\n// This class holds extra entity-related fields used by the runtime. Instances of this are stored\n// in their parent Entity via a Symbol-based key. This allows Entities to hold whatever field names\n// their Schemas describe without any possibility of names clashing. For example, an Entity can have\n// an 'id' field that is distinct (in both value and type) from the id field here. Access to this\n// class should be via the static helpers in Entity.\nclass EntityInternals {\n    constructor(entity, entityClass, schema, context, userIDComponent) {\n        // TODO: Only the Arc that \"owns\" this Entity should be allowed to mutate it.\n        this.mutable = true;\n        this.entity = entity;\n        this.entityClass = entityClass;\n        this.schema = schema;\n        this.context = context;\n        this.userIDComponent = userIDComponent;\n    }\n    getId() {\n        if (this.id === undefined) {\n            throw new Error('no id');\n        }\n        return this.id;\n    }\n    getEntityClass() {\n        return this.entityClass;\n    }\n    isIdentified() {\n        return this.id !== undefined;\n    }\n    identify(identifier) {\n        assert(!this.isIdentified(), 'identify() called on already identified entity');\n        this.id = identifier;\n        const components = identifier.split(':');\n        const uid = components.lastIndexOf('uid');\n        this.userIDComponent = uid > 0 ? components.slice(uid + 1).join(':') : '';\n    }\n    createIdentity(parentId, idGenerator) {\n        assert(!this.isIdentified(), 'createIdentity() called on already identified entity');\n        let id;\n        if (this.userIDComponent) {\n            // TODO: Stop creating IDs by manually concatenating strings.\n            id = `${parentId.toString()}:uid:${this.userIDComponent}`;\n        }\n        else {\n            id = idGenerator.newChildId(parentId).toString();\n        }\n        this.id = id;\n    }\n    isMutable() {\n        return this.mutable;\n    }\n    /**\n     * Prevents further mutation of this Entity instance. Note that calling this method only affects\n     * this particular Entity instance; the entity it represents (in a data store somewhere) can\n     * still be mutated by others. Also note that this doesn't necessarily offer any security against\n     * malicious developers.\n     */\n    makeImmutable() {\n        this.mutable = false;\n    }\n    /**\n     * Mutates the entity. Supply either the new data for the entity, which replaces the existing\n     * entity's data entirely, or a mutation function. The supplied mutation function will be called\n     * with a mutable copy of the entity's data. The mutations performed by that function will be\n     * reflected in the original entity instance (i.e. mutations applied in place).\n     */\n    mutate(mutation) {\n        if (!this.mutable) {\n            throw new Error('Entity is immutable.');\n        }\n        let newData;\n        // Using typeof instead of instanceof here, because apparently sometimes lambdas aren't an instance of Function... :-/\n        if (typeof mutation === 'function') {\n            newData = this.dataClone();\n            mutation(newData);\n        }\n        else {\n            newData = mutation;\n        }\n        // Note that this does *not* trigger the error in the Entity's Proxy 'set' trap, because we're\n        // applying the field updates directly to the original Entity instance (this.entity), not the\n        // Proxied version returned by the Entity constructor. Not confusing at all!\n        sanitizeAndApply(this.entity, newData, this.schema, this.context);\n        // TODO: Send mutations to data store.\n    }\n    toLiteral() {\n        return JSON.parse(JSON.stringify(this.entity));\n    }\n    dataClone() {\n        const clone = {};\n        const fieldTypes = this.schema.fields;\n        for (const name of Object.keys(fieldTypes)) {\n            if (this.entity[name] !== undefined) {\n                if (fieldTypes[name] && fieldTypes[name].kind === 'schema-reference') {\n                    if (this.entity[name]) {\n                        clone[name] = this.entity[name].dataClone();\n                    }\n                }\n                else if (fieldTypes[name] && fieldTypes[name].kind === 'schema-collection') {\n                    if (this.entity[name]) {\n                        clone[name] = [...this.entity[name]].map(a => a.dataClone());\n                    }\n                }\n                else {\n                    clone[name] = this.entity[name];\n                }\n            }\n        }\n        return clone;\n    }\n    serialize() {\n        return { id: this.id, rawData: this.dataClone() };\n    }\n    debugLog() {\n        // Here be dragons! Create a copy of the entity class but with an enumerable version of this\n        // internals object so it will appear in the log output, with a few tweaks for better display.\n        const original = this.entity;\n        const copy = new EntityInternals(null, this.entityClass, this.schema, this.context, this.userIDComponent);\n        copy.id = this.id;\n        // Force 'entity' to show as '[Circular]'. The 'any' is required because 'entity' is readonly.\n        // tslint:disable-next-line: no-any\n        copy.entity = copy;\n        // Set up a class that looks the same as the real entity, copy the schema fields in, add an\n        // enumerable version of the copied internals, and use console.dir to show the full object.\n        // Node displays the name set up with defineProperty below, but Chrome uses the name of the\n        // class variable defined here, so we'll call that entity.\n        const entity = class extends Entity {\n            constructor() {\n                super();\n                Object.assign(this, original);\n                this[SYMBOL_INTERNALS] = copy;\n            }\n        };\n        Object.defineProperty(entity, 'name', { value: original.constructor.name });\n        console.dir(new entity(), { depth: null });\n    }\n}\nexport class Entity {\n    toString() {\n        const fields = Object.entries(this).map(([name, value]) => `${name}: ${JSON.stringify(value)}`);\n        return `${this.constructor.name} { ${fields.join(', ')} }`;\n    }\n    // Dynamically constructs a new JS class for the entity type represented by the given schema.\n    // This creates a new class which extends the Entity base class and implements the required\n    // static properties, then returns a Proxy wrapping that to guard against incorrect field writes.\n    static createEntityClass(schema, context) {\n        const clazz = class extends Entity {\n            constructor(data, userIDComponent) {\n                super();\n                assert(data, `can't construct entity with null data`);\n                assert(!userIDComponent || userIDComponent.indexOf(':') === -1, `user IDs must not contain the ':' character`);\n                // We want the SYMBOL_INTERNALS property to be non-enumerable so any copies made of this\n                // entity (e.g. via Object.assign) pick up only the plain data fields from the schema, and\n                // not the EntityInternals object (which should be unique to this instance).\n                Object.defineProperty(this, SYMBOL_INTERNALS, {\n                    value: new EntityInternals(this, clazz, schema, context, userIDComponent),\n                    enumerable: false\n                });\n                sanitizeAndApply(this, data, schema, context);\n                // We don't want a 'get' trap here because JS accesses various fields as part of routine\n                // system behaviour, and making sure we special case all of them is going to be brittle.\n                // For example: when returning an object from an async function, JS needs to check if the\n                // object is a 'thenable' (so it knows whether to wrap it in a Promise or not), and it does\n                // this by checking for the existence of a 'then' method. Not trapping 'get' is ok because\n                // callers who try to read fields that aren't in the schema will just get 'undefined', which\n                // is idiomatic for JS anyway.\n                return new Proxy(this, {\n                    set: (target, name, value) => {\n                        throw new Error(`Tried to modify entity field '${name}'. Use the mutate method instead.`);\n                    }\n                });\n            }\n            static get type() {\n                // TODO: should the entity's key just be its type?\n                // Should it just be called type in that case?\n                return new EntityType(schema);\n            }\n            static get key() {\n                return { tag: 'entity', schema };\n            }\n            static get schema() {\n                return schema;\n            }\n        };\n        // Override the name property to use the name of the entity given in the schema.\n        Object.defineProperty(clazz, 'name', { value: schema.name });\n        return clazz;\n    }\n    static id(entity) {\n        return getInternals(entity).getId();\n    }\n    static entityClass(entity) {\n        return getInternals(entity).getEntityClass();\n    }\n    static isIdentified(entity) {\n        return getInternals(entity).isIdentified();\n    }\n    static identify(entity, identifier) {\n        getInternals(entity).identify(identifier);\n        return entity;\n    }\n    static createIdentity(entity, parentId, idGenerator) {\n        getInternals(entity).createIdentity(parentId, idGenerator);\n    }\n    static isMutable(entity) {\n        return getInternals(entity).isMutable();\n    }\n    static makeImmutable(entity) {\n        getInternals(entity).makeImmutable();\n    }\n    static mutate(entity, mutation) {\n        getInternals(entity).mutate(mutation);\n    }\n    static toLiteral(entity) {\n        return getInternals(entity).toLiteral();\n    }\n    static dataClone(entity) {\n        return getInternals(entity).dataClone();\n    }\n    static serialize(entity) {\n        return getInternals(entity).serialize();\n    }\n    // Because the internals object is non-enumerable, console.log(entity) in Node only shows the\n    // schema-based fields; use this function to log a more complete record of the entity in tests.\n    // Chrome's console.log already shows the internals object so that's usually sufficient for\n    // debugging, but this function can still be useful for logging a snapshot of an entity that\n    // is later modified.\n    static debugLog(entity) {\n        getInternals(entity).debugLog();\n    }\n}\nfunction getInternals(entity) {\n    const internals = entity[SYMBOL_INTERNALS];\n    assert(internals !== undefined, 'SYMBOL_INTERNALS lookup on non-entity');\n    return internals;\n}\nfunction sanitizeAndApply(target, data, schema, context) {\n    for (const [name, value] of Object.entries(data)) {\n        const sanitizedValue = sanitizeEntry(schema.fields[name], value, name, context);\n        validateFieldAndTypes(name, sanitizedValue, schema);\n        target[name] = sanitizedValue;\n    }\n}\nfunction convertToJsType(primitiveType, schemaName) {\n    switch (primitiveType.type) {\n        case 'Text':\n            return 'string';\n        case 'URL':\n            return 'string';\n        case 'Number':\n            return 'number';\n        case 'Boolean':\n            return 'boolean';\n        case 'Bytes':\n            return 'Uint8Array';\n        default:\n            throw new Error(`Unknown field type ${primitiveType.type} in schema ${schemaName}`);\n    }\n}\n// tslint:disable-next-line: no-any\nfunction validateFieldAndTypes(name, value, schema, fieldType) {\n    fieldType = fieldType || schema.fields[name];\n    if (fieldType === undefined) {\n        throw new Error(`Can't set field ${name}; not in schema ${schema.name}`);\n    }\n    if (value === undefined || value === null) {\n        return;\n    }\n    switch (fieldType.kind) {\n        case 'schema-primitive': {\n            const valueType = value.constructor.name === 'Uint8Array' ? 'Uint8Array' : typeof (value);\n            if (valueType !== convertToJsType(fieldType, schema.name)) {\n                throw new TypeError(`Type mismatch setting field ${name} (type ${fieldType.type}); ` +\n                    `value '${value}' is type ${typeof (value)}`);\n            }\n            break;\n        }\n        case 'schema-union':\n            // Value must be a primitive that matches one of the union types.\n            for (const innerType of fieldType.types) {\n                if (typeof (value) === convertToJsType(innerType, schema.name)) {\n                    return;\n                }\n            }\n            throw new TypeError(`Type mismatch setting field ${name} (union [${fieldType.types}]); ` +\n                `value '${value}' is type ${typeof (value)}`);\n        case 'schema-tuple':\n            // Value must be an array whose contents match each of the tuple types.\n            if (!Array.isArray(value)) {\n                throw new TypeError(`Cannot set tuple ${name} with non-array value '${value}'`);\n            }\n            if (value.length !== fieldType.types.length) {\n                throw new TypeError(`Length mismatch setting tuple ${name} ` +\n                    `[${fieldType.types}] with value '${value}'`);\n            }\n            fieldType.types.map((innerType, i) => {\n                if (value[i] !== undefined && value[i] !== null &&\n                    typeof (value[i]) !== convertToJsType(innerType, schema.name)) {\n                    throw new TypeError(`Type mismatch setting field ${name} (tuple [${fieldType.types}]); ` +\n                        `value '${value}' has type ${typeof (value[i])} at index ${i}`);\n                }\n            });\n            break;\n        case 'schema-reference':\n            if (!(value instanceof Reference)) {\n                throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);\n            }\n            if (!TypeChecker.compareTypes({ type: value.type }, { type: new ReferenceType(fieldType.schema.model) })) {\n                throw new TypeError(`Cannot set reference ${name} with value '${value}' of mismatched type`);\n            }\n            break;\n        case 'schema-collection':\n            // WTF?! value instanceof Set is returning false sometimes here because the Set in\n            // this environment (a native code constructor) isn't equal to the Set that the value\n            // has been constructed with (another native code constructor)...\n            if (value.constructor.name !== 'Set') {\n                throw new TypeError(`Cannot set collection ${name} with non-Set '${value}'`);\n            }\n            for (const element of value) {\n                validateFieldAndTypes(name, element, schema, fieldType.schema);\n            }\n            break;\n        default:\n            throw new Error(`Unknown kind '${fieldType.kind}' for field ${name} in schema ${schema.name}`);\n    }\n}\nfunction sanitizeEntry(type, value, name, context) {\n    if (!type) {\n        // If there isn't a field type for this, the proxy will pick up\n        // that fact and report a meaningful error.\n        return value;\n    }\n    if (type.kind === 'schema-reference' && value) {\n        if (value instanceof Reference) {\n            // Setting value as Reference (Particle side). This will enforce that the type provided for\n            // the handle matches the type of the reference.\n            return value;\n        }\n        else if (value.id && value.storageKey) {\n            // Setting value from raw data (Channel side).\n            // TODO(shans): This can't enforce type safety here as there isn't any type data available.\n            // Maybe this is OK because there's type checking on the other side of the channel?\n            return new Reference(value, new ReferenceType(type.schema.model), context);\n        }\n        else {\n            throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);\n        }\n    }\n    else if (type.kind === 'schema-collection' && value) {\n        // WTF?! value instanceof Set is returning false sometimes here because the Set in\n        // this environment (a native code constructor) isn't equal to the Set that the value\n        // has been constructed with (another native code constructor)...\n        if (value.constructor.name === 'Set') {\n            return value;\n        }\n        else if (value.length && value instanceof Object) {\n            return new Set(value.map(v => sanitizeEntry(type.schema, v, name, context)));\n        }\n        else {\n            throw new TypeError(`Cannot set collection ${name} with non-collection '${value}'`);\n        }\n    }\n    else {\n        return value;\n    }\n}\n//# sourceMappingURL=entity.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { unifiedHandleFor } from './handle.js';\nimport { ReferenceType } from './type.js';\nimport { Entity } from './entity.js';\nimport { SYMBOL_INTERNALS } from './symbols.js';\nimport { CollectionHandle } from './storageNG/handle.js';\nvar ReferenceMode;\n(function (ReferenceMode) {\n    ReferenceMode[ReferenceMode[\"Unstored\"] = 0] = \"Unstored\";\n    ReferenceMode[ReferenceMode[\"Stored\"] = 1] = \"Stored\";\n})(ReferenceMode || (ReferenceMode = {}));\nexport class Reference {\n    constructor(data, type, context) {\n        this.entity = null;\n        this.storageProxy = null;\n        // tslint:disable-next-line: no-any\n        this.handle = null;\n        this.id = data.id;\n        this.storageKey = data.storageKey;\n        this.context = context;\n        this.type = type;\n        this[SYMBOL_INTERNALS] = {\n            serialize: () => ({ id: this.id, rawData: this.dataClone() })\n        };\n    }\n    async ensureStorageProxy() {\n        if (this.storageProxy == null) {\n            this.storageProxy = await this.context.getStorageProxy(this.storageKey, this.type.referredType);\n            // tslint:disable-next-line: no-any\n            this.handle = unifiedHandleFor({ proxy: this.storageProxy, idGenerator: this.context.idGenerator });\n            if (this.storageKey) {\n                assert(this.storageKey === this.storageProxy.storageKey);\n            }\n            else {\n                this.storageKey = this.storageProxy.storageKey;\n            }\n        }\n    }\n    async dereference() {\n        assert(this.context, 'Must have context to dereference');\n        if (this.entity) {\n            return this.entity;\n        }\n        await this.ensureStorageProxy();\n        this.entity = await this.handle.get(this.id);\n        return this.entity;\n    }\n    dataClone() {\n        return { storageKey: this.storageKey, id: this.id };\n    }\n    // Called by WasmParticle to retrieve the entity for a reference held in a wasm module.\n    static async retrieve(pec, id, storageKey, entityType) {\n        const proxy = await pec.getStorageProxy(storageKey, entityType);\n        // tslint:disable-next-line: no-any\n        const handle = unifiedHandleFor({ proxy, idGenerator: pec.idGenerator });\n        return await handle.get(id);\n    }\n}\n/** A subclass of Reference that clients can create. */\nexport class ClientReference extends Reference {\n    /** Use the newClientReference factory method instead. */\n    constructor(entity, context) {\n        // TODO(shans): start carrying storageKey information around on Entity objects\n        super({ id: Entity.id(entity), storageKey: null }, new ReferenceType(Entity.entityClass(entity).type), context);\n        this.mode = ReferenceMode.Unstored;\n        this.entity = entity;\n        this.stored = this.storeReference(entity);\n    }\n    async storeReference(entity) {\n        await this.ensureStorageProxy();\n        if (this.handle instanceof CollectionHandle) {\n            await this.handle.add(entity);\n        }\n        else {\n            await this.handle.store(entity);\n        }\n        this.mode = ReferenceMode.Stored;\n    }\n    async dereference() {\n        if (this.mode === ReferenceMode.Unstored) {\n            return null;\n        }\n        return super.dereference();\n    }\n    isIdentified() {\n        return Entity.isIdentified(this.entity);\n    }\n    static newClientReference(context) {\n        return class extends ClientReference {\n            constructor(entity) {\n                super(entity, context);\n            }\n        };\n    }\n}\n//# sourceMappingURL=reference.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { SystemException, UserException } from './arc-exceptions.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { Reference } from './reference.js';\nimport { StorageProxy } from './storage-proxy.js';\nimport { BigCollectionType, CollectionType, EntityType, InterfaceType, ReferenceType } from './type.js';\nimport { Entity } from './entity.js';\nimport { Id } from './id.js';\nimport { SYMBOL_INTERNALS } from './symbols.js';\nimport { handleNGFor } from './storageNG/handle.js';\nimport { StorageProxy as StorageProxyNG } from './storageNG/storage-proxy.js';\n// TODO: This won't be needed once runtime is transferred between contexts.\nfunction cloneData(data) {\n    return data;\n    //return JSON.parse(JSON.stringify(data));\n}\nfunction restore(entry, entityClass) {\n    assert(entityClass, 'Handles need entity classes for deserialization');\n    const { id, rawData } = entry;\n    const entity = new entityClass(cloneData(rawData));\n    if (entry.id) {\n        Entity.identify(entity, entry.id);\n    }\n    // TODO some relation magic, somewhere, at some point.\n    return entity;\n}\n/**\n * Base class for Collections and Singletons.\n */\nexport class HandleOld {\n    // TODO type particleId, marked as string, but called with number\n    constructor(storage, idGenerator, name, particleId, canRead, canWrite) {\n        assert(!(storage instanceof HandleOld));\n        this._storage = storage;\n        this.idGenerator = idGenerator;\n        this.name = name || this.storage.name;\n        this.canRead = canRead;\n        this.canWrite = canWrite;\n        this._particleId = particleId;\n        this.options = {\n            keepSynced: true,\n            notifySync: true,\n            notifyUpdate: true,\n            notifyDesync: false,\n        };\n    }\n    reportUserExceptionInHost(exception, particle, method) {\n        this.storage.reportExceptionInHost(new UserException(exception, method, this._particleId, particle.spec.name));\n    }\n    reportSystemExceptionInHost(exception, method) {\n        this.storage.reportExceptionInHost(new SystemException(exception, method, this._particleId));\n    }\n    // `options` may contain any of:\n    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required\n    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received\n    // - notifyUpdate (bool): call onHandleUpdate for every change event received\n    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected\n    configure(options) {\n        assert(this.canRead, 'configure can only be called on readable Handles');\n        try {\n            const keys = Object.keys(this.options);\n            const badKeys = Object.keys(options).filter(o => !keys.includes(o));\n            if (badKeys.length > 0) {\n                throw new Error(`Invalid option in Handle.configure(): ${badKeys}`);\n            }\n            Object.assign(this.options, options);\n        }\n        catch (e) {\n            this.reportSystemExceptionInHost(e, 'Handle::configure');\n            throw e;\n        }\n    }\n    _serialize(entity) {\n        assert(entity, `can't serialize a null entity`);\n        if (entity instanceof Entity) {\n            if (!Entity.isIdentified(entity)) {\n                this.createIdentityFor(entity);\n            }\n        }\n        return entity[SYMBOL_INTERNALS].serialize();\n    }\n    createIdentityFor(entity) {\n        Entity.createIdentity(entity, Id.fromString(this._id), this.idGenerator);\n    }\n    get type() {\n        return this.storage.type;\n    }\n    get _id() {\n        return this.storage.id;\n    }\n    get storage() {\n        return this._storage;\n    }\n    toManifestString() {\n        return `'${this._id}'`;\n    }\n    generateKey() {\n        return this.idGenerator.newChildId(Id.fromString(this._id), 'key').toString();\n    }\n    /**\n     * Disables this handle so that it is no longer able to make changes or receive updates from the\n     * storage proxy\n     */\n    disable(particle) {\n        if (this.storage instanceof StorageProxy) {\n            this.storage.deregister(particle, this);\n        }\n        // Set this handle's storage to a no-operation storage proxy so any actions that need to be\n        // taken by this handle in the future (due to some async operations) will do nothing and finish quietly\n        this._storage = StorageProxy.newNoOpProxy(this.storage.id, this.storage.type);\n    }\n}\n/**\n * A handle on a set of Entity data. Note that, as a set, a Collection can only\n * contain a single version of an Entity for each given ID. Further, no order is\n * implied by the set. A particle's manifest dictates the types of handles that\n * need to be connected to that particle, and the current recipe identifies\n * which handles are connected.\n */\nexport class Collection extends HandleOld {\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                await particle.callOnHandleSync(this, this._restore(details), e => this.reportUserExceptionInHost(e, particle, 'onHandleSync'));\n                return;\n            case 'update': {\n                // tslint:disable-next-line: no-any\n                const update = {};\n                if ('add' in details) {\n                    update.added = this._restore(details.add);\n                }\n                if ('remove' in details) {\n                    update.removed = this._restore(details.remove);\n                }\n                update.originator = details.originatorId === this._particleId;\n                await particle.callOnHandleUpdate(this, update, e => this.reportUserExceptionInHost(e, particle, 'onHandleUpdate'));\n                return;\n            }\n            case 'desync':\n                await particle.callOnHandleDesync(this, e => this.reportUserExceptionInHost(e, particle, 'onHandleUpdate'));\n                return;\n            default:\n                throw new Error('unsupported');\n        }\n    }\n    /**\n     * Returns the Entity specified by id contained by the handle, or null if this id is not\n     * contained by the handle.\n     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async get(id) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        return this._restore([await this.storage.get(id)])[0];\n    }\n    /**\n     * @returns a list of the Entities contained by the handle.\n     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async toList() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        return this._restore(await this.storage.toList());\n    }\n    _restore(list) {\n        if (list == null) {\n            return null;\n        }\n        const containedType = this.type.getContainedType();\n        if (containedType instanceof EntityType) {\n            return list.map(e => restore(e, this.entityClass));\n        }\n        if (containedType instanceof ReferenceType) {\n            return list.map(r => new Reference(r, containedType, this.storage.pec));\n        }\n        throw new Error(`Don't know how to deliver handle data of type ${this.type}`);\n    }\n    /**\n     * Stores a new entity into the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async store(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        const keys = [this.generateKey()];\n        return this.storage.store(serialization, keys, this._particleId);\n    }\n    /**\n     * Removes all known entities from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        if (this.storage.clear) {\n            return this.storage.clear(this._particleId);\n        }\n        else {\n            throw new Error('clear not implemented by storage');\n        }\n    }\n    /**\n     * Removes an entity from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        // Remove the keys that exist at storage/proxy.\n        const keys = [];\n        await this.storage.remove(serialization.id, keys, this._particleId);\n    }\n    get storage() {\n        return this._storage;\n    }\n}\n/**\n * A handle on a single entity. A particle's manifest dictates\n * the types of handles that need to be connected to that particle, and\n * the current recipe identifies which handles are connected.\n */\nexport class Singleton extends HandleOld {\n    // Called by StorageProxy.\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                await particle.callOnHandleSync(this, this._restore(details), e => this.reportUserExceptionInHost(e, particle, 'onHandleSync'));\n                return;\n            case 'update': {\n                const data = this._restore(details.data);\n                await particle.callOnHandleUpdate(this, { data }, e => this.reportUserExceptionInHost(e, particle, 'onHandleUpdate'));\n                return;\n            }\n            case 'desync':\n                await particle.callOnHandleDesync(this, e => this.reportUserExceptionInHost(e, particle, 'onHandleDesync'));\n                return;\n            default:\n                throw new Error('unsupported');\n        }\n    }\n    /**\n     * @returns the Entity contained by the Singleton, or undefined if the Singleton is cleared.\n     * @throws {Error} if this Singleton is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async get() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        const model = await this.storage.get();\n        return this._restore(model);\n    }\n    _restore(model) {\n        if (model == null) {\n            return null;\n        }\n        if (this.type instanceof EntityType) {\n            return restore(model, this.entityClass);\n        }\n        if (this.type instanceof InterfaceType) {\n            return ParticleSpec.fromLiteral(model);\n        }\n        if (this.type instanceof ReferenceType) {\n            return new Reference(model, this.type, this.storage.pec);\n        }\n        throw new Error(`Don't know how to deliver handle data of type ${this.type}`);\n    }\n    /**\n     * Stores a new entity into the Singleton, replacing any existing entity.\n     * @throws {Error} if this Singleton is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async set(entity) {\n        try {\n            if (!this.canWrite) {\n                throw new Error('Handle not writeable');\n            }\n            const serialization = this._serialize(entity);\n            return this.storage.set(serialization, this._particleId);\n        }\n        catch (e) {\n            this.reportSystemExceptionInHost(e, 'Handle::set');\n            throw e;\n        }\n    }\n    /**\n     * Clears any entity currently in the Singleton.\n     * @throws {Error} if this Singleton is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        return this.storage.clear(this._particleId);\n    }\n    get storage() {\n        return this._storage;\n    }\n}\n/**\n * Provides paginated read access to a BigCollection. Conforms to the javascript iterator protocol\n * but is not marked as iterable because next() is async, which is currently not supported by\n * implicit iteration in Javascript.\n */\nclass Cursor {\n    constructor(parent, cursorId) {\n        this._parent = parent;\n        this._cursorId = cursorId;\n    }\n    /**\n     * Returns {value: [items], done: false} while there are items still available, or {done: true}\n     * when the cursor has completed reading the collection.\n     */\n    async next() {\n        const data = await this._parent.storage.cursorNext(this._cursorId);\n        if (!data.done) {\n            data.value = data.value.map(a => restore(a, this._parent.entityClass));\n        }\n        return data;\n    }\n    /**\n     * Terminates the streamed read. This must be called if a cursor is no longer needed but has not\n     * yet completed streaming (i.e. next() hasn't returned {done: true}).\n     */\n    close() {\n        this._parent.storage.cursorClose(this._cursorId);\n    }\n}\n/**\n * A handle on a large set of Entity data. Similar to Collection, except the complete set of\n * entities is not available directly; use stream() to read the full set. Particles wanting to\n * operate on BigCollections should do so in the setHandles() call, since BigCollections do not\n * trigger onHandleSync() or onHandleUpdate().\n */\nexport class BigCollection extends HandleOld {\n    configure(options) {\n        throw new Error('BigCollections do not support sync/update configuration');\n    }\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        assert(kind === 'sync', 'BigCollection._notify only supports sync events');\n        await particle.callOnHandleSync(this, [], e => this.reportUserExceptionInHost(e, particle, 'onHandleSync'));\n    }\n    /**\n     * Stores a new entity into the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async store(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        const keys = [this.generateKey()];\n        return this.storage.store(serialization, keys, this._particleId);\n    }\n    /**\n     * Removes an entity from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        await this.storage.remove(serialization.id, [], this._particleId);\n    }\n    /**\n     * @returns a Cursor instance that iterates over the full set of entities, reading `pageSize`\n     * entities at a time. The cursor views a snapshot of the collection, locked to the version\n     * at which the cursor is created.\n     *\n     * By default items are returned in order of original insertion into the collection (with the\n     * caveat that items removed during a streamed read may be returned at the end). Set `forward`\n     * to false to return items in reverse insertion order.\n     *\n     * @throws {Error} if this Singleton is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async stream({ pageSize, forward = true }) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        if (isNaN(pageSize) || pageSize < 1) {\n            throw new Error('Streamed reads require a positive pageSize');\n        }\n        const cursorId = await this.storage.stream(pageSize, forward);\n        return new Cursor(this, cursorId);\n    }\n    get storage() {\n        return this._storage;\n    }\n}\nexport function handleFor(storage, idGenerator, name = null, particleId = '', canRead = true, canWrite = true) {\n    let handle;\n    if (storage.type instanceof CollectionType) {\n        handle = new Collection(storage, idGenerator, name, particleId, canRead, canWrite);\n    }\n    else if (storage.type instanceof BigCollectionType) {\n        handle = new BigCollection(storage, idGenerator, name, particleId, canRead, canWrite);\n    }\n    else {\n        handle = new Singleton(storage, idGenerator, name, particleId, canRead, canWrite);\n    }\n    const schema = storage.type.getEntitySchema();\n    if (schema) {\n        handle.entityClass = schema.entityClass(storage.pec);\n    }\n    return handle;\n}\n/** Creates either a new- or old-style Handle for the given storage proxy. */\nexport function unifiedHandleFor(opts) {\n    const defaultOpts = { particleId: '', canRead: true, canWrite: true };\n    opts = { ...defaultOpts, ...opts };\n    if (opts.proxy instanceof StorageProxyNG) {\n        assert(opts.particleId.length, 'NG Handles require a particle ID');\n        return handleNGFor(opts.particleId, opts.proxy, opts.idGenerator, opts.particle, opts.canRead, opts.canWrite, opts.name);\n    }\n    else {\n        return handleFor(opts.proxy, opts.idGenerator, opts.name, opts.particleId, opts.canRead, opts.canWrite);\n    }\n}\n//# sourceMappingURL=handle.js.map","/** An exception that is to be propagated back to the host. */\nexport class PropagatedException extends Error {\n    constructor(cause, method, particleId, particleName) {\n        super();\n        this.cause = cause;\n        this.method = method;\n        this.particleId = particleId;\n        this.particleName = particleName;\n        this.stack += `\\nCaused by: ${this.cause.stack}`;\n    }\n    toLiteral() {\n        return {\n            exceptionType: this.constructor.name,\n            cause: {\n                name: this.cause.name,\n                message: this.cause.message,\n                stack: this.cause.stack,\n            },\n            method: this.method,\n            particleId: this.particleId,\n            particleName: this.particleName,\n            stack: this.stack,\n        };\n    }\n    static fromLiteral(literal) {\n        const cause = literal.cause;\n        let exception;\n        switch (literal.exceptionType) {\n            case SystemException.name:\n                exception = new SystemException(cause, literal.method, literal.particleId, literal.particleName);\n                break;\n            case UserException.name:\n                exception = new UserException(cause, literal.method, literal.particleId, literal.particleName);\n                break;\n            default:\n                throw new Error(`Unknown exception type: ${literal.exceptionType}`);\n        }\n        exception.stack = literal.stack;\n        return exception;\n    }\n}\n/** An exception thrown in Arcs runtime code. */\nexport class SystemException extends PropagatedException {\n    get message() {\n        const particleName = this.particleName ? this.particleName : this.particleId;\n        return `SystemException: exception ${this.cause.name} raised when invoking system function ${this.method} on behalf of particle ${particleName}: ${this.cause.message}`;\n    }\n}\n/** An exception thrown in the user particle code (as opposed to an error in the Arcs runtime). */\nexport class UserException extends PropagatedException {\n    get message() {\n        const particleName = this.particleName ? this.particleName : this.particleId;\n        return `UserException: exception ${this.cause.name} raised when invoking function ${this.method} on particle ${particleName}: ${this.cause.message}`;\n    }\n}\nconst systemHandlers = [];\nexport function reportSystemException(exception) {\n    for (const handler of systemHandlers) {\n        handler(exception);\n    }\n}\nexport function registerSystemExceptionHandler(handler) {\n    if (!systemHandlers.includes(handler)) {\n        systemHandlers.push(handler);\n    }\n}\nexport function removeSystemExceptionHandler(handler) {\n    const idx = systemHandlers.indexOf(handler);\n    if (idx > -1) {\n        systemHandlers.splice(idx, 1);\n    }\n}\nregisterSystemExceptionHandler((exception) => {\n    console.log(exception.method, exception.particleName);\n    throw exception;\n});\n//# sourceMappingURL=arc-exceptions.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { mapStackTrace } from '../platform/sourcemapped-stacktrace-web.js';\nimport { SystemException } from './arc-exceptions.js';\nimport { HandleOld } from './handle.js';\nimport { CrdtCollectionModel } from './storage/crdt-collection-model.js';\nimport { BigCollectionType, CollectionType } from './type.js';\nimport { Id } from './id.js';\nvar SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"none\"] = 0] = \"none\";\n    SyncState[SyncState[\"pending\"] = 1] = \"pending\";\n    SyncState[SyncState[\"full\"] = 2] = \"full\";\n})(SyncState || (SyncState = {}));\n/**\n * Mediates between one or more Handles and the backing store outside the PEC.\n *\n * This can operate in two modes, based on how observing handles are configured:\n * - synchronized: the proxy maintains a copy of the full data held by the backing store, keeping\n *                 it in sync by listening to change events from the store.\n * - unsynchronized: the proxy simply passes through calls from Handles to the backing store.\n *\n * In synchronized mode we maintain a queue of sorted update events received from the backing store.\n * While events are received correctly - each update is one version ahead of our stored model - they\n * are processed immediately and observing handles are notified accordingly. If we receive an update\n * with a \"future\" version, the proxy is desynchronized:\n * - a request for the full data is sent to the backing store;\n * - any update events received after that (and before the response) are added to the queue;\n * - any new updates that can be applied will be (which may cause the proxy to \"catch up\" and resync\n *   before the full data response arrives);\n * - once the resync response is received, stale queued updates are discarded and any remaining ones\n *   are applied.\n */\nexport class StorageProxy {\n    constructor(id, type, port, pec, scheduler, name) {\n        this.version = undefined;\n        this.listenerAttached = false;\n        this.keepSynced = false;\n        this.synchronized = SyncState.none;\n        this.observers = [];\n        this.updates = [];\n        this.barrier = null;\n        this.id = id;\n        this.type = type;\n        this.port = port;\n        this.scheduler = scheduler;\n        this.name = name;\n        this.updates = [];\n        this.pec = pec;\n    }\n    static newProxy(id, type, port, pec, scheduler, name) {\n        if (type instanceof CollectionType) {\n            return new CollectionProxy(id, type, port, pec, scheduler, name);\n        }\n        if (type instanceof BigCollectionType) {\n            return new BigCollectionProxy(id, type, port, pec, scheduler, name);\n        }\n        return new SingletonProxy(id, type, port, pec, scheduler, name);\n    }\n    static newNoOpProxy(id, type) {\n        return new NoOpStorageProxy(id, type, null, null, null, 'NoOpStorage');\n    }\n    reportExceptionInHost(exception) {\n        // TODO: Encapsulate source-mapping of the stack trace once there are more users of the port.RaiseSystemException() call.\n        if (mapStackTrace) {\n            mapStackTrace(exception.cause.stack, mappedStack => {\n                exception.cause.stack = mappedStack;\n                this.port.ReportExceptionInHost(exception);\n            });\n        }\n        else {\n            this.port.ReportExceptionInHost(exception);\n        }\n    }\n    /**\n     *  Called by ParticleExecutionContext to associate (potentially multiple) particle/handle pairs with this proxy.\n     */\n    register(particle, handle) {\n        if (!handle.canRead) {\n            return;\n        }\n        assert(handle instanceof HandleOld);\n        this.observers.push({ particle, handle: handle });\n        // Attach an event listener to the backing store when the first readable handle is registered.\n        if (!this.listenerAttached) {\n            this.port.InitializeProxy(this, x => this._onUpdate(x));\n            this.listenerAttached = true;\n        }\n        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send\n        // a request to get the full model (once).\n        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced\n        if (handle.options.keepSynced) {\n            if (!this.keepSynced) {\n                this.port.SynchronizeProxy(this, x => this._onSynchronize(x));\n                this.keepSynced = true;\n            }\n            // If a handle configured for sync notifications registers after we've received the full\n            // model, notify it immediately.\n            if (handle.options.notifySync && this.synchronized === SyncState.full) {\n                const syncModel = this._getModelForSync();\n                this.scheduler.enqueue(particle, handle, ['sync', particle, syncModel]);\n            }\n        }\n    }\n    /**\n     * Called by Handle to dissociate particle/handle pair associated with this proxy\n     */\n    deregister(particleIn, handleIn) {\n        this.observers = this.observers.filter(({ particle, handle }) => particle !== particleIn || handle !== handleIn);\n    }\n    _onSynchronize({ version, model }) {\n        if (this.version !== undefined && version <= this.version) {\n            console.warn(`StorageProxy '${this.id}' received stale model version ${version}; ` +\n                `current is ${this.version}`);\n            return;\n        }\n        // Replace the stored data with the new one and notify handles that are configured for it.\n        if (!this._synchronizeModel(version, model)) {\n            return;\n        }\n        // We may have queued updates that were received after a desync; discard any that are stale\n        // with respect to the received model.\n        this.synchronized = SyncState.full;\n        while (this.updates.length > 0 && this.updates[0].version <= version) {\n            this.updates.shift();\n        }\n        const syncModel = this._getModelForSync();\n        this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n        this._processUpdates();\n    }\n    _onUpdate(update) {\n        // Immediately notify any handles that are not configured with keepSynced but do want updates.\n        if (this.observers.find(({ handle }) => !handle.options.keepSynced && handle.options.notifyUpdate)) {\n            const handleUpdate = this._processUpdate(update, false);\n            this._notify('update', handleUpdate, options => !options.keepSynced && options.notifyUpdate);\n        }\n        // Bail if we're not in synchronized mode or this is a stale event.\n        if (!this.keepSynced) {\n            return;\n        }\n        if (update.version <= this.version) {\n            console.warn(`StorageProxy '${this.id}' received stale update version ${update.version}; ` +\n                `current is ${this.version}`);\n            return;\n        }\n        // Add the update to the queue and process. Most of the time the queue should be empty and\n        // _processUpdates will consume this event immediately.\n        this.updates.push(update);\n        this.updates.sort((a, b) => a.version - b.version);\n        this._processUpdates();\n    }\n    _notify(kind, details, predicate = (ignored) => true) {\n        for (const { handle, particle } of this.observers) {\n            if (predicate(handle.options)) {\n                this.scheduler.enqueue(particle, handle, [kind, particle, details]);\n            }\n        }\n    }\n    _processUpdates() {\n        const updateIsNext = update => {\n            if (update.version === this.version + 1) {\n                return true;\n            }\n            // Holy Layering Violation Batman\n            //\n            // If we are a singleton waiting for a barriered set response\n            // then that set response *is* the next thing we're waiting for,\n            // regardless of version numbers.\n            //\n            // TODO(shans): refactor this code so we don't need to layer-violate.\n            if (this.barrier && update.barrier === this.barrier) {\n                return true;\n            }\n            return false;\n        };\n        // Consume all queued updates whose versions are monotonically increasing from our stored one.\n        while (this.updates.length > 0 && updateIsNext(this.updates[0])) {\n            const update = this.updates.shift();\n            // Fold the update into our stored model.\n            const handleUpdate = this._processUpdate(update);\n            this.version = update.version;\n            // Notify handles configured with keepSynced and notifyUpdates (non-keepSynced handles are\n            // notified as updates are received).\n            if (handleUpdate) {\n                this._notify('update', handleUpdate, options => options.keepSynced && options.notifyUpdate);\n            }\n        }\n        // If we still have update events queued, we must have received a future version are are now\n        // desynchronized. Send a request for the full model and notify handles configured for it.\n        if (this.updates.length > 0) {\n            if (this.synchronized !== SyncState.none) {\n                this.synchronized = SyncState.none;\n                this.port.SynchronizeProxy(this, x => this._onSynchronize(x));\n                for (const { handle, particle } of this.observers) {\n                    if (handle.options.notifyDesync) {\n                        this.scheduler.enqueue(particle, handle, ['desync', particle, {}]);\n                    }\n                }\n            }\n        }\n        else if (this.synchronized !== SyncState.full) {\n            // If we were desynced but have now consumed all update events, we've caught up.\n            this.synchronized = SyncState.full;\n        }\n    }\n    generateBarrier() {\n        return this.pec.idGenerator.newChildId(Id.fromString(this.id), 'barrier').toString();\n    }\n}\n/**\n * Collections are synchronized in a CRDT Observed/Removed scheme.\n * Each value is identified by an ID and a set of membership keys.\n * Concurrent adds of the same value will specify the same ID but different\n * keys. A value is removed by removing all of the observed keys. A value\n * is considered to be removed if all of it's keys have been removed.\n *\n * In synchronized mode mutation takes place synchronously inside the proxy.\n * The proxy uses the originatorId to skip over redundant events sent back\n * by the storage object.\n *\n * In unsynchronized mode removal is not based on the keys observed at the\n * proxy, since the proxy does not remember the state, but instead the set\n * of keys that exist at the storage object at the time it receives the\n * request.\n */\nexport class CollectionProxy extends StorageProxy {\n    constructor() {\n        super(...arguments);\n        this.model = new CrdtCollectionModel();\n    }\n    _getModelForSync() {\n        return this.model.toList();\n    }\n    _synchronizeModel(version, model) {\n        this.version = version;\n        this.model = new CrdtCollectionModel(model);\n        return true;\n    }\n    _processUpdate(update, apply = true) {\n        if (this.synchronized === SyncState.full) {\n            // If we're synchronized, then any updates we sent have\n            // already been applied/notified.\n            for (const { handle } of this.observers) {\n                if (update.originatorId === handle._particleId) {\n                    return null;\n                }\n            }\n        }\n        const added = [];\n        const removed = [];\n        if ('add' in update) {\n            for (const { value, keys, effective } of update.add) {\n                if (apply && this.model.add(value.id, value, keys) || !apply && effective) {\n                    added.push(value);\n                }\n            }\n        }\n        else if ('remove' in update) {\n            for (const { value, keys, effective } of update.remove) {\n                const localValue = this.model.getValue(value.id);\n                if (apply && this.model.remove(value.id, keys) || !apply && effective) {\n                    removed.push(localValue);\n                }\n            }\n        }\n        else {\n            throw new Error(`StorageProxy received invalid update event: ${JSON.stringify(update)}`);\n        }\n        if (added.length || removed.length) {\n            const result = { originatorId: update.originatorId };\n            if (added.length)\n                result.add = added;\n            if (removed.length)\n                result.remove = removed;\n            return result;\n        }\n        return null;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    async toList() {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model.toList());\n        }\n        else {\n            // TODO: in synchronized mode, this should integrate with SynchronizeProxy rather than\n            //       sending a parallel request\n            return new Promise(resolve => this.port.HandleToList(this, resolve));\n        }\n    }\n    async get(id) {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model.getValue(id));\n        }\n        else {\n            return new Promise((resolve, reject) => this.port.HandleToList(this, r => resolve(r.find(entity => entity.id === id))));\n        }\n    }\n    // tslint:disable-next-line: no-any\n    async store(value, keys, particleId) {\n        const id = value.id;\n        const data = { value, keys };\n        this.port.HandleStore(this, () => { }, data, particleId);\n        if (this.synchronized !== SyncState.full) {\n            return Promise.resolve();\n        }\n        if (!this.model.add(id, value, keys)) {\n            return Promise.resolve();\n        }\n        const update = { originatorId: particleId, add: [value] };\n        this._notify('update', update, options => options.notifyUpdate);\n        return Promise.resolve();\n    }\n    async clear(particleId) {\n        if (this.synchronized !== SyncState.full) {\n            this.port.HandleRemoveMultiple(this, () => { }, [], particleId);\n        }\n        let items = this.model.toList().map(item => ({ id: item.id, keys: this.model.getKeys(item.id) }));\n        this.port.HandleRemoveMultiple(this, () => { }, items, particleId);\n        items = items.map(({ id, keys }) => ({ rawData: this.model.getValue(id).rawData, id, keys }));\n        items = items.filter(item => this.model.remove(item.id, item.keys));\n        if (items.length > 0) {\n            this._notify('update', { originatorId: particleId, remove: items }, options => options.notifyUpdate);\n        }\n        return Promise.resolve();\n    }\n    async remove(id, keys, particleId) {\n        if (this.synchronized !== SyncState.full) {\n            const data = { id, keys: [] };\n            this.port.HandleRemove(this, () => { }, data, particleId);\n            return Promise.resolve();\n        }\n        const value = this.model.getValue(id);\n        if (!value) {\n            return Promise.resolve();\n        }\n        if (keys.length === 0) {\n            keys = this.model.getKeys(id);\n        }\n        const data = { id, keys };\n        this.port.HandleRemove(this, () => { }, data, particleId);\n        if (!this.model.remove(id, keys)) {\n            return Promise.resolve();\n        }\n        const update = { originatorId: particleId, remove: [value] };\n        this._notify('update', update, options => options.notifyUpdate);\n        return Promise.resolve();\n    }\n}\n/**\n * Variables are synchronized in a 'last-writer-wins' scheme. When the\n * SingletonProxy mutates the model, it sets a barrier and expects to\n * receive the barrier value echoed back in a subsequent update event.\n * Between those two points in time updates are not applied or\n * notified about as these reflect concurrent writes that did not 'win'.\n */\nexport class SingletonProxy extends StorageProxy {\n    constructor() {\n        super(...arguments);\n        this.model = null;\n    }\n    _getModelForSync() {\n        return this.model;\n    }\n    _synchronizeModel(version, model) {\n        // If there's an active barrier then we shouldn't apply the model here, because\n        // there is a more recent write from the particle side that is still in flight.\n        if (this.barrier != null) {\n            return false;\n        }\n        this.version = version;\n        this.model = model.length === 0 ? null : model[0].value;\n        assert(this.model !== undefined);\n        return true;\n    }\n    _processUpdate(update, apply = true) {\n        assert('data' in update);\n        if (!apply) {\n            return update;\n        }\n        // If we have set a barrier, suppress updates until after\n        // we have seen the barrier return via an update.\n        if (this.barrier != null) {\n            if (update.barrier === this.barrier) {\n                this.barrier = null;\n                // HOLY LAYERING VIOLATION BATMAN\n                //\n                // We just cleared a barrier which means we are now synchronized. If we weren't\n                // synchronized already, then we need to tell the handles.\n                //\n                // TODO(shans): refactor this code so we don't need to layer-violate.\n                if (this.synchronized !== SyncState.full) {\n                    this.synchronized = SyncState.full;\n                    const syncModel = this._getModelForSync();\n                    this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n                }\n            }\n            return null;\n        }\n        this.model = update.data;\n        return { ...update };\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    // TODO: in synchronized mode, these should integrate with SynchronizeProxy rather than\n    //       sending a parallel request\n    async get() {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model);\n        }\n        else {\n            return new Promise(resolve => this.port.HandleGet(this, resolve));\n        }\n    }\n    async set(entity, particleId) {\n        assert(entity !== undefined);\n        if (JSON.stringify(this.model) === JSON.stringify(entity)) {\n            return Promise.resolve();\n        }\n        let barrier;\n        // If we're setting to this handle but we aren't listening to firebase,\n        // then there's no point creating a barrier. In fact, if the response\n        // to the set comes back before a listener is registered then this proxy will\n        // end up locked waiting for a barrier that will never arrive.\n        if (this.listenerAttached) {\n            barrier = this.generateBarrier();\n        }\n        else {\n            barrier = null;\n        }\n        // TODO: is this already a clone?\n        this.model = JSON.parse(JSON.stringify(entity));\n        this.barrier = barrier;\n        this.port.HandleSet(this, entity, particleId, barrier);\n        const update = { originatorId: particleId, data: entity };\n        this._notify('update', update, options => options.notifyUpdate);\n        return Promise.resolve();\n    }\n    async clear(particleId) {\n        if (this.synchronized === SyncState.full && this.model == null) {\n            return Promise.resolve();\n        }\n        const barrier = this.generateBarrier();\n        this.model = null;\n        this.barrier = barrier;\n        this.port.HandleClear(this, particleId, barrier);\n        const update = { originatorId: particleId, data: null };\n        this._notify('update', update, options => options.notifyUpdate);\n        return Promise.resolve();\n    }\n}\n// BigCollections are never synchronized. No local state is held and all operations are passed\n// directly through to the backing store.\nexport class BigCollectionProxy extends StorageProxy {\n    register(particle, handle) {\n        if (handle.canRead) {\n            this.scheduler.enqueue(particle, handle, ['sync', particle, {}]);\n        }\n    }\n    _getModelForSync() {\n        throw new Error('_getModelForSync not implemented for BigCollectionProxy');\n    }\n    _processUpdate() {\n        throw new Error('_processUpdate not implemented for BigCollectionProxy');\n    }\n    _synchronizeModel() {\n        throw new Error('_synchronizeModel not implemented for BigCollectionProxy');\n    }\n    // TODO: surface get()\n    async get(id) {\n        throw new Error('unimplemented');\n    }\n    async store(value, keys, particleId) {\n        return new Promise(resolve => this.port.HandleStore(this, resolve, { value, keys }, particleId));\n    }\n    async remove(id, keys, particleId) {\n        return new Promise(resolve => this.port.HandleRemove(this, resolve, { id, keys: [] }, particleId));\n    }\n    async stream(pageSize, forward) {\n        return new Promise(resolve => this.port.HandleStream(this, resolve, pageSize, forward));\n    }\n    // tslint:disable-next-line: no-any\n    async cursorNext(cursorId) {\n        return new Promise(resolve => this.port.StreamCursorNext(this, resolve, cursorId));\n    }\n    async cursorClose(cursorId) {\n        this.port.StreamCursorClose(this, cursorId);\n        return Promise.resolve();\n    }\n}\n/**\n * NoOpStorageProxy is an implementation of StorageProxy that does no operations. It silently\n * absorbs and throws away all changes without creating any logging, warnings or any other visible\n * behaviors or persistent changes.\n *\n * It is aimed to be used by disabled particles to finish their job without causing any post-disabled\n * async errors, etc.\n *\n * TODO(sherrypra): Add a unit test to ensure this stays in sync with the real storage APIs\n */\nexport class NoOpStorageProxy extends StorageProxy {\n    _getModelForSync() {\n        return null;\n    }\n    _synchronizeModel(version, model) {\n        return true;\n    }\n    _processUpdate(update, apply) {\n        return null;\n    }\n    reportExceptionInHost(exception) { }\n    deregister() { }\n    register() { }\n    _onSynchronize({ version, model }) { }\n    _onUpdate(update) { }\n    _notify(kind, details, predicate = (ignored) => true) { }\n    _processUpdates() { }\n    generateBarrier() {\n        return null;\n    }\n    async get(id) {\n        return new Promise(resolve => { });\n    }\n    // tslint:disable-next-line: no-any\n    async store(value, keys, particleId) {\n        return new Promise(resolve => { });\n    }\n    async clear(particleId) {\n        return new Promise(resolve => { });\n    }\n    async remove(id, keys, particleId) {\n        return new Promise(resolve => { });\n    }\n    async toList() {\n        return new Promise(resolve => { });\n    }\n    async stream(pageSize, forward) {\n        return new Promise(resolve => { });\n    }\n    // tslint:disable-next-line: no-any\n    async cursorNext(cursorId) {\n        return new Promise(resolve => { });\n    }\n    async cursorClose(cursorId) {\n        return new Promise(resolve => { });\n    }\n    async set(entity, particleId) {\n        return new Promise(resolve => { });\n    }\n}\nexport class StorageProxyScheduler {\n    constructor() {\n        this._scheduled = false;\n        this._queues = new Map();\n        this._idleResolver = null;\n        this._idle = null;\n        this._scheduled = false;\n        // Particle -> {Handle -> [Queue of events]}\n        this._queues = new Map();\n    }\n    // TODO: break apart args here, sync events should flush the queue.\n    enqueue(particle, handle, args) {\n        if (!this._queues.has(particle)) {\n            this._queues.set(particle, new Map());\n        }\n        const byHandle = this._queues.get(particle);\n        if (!byHandle.has(handle)) {\n            byHandle.set(handle, []);\n        }\n        const queue = byHandle.get(handle);\n        queue.push(args);\n        this._schedule();\n    }\n    get busy() {\n        return this._queues.size > 0;\n    }\n    _updateIdle() {\n        if (this._idleResolver && !this.busy) {\n            this._idleResolver();\n            this._idle = null;\n            this._idleResolver = null;\n        }\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        if (!this._idle) {\n            this._idle = new Promise(resolve => this._idleResolver = resolve);\n        }\n        return this._idle;\n    }\n    _schedule() {\n        if (this._scheduled) {\n            return;\n        }\n        this._scheduled = true;\n        setTimeout(() => {\n            this._scheduled = false;\n            this._dispatch();\n        }, 0);\n    }\n    _dispatch() {\n        // TODO: should we process just one particle per task?\n        while (this._queues.size > 0) {\n            const particle = [...this._queues.keys()][0];\n            const byHandle = this._queues.get(particle);\n            this._queues.delete(particle);\n            for (const [handle, queue] of byHandle.entries()) {\n                for (const args of queue) {\n                    try {\n                        handle._notify(...args);\n                    }\n                    catch (e) {\n                        console.error('Error dispatching to particle', e);\n                        handle.storage.reportExceptionInHost(new SystemException(e, handle._particleId, 'StorageProxyScheduler::_dispatch'));\n                    }\n                }\n            }\n        }\n        this._updateIdle();\n    }\n}\n//# sourceMappingURL=storage-proxy.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// This is only relevant in the web devtools, but we need to\n// ensure that the stack trace is passed through on node\n// so that system exceptions are plumbed properly.\nexport const mapStackTrace = (x, f) => f([x]);\n//# sourceMappingURL=sourcemapped-stacktrace-node.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nexport class CrdtCollectionModel {\n    constructor(model) {\n        // id => {value, Set[keys]}\n        this.items = new Map();\n        if (model) {\n            for (let { id, value, keys } of model) {\n                if (!keys) {\n                    keys = [];\n                }\n                this.items.set(id, { value, keys: new Set(keys) });\n            }\n        }\n    }\n    /**\n     * Adds membership, `keys`, of `value` indexed by `id` to this collection.\n     * Returns whether the change is effective (`id` is new to the collection,\n     * or `value` is different to the value previously stored).\n     */\n    add(id, value, keys) {\n        // Ensure that keys is actually an array, not a single string.\n        // TODO(shans): remove this when all callers are implemented in typeScript.\n        assert(keys.length > 0 && typeof keys === 'object', 'add requires a list of keys');\n        let item = this.items.get(id);\n        let effective = false;\n        if (!item) {\n            item = { value, keys: new Set(keys) };\n            this.items.set(id, item);\n            effective = true;\n        }\n        else {\n            let newKeys = false;\n            for (const key of keys) {\n                if (!item.keys.has(key)) {\n                    newKeys = true;\n                }\n                item.keys.add(key);\n            }\n            if (!this._equals(item.value, value)) {\n                assert(newKeys, 'cannot add without new keys. incoming=' + keys.join(',') + ' existing=' + [...item.keys].join(','));\n                item.value = value;\n                effective = true;\n            }\n        }\n        return effective;\n    }\n    _equals(value1, value2) {\n        if (Boolean(value1) !== Boolean(value2)) {\n            return false;\n        }\n        if (!value1) {\n            return true;\n        }\n        const type1 = typeof (value1);\n        if (type1 !== typeof (value2)) {\n            return false;\n        }\n        if (type1 === 'object') {\n            const keys = Object.keys(value1);\n            if (keys.length !== Object.keys(value2).length) {\n                return false;\n            }\n            return keys.every(key => this._equals(value1[key], value2[key]));\n        }\n        return JSON.stringify(value1) === JSON.stringify(value2);\n    }\n    /**\n     * Removes the membership, `keys`, of the value indexed by `id` from this collection.\n     * Returns whether the change is effective (the value is no longer present\n     * in the collection because all of the keys have been removed).\n     */\n    remove(id, keys) {\n        const item = this.items.get(id);\n        if (!item) {\n            return false;\n        }\n        for (const key of keys) {\n            item.keys.delete(key);\n        }\n        const effective = item.keys.size === 0;\n        if (effective) {\n            this.items.delete(id);\n        }\n        return effective;\n    }\n    toLiteral() {\n        const result = [];\n        for (const [id, { value, keys }] of this.items.entries()) {\n            result.push({ id, value, keys: [...keys] });\n        }\n        return result;\n    }\n    toList() {\n        return [...this.items.values()].map(item => item.value);\n    }\n    has(id) {\n        return this.items.has(id);\n    }\n    getKeys(id) {\n        const item = this.items.get(id);\n        return item ? [...item.keys] : [];\n    }\n    getValue(id) {\n        const item = this.items.get(id);\n        return item ? item.value : null;\n    }\n    get size() {\n        return this.items.size;\n    }\n}\n//# sourceMappingURL=crdt-collection-model.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Random } from './random.js';\n/**\n * Generates new IDs which are rooted in the current session. Only one IdGenerator should be instantiated for each running Arc, and all of the\n * IDs created should be created using that same IdGenerator instance.\n */\nexport class IdGenerator {\n    /** Use the newSession factory method instead. */\n    constructor(currentSessionId) {\n        this._nextComponentId = 0;\n        this._currentSessionId = currentSessionId;\n    }\n    /** Generates a new random session ID to use when creating new IDs. */\n    static newSession() {\n        const sessionId = Math.floor(Random.next() * Math.pow(2, 50)) + '';\n        return new IdGenerator(sessionId);\n    }\n    /**\n     * Intended only for testing the IdGenerator class itself. Lets you specify the session ID manually. Prefer using the real\n     * IdGenerator.newSession() method when testing other classes.\n     */\n    static createWithSessionIdForTesting(sessionId) {\n        return new IdGenerator(sessionId);\n    }\n    newArcId(name) {\n        return ArcId._newArcIdInternal(this._currentSessionId, name);\n    }\n    /**\n     * Creates a new ID, as a child of the given parentId. The given subcomponent will be appended to the component hierarchy of the given ID, but\n     * the generator's random session ID will be used as the ID's root.\n     */\n    newChildId(parentId, subcomponent = '') {\n        // Append (and increment) a counter to the subcomponent, to ensure that it is unique.\n        subcomponent += this._nextComponentId++;\n        return Id._newIdInternal(this._currentSessionId, [...parentId.idTree, subcomponent]);\n    }\n    get currentSessionIdForTesting() {\n        return this._currentSessionId;\n    }\n}\n/**\n * An immutable object consisting of two components: a root, and an idTree. The root is the session ID from the particular session in which the\n * ID was constructed (see the IdGenerator class). The idTree is a list of subcomponents, forming a hierarchy of IDs (child IDs are created by\n * appending subcomponents to their parent ID's idTree).\n */\nexport class Id {\n    /** Protected constructor. Use IdGenerator to create new IDs instead. */\n    constructor(root, idTree = []) {\n        /** The components of the idTree. */\n        this.idTree = [];\n        this.root = root;\n        this.idTree = idTree;\n    }\n    /** Creates a new ID. Use IdGenerator to create new IDs instead. */\n    static _newIdInternal(root, idTree = []) {\n        return new Id(root, idTree);\n    }\n    /** Parses a string representation of an ID (see toString). */\n    static fromString(str) {\n        const bits = str.split(':');\n        if (bits[0].startsWith('!')) {\n            const root = bits[0].slice(1);\n            const idTree = bits.slice(1).filter(component => component.length > 0);\n            return new Id(root, idTree);\n        }\n        else {\n            return new Id('', bits);\n        }\n    }\n    /** Returns the full ID string. */\n    toString() {\n        return `!${this.root}:${this.idTree.join(':')}`;\n    }\n    /** Returns the idTree as as string (without the root). */\n    idTreeAsString() {\n        return this.idTree.join(':');\n    }\n    equal(id) {\n        if (id.root !== this.root || id.idTree.length !== this.idTree.length) {\n            return false;\n        }\n        for (let i = 0; i < id.idTree.length; i++) {\n            if (id.idTree[i] !== this.idTree[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class ArcId extends Id {\n    /** Creates a new Arc ID. Use IdGenerator to create new IDs instead. */\n    static _newArcIdInternal(root, name) {\n        return new ArcId(root, [name]);\n    }\n    /** Creates a new Arc ID with the given name. For convenience in unit testing only; otherwise use IdGenerator to create new IDs instead. */\n    static newForTest(id) {\n        return IdGenerator.newSession().newArcId(id);\n    }\n}\n//# sourceMappingURL=id.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nclass RNG {\n}\n/**\n * A basic random number generator using Math.random();\n */\nclass MathRandomRNG extends RNG {\n    next() {\n        return Math.random();\n    }\n}\n// Singleton Pattern\nconst random = new MathRandomRNG();\nexport class Random {\n    static next() {\n        return random.next();\n    }\n}\n//# sourceMappingURL=random.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// TypeScript seems to lose the necessary type info if this symbol is wrapped in an object and then\n// used as an interface key (e.g. 'interface Foo { [Symbols.internals]: {...} }'), so we just have\n// to export it as a standard variable. See the EntityInternals class for the usage of this symbol.\nexport const SYMBOL_INTERNALS = Symbol('internals');\n//# sourceMappingURL=symbols.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nimport { UserException } from '../arc-exceptions.js';\nimport { CollectionOpTypes } from '../crdt/crdt-collection.js';\nimport { SingletonOpTypes } from '../crdt/crdt-singleton.js';\nimport { Entity } from '../entity.js';\nimport { Id } from '../id.js';\nimport { EntityType } from '../type.js';\nimport { NoOpStorageProxy } from './storage-proxy.js';\nimport { SYMBOL_INTERNALS } from '../symbols.js';\n/**\n * Base class for Handles.\n */\nexport class Handle {\n    constructor(key, storageProxy, idGenerator, particle, canRead, canWrite, name) {\n        this.key = key;\n        this.name = name;\n        this.storageProxy = storageProxy;\n        this.idGenerator = idGenerator;\n        this.particle = particle;\n        this.options = {\n            keepSynced: true,\n            notifySync: true,\n            notifyUpdate: true,\n            notifyDesync: false,\n        };\n        this.canRead = canRead;\n        this.canWrite = canWrite;\n        this.clock = this.storageProxy.registerHandle(this);\n    }\n    //TODO: this is used by multiplexer-dom-particle.ts, it probably won't work with this kind of store.\n    get storage() {\n        return this.storageProxy;\n    }\n    get type() {\n        return this.storageProxy.type;\n    }\n    // TODO: after NG migration, this can be renamed to something like \"apiChannelId()\".\n    get _id() {\n        return this.storageProxy.apiChannelId;\n    }\n    createIdentityFor(entity) {\n        Entity.createIdentity(entity, Id.fromString(this._id), this.idGenerator);\n    }\n    // `options` may contain any of:\n    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required\n    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received\n    // - notifyUpdate (bool): call onHandleUpdate for every change event received\n    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected\n    configure(options) {\n        assert(this.canRead, 'configure can only be called on readable Handles');\n        this.options = { ...this.options, ...options };\n    }\n    reportUserExceptionInHost(exception, particle, method) {\n        this.storageProxy.reportExceptionInHost(new UserException(exception, method, this.key, particle.spec.name));\n    }\n    async onDesync() {\n        await this.particle.callOnHandleDesync(this, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleDesync'));\n    }\n    disable(particle) {\n        this.storageProxy.deregisterHandle(this);\n        this.storageProxy = new NoOpStorageProxy();\n    }\n}\n/**\n * This handle class allows particles to manipulate collections and singletons of Entities\n * before the Entity Mutation API (and CRDT stack) is live. Once entity mutation is\n * available then this class will be deprecated and removed, and CollectionHandle / SingletonHandle\n * will become wrappers that reconstruct collections from a collection of references and\n * multiple entity stacks.\n */\nexport class PreEntityMutationHandle extends Handle {\n    constructor(key, storageProxy, idGenerator, particle, canRead, canWrite, name) {\n        super(key, storageProxy, idGenerator, particle, canRead, canWrite, name);\n        const type = this.storageProxy.type.getContainedType() || this.storageProxy.type;\n        if (type instanceof EntityType) {\n            this.entityClass = type.entitySchema.entityClass();\n        }\n        else {\n            throw new Error(`can't construct handle for entity mutation if type is not an entity type`);\n        }\n    }\n    serialize(entity) {\n        const serialization = entity[SYMBOL_INTERNALS].serialize();\n        return serialization;\n    }\n    ensureEntityHasId(entity) {\n        if (!Entity.isIdentified(entity)) {\n            this.createIdentityFor(entity);\n        }\n    }\n    deserialize(value) {\n        const { id, rawData } = value;\n        const entity = new this.entityClass(rawData);\n        Entity.identify(entity, id);\n        return entity;\n    }\n}\n/**\n * A handle on a set of Entity data. Note that, as a set, a Collection can only\n * contain a single version of an Entity for each given ID. Further, no order is\n * implied by the set.\n */\n// TODO(shanestephens): we can't guarantee the safety of this stack (except by the Type instance matching) - do we need the T\n// parameter here?\nexport class CollectionHandle extends PreEntityMutationHandle {\n    async get(id) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        const values = await this.toCRDTList();\n        return this.deserialize(values.find(element => element.id === id));\n    }\n    async add(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        this.ensureEntityHasId(entity);\n        this.clock[this.key] = (this.clock[this.key] || 0) + 1;\n        const op = {\n            type: CollectionOpTypes.Add,\n            added: this.serialize(entity),\n            actor: this.key,\n            clock: this.clock,\n        };\n        return this.storageProxy.applyOp(op);\n    }\n    async addMultiple(entities) {\n        return Promise.all(entities.map(e => this.add(e))).then(array => array.every(Boolean));\n    }\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const op = {\n            type: CollectionOpTypes.Remove,\n            removed: this.serialize(entity),\n            actor: this.key,\n            clock: this.clock,\n        };\n        return this.storageProxy.applyOp(op);\n    }\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const values = await this.toCRDTList();\n        for (const value of values) {\n            const removeOp = {\n                type: CollectionOpTypes.Remove,\n                removed: value,\n                actor: this.key,\n                clock: this.clock,\n            };\n            if (!this.storageProxy.applyOp(removeOp)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    async toList() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        const list = await this.toCRDTList();\n        return list.map(entry => this.deserialize(entry));\n    }\n    async toCRDTList() {\n        const [set, versionMap] = await this.storageProxy.getParticleView();\n        this.clock = versionMap;\n        return [...set];\n    }\n    async onUpdate(op, version) {\n        assert(this.canRead, 'onUpdate should not be called for non-readable handles');\n        this.clock = version;\n        // FastForward cannot be expressed in terms of ordered added/removed, so pass a full model to\n        // the particle.\n        if (op.type === CollectionOpTypes.FastForward) {\n            return this.onSync();\n        }\n        // Pass the change up to the particle.\n        const update = { originator: ('actor' in op && this.key === op.actor) };\n        if (op.type === CollectionOpTypes.Add) {\n            update.added = this.deserialize(op.added);\n        }\n        if (op.type === CollectionOpTypes.Remove) {\n            update.removed = this.deserialize(op.removed);\n        }\n        if (this.particle) {\n            await this.particle.callOnHandleUpdate(this /*handle*/, update, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleUpdate'));\n        }\n    }\n    async onSync() {\n        assert(this.canRead, 'onSync should not be called for non-readable handles');\n        if (this.particle) {\n            await this.particle.callOnHandleSync(this /*handle*/, this.toList() /*model*/, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleSync'));\n        }\n    }\n}\n/**\n * A handle on a single entity.\n */\nexport class SingletonHandle extends PreEntityMutationHandle {\n    async set(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        this.ensureEntityHasId(entity);\n        this.clock[this.key] = (this.clock[this.key] || 0) + 1;\n        const op = {\n            type: SingletonOpTypes.Set,\n            value: this.serialize(entity),\n            actor: this.key,\n            clock: this.clock,\n        };\n        return this.storageProxy.applyOp(op);\n    }\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const op = {\n            type: SingletonOpTypes.Clear,\n            actor: this.key,\n            clock: this.clock,\n        };\n        return this.storageProxy.applyOp(op);\n    }\n    async get() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        const [value, versionMap] = await this.storageProxy.getParticleView();\n        this.clock = versionMap;\n        return value == null ? null : this.deserialize(value);\n    }\n    async onUpdate(op, version) {\n        assert(this.canRead, 'onUpdate should not be called for non-readable handles');\n        this.clock = version;\n        // Pass the change up to the particle.\n        const update = { originator: (this.key === op.actor) };\n        if (op.type === SingletonOpTypes.Set) {\n            update.data = this.deserialize(op.value);\n        }\n        // Nothing else to add (beyond oldData) for SingletonOpTypes.Clear.\n        if (this.particle) {\n            await this.particle.callOnHandleUpdate(this /*handle*/, update, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleUpdate'));\n        }\n    }\n    async onSync() {\n        assert(this.canRead, 'onSync should not be called for non-readable handles');\n        if (this.particle) {\n            await this.particle.callOnHandleSync(this /*handle*/, this.get() /*model*/, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleSync'));\n        }\n    }\n}\nexport function handleNGFor(key, storageProxy, idGenerator, particle, canRead, canWrite, name) {\n    return new (storageProxy.type.handleConstructor())(key, storageProxy, idGenerator, particle, canRead, canWrite, name);\n}\n//# sourceMappingURL=handle.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { ChangeType, CRDTError, createEmptyChange } from './crdt.js';\nimport { assert } from '../../platform/assert-web.js';\nexport var CollectionOpTypes;\n(function (CollectionOpTypes) {\n    CollectionOpTypes[CollectionOpTypes[\"Add\"] = 0] = \"Add\";\n    CollectionOpTypes[CollectionOpTypes[\"Remove\"] = 1] = \"Remove\";\n    CollectionOpTypes[CollectionOpTypes[\"FastForward\"] = 2] = \"FastForward\";\n})(CollectionOpTypes || (CollectionOpTypes = {}));\nexport class CRDTCollection {\n    constructor() {\n        this.model = { values: {}, version: {} };\n    }\n    merge(other) {\n        // Ensure we never send an update if the two versions are already the same.\n        // TODO(shans): Remove this once fast-forwarding is two-sided, and replace with\n        // a check for an effect-free fast-forward op in each direction instead.\n        if (sameVersions(this.model.version, other.version)) {\n            let entriesMatch = true;\n            const theseKeys = Object.keys(this.model.values);\n            const otherKeys = Object.keys(other.values);\n            if (theseKeys.length === otherKeys.length) {\n                for (const key of Object.keys(this.model.values)) {\n                    if (!other.values[key]) {\n                        entriesMatch = false;\n                        break;\n                    }\n                }\n                if (entriesMatch) {\n                    return { modelChange: createEmptyChange(), otherChange: createEmptyChange() };\n                }\n            }\n        }\n        const newClock = mergeVersions(this.model.version, other.version);\n        const merged = {};\n        // Fast-forward op to send to other model. Elements added and removed will\n        // be filled in below.\n        const fastForwardOp = {\n            type: CollectionOpTypes.FastForward,\n            added: [],\n            removed: [],\n            oldClock: other.version,\n            newClock,\n        };\n        for (const otherEntry of Object.values(other.values)) {\n            const value = otherEntry.value;\n            const id = value.id;\n            const thisEntry = this.model.values[id];\n            if (thisEntry) {\n                if (sameVersions(thisEntry.version, otherEntry.version)) {\n                    // Both models have the same value at the same version. Add it to the\n                    // merge.\n                    merged[id] = thisEntry;\n                }\n                else {\n                    // Models have different versions for the same value. Merge the\n                    // versions, and update other.\n                    const mergedVersion = mergeVersions(thisEntry.version, otherEntry.version);\n                    merged[id] = { value, version: mergedVersion };\n                    fastForwardOp.added.push([value, mergedVersion]);\n                }\n            }\n            else if (dominates(this.model.version, otherEntry.version)) {\n                // Value was deleted by this model.\n                fastForwardOp.removed.push(value);\n            }\n            else {\n                // Value was added by other model.\n                merged[id] = otherEntry;\n            }\n        }\n        for (const [id, thisEntry] of Object.entries(this.model.values)) {\n            if (!other.values[id] && !dominates(other.version, thisEntry.version)) {\n                // Value was added by this model.\n                merged[id] = thisEntry;\n                fastForwardOp.added.push([thisEntry.value, thisEntry.version]);\n            }\n        }\n        const operations = simplifyFastForwardOp(fastForwardOp) || [fastForwardOp];\n        this.model.values = merged;\n        this.model.version = newClock;\n        const modelChange = {\n            changeType: ChangeType.Model,\n            modelPostChange: this.model\n        };\n        const otherChange = {\n            changeType: ChangeType.Operations,\n            operations,\n        };\n        return { modelChange, otherChange };\n    }\n    applyOperation(op) {\n        switch (op.type) {\n            case CollectionOpTypes.Add:\n                return this.add(op.added, op.actor, op.clock);\n            case CollectionOpTypes.Remove:\n                return this.remove(op.removed, op.actor, op.clock);\n            case CollectionOpTypes.FastForward:\n                return this.fastForward(op);\n            default:\n                throw new CRDTError(`Op ${op} not supported`);\n        }\n    }\n    getData() {\n        return this.model;\n    }\n    getParticleView() {\n        return new Set(Object.values(this.model.values).map(entry => entry.value));\n    }\n    add(value, key, version) {\n        this.checkValue(value);\n        // Only accept an add if it is immediately consecutive to the clock for that actor.\n        const expectedClockValue = (this.model.version[key] || 0) + 1;\n        if (!(expectedClockValue === version[key] || 0)) {\n            return false;\n        }\n        this.model.version[key] = version[key];\n        const previousVersion = this.model.values[value.id] ? this.model.values[value.id].version : {};\n        this.model.values[value.id] = { value, version: mergeVersions(version, previousVersion) };\n        return true;\n    }\n    remove(value, key, version) {\n        this.checkValue(value);\n        if (!this.model.values[value.id]) {\n            return false;\n        }\n        const clockValue = (version[key] || 0);\n        // Removes do not increment the clock.\n        const expectedClockValue = (this.model.version[key] || 0);\n        if (!(expectedClockValue === clockValue)) {\n            return false;\n        }\n        // Cannot remove an element unless version is higher for all other actors as\n        // well.\n        if (!dominates(version, this.model.values[value.id].version)) {\n            return false;\n        }\n        this.model.version[key] = clockValue;\n        delete this.model.values[value.id];\n        return true;\n    }\n    fastForward(op) {\n        const currentClock = this.model.version;\n        if (!dominates(currentClock, op.oldClock)) {\n            // Can't apply fast-forward op. Current model's clock is behind oldClock.\n            return false;\n        }\n        if (dominates(currentClock, op.newClock)) {\n            // Current model already knows about everything in this fast-forward op.\n            // Nothing to do, but not an error.\n            return true;\n        }\n        for (const [value, version] of op.added) {\n            this.checkValue(value);\n            const existingValue = this.model.values[value.id];\n            if (existingValue) {\n                existingValue.version = mergeVersions(existingValue.version, version);\n            }\n            else if (!dominates(currentClock, version)) {\n                this.model.values[value.id] = { value, version };\n            }\n        }\n        for (const value of op.removed) {\n            this.checkValue(value);\n            const existingValue = this.model.values[value.id];\n            if (existingValue && dominates(op.newClock, existingValue.version)) {\n                delete this.model.values[value.id];\n            }\n        }\n        this.model.version = mergeVersions(currentClock, op.newClock);\n        return true;\n    }\n    checkValue(value) {\n        assert(value.id && value.id.length, `CRDT value must have an ID.`);\n    }\n}\nfunction mergeVersions(version1, version2) {\n    const merged = {};\n    for (const [k, v] of Object.entries(version1)) {\n        merged[k] = v;\n    }\n    for (const [k, v] of Object.entries(version2)) {\n        merged[k] = Math.max(v, version1[k] || 0);\n    }\n    return merged;\n}\nfunction sameVersions(version1, version2) {\n    if (Object.keys(version1).length !== Object.keys(version2).length) {\n        return false;\n    }\n    for (const [k, v] of Object.entries(version1)) {\n        if (v !== version2[k]) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Returns true if map1 dominates map2. */\nfunction dominates(map1, map2) {\n    for (const [k, v] of Object.entries(map2)) {\n        if ((map1[k] || 0) < v) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Converts a simple fast-forward operation into a sequence of regular ops.\n * Currently only supports converting add ops made by a single actor. Returns\n * null if it could not simplify the fast-forward operation.\n */\nexport function simplifyFastForwardOp(fastForwardOp) {\n    if (fastForwardOp.removed.length > 0) {\n        // Remove ops can't be replayed in order.\n        return null;\n    }\n    if (fastForwardOp.added.length === 0) {\n        // Just a version bump, no add ops to replay.\n        return null;\n    }\n    const actor = getSingleActorIncrement(fastForwardOp.oldClock, fastForwardOp.newClock);\n    if (actor === null) {\n        return null;\n    }\n    // Sort the add ops in increasing order by the actor's version.\n    const addOps = [...fastForwardOp.added].sort(([elem1, v1], [elem2, v2]) => (v1[actor] || 0) - (v2[actor] || 0));\n    let expectedVersion = fastForwardOp.oldClock[actor];\n    for (const [elem, version] of addOps) {\n        if (++expectedVersion !== version[actor]) {\n            // The add op didn't match the expected increment-by-one pattern. Can't\n            // replay it properly.\n            return null;\n        }\n    }\n    // If we reach here then all added versions are incremented by one.\n    // Check the final clock.\n    const expectedClock = { ...fastForwardOp.oldClock };\n    expectedClock[actor] = expectedVersion;\n    if (!sameVersions(expectedClock, fastForwardOp.newClock)) {\n        return null;\n    }\n    return addOps.map(([elem, version]) => ({\n        type: CollectionOpTypes.Add,\n        added: elem,\n        actor,\n        clock: version,\n    }));\n}\n/**\n * Given two version maps, returns the actor who incremented their version. If\n * there's more than one such actor, returns null.\n */\nfunction getSingleActorIncrement(oldVersion, newVersion) {\n    if (Object.keys(oldVersion).length !== Object.keys(newVersion).length) {\n        return null;\n    }\n    const incrementedActors = Object.entries(oldVersion).filter(([k, v]) => newVersion[k] > v);\n    return incrementedActors.length === 1 ? incrementedActors[0][0] : null;\n}\n//# sourceMappingURL=crdt-collection.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class CRDTError extends Error {\n}\n// A CRDT Change represents a delta between model states. Where possible,\n// this delta should be expressed as a sequence of operations; in which case\n// changeType will be ChangeType.Operations.\n// Sometimes it isn't possible to express a delta as operations. In this case,\n// changeType will be ChangeType.Model, and a full post-merge model will be supplied.\n// A CRDT Change is parameterized by the operations that can be represented, and the data representation\n// of the model.\nexport var ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"Operations\"] = 0] = \"Operations\";\n    ChangeType[ChangeType[\"Model\"] = 1] = \"Model\";\n})(ChangeType || (ChangeType = {}));\nexport function isEmptyChange(change) {\n    return change.changeType === ChangeType.Operations && change.operations.length === 0;\n}\nexport function createEmptyChange() {\n    return { changeType: ChangeType.Operations, operations: [] };\n}\n//# sourceMappingURL=crdt.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { ChangeType, isEmptyChange, createEmptyChange } from './crdt.js';\nimport { CollectionOpTypes, CRDTCollection } from './crdt-collection.js';\nexport var SingletonOpTypes;\n(function (SingletonOpTypes) {\n    SingletonOpTypes[SingletonOpTypes[\"Set\"] = 0] = \"Set\";\n    SingletonOpTypes[SingletonOpTypes[\"Clear\"] = 1] = \"Clear\";\n})(SingletonOpTypes || (SingletonOpTypes = {}));\nexport class CRDTSingleton {\n    constructor() {\n        this.collection = new CRDTCollection();\n    }\n    merge(other) {\n        const { modelChange, otherChange } = this.collection.merge(other);\n        // We cannot pass through the collection ops, so always return the updated model.\n        let newModelChange = {\n            changeType: ChangeType.Model,\n            modelPostChange: this.collection.getData()\n        };\n        let newOtherChange = newModelChange;\n        if (isEmptyChange(modelChange)) {\n            newModelChange = createEmptyChange();\n        }\n        if (isEmptyChange(otherChange)) {\n            newOtherChange = createEmptyChange();\n        }\n        return { modelChange: newModelChange, otherChange: newOtherChange };\n    }\n    applyOperation(op) {\n        if (op.type === SingletonOpTypes.Clear) {\n            return this.clear(op.actor, op.clock);\n        }\n        if (op.type === SingletonOpTypes.Set) {\n            // Remove does not require an increment, but the caller of this method will have incremented\n            // its version, so we hack a version with t-1 for this actor.\n            const removeClock = {};\n            for (const [k, v] of Object.entries(op.clock)) {\n                removeClock[k] = v;\n            }\n            removeClock[op.actor] = op.clock[op.actor] - 1;\n            if (!this.clear(op.actor, removeClock)) {\n                return false;\n            }\n            const addOp = {\n                type: CollectionOpTypes.Add,\n                added: op.value,\n                actor: op.actor,\n                clock: op.clock,\n            };\n            if (!this.collection.applyOperation(addOp)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getData() {\n        return this.collection.getData();\n    }\n    getParticleView() {\n        // Return any value.\n        return [...this.collection.getParticleView()].sort()[0] || null;\n    }\n    clear(actor, clock) {\n        // Clear all existing values if our clock allows it.\n        for (const value of Object.values(this.collection.getData().values)) {\n            const removeOp = {\n                type: CollectionOpTypes.Remove,\n                removed: value.value,\n                actor,\n                clock,\n            };\n            // If any value fails to remove, we haven't cleared the value and we fail the whole op.\n            //if (!this.collection.applyOperation(removeOp)) {\n            //   return false;\n            // }\n            this.collection.applyOperation(removeOp);\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=crdt-singleton.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { mapStackTrace } from '../../platform/sourcemapped-stacktrace-web.js';\nimport { SystemException } from '../arc-exceptions.js';\nimport { CRDTError } from '../crdt/crdt.js';\nimport { EntityType } from '../type.js';\nimport { ProxyMessageType } from './store.js';\n/**\n * Mediates between one or more Handles and the backing store. The store can be outside the PEC or\n * directly connected to the StorageProxy.\n */\nexport class StorageProxy {\n    constructor(apiChannelId, storeProvider, type) {\n        this.handles = [];\n        this.listenerAttached = false;\n        this.keepSynced = false;\n        this.synchronized = false;\n        this.modelHasSynced = () => undefined;\n        this.apiChannelId = apiChannelId;\n        this.store = storeProvider.getStorageEndpoint(this);\n        this.crdt = new (type.crdtInstanceConstructor())();\n        this.type = type;\n        this.scheduler = new StorageProxyScheduler();\n    }\n    // TODO: remove this after migration.\n    get pec() {\n        throw new Error('StorageProxyNG does not have a pec.');\n    }\n    async idle() {\n        return this.scheduler.idle;\n    }\n    reportExceptionInHost(exception) {\n        // TODO: Encapsulate source-mapping of the stack trace once there are more users of the port.RaiseSystemException() call.\n        if (mapStackTrace) {\n            mapStackTrace(exception.cause.stack, mappedStack => {\n                exception.cause.stack = mappedStack;\n                this.store.reportExceptionInHost(exception);\n            });\n        }\n        else {\n            this.store.reportExceptionInHost(exception);\n        }\n    }\n    registerHandle(handle) {\n        if (!handle.canRead) {\n            return this.versionCopy();\n        }\n        this.handles.push(handle);\n        // Attach an event listener to the backing store when the first readable handle is registered.\n        if (!this.listenerAttached) {\n            this.store.setCallback(x => this.onMessage(x));\n            this.listenerAttached = true;\n        }\n        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send\n        // a request to get the full model (once).\n        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced.\n        if (handle.options.keepSynced) {\n            if (!this.keepSynced) {\n                this.requestSynchronization().catch(e => {\n                    this.reportExceptionInHost(new SystemException(e, handle.key, 'StorageProxy::registerHandle'));\n                });\n                this.keepSynced = true;\n            }\n            // If a handle configured for sync notifications registers after we've received the full\n            // model, notify it immediately.\n            if (handle.options.notifySync && this.synchronized) {\n                handle.onSync();\n            }\n        }\n        return this.versionCopy();\n    }\n    deregisterHandle(handleIn) {\n        this.handles = this.handles.filter(handle => handle !== handleIn);\n    }\n    versionCopy() {\n        const version = {};\n        for (const [k, v] of Object.entries(this.crdt.getData().version)) {\n            version[k] = v;\n        }\n        return version;\n    }\n    async applyOp(op) {\n        if (!this.crdt.applyOperation(op)) {\n            return false;\n        }\n        const message = {\n            type: ProxyMessageType.Operations,\n            operations: [op],\n        };\n        await this.store.onProxyMessage(message);\n        this.notifyUpdate(op);\n        return true;\n    }\n    async getParticleView() {\n        if (this.synchronized) {\n            return [this.crdt.getParticleView(), this.versionCopy()];\n        }\n        else {\n            const promise = new Promise((resolve) => {\n                this.modelHasSynced = () => {\n                    this.modelHasSynced = () => undefined;\n                    resolve([this.crdt.getParticleView(), this.versionCopy()]);\n                };\n            });\n            // Request a new model, it will come back asynchronously with a ModelUpdate message.\n            await this.requestSynchronization();\n            return promise;\n        }\n    }\n    async onMessage(message) {\n        switch (message.type) {\n            case ProxyMessageType.ModelUpdate:\n                this.crdt.merge(message.model);\n                this.synchronized = true;\n                this.modelHasSynced();\n                this.notifySync();\n                break;\n            case ProxyMessageType.Operations: {\n                // Bail if we're not in synchronized mode.\n                if (!this.keepSynced) {\n                    return false;\n                }\n                for (const op of message.operations) {\n                    if (!this.crdt.applyOperation(op)) {\n                        // If we cannot cleanly apply ops, sync the whole model.\n                        this.synchronized = false;\n                        await this.notifyDesync();\n                        return this.requestSynchronization();\n                    }\n                    this.notifyUpdate(op);\n                }\n                // If we have consumed all operations, we've caught up.\n                this.synchronized = true;\n                break;\n            }\n            case ProxyMessageType.SyncRequest:\n                await this.store.onProxyMessage({ type: ProxyMessageType.ModelUpdate, model: this.crdt.getData() });\n                break;\n            default:\n                throw new CRDTError(`Invalid operation provided to onMessage, message: ${message}`);\n        }\n        return true;\n    }\n    notifyUpdate(operation) {\n        const version = this.versionCopy();\n        for (const handle of this.handles) {\n            if (handle.options.notifyUpdate) {\n                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Update, op: operation, version });\n            }\n            else if (handle.options.keepSynced) {\n                // keepSynced but not notifyUpdate, notify of the new model.\n                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Sync });\n            }\n        }\n    }\n    notifySync() {\n        for (const handle of this.handles) {\n            if (handle.options.notifySync) {\n                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Sync });\n            }\n        }\n    }\n    notifyDesync() {\n        for (const handle of this.handles) {\n            if (handle.options.notifyDesync) {\n                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Desync });\n            }\n        }\n    }\n    async requestSynchronization() {\n        return this.store.onProxyMessage({ type: ProxyMessageType.SyncRequest });\n    }\n}\nexport class NoOpStorageProxy extends StorageProxy {\n    constructor() {\n        super(null, { getStorageEndpoint() { } }, EntityType.make([], {}));\n    }\n    async idle() {\n        return new Promise(resolve => { });\n    }\n    reportExceptionInHost(exception) { }\n    registerHandle(handle) {\n        return {};\n    }\n    deregisterHandle(handle) { }\n    versionCopy() {\n        return null;\n    }\n    async applyOp(op) {\n        return new Promise(resolve => { });\n    }\n    async getParticleView() {\n        return new Promise(resolve => { });\n    }\n    async getData() {\n        return new Promise(resolve => { });\n    }\n    async onMessage(message) {\n        return new Promise(resolve => { });\n    }\n    notifyUpdate(operation) { }\n    notifySync() { }\n    notifyDesync() { }\n    async requestSynchronization() {\n        return new Promise(resolve => { });\n    }\n}\nvar HandleMessageType;\n(function (HandleMessageType) {\n    HandleMessageType[HandleMessageType[\"Sync\"] = 0] = \"Sync\";\n    HandleMessageType[HandleMessageType[\"Desync\"] = 1] = \"Desync\";\n    HandleMessageType[HandleMessageType[\"Update\"] = 2] = \"Update\";\n})(HandleMessageType || (HandleMessageType = {}));\nexport class StorageProxyScheduler {\n    constructor() {\n        this._scheduled = false;\n        this._queues = new Map();\n        this._idleResolver = null;\n        this._idle = null;\n        this._scheduled = false;\n        // Particle -> {Handle -> [Queue of events]}\n        this._queues = new Map();\n    }\n    enqueue(particle, handle, args) {\n        if (!this._queues.has(particle)) {\n            this._queues.set(particle, new Map());\n        }\n        const byHandle = this._queues.get(particle);\n        if (!byHandle.has(handle)) {\n            byHandle.set(handle, []);\n        }\n        const queue = byHandle.get(handle);\n        queue.push(args);\n        this._schedule();\n    }\n    get busy() {\n        return this._queues.size > 0;\n    }\n    _updateIdle() {\n        if (this._idleResolver && !this.busy) {\n            this._idleResolver();\n            this._idle = null;\n            this._idleResolver = null;\n        }\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        if (!this._idle) {\n            this._idle = new Promise(resolve => this._idleResolver = resolve);\n        }\n        return this._idle;\n    }\n    _schedule() {\n        if (this._scheduled) {\n            return;\n        }\n        this._scheduled = true;\n        setTimeout(() => {\n            this._scheduled = false;\n            this._dispatch();\n        }, 0);\n    }\n    _dispatch() {\n        // TODO: should we process just one particle per task?\n        while (this._queues.size > 0) {\n            const particle = [...this._queues.keys()][0];\n            const byHandle = this._queues.get(particle);\n            this._queues.delete(particle);\n            for (const [handle, queue] of byHandle.entries()) {\n                for (const update of queue) {\n                    this._dispatchUpdate(handle, update).catch(e => handle.storageProxy.reportExceptionInHost(new SystemException(e, 'StorageProxyScheduler::_dispatch', handle.key)));\n                }\n            }\n        }\n        this._updateIdle();\n    }\n    async _dispatchUpdate(handle, update) {\n        switch (update.type) {\n            case HandleMessageType.Sync:\n                handle.onSync();\n                break;\n            case HandleMessageType.Desync:\n                await handle.onDesync();\n                break;\n            case HandleMessageType.Update:\n                handle.onUpdate(update.op, update.version);\n                break;\n            default:\n                console.error('Ignoring unknown update', update);\n        }\n    }\n}\n//# sourceMappingURL=storage-proxy.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Exists } from './drivers/driver-factory.js';\nimport { StorageMode, ActiveStore, ProxyMessageType } from './store-interface.js';\nimport { DirectStore } from './direct-store.js';\nimport { ReferenceModeStore } from './reference-mode-store.js';\nimport { UnifiedStore } from './unified-store.js';\nimport { ReferenceModeStorageKey } from './reference-mode-storage-key.js';\nexport { ActiveStore, ProxyMessageType, StorageMode };\n// A representation of a store. Note that initially a constructed store will be\n// inactive - it will not connect to a driver, will not accept connections from\n// StorageProxy objects, and no data will be read or written.\n//\n// Calling 'activate()' will generate an interactive store and return it.\nexport class Store extends UnifiedStore {\n    constructor(opts) {\n        super(opts);\n        this.unifiedStoreType = 'Store';\n        // The last known version of this store that was stored in the serialized\n        // representation.\n        this.parsedVersionToken = null;\n        this.storageKey = opts.storageKey;\n        this.exists = opts.exists;\n        this.mode = opts.storageKey instanceof ReferenceModeStorageKey ? StorageMode.ReferenceMode : StorageMode.Direct;\n        this.parsedVersionToken = opts.versionToken;\n        this.model = opts.model;\n    }\n    get versionToken() {\n        if (this.activeStore) {\n            return this.activeStore.versionToken;\n        }\n        return this.parsedVersionToken;\n    }\n    async activate() {\n        if (this.activeStore) {\n            return this.activeStore;\n        }\n        if (Store.constructors.get(this.mode) == null) {\n            throw new Error(`StorageMode ${this.mode} not yet implemented`);\n        }\n        const constructor = Store.constructors.get(this.mode);\n        if (constructor == null) {\n            throw new Error(`No constructor registered for mode ${this.mode}`);\n        }\n        const activeStore = await constructor.construct({\n            storageKey: this.storageKey,\n            exists: this.exists,\n            type: this.type,\n            mode: this.mode,\n            baseStore: this,\n            versionToken: this.parsedVersionToken\n        });\n        this.exists = Exists.ShouldExist;\n        this.activeStore = activeStore;\n        return activeStore;\n    }\n    // TODO(shans): DELETEME once we've switched to this storage stack\n    get referenceMode() {\n        return this.mode === StorageMode.ReferenceMode;\n    }\n}\nStore.constructors = new Map([\n    [StorageMode.Direct, DirectStore],\n    [StorageMode.ReferenceMode, ReferenceModeStore]\n]);\n//# sourceMappingURL=store.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport var Exists;\n(function (Exists) {\n    Exists[Exists[\"ShouldExist\"] = 0] = \"ShouldExist\";\n    Exists[Exists[\"ShouldCreate\"] = 1] = \"ShouldCreate\";\n    Exists[Exists[\"MayExist\"] = 2] = \"MayExist\";\n})(Exists || (Exists = {}));\n// Interface that drivers must support.\n//\n// Note the threading of a version number here; each model provided\n// by the driver to the Store (using the receiver) is paired with a version,\n// as is each model sent from the Store to the driver (using Driver.send()).\n//\n// This threading is used to track whether driver state has changed while\n// the Store is processing a particular model. send() should always fail\n// if the version isn't exactly 1 greater than the current internal version.\nexport class Driver {\n    constructor(storageKey, exists) {\n        this.storageKey = storageKey;\n        this.exists = exists;\n    }\n}\nexport class DriverFactory {\n    static clearRegistrationsForTesting() {\n        this.providers = new Set();\n    }\n    static async driverInstance(storageKey, exists) {\n        for (const provider of this.providers) {\n            if (provider.willSupport(storageKey)) {\n                return provider.driver(storageKey, exists);\n            }\n        }\n        return null;\n    }\n    static register(storageDriverProvider) {\n        this.providers.add(storageDriverProvider);\n    }\n    static unregister(storageDriverProvider) {\n        this.providers.delete(storageDriverProvider);\n    }\n    static willSupport(storageKey) {\n        for (const provider of this.providers) {\n            if (provider.willSupport(storageKey)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nDriverFactory.providers = new Set();\n//# sourceMappingURL=driver-factory.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\n/**\n * This file exists to break a circular dependency between Store and the ActiveStore implementations.\n * Source code outside of the storageNG directory should not import this file directly; instead use\n * store.ts, which re-exports all the useful symbols.\n */\nexport var StorageMode;\n(function (StorageMode) {\n    StorageMode[StorageMode[\"Direct\"] = 0] = \"Direct\";\n    StorageMode[StorageMode[\"Backing\"] = 1] = \"Backing\";\n    StorageMode[StorageMode[\"ReferenceMode\"] = 2] = \"ReferenceMode\";\n})(StorageMode || (StorageMode = {}));\nexport var ProxyMessageType;\n(function (ProxyMessageType) {\n    ProxyMessageType[ProxyMessageType[\"SyncRequest\"] = 0] = \"SyncRequest\";\n    ProxyMessageType[ProxyMessageType[\"ModelUpdate\"] = 1] = \"ModelUpdate\";\n    ProxyMessageType[ProxyMessageType[\"Operations\"] = 2] = \"Operations\";\n})(ProxyMessageType || (ProxyMessageType = {}));\n// A representation of an active store. Subclasses of this class provide specific\n// behaviour as controlled by the provided StorageMode.\nexport class ActiveStore {\n    // TODO: Lots of these params can be pulled from baseStore.\n    constructor(options) {\n        this.storageKey = options.storageKey;\n        this.exists = options.exists;\n        this.type = options.type;\n        this.mode = options.mode;\n        this.baseStore = options.baseStore;\n    }\n    async idle() {\n        return Promise.resolve();\n    }\n    async cloneFrom(store) {\n        assert(store instanceof ActiveStore);\n        const activeStore = store;\n        assert(this.mode === activeStore.mode);\n        await this.onProxyMessage({\n            type: ProxyMessageType.ModelUpdate,\n            model: await activeStore.serializeContents()\n        });\n    }\n    async modelForSynchronization() {\n        return this.serializeContents();\n    }\n    getStorageEndpoint() {\n        const store = this;\n        let id;\n        return {\n            async onProxyMessage(message) {\n                message.id = id;\n                return store.onProxyMessage(message);\n            },\n            setCallback(callback) {\n                id = store.on(callback);\n            },\n            reportExceptionInHost(exception) {\n                store.reportExceptionInHost(exception);\n            }\n        };\n    }\n}\n//# sourceMappingURL=store-interface.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { ChangeType, CRDTError } from '../crdt/crdt.js';\nimport { DriverFactory } from './drivers/driver-factory.js';\nimport { ActiveStore, ProxyMessageType } from './store-interface.js';\nimport { noAwait } from '../util.js';\nexport var DirectStoreState;\n(function (DirectStoreState) {\n    DirectStoreState[\"Idle\"] = \"Idle\";\n    DirectStoreState[\"AwaitingResponse\"] = \"AwaitingResponse\";\n    DirectStoreState[\"AwaitingResponseDirty\"] = \"AwaitingResponseDirty\";\n    DirectStoreState[\"AwaitingDriverModel\"] = \"AwaitingDriverModel\";\n})(DirectStoreState || (DirectStoreState = {}));\nexport class DirectStore extends ActiveStore {\n    /*\n     * This class should only ever be constructed via the static construct method\n     */\n    constructor(options) {\n        super(options);\n        this.callbacks = new Map();\n        this.nextCallbackID = 1;\n        this.version = 0;\n        this.pendingException = null;\n        this.pendingResolves = [];\n        this.pendingRejects = [];\n        this.pendingDriverModels = [];\n        this.state = DirectStoreState.Idle;\n    }\n    async serializeContents() {\n        await this.idle();\n        return this.localModel.getData();\n    }\n    async idle() {\n        if (this.pendingException) {\n            return Promise.reject(this.pendingException);\n        }\n        if (this.state === DirectStoreState.Idle) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve, reject) => {\n            this.pendingResolves.push(resolve);\n            this.pendingRejects.push(reject);\n        });\n    }\n    get versionToken() {\n        return this.driver.getToken();\n    }\n    setState(state) {\n        this.state = state;\n        if (state === DirectStoreState.Idle) {\n            // If we are already idle, this won't notify external parties.\n            this.notifyIdle();\n        }\n    }\n    notifyIdle() {\n        if (this.pendingException) {\n            // this is termination.\n            this.pendingRejects.forEach(reject => reject(this.pendingException));\n        }\n        else {\n            this.pendingResolves.forEach(resolve => resolve());\n            this.pendingResolves = [];\n        }\n    }\n    static async construct(options) {\n        const me = new DirectStore(options);\n        me.localModel = new (options.type.crdtInstanceConstructor())();\n        me.driver = await DriverFactory.driverInstance(options.storageKey, options.exists);\n        if (me.driver == null) {\n            throw new CRDTError(`No driver exists to support storage key ${options.storageKey}`);\n        }\n        me.driver.registerReceiver(me.onReceive.bind(me), options.versionToken);\n        return me;\n    }\n    // The driver will invoke this method when it has an updated remote model\n    async onReceive(model, version) {\n        this.pendingDriverModels.push({ model, version });\n        if (this.state === DirectStoreState.AwaitingResponse || this.state === DirectStoreState.AwaitingResponseDirty) {\n            return;\n        }\n        this.applyPendingDriverModels();\n    }\n    deliverCallbacks(thisChange, messageFromDriver, channel) {\n        if (thisChange.changeType === ChangeType.Operations && thisChange.operations.length > 0) {\n            this.callbacks.forEach((cb, id) => {\n                if (messageFromDriver || channel !== id) {\n                    void cb({ type: ProxyMessageType.Operations, operations: thisChange.operations, id });\n                }\n            });\n        }\n        else if (thisChange.changeType === ChangeType.Model) {\n            this.callbacks.forEach((cb, id) => {\n                if (messageFromDriver || channel !== id) {\n                    void cb({ type: ProxyMessageType.ModelUpdate, model: thisChange.modelPostChange, id });\n                }\n            });\n        }\n    }\n    async processModelChange(modelChange, otherChange, version, channel) {\n        this.deliverCallbacks(modelChange, /* messageFromDriver= */ false, channel);\n        await this.updateStateAndAct(this.noDriverSideChanges(modelChange, otherChange, false), version, false);\n    }\n    // This function implements a state machine that controls when data is sent to the driver.\n    // You can see the state machine in all its glory at the following URL:\n    //\n    // https://github.com/PolymerLabs/arcs/wiki/Store-object-State-Machine\n    //\n    async updateStateAndAct(noDriverSideChanges, version, messageFromDriver) {\n        // Don't send to the driver if we're already in sync and there are no driver-side changes.\n        if (noDriverSideChanges) {\n            // Need to record the driver version so that we can continue to send.\n            this.setState(DirectStoreState.Idle);\n            this.version = version;\n            return;\n        }\n        switch (this.state) {\n            case DirectStoreState.AwaitingDriverModel:\n                if (!messageFromDriver) {\n                    return;\n                }\n            /* falls through */\n            case DirectStoreState.Idle:\n                // This loop implements sending -> AwaitingResponse -> AwaitingResponseDirty -> sending.\n                // Breakouts happen if:\n                //  (1) a response arrives while still AwaitingResponse. This returns the store to Idle.\n                //  (2) a negative response arrives. This means we're now waiting for driver models\n                //      (AwaitingDriverModel). Note that in this case we are likely to end up back in\n                //      this loop when a driver model arrives.\n                while (true) {\n                    this.setState(DirectStoreState.AwaitingResponse);\n                    // Work around a typescript compiler bug. Apparently typescript won't guarantee that\n                    // a Map key you've just set will exist, but is happy to assure you that a private\n                    // member variable couldn't possibly change in any function outside the local scope\n                    // when within a switch statement.\n                    this.state = DirectStoreState.AwaitingResponse;\n                    this.version = ++version;\n                    const response = await this.driver.send(this.localModel.getData(), version);\n                    if (response) {\n                        if (this.state === DirectStoreState.AwaitingResponse) {\n                            this.setState(DirectStoreState.Idle);\n                            this.applyPendingDriverModels();\n                            break;\n                        }\n                        if (this.state !== DirectStoreState.AwaitingResponseDirty) {\n                            // This shouldn't be possible as only a 'nack' should put us into\n                            // AwaitingDriverModel, and only the above code should put us back\n                            // into Idle.\n                            throw new Error('reached impossible state in store state machine');\n                        }\n                        // fallthrough to re-execute the loop.\n                    }\n                    else {\n                        this.setState(DirectStoreState.AwaitingDriverModel);\n                        this.applyPendingDriverModels();\n                        break;\n                    }\n                }\n                return;\n            case DirectStoreState.AwaitingResponse:\n                this.setState(DirectStoreState.AwaitingResponseDirty);\n                return;\n            case DirectStoreState.AwaitingResponseDirty:\n                return;\n            default:\n                throw new Error('reached impossible default state in switch statement');\n        }\n    }\n    applyPendingDriverModels() {\n        if (this.pendingDriverModels.length > 0) {\n            const models = this.pendingDriverModels;\n            this.pendingDriverModels = [];\n            let noDriverSideChanges = true;\n            let theVersion = 0;\n            for (const { model, version } of models) {\n                try {\n                    const { modelChange, otherChange } = this.localModel.merge(model);\n                    this.deliverCallbacks(modelChange, /* messageFromDriver= */ true, 0);\n                    noDriverSideChanges = noDriverSideChanges && this.noDriverSideChanges(modelChange, otherChange, true);\n                    theVersion = version;\n                }\n                catch (e) {\n                    this.pendingException = e;\n                    this.notifyIdle();\n                    return;\n                }\n            }\n            void this.updateStateAndAct(noDriverSideChanges, theVersion, true);\n        }\n    }\n    // Note that driver-side changes are stored in 'otherChange' when the merged operations/model is sent\n    // from the driver, and 'thisChange' when the merged operations/model is sent from a storageProxy.\n    // In the former case, we want to look at what has changed between what the driver sent us and what\n    // we now have. In the latter, the driver is only as up-to-date as our local model before we've\n    // applied the operations.\n    noDriverSideChanges(thisChange, otherChange, messageFromDriver) {\n        if (messageFromDriver) {\n            return otherChange.changeType === ChangeType.Operations && otherChange.operations.length === 0;\n        }\n        else {\n            return thisChange.changeType === ChangeType.Operations && thisChange.operations.length === 0;\n        }\n    }\n    // Operation or model updates from connected StorageProxies will arrive here.\n    // Additionally, StorageProxy objects may request a SyncRequest, which will\n    // result in an up-to-date model being sent back to that StorageProxy.\n    // a return value of true implies that the message was accepted, a\n    // return value of false requires that the proxy send a model sync\n    async onProxyMessage(message) {\n        if (this.pendingException) {\n            throw this.pendingException;\n        }\n        switch (message.type) {\n            case ProxyMessageType.SyncRequest:\n                await this.callbacks.get(message.id)({ type: ProxyMessageType.ModelUpdate, model: this.localModel.getData(), id: message.id });\n                return true;\n            case ProxyMessageType.Operations: {\n                for (const operation of message.operations) {\n                    if (!this.localModel.applyOperation(operation)) {\n                        await this.callbacks.get(message.id)({ type: ProxyMessageType.SyncRequest, id: message.id });\n                        return false;\n                    }\n                }\n                const change = { changeType: ChangeType.Operations, operations: message.operations };\n                // to make tsetse checks happy\n                noAwait(this.processModelChange(change, null, this.version, message.id));\n                return true;\n            }\n            case ProxyMessageType.ModelUpdate: {\n                const { modelChange, otherChange } = this.localModel.merge(message.model);\n                // to make tsetse checks happy\n                noAwait(this.processModelChange(modelChange, otherChange, this.version, message.id));\n                return true;\n            }\n            default:\n                throw new CRDTError('Invalid operation provided to onProxyMessage');\n        }\n    }\n    on(callback) {\n        const id = this.nextCallbackID++;\n        this.callbacks.set(id, callback);\n        if (this.version > 0) {\n            noAwait(callback({ type: ProxyMessageType.ModelUpdate, model: this.localModel.getData(), id }));\n        }\n        return id;\n    }\n    off(callback) {\n        this.callbacks.delete(callback);\n    }\n    reportExceptionInHost(exception) {\n        this.pendingException = exception;\n        this.notifyIdle();\n    }\n}\n//# sourceMappingURL=direct-store.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\n/**\n * Returns the set delta between two lists based on direct object comparison.\n */\nexport function setDiff(from, to) {\n    const result = { add: [], remove: [] };\n    const items = new Set([...from, ...to]);\n    const fromSet = new Set(from);\n    const toSet = new Set(to);\n    for (const item of items) {\n        if (fromSet.has(item)) {\n            if (toSet.has(item)) {\n                continue;\n            }\n            result.remove.push(item);\n            continue;\n        }\n        assert(toSet.has(item));\n        result.add.push(item);\n    }\n    return result;\n}\n/**\n * Returns the set delta between two lists based on custom object comparison.\n * `keyFn` takes type T and returns the value by which items should be compared.\n */\nexport function setDiffCustom(from, to, keyFn) {\n    const result = { add: [], remove: [] };\n    const items = new Map();\n    const fromSet = new Map();\n    const toSet = new Map();\n    for (const item of from) {\n        const key = keyFn(item);\n        items.set(key, item);\n        fromSet.set(key, item);\n    }\n    for (const item of to) {\n        const key = keyFn(item);\n        items.set(key, item);\n        toSet.set(key, item);\n    }\n    for (const [key, item] of items) {\n        if (fromSet.has(key)) {\n            if (toSet.has(key)) {\n                continue;\n            }\n            result.remove.push(item);\n            continue;\n        }\n        assert(toSet.has(key));\n        result.add.push(item);\n    }\n    return result;\n}\n/**\n * A hack to ignore a floating promise and bypass the linter. Promises should very rarely be left floating, and when such behaviour is intended,\n * it should be clearly marked as such. See https://tsetse.info/must-use-promises.html for details.\n *\n * TODO: Remove all usages of this function and then delete it.\n */\nexport function floatingPromiseToAudit(promise) { }\n/**\n * Noop function that can be used to supress the tsetse must-use-promises rule.\n *\n * Example Usage:\n *   async function x() {\n *     await doA();\n *     noAwait(doB());\n *   }\n */\nexport function noAwait(result) { }\n//# sourceMappingURL=util.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { SingletonOpTypes, CRDTSingleton } from '../crdt/crdt-singleton.js';\nimport { CollectionOpTypes, CRDTCollection } from '../crdt/crdt-collection.js';\nimport { ActiveStore, ProxyMessageType, StorageMode } from './store-interface.js';\nimport { BackingStore } from './backing-store.js';\nimport { CRDTEntity } from '../crdt/crdt-entity.js';\nimport { DirectStore } from './direct-store.js';\nimport { CollectionType, ReferenceType, SingletonType } from '../type.js';\nimport { noAwait } from '../util.js';\nexport class ReferenceCollection extends CRDTCollection {\n}\nexport class ReferenceSingleton extends CRDTSingleton {\n}\nvar ReferenceModeUpdateSource;\n(function (ReferenceModeUpdateSource) {\n    ReferenceModeUpdateSource[ReferenceModeUpdateSource[\"Container\"] = 0] = \"Container\";\n    ReferenceModeUpdateSource[ReferenceModeUpdateSource[\"BackingStore\"] = 1] = \"BackingStore\";\n    ReferenceModeUpdateSource[ReferenceModeUpdateSource[\"StorageProxy\"] = 2] = \"StorageProxy\";\n})(ReferenceModeUpdateSource || (ReferenceModeUpdateSource = {}));\n/**\n * ReferenceModeStores adapt between a collection (CRDTCollection or CRDTSingleton) of entities from the perspective of their public API,\n * and a collection of references + a backing store of entity CRDTs from an internal storage perspective.\n *\n * ReferenceModeStores maintain a queue of incoming updates (the receiveQueue) and process them one at a time. When possible, the results\n * of this processing are immediately sent upwards (to connected StorageProxies) and downwards (to storage). However, there are a few\n * caveats:\n * - incoming operations and models from StorageProxies may require several writes to storage - one for each modified entity, and one\n *   to the container store. These are processed serially, so that a container doesn't get updated if backing store modifications fail.\n * - updates from the container store need to be blocked on ensuring the required data is also available in the backing store.\n *   The holdQueue ensures that these blocks are tracked and processed appropriately.\n * - updates should always be sent in order, so a blocked send should block subsequent sends too. The pendingSends queue ensures that all\n *   outgoing updates are sent in the correct order.\n *\n */\nexport class ReferenceModeStore extends ActiveStore {\n    constructor() {\n        super(...arguments);\n        /*\n         * Registered callbacks to Storage Proxies\n         */\n        this.callbacks = new Map();\n        this.nextCallbackID = 1;\n        /*\n         * A randomly generated key that is used for synthesized entity CRDT modifications.\n         *\n         * When entity updates are received by instances of ReferenceModeStore, they're non-CRDT blobs of data.\n         * The ReferenceModeStore needs to convert them to tracked CRDTs, which means it needs to synthesize\n         * updates. This key is used as the unique write key for those updates.\n         */\n        this.crdtKey = (Math.random() * Math.pow(2, 64)) + '';\n        /*\n         * The versions dictionary tracks the maximum write version for each entity ID, to ensure synthesized\n         * updates can be correctly applied downstream.\n         */\n        this.versions = {};\n        /*\n         * A queue of incoming updates from the backing store, container store, and connected proxies.\n         * These are dealt with atomically, to avoid transient states where an operation has only been partially\n         * processed (e.g. backing written but container update not written).\n         */\n        this.receiveQueue = [];\n        /*\n         * A queue of send Runnables. Some of these may be blocked on entities becoming available in the\n         * backing store.\n         */\n        this.pendingSends = [];\n        /*\n         * A queue of blocks to the pendingSends queue.\n         */\n        this.holdQueue = new HoldQueue();\n        /*\n         * An incrementing ID to uniquely identify each blocked send.\n         */\n        this.blockCounter = 0;\n    }\n    static async construct(options) {\n        const result = new ReferenceModeStore(options);\n        const { storageKey, type } = options;\n        result.backingStore = await BackingStore.construct({\n            storageKey: storageKey.backingKey,\n            type: type.getContainedType(),\n            mode: StorageMode.Backing,\n            exists: options.exists,\n            baseStore: options.baseStore,\n            versionToken: null\n        });\n        let refType;\n        if (type.isCollectionType()) {\n            refType = new CollectionType(new ReferenceType(type.getContainedType()));\n        }\n        else {\n            refType = new SingletonType(new ReferenceType(type.getContainedType()));\n        }\n        result.containerStore = await DirectStore.construct({\n            storageKey: storageKey.storageKey,\n            type: refType,\n            mode: StorageMode.Direct,\n            exists: options.exists,\n            baseStore: options.baseStore,\n            versionToken: options.versionToken\n        });\n        result.registerStoreCallbacks();\n        return result;\n    }\n    async serializeContents() {\n        const data = await this.containerStore.serializeContents();\n        const { pendingIds, model } = this.constructPendingIdsAndModel(data);\n        if (pendingIds.length === 0) {\n            return model();\n        }\n        return new Promise((resolve, reject) => {\n            this.enqueueBlockingSend(pendingIds, () => resolve(model()));\n        });\n    }\n    reportExceptionInHost(exception) {\n        // TODO(shans): Figure out idle / exception store for reference mode stores.\n    }\n    // For referenceMode stores, the version tracked is just the version\n    // of the container, because any updates to Entities must necessarily be\n    // stored as version updates to the references in the container.\n    get versionToken() {\n        return this.containerStore.versionToken;\n    }\n    on(callback) {\n        const id = this.nextCallbackID++;\n        this.callbacks.set(id, callback);\n        return id;\n    }\n    off(callback) {\n        this.callbacks.delete(callback);\n    }\n    registerStoreCallbacks() {\n        this.backingStore.on(this.onBackingStore.bind(this));\n        this.containerStore.on(this.onContainerStore.bind(this));\n    }\n    /**\n     * Messages are enqueued onto an object-wide queue and processed in order.\n     * Internally, each handler (handleContainerStore, handleBackingStore, handleProxyMessage)\n     * should not return until the response relevant to the message has been received.\n     *\n     * When handling proxy messages, this implies 2 rounds of update - first the backing\n     * store needs to be updated, and once that has completed then the container store needs\n     * to be updated.\n     */\n    async onContainerStore(message) {\n        return this.enqueue({ from: ReferenceModeUpdateSource.Container, message });\n    }\n    async onBackingStore(message, muxId) {\n        return this.enqueue({ from: ReferenceModeUpdateSource.BackingStore, message, muxId });\n    }\n    async onProxyMessage(message) {\n        return this.enqueue({ from: ReferenceModeUpdateSource.StorageProxy, message });\n    }\n    /**\n     * enqueue an incoming update onto the object-wide queue and return a promise that will be resolved\n     * when the update is processed.\n     */\n    async enqueue(entry) {\n        return new Promise((resolve, reject) => {\n            const startProcessing = this.receiveQueue.length === 0;\n            this.receiveQueue.push({ ...entry, promise: resolve });\n            if (startProcessing) {\n                void this.processQueue();\n            }\n        });\n    }\n    async processQueue() {\n        while (this.receiveQueue.length > 0) {\n            // ths.receiveQueue.length === 0 is used as a signal to start processing (see enqueue). As\n            // this method is asynchronous, we can't remove the current element until it's processed\n            // or we'll potentially get duplicate calls to processQueue.\n            const nextMessage = this.receiveQueue[0];\n            switch (nextMessage.from) {\n                case ReferenceModeUpdateSource.StorageProxy:\n                    nextMessage.promise(await this.handleProxyMessage(nextMessage.message));\n                    break;\n                case ReferenceModeUpdateSource.BackingStore:\n                    nextMessage.promise(await this.handleBackingStore(nextMessage.message, nextMessage.muxId));\n                    break;\n                case ReferenceModeUpdateSource.Container:\n                    nextMessage.promise(await this.handleContainerStore(nextMessage.message));\n                    break;\n                default:\n                    throw new Error('invalid message type');\n            }\n            this.receiveQueue.shift();\n        }\n    }\n    /**\n     * Handle an update from the container store.\n     *\n     * Operations and Models either enqueue an immediate send (if all referenced entities\n     * are available in the backing store) or enqueue a blocked send (if some referenced\n     * entities are not yet present or are at the incorrect version).\n     *\n     * Sync requests are propagated upwards to the storage proxy.\n     */\n    async handleContainerStore(message) {\n        switch (message.type) {\n            case ProxyMessageType.Operations: {\n                for (const operation of message.operations) {\n                    const reference = this.operationElement(operation);\n                    let getEntity;\n                    if (reference) {\n                        const entityCRDT = this.backingStore.getLocalModel(reference.id);\n                        if (!entityCRDT) {\n                            this.enqueueBlockingSend([reference], () => {\n                                const entityCRDT = this.backingStore.getLocalModel(reference.id);\n                                const getEntity = () => this.entityFromModel(entityCRDT.getData(), reference.id);\n                                const upstreamOp = this.updateOp(operation, getEntity);\n                                void this.send({ type: ProxyMessageType.Operations, operations: [upstreamOp] });\n                            });\n                            break;\n                        }\n                        getEntity = () => this.entityFromModel(entityCRDT.getData(), reference.id);\n                    }\n                    else {\n                        getEntity = () => null;\n                    }\n                    this.enqueueSend(() => {\n                        const upstreamOp = this.updateOp(operation, getEntity);\n                        void this.send({ type: ProxyMessageType.Operations, operations: [upstreamOp] });\n                    });\n                }\n                break;\n            }\n            case ProxyMessageType.ModelUpdate: {\n                const data = message.model;\n                const { pendingIds, model } = this.constructPendingIdsAndModel(data);\n                const send = () => void this.send({ type: ProxyMessageType.ModelUpdate, model: model() });\n                if (pendingIds.length === 0) {\n                    this.enqueueSend(send);\n                }\n                else {\n                    this.enqueueBlockingSend(pendingIds, send);\n                }\n                break;\n            }\n            case ProxyMessageType.SyncRequest: {\n                this.enqueueSend(() => {\n                    void this.send({ type: ProxyMessageType.SyncRequest });\n                });\n                break;\n            }\n            default: {\n                throw new Error('Unexpected ProxyMessageType');\n            }\n        }\n        return true;\n    }\n    /**\n     * Handle an update from the backing store.\n     *\n     * Model and Operation updates are routed directly to the holdQueue, where they may unblock\n     * pending sends but will not have any other action.\n     *\n     * Syncs should never occur as operation/model updates to the backing store are generated\n     * by this ReferenceModeStore object and hence should never be out-of-order.\n     */\n    async handleBackingStore(message, muxId) {\n        switch (message.type) {\n            case ProxyMessageType.ModelUpdate:\n                this.holdQueue.processID(muxId, message.model.version);\n                break;\n            case ProxyMessageType.Operations:\n                this.holdQueue.processID(muxId, message.operations[message.operations.length - 1].clock);\n                break;\n            case ProxyMessageType.SyncRequest:\n                throw new Error('Unexpected SyncRequest from backing store');\n            default:\n                throw new Error('Unexpected ProxyMessageType');\n        }\n        return true;\n    }\n    /**\n     * Handle an update from an upstream StorageProxy.\n     *\n     * Model and Operation updates apply first to the backing store, then to the container store.\n     * Backing store updates should never fail as updates are locally generated.\n     * For Operations:\n     * - If the container store update succeeds, then the update is mirrored to non-sending StorageProxies.\n     * - If the container store update fails, then a `false` return value ensures that the upstream proxy\n     *   will request a sync.\n     * Model updates should not fail.\n     *\n     * Sync requests are handled by directly constructing and sending a model\n     */\n    async handleProxyMessage(message) {\n        switch (message.type) {\n            case ProxyMessageType.Operations: {\n                const operations = message.operations;\n                for (const operation of operations) {\n                    const entity = this.operationElement(operation);\n                    let reference = null;\n                    if (entity) {\n                        await this.updateBackingStore(entity);\n                        const version = this.backingStore.getLocalModel(entity.id).getData().version;\n                        reference = { id: entity.id, storageKey: this.backingStore.storageKey, version };\n                    }\n                    const containerMessage = this.updateOp(operation, () => reference);\n                    const response = await this.containerStore.onProxyMessage({ type: ProxyMessageType.Operations, operations: [containerMessage], id: 1 });\n                    if (response) {\n                        this.enqueueSend(() => void this.sendExcept(message, message.id));\n                    }\n                    else {\n                        return false;\n                    }\n                }\n                break;\n            }\n            case ProxyMessageType.ModelUpdate: {\n                const { version, values } = message.model;\n                const newValues = {};\n                const backingStoreReceipts = [];\n                Object.entries(values).forEach(([id, { value, version }]) => {\n                    backingStoreReceipts.push(this.updateBackingStore(value).then(success => {\n                        if (success) {\n                            const entityVersion = this.backingStore.getLocalModel(id).getData().version;\n                            newValues[id] = { value: { id, storageKey: this.backingStore.storageKey, version: entityVersion }, version };\n                        }\n                        return success;\n                    }));\n                });\n                await Promise.all(backingStoreReceipts);\n                const model = { version, values: newValues };\n                await this.containerStore.onProxyMessage({ type: ProxyMessageType.ModelUpdate, model, id: 1 });\n                this.enqueueSend(() => this.sendExcept(message, message.id));\n                break;\n            }\n            case ProxyMessageType.SyncRequest: {\n                const { pendingIds, model } = this.constructPendingIdsAndModel(this.containerStore.localModel.getData());\n                const send = () => void this.callbacks.get(message.id)({ type: ProxyMessageType.ModelUpdate, model: model(), id: message.id });\n                if (pendingIds.length === 0) {\n                    this.enqueueSend(send);\n                }\n                else {\n                    this.enqueueBlockingSend(pendingIds, send);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unexpected ProxyMessageType');\n        }\n        return true;\n    }\n    /**\n     * Enqueues a sending function on the send queue. If the send queue is empty then\n     * the function is immediately invoked.\n     */\n    enqueueSend(runnable) {\n        if (this.pendingSends.length === 0) {\n            runnable();\n        }\n        else {\n            this.pendingSends.push({ fn: runnable });\n        }\n    }\n    /**\n     * Enqueues a send function on the send queue, deferring execution until the\n     * provided id list is available in the backing store.\n     */\n    enqueueBlockingSend(entities, runnable) {\n        const block = (this.blockCounter++) + '';\n        this.pendingSends.push({ fn: runnable, block });\n        this.holdQueue.enqueue(entities, () => this.processPendingSends(block));\n    }\n    /**\n     * Process any sends in the pending send queue, including sends blocked on the\n     * provided block. This should only be called by the holdQueue.\n     */\n    processPendingSends(block) {\n        while (this.pendingSends.length > 0) {\n            if (this.pendingSends[0].block == null || this.pendingSends[0].block === block) {\n                const send = this.pendingSends.shift();\n                send.fn();\n            }\n            else {\n                return;\n            }\n        }\n    }\n    addFieldToValueList(list, value, version) {\n        // NOTE: This could potentially be an extension point to provide automatic IDs if we\n        // need some sort of field-level collection capabilities ahead of entity mutation.\n        list[value['id']] = { value, version };\n    }\n    /**\n     * Convert the provided entity to a CRDT Model of the entity. This requires synthesizing\n     * a version map for the CRDT model, which is also provided as an output.\n     */\n    entityToModel(entity) {\n        if (this.versions[entity.id] == undefined) {\n            this.versions[entity.id] = {};\n        }\n        const entityVersion = this.versions[entity.id];\n        const model = this.newBackingInstance().getData();\n        let maxVersion = 0;\n        for (const key of Object.keys(entity.rawData)) {\n            if (entityVersion[key] == undefined) {\n                entityVersion[key] = 0;\n            }\n            const version = { [this.crdtKey]: ++entityVersion[key] };\n            maxVersion = Math.max(maxVersion, entityVersion[key]);\n            if (model.singletons[key]) {\n                model.singletons[key].values = {};\n                this.addFieldToValueList(model.singletons[key].values, entity.rawData[key], version);\n                model.singletons[key].version = version;\n            }\n            else if (model.collections[key]) {\n                model.collections[key].values = {};\n                for (const value of entity.rawData[key]) {\n                    this.addFieldToValueList(model.collections[key].values, value, version);\n                }\n                model.collections[key].version = version;\n            }\n            else {\n                throw new Error(`key ${key} not found for model ${model}`);\n            }\n        }\n        model.version = { [this.crdtKey]: maxVersion };\n        return model;\n    }\n    /**\n     * Convert the provided CRDT model into an entity.\n     */\n    entityFromModel(model, id) {\n        const entity = { id, rawData: {} };\n        const singletons = {};\n        for (const field of Object.keys(model.singletons)) {\n            singletons[field] = new CRDTSingleton();\n        }\n        const collections = {};\n        for (const field of Object.keys(model.collections)) {\n            collections[field] = new CRDTCollection();\n        }\n        const entityCRDT = new CRDTEntity(singletons, collections);\n        entityCRDT.merge(model);\n        const data = entityCRDT.getParticleView();\n        for (const [key, value] of Object.entries(data.singletons)) {\n            entity.rawData[key] = value;\n        }\n        for (const [key, value] of Object.entries(data.collections)) {\n            entity.rawData[key] = value;\n        }\n        return entity;\n    }\n    cloneMap(map) {\n        const result = {};\n        Object.entries(map).forEach(([key, value]) => result[key] = value);\n        return result;\n    }\n    /**\n     * Returns a function that can construct a CRDTModel of a Container of Entities based off the\n     * provided Container of References. Any referenced IDs that are not yet available in the backing\n     * store are returned in the pendingIds list. The returned function should not be invoked until\n     * all references in pendingIds have valid backing in the backing store.\n     */\n    constructPendingIdsAndModel(data) {\n        const pendingIds = [];\n        for (const id of Object.keys(data.values)) {\n            const version = data.values[id].value.version;\n            if (Object.keys(version).length === 0) {\n                // This object is requested at an empty version, which means that it's new and can be directly constructed\n                // rather than waiting for an update.\n                continue;\n            }\n            const backingModel = this.backingStore.getLocalModel(id);\n            if ((backingModel == null) || !versionIsLarger(backingModel.getData().version, version)) {\n                pendingIds.push({ id, version });\n            }\n        }\n        const fn = () => {\n            const model = { values: {}, version: this.cloneMap(data.version) };\n            for (const id of Object.keys(data.values)) {\n                const version = data.values[id].value.version;\n                const entity = Object.keys(version).length === 0 ? this.newBackingInstance() : this.backingStore.getLocalModel(id);\n                model.values[id] = { value: this.entityFromModel(entity.getData(), id), version: data.values[id].version };\n            }\n            return model;\n        };\n        return { pendingIds, model: fn };\n    }\n    /**\n     * Add appropriate ids and send the provided message on all registered StorageProxy callbacks.\n     */\n    async send(message) {\n        for (const key of this.callbacks.keys()) {\n            noAwait(this.callbacks.get(key)({ ...message, id: key }));\n        }\n    }\n    /**\n     * Add appropriate ids and send the provided message on all registered StorageProxy callbacks,\n     * except for the callback identified by the provided callback ID.\n     */\n    async sendExcept(message, notTo) {\n        for (const key of this.callbacks.keys()) {\n            if (key === notTo) {\n                continue;\n            }\n            noAwait(this.callbacks.get(key)({ ...message, id: key }));\n        }\n    }\n    /**\n     * Write the provided entity to the backing store.\n     */\n    async updateBackingStore(entity) {\n        const model = this.entityToModel(entity);\n        return this.backingStore.onProxyMessage({ type: ProxyMessageType.ModelUpdate, model, id: 1 }, entity.id);\n    }\n    newBackingInstance() {\n        const instanceConstructor = this.type.getContainedType().crdtInstanceConstructor();\n        return new instanceConstructor();\n    }\n    /**\n     * Apply the an add, remove, set or clear method to the provided operation\n     * based on the operation type.\n     */\n    processOp(onAdd, onRemove, onSet, onClear, operation) {\n        if (isCollectionOperation(operation)) {\n            switch (operation.type) {\n                case CollectionOpTypes.Add:\n                    return onAdd(operation);\n                case CollectionOpTypes.Remove:\n                    return onRemove(operation);\n                default:\n                    throw new Error('unexpected operation type');\n            }\n        }\n        else if (isSingletonOperation(operation)) {\n            switch (operation.type) {\n                case SingletonOpTypes.Set:\n                    return onSet(operation);\n                case SingletonOpTypes.Clear:\n                    return onClear(operation);\n                default:\n                    throw new Error('unexpected operation type');\n            }\n        }\n        throw new Error('unexpected operation type');\n    }\n    /**\n     * Return the element referenced by the provided operation, or null if the operation is a clear operation.\n     */\n    operationElement(operation) {\n        return this.processOp(addOp => addOp.added, removeOp => removeOp.removed, setOp => setOp.value, clearOp => null, operation);\n    }\n    /**\n     * Update the provided operation's element using the provided producer.\n     */\n    updateOp(operation, getValue) {\n        const add = addOp => ({ ...addOp, added: getValue() });\n        const remove = removeOp => ({ ...removeOp, removed: getValue() });\n        const set = setOp => ({ ...setOp, value: getValue() });\n        const clear = clearOp => clearOp;\n        return this.processOp(add, remove, set, clear, operation);\n    }\n}\nfunction versionIsLarger(larger, smaller) {\n    for (const key in Object.keys(smaller)) {\n        if (larger[key] < smaller[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass HoldQueue {\n    constructor() {\n        this.queue = {};\n    }\n    enqueue(entities, onRelease) {\n        const ids = {};\n        for (const { id, version } of entities) {\n            ids[id] = version;\n        }\n        const holdRecord = { ids, onRelease };\n        for (const entity of entities) {\n            if (!this.queue[entity.id]) {\n                this.queue[entity.id] = [];\n            }\n            this.queue[entity.id].push(holdRecord);\n        }\n    }\n    processID(id, version) {\n        const records = this.queue[id];\n        if (!records) {\n            return;\n        }\n        for (const record of records) {\n            if (versionIsLarger(version, record.ids[id])) {\n                delete record.ids[id];\n                if (Object.keys(record.ids).length === 0) {\n                    record.onRelease();\n                }\n            }\n        }\n        this.queue[id] = [];\n    }\n}\nfunction isCollectionOperation(operation) {\n    return Boolean(operation['added'] || operation['removed']);\n}\nfunction isSingletonOperation(operation) {\n    return !isCollectionOperation(operation);\n}\n//# sourceMappingURL=reference-mode-store.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { DirectStore } from './direct-store.js';\n/**\n * A store that allows multiple CRDT models to be stored as sub-keys of a single storageKey location.\n */\nexport class BackingStore {\n    constructor(options) {\n        this.stores = {};\n        this.callbacks = new Map();\n        this.nextCallbackId = 1;\n        this.storageKey = options.storageKey;\n        this.options = options;\n    }\n    on(callback) {\n        this.callbacks.set(this.nextCallbackId, callback);\n        return this.nextCallbackId++;\n    }\n    off(callback) {\n        this.callbacks.delete(callback);\n    }\n    getLocalModel(muxId) {\n        const store = this.stores[muxId];\n        if (store == null) {\n            this.stores[muxId] = { type: 'pending', promise: this.setupStore(muxId) };\n            return null;\n        }\n        if (store.type === 'pending') {\n            return null;\n        }\n        else {\n            return store.store.localModel;\n        }\n    }\n    async setupStore(muxId) {\n        const store = await DirectStore.construct({ ...this.options, storageKey: this.storageKey.childKeyForBackingElement(muxId) });\n        const record = { store, id: 0, type: 'record' };\n        this.stores[muxId] = record;\n        // Calling store.on may trigger an event; this will be delivered (via processStoreCallback) upstream and may in\n        // turn trigger a request for the localModel. It's important that there's a recorded store in place for the local\n        // model to be retrieved from, even though we don't have the correct id until store.on returns.\n        record.id = store.on(msg => this.processStoreCallback(muxId, msg));\n        return record;\n    }\n    async onProxyMessage(message, muxId) {\n        let storeRecord = this.stores[muxId];\n        if (storeRecord == null) {\n            storeRecord = await this.setupStore(muxId);\n        }\n        if (storeRecord.type === 'pending') {\n            storeRecord = await storeRecord.promise;\n        }\n        const { store, id } = storeRecord;\n        message.id = id;\n        return store.onProxyMessage(message);\n    }\n    static async construct(options) {\n        return new BackingStore(options);\n    }\n    async idle() {\n        const stores = [];\n        for (const store of Object.values(this.stores)) {\n            if (store.type === 'record') {\n                stores.push(store.store);\n            }\n        }\n        await Promise.all(stores.map(store => store.idle()));\n    }\n    async processStoreCallback(muxId, message) {\n        return Promise.all([...this.callbacks.values()].map(callback => callback(message, muxId))).then(a => a.reduce((a, b) => a && b));\n    }\n}\n//# sourceMappingURL=backing-store.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { ChangeType } from './crdt.js';\nimport { CollectionOpTypes } from './crdt-collection.js';\nimport { SingletonOpTypes } from './crdt-singleton.js';\nexport var EntityOpTypes;\n(function (EntityOpTypes) {\n    EntityOpTypes[EntityOpTypes[\"Set\"] = 0] = \"Set\";\n    EntityOpTypes[EntityOpTypes[\"Clear\"] = 1] = \"Clear\";\n    EntityOpTypes[EntityOpTypes[\"Add\"] = 2] = \"Add\";\n    EntityOpTypes[EntityOpTypes[\"Remove\"] = 3] = \"Remove\";\n})(EntityOpTypes || (EntityOpTypes = {}));\nexport class CRDTEntity {\n    constructor(singletons, collections) {\n        this.model = { singletons, collections, version: {} };\n    }\n    merge(other) {\n        const singletonChanges = {};\n        const collectionChanges = {};\n        let allOps = true;\n        for (const singleton of Object.keys(this.model.singletons)) {\n            singletonChanges[singleton] = this.model.singletons[singleton].merge(other.singletons[singleton]);\n            if (singletonChanges[singleton].modelChange.changeType === ChangeType.Model ||\n                singletonChanges[singleton].otherChange.changeType === ChangeType.Model) {\n                allOps = false;\n            }\n        }\n        for (const collection of Object.keys(this.model.collections)) {\n            collectionChanges[collection] = this.model.collections[collection].merge(other.collections[collection]);\n            if (collectionChanges[collection].modelChange.changeType === ChangeType.Model ||\n                collectionChanges[collection].otherChange.changeType === ChangeType.Model) {\n                allOps = false;\n            }\n        }\n        for (const versionKey of Object.keys(other.version)) {\n            this.model.version[versionKey] = Math.max(this.model.version[versionKey] || 0, other.version[versionKey]);\n        }\n        if (allOps) {\n            const modelOps = [];\n            const otherOps = [];\n            for (const singleton of Object.keys(singletonChanges)) {\n                for (const operation of singletonChanges[singleton].modelChange.operations) {\n                    let op;\n                    if (operation.type === SingletonOpTypes.Set) {\n                        op = { ...operation, type: EntityOpTypes.Set, field: singleton };\n                    }\n                    else {\n                        op = { ...operation, type: EntityOpTypes.Clear, field: singleton };\n                    }\n                    modelOps.push(op);\n                }\n                for (const operation of singletonChanges[singleton].otherChange.operations) {\n                    let op;\n                    if (operation.type === SingletonOpTypes.Set) {\n                        op = { ...operation, type: EntityOpTypes.Set, field: singleton };\n                    }\n                    else {\n                        op = { ...operation, type: EntityOpTypes.Clear, field: singleton };\n                    }\n                    otherOps.push(op);\n                }\n            }\n            for (const collection of Object.keys(collectionChanges)) {\n                for (const operation of collectionChanges[collection].modelChange.operations) {\n                    let op;\n                    if (operation.type === CollectionOpTypes.Add) {\n                        op = { ...operation, type: EntityOpTypes.Add, field: collection };\n                    }\n                    else {\n                        op = { ...operation, type: EntityOpTypes.Remove, field: collection };\n                    }\n                    modelOps.push(op);\n                }\n                for (const operation of collectionChanges[collection].otherChange.operations) {\n                    let op;\n                    if (operation.type === CollectionOpTypes.Add) {\n                        op = { ...operation, type: EntityOpTypes.Add, field: collection };\n                    }\n                    else {\n                        op = { ...operation, type: EntityOpTypes.Remove, field: collection };\n                    }\n                    otherOps.push(op);\n                }\n            }\n            return { modelChange: { changeType: ChangeType.Operations, operations: modelOps },\n                otherChange: { changeType: ChangeType.Operations, operations: otherOps } };\n        }\n        else {\n            // need to map this.model to get the data out.\n            const change = { changeType: ChangeType.Model, modelPostChange: this.getData() };\n            return { modelChange: change, otherChange: change };\n        }\n    }\n    applyOperation(op) {\n        if (op.type === EntityOpTypes.Set || op.type === EntityOpTypes.Clear) {\n            if (!this.model.singletons[op.field]) {\n                if (this.model.collections[op.field]) {\n                    throw new Error(`Can't apply ${op.type === EntityOpTypes.Set ? 'Set' : 'Clear'} operation to collection field ${op.field}`);\n                }\n                throw new Error(`Invalid field: ${op.field} does not exist`);\n            }\n        }\n        else {\n            if (!this.model.collections[op.field]) {\n                if (this.model.singletons[op.field]) {\n                    throw new Error(`Can't apply ${op.type === EntityOpTypes.Add ? 'Add' : 'Remove'} operation to singleton field ${op.field}`);\n                }\n                throw new Error(`Invalid field: ${op.field} does not exist`);\n            }\n        }\n        const apply = () => {\n            switch (op.type) {\n                case EntityOpTypes.Set:\n                    return this.model.singletons[op.field].applyOperation({ ...op, type: SingletonOpTypes.Set });\n                case EntityOpTypes.Clear:\n                    return this.model.singletons[op.field].applyOperation({ ...op, type: SingletonOpTypes.Clear });\n                case EntityOpTypes.Add:\n                    return this.model.collections[op.field].applyOperation({ ...op, type: CollectionOpTypes.Add });\n                case EntityOpTypes.Remove:\n                    return this.model.collections[op.field].applyOperation({ ...op, type: CollectionOpTypes.Remove });\n                default:\n                    throw new Error(`Unexpected op ${op} for Entity CRDT`);\n            }\n        };\n        if (apply()) {\n            for (const versionKey of Object.keys(op.clock)) {\n                this.model.version[versionKey] = Math.max(this.model.version[versionKey] || 0, op.clock[versionKey]);\n            }\n            return true;\n        }\n        return false;\n    }\n    getData() {\n        const singletons = {};\n        const collections = {};\n        Object.keys(this.model.singletons).forEach(singleton => {\n            singletons[singleton] = this.model.singletons[singleton].getData();\n        });\n        Object.keys(this.model.collections).forEach(collection => {\n            collections[collection] = this.model.collections[collection].getData();\n        });\n        return { singletons, collections, version: this.model.version };\n    }\n    getParticleView() {\n        const result = { singletons: {}, collections: {} };\n        for (const key of Object.keys(this.model.singletons)) {\n            result.singletons[key] = this.model.singletons[key].getParticleView();\n        }\n        for (const key of Object.keys(this.model.collections)) {\n            result.collections[key] = this.model.collections[key].getParticleView();\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=crdt-entity.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { compareStrings } from '../recipe/comparable.js';\nimport { assert } from '../../platform/assert-web.js';\n/**\n * This is a temporary interface used to unify old-style stores (storage/StorageProviderBase) and new-style stores (storageNG/Store).\n * We should be able to remove this once we've switched across to the NG stack.\n *\n * Note that for old-style stores, StorageStubs are used *sometimes* to represent storage which isn't activated. For new-style stores,\n * Store itself represents an inactive store, and needs to be activated using activate(). This will present some integration\n * challenges :)\n *\n * Note also that old-style stores use strings for Storage Keys, while NG storage uses storageNG/StorageKey subclasses. This provides\n * a simple test for determining whether a store is old or new.\n *\n * Common functionality between old- and new-style stores goes in this class.\n * Once the old-style stores are deleted, this class can be merged into the new\n * Store class.\n */\nexport class UnifiedStore {\n    constructor(storeInfo) {\n        this.storeInfo = storeInfo;\n    }\n    // Series of StoreInfo getters to make migration easier.\n    get id() { return this.storeInfo.id; }\n    get apiChannelMappingId() { return this.id; }\n    get name() { return this.storeInfo.name; }\n    get type() { return this.storeInfo.type; }\n    get originalId() { return this.storeInfo.originalId; }\n    get source() { return this.storeInfo.source; }\n    get description() { return this.storeInfo.description; }\n    get claims() { return this.storeInfo.claims; }\n    /**\n     * Hack to cast this UnifiedStore to the old-style class StorageStub.\n     * TODO: Fix all usages of this method to handle new-style stores, and then\n     * delete.\n     */\n    castToStorageStub() {\n        // Can't use instanceof; causes circular dependencies.\n        assert(this.unifiedStoreType === 'StorageStub', 'Not a StorageStub!');\n        return this;\n    }\n    // TODO: Delete this method when the old-style storage is deleted.\n    reportExceptionInHost(exception) {\n        // This class lives in the host, so it's safe to just rethrow the exception.\n        throw exception;\n    }\n    _compareTo(other) {\n        let cmp;\n        cmp = compareStrings(this.name, other.name);\n        if (cmp !== 0)\n            return cmp;\n        cmp = compareStrings(this.versionToken, other.versionToken);\n        if (cmp !== 0)\n            return cmp;\n        cmp = compareStrings(this.source, other.source);\n        if (cmp !== 0)\n            return cmp;\n        cmp = compareStrings(this.id, other.id);\n        if (cmp !== 0)\n            return cmp;\n        return 0;\n    }\n    // TODO: Make these tags live inside StoreInfo.\n    toManifestString(opts) {\n        opts = opts || {};\n        const info = { ...this.storeInfo, ...opts.overrides };\n        const results = [];\n        const handleStr = [];\n        handleStr.push(`store`);\n        if (info.name) {\n            handleStr.push(`${info.name}`);\n        }\n        handleStr.push(`of ${info.type.toString()}`);\n        if (info.id) {\n            handleStr.push(`'${info.id}'`);\n        }\n        if (info.originalId) {\n            handleStr.push(`!!${info.originalId}`);\n        }\n        if (this.versionToken != null) {\n            handleStr.push(`@${this.versionToken}`);\n        }\n        if (opts.handleTags && opts.handleTags.length) {\n            handleStr.push(`${opts.handleTags.map(tag => `#${tag}`).join(' ')}`);\n        }\n        if (info.source) {\n            if (info.origin === 'file') {\n                handleStr.push(`in '${info.source}'`);\n            }\n            else {\n                handleStr.push(`in ${info.source}`);\n                if (info.includeKey) {\n                    handleStr.push(`at '${info.includeKey}'`);\n                }\n            }\n        }\n        else if (this.storageKey) {\n            handleStr.push(`at '${this.storageKey}'`);\n        }\n        // TODO(shans): there's a 'this.source' in StorageProviderBase which is sometimes\n        // serialized here too - could it ever be part of StorageStub?\n        results.push(handleStr.join(' '));\n        if (info.claims && info.claims.length > 0) {\n            results.push(`  claim is ${info.claims.map(claim => claim.tag).join(' and is ')}`);\n        }\n        if (info.description) {\n            results.push(`  description \\`${info.description}\\``);\n        }\n        return results.join('\\n');\n    }\n}\n//# sourceMappingURL=unified-store.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nexport function compareNulls(o1, o2) {\n    if (o1 === o2)\n        return 0;\n    if (o1 === null)\n        return -1;\n    return 1;\n}\nexport function compareStrings(s1, s2) {\n    if (s1 == null || s2 == null)\n        return compareNulls(s1, s2);\n    return s1.localeCompare(s2);\n}\nexport function compareNumbers(n1, n2) {\n    if (n1 == null || n2 == null)\n        return compareNulls(n1, n2);\n    return n1 - n2;\n}\nexport function compareBools(b1, b2) {\n    if (b1 == null || b2 == null)\n        return compareNulls(b1, b2);\n    return Number(b1) - Number(b2);\n}\nexport function compareArrays(a1, a2, compare) {\n    assert(a1 != null);\n    assert(a2 != null);\n    if (a1.length !== a2.length)\n        return compareNumbers(a1.length, a2.length);\n    for (let i = 0; i < a1.length; i++) {\n        let result;\n        if ((result = compare(a1[i], a2[i])) !== 0)\n            return result;\n    }\n    return 0;\n}\nexport function compareObjects(o1, o2, compare) {\n    const keys = Object.keys(o1);\n    let result;\n    if ((result = compareNumbers(keys.length, Object.keys(o2).length)) !== 0)\n        return result;\n    for (const key of keys) {\n        if ((result = compare(o1[key], o2[key])) !== 0)\n            return result;\n    }\n    return 0;\n}\nexport function compareComparables(o1, o2) {\n    if (o1 == null || o2 == null)\n        return compareNulls(o1, o2);\n    return o1._compareTo(o2);\n}\n//# sourceMappingURL=comparable.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { StorageKey } from './storage-key.js';\nexport class ReferenceModeStorageKey extends StorageKey {\n    constructor(backingKey, storageKey) {\n        super('reference-mode');\n        this.backingKey = backingKey;\n        this.storageKey = storageKey;\n    }\n    embedKey(key) {\n        return key.toString().replace(/\\{/g, '{{').replace(/\\}/g, '}}');\n    }\n    static unembedKey(key) {\n        return key.replace(/\\}\\}/g, '}').replace(/\\{\\{/g, '}');\n    }\n    toString() {\n        return `${this.protocol}://{${this.embedKey(this.backingKey)}}{${this.embedKey(this.storageKey)}}`;\n    }\n    childWithComponent(component) {\n        return new ReferenceModeStorageKey(this.backingKey, this.storageKey.childWithComponent(component));\n    }\n    static fromString(key, parse) {\n        const match = key.match(/^reference-mode:\\/\\/{((?:\\}\\}|[^}])+)}{((?:\\}\\}|[^}])+)}$/);\n        if (!match) {\n            throw new Error(`Not a valid ReferenceModeStorageKey: ${key}.`);\n        }\n        const [_, backingKey, storageKey] = match;\n        return new ReferenceModeStorageKey(parse(ReferenceModeStorageKey.unembedKey(backingKey)), parse(ReferenceModeStorageKey.unembedKey(storageKey)));\n    }\n}\n//# sourceMappingURL=reference-mode-storage-key.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class StorageKey {\n    constructor(protocol) {\n        this.protocol = protocol;\n    }\n    subKeyWithComponent(component) {\n        return this.childWithComponent(component);\n    }\n    childKeyForBackingElement(id) {\n        return this.childWithComponent(id);\n    }\n    childKeyForArcInfo() {\n        return this.subKeyWithComponent('arc-info');\n    }\n    childKeyForHandle(id) {\n        return this.subKeyWithComponent(`handle/${id}`);\n    }\n}\n//# sourceMappingURL=storage-key.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { CRDTError, ChangeType } from './crdt.js';\nexport var CountOpTypes;\n(function (CountOpTypes) {\n    CountOpTypes[CountOpTypes[\"Increment\"] = 0] = \"Increment\";\n    CountOpTypes[CountOpTypes[\"MultiIncrement\"] = 1] = \"MultiIncrement\";\n})(CountOpTypes || (CountOpTypes = {}));\nexport class CRDTCount {\n    constructor() {\n        this.model = { values: {}, version: {} };\n    }\n    merge(other) {\n        const otherChanges = [];\n        const thisChanges = [];\n        for (const key of Object.keys(other.values)) {\n            const thisValue = this.model.values[key] || 0;\n            const otherValue = other.values[key] || 0;\n            const thisVersion = this.model.version[key] || 0;\n            const otherVersion = other.version[key] || 0;\n            if (thisValue > otherValue) {\n                if (otherVersion >= thisVersion) {\n                    throw new CRDTError('Divergent versions encountered when merging CRDTCount models');\n                }\n                otherChanges.push({ type: CountOpTypes.MultiIncrement, value: thisValue - otherValue, actor: key,\n                    version: { from: otherVersion, to: thisVersion } });\n            }\n            else if (otherValue > thisValue) {\n                if (thisVersion >= otherVersion) {\n                    throw new CRDTError('Divergent versions encountered when merging CRDTCount models');\n                }\n                thisChanges.push({ type: CountOpTypes.MultiIncrement, value: otherValue - thisValue, actor: key,\n                    version: { from: thisVersion, to: otherVersion } });\n                this.model.values[key] = otherValue;\n                this.model.version[key] = otherVersion;\n            }\n        }\n        for (const key of Object.keys(this.model.values)) {\n            if (other.values[key]) {\n                continue;\n            }\n            if (other.version[key]) {\n                throw new CRDTError(`CRDTCount model has version but no value for key ${key}`);\n            }\n            otherChanges.push({ type: CountOpTypes.MultiIncrement, value: this.model.values[key], actor: key,\n                version: { from: 0, to: this.model.version[key] } });\n        }\n        return { modelChange: { changeType: ChangeType.Operations, operations: thisChanges }, otherChange: { changeType: ChangeType.Operations, operations: otherChanges } };\n    }\n    applyOperation(op) {\n        let value;\n        if (op.version.from !== (this.model.version[op.actor] || 0)) {\n            return false;\n        }\n        if (op.version.to <= op.version.from) {\n            return false;\n        }\n        if (op.type === CountOpTypes.MultiIncrement) {\n            if (op.value < 0) {\n                return false;\n            }\n            value = (this.model.values[op.actor] || 0) + op.value;\n        }\n        else {\n            value = (this.model.values[op.actor] || 0) + 1;\n        }\n        this.model.values[op.actor] = value;\n        this.model.version[op.actor] = op.version.to;\n        return true;\n    }\n    cloneMap(map) {\n        const result = {};\n        Object.keys(map).forEach(key => result[key] = map[key]);\n        return result;\n    }\n    getData() {\n        return { values: this.cloneMap(this.model.values), version: this.cloneMap(this.model.version) };\n    }\n    getParticleView() {\n        return Object.values(this.model.values).reduce((prev, current) => prev + current, 0);\n    }\n}\n//# sourceMappingURL=crdt-count.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { HandleConnectionSpec } from './particle-spec.js';\nimport { assert } from '../platform/assert-web.js';\n/** The different types of trust checks that particles can make. */\nexport var CheckType;\n(function (CheckType) {\n    CheckType[\"HasTag\"] = \"has-tag\";\n    CheckType[\"IsFromHandle\"] = \"is-from-handle\";\n    CheckType[\"IsFromOutput\"] = \"is-from-output\";\n    CheckType[\"IsFromStore\"] = \"is-from-store\";\n})(CheckType || (CheckType = {}));\nexport class Check {\n    constructor(target, expression) {\n        this.target = target;\n        this.expression = expression;\n    }\n    toManifestString() {\n        let targetString;\n        if (this.target instanceof HandleConnectionSpec) {\n            targetString = this.target.name;\n        }\n        else {\n            targetString = `${this.target.name} data`;\n        }\n        return `check ${targetString} ${this.expression.toManifestString()}`;\n    }\n}\n/** A boolean expression inside a trust check. */\nexport class CheckBooleanExpression {\n    constructor(type, children) {\n        this.type = type;\n        this.children = children;\n    }\n    /**\n     * @inheritdoc\n     * @param requireParens Indicates whether to enclose the expression inside parentheses. All nested boolean expressions must have parentheses,\n     *     but a top-level expression doesn't need to.\n     */\n    toManifestString(requireParens = false) {\n        const str = this.children.map(child => child.toManifestString(/* requireParens= */ true)).join(` ${this.type} `);\n        return requireParens ? `(${str})` : str;\n    }\n}\n/** A check condition of the form 'check x is <tag>'. */\nexport class CheckHasTag {\n    constructor(tag, isNot) {\n        this.tag = tag;\n        this.isNot = isNot;\n        this.type = CheckType.HasTag;\n    }\n    static fromASTNode(astNode) {\n        return new CheckHasTag(astNode.tag, astNode.isNot);\n    }\n    toManifestString() {\n        return `is ${this.isNot ? 'not ' : ''}${this.tag}`;\n    }\n}\n/** A check condition of the form 'check x is from handle <handle>'. */\nexport class CheckIsFromHandle {\n    constructor(parentHandle, isNot) {\n        this.parentHandle = parentHandle;\n        this.isNot = isNot;\n        this.type = CheckType.IsFromHandle;\n    }\n    static fromASTNode(astNode, handleConnectionMap) {\n        const parentHandle = handleConnectionMap.get(astNode.parentHandle);\n        if (!parentHandle) {\n            throw new Error(`Unknown \"check is from handle\" handle name: ${astNode.parentHandle}.`);\n        }\n        return new CheckIsFromHandle(parentHandle, astNode.isNot);\n    }\n    toManifestString() {\n        return `is ${this.isNot ? 'not ' : ''}from handle ${this.parentHandle.name}`;\n    }\n}\n/** A check condition of the form 'check x is from output <output>'. */\nexport class CheckIsFromOutput {\n    constructor(output, isNot) {\n        this.output = output;\n        this.isNot = isNot;\n        this.type = CheckType.IsFromOutput;\n    }\n    static fromASTNode(astNode, handleConnectionMap) {\n        const output = handleConnectionMap.get(astNode.output);\n        if (!output) {\n            throw new Error(`Unknown \"check is from output\" output name: ${astNode.output}.`);\n        }\n        return new CheckIsFromOutput(output, astNode.isNot);\n    }\n    toManifestString() {\n        return `is ${this.isNot ? 'not ' : ''}from output ${this.output.name}`;\n    }\n}\n/** A check condition of the form 'check x is from store <store reference>'. */\nexport class CheckIsFromStore {\n    constructor(storeRef, isNot) {\n        this.storeRef = storeRef;\n        this.isNot = isNot;\n        this.type = CheckType.IsFromStore;\n    }\n    static fromASTNode(astNode) {\n        return new CheckIsFromStore({\n            type: astNode.storeRef.type,\n            store: astNode.storeRef.store,\n        }, astNode.isNot);\n    }\n    toManifestString() {\n        let store = this.storeRef.store;\n        if (this.storeRef.type === 'id') {\n            // Put the ID inside single-quotes.\n            store = `'${store}'`;\n        }\n        return `is ${this.isNot ? 'not ' : ''}from store ${store}`;\n    }\n}\n/** Converts the given AST node into a CheckCondition object. */\nfunction createCheckCondition(astNode, handleConnectionMap) {\n    switch (astNode.checkType) {\n        case CheckType.HasTag:\n            return CheckHasTag.fromASTNode(astNode);\n        case CheckType.IsFromHandle:\n            return CheckIsFromHandle.fromASTNode(astNode, handleConnectionMap);\n        case CheckType.IsFromStore:\n            return CheckIsFromStore.fromASTNode(astNode);\n        case CheckType.IsFromOutput:\n            return CheckIsFromOutput.fromASTNode(astNode, handleConnectionMap);\n        default:\n            throw new Error('Unknown check type.');\n    }\n}\n/** Converts the given AST node into a CheckExpression object. */\nfunction createCheckExpression(astNode, handleConnectionMap) {\n    if (astNode.kind === 'particle-trust-check-boolean-expression') {\n        assert(astNode.children.length >= 2, 'Boolean check expressions must have at least two children.');\n        return new CheckBooleanExpression(astNode.operator, astNode.children.map(child => createCheckExpression(child, handleConnectionMap)));\n    }\n    else {\n        return createCheckCondition(astNode, handleConnectionMap);\n    }\n}\n/** Converts the given AST node into a Check object. */\nexport function createCheck(checkTarget, astNode, handleConnectionMap) {\n    const expression = createCheckExpression(astNode.expression, handleConnectionMap);\n    return new Check(checkTarget, expression);\n}\n//# sourceMappingURL=particle-check.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/** The different types of trust claims that particles can make. */\nexport var ClaimType;\n(function (ClaimType) {\n    ClaimType[\"IsTag\"] = \"is-tag\";\n    ClaimType[\"DerivesFrom\"] = \"derives-from\";\n})(ClaimType || (ClaimType = {}));\n/** A list of claims made by a particle on a specific handle. */\nexport class ParticleClaim {\n    constructor(handle, claims) {\n        this.handle = handle;\n        this.claims = claims;\n    }\n    toManifestString() {\n        const manifestStrings = this.claims.map(claim => claim.toManifestString());\n        return `claim ${this.handle.name} ${manifestStrings.join(' and ')}`;\n    }\n}\nexport class ClaimIsTag {\n    constructor(isNot, tag) {\n        this.isNot = isNot;\n        this.tag = tag;\n        this.type = ClaimType.IsTag;\n    }\n    static fromASTNode(astNode) {\n        return new ClaimIsTag(astNode.isNot, astNode.tag);\n    }\n    toManifestString() {\n        return `is ${this.isNot ? 'not ' : ''}${this.tag}`;\n    }\n}\nexport class ClaimDerivesFrom {\n    constructor(parentHandle) {\n        this.parentHandle = parentHandle;\n        this.type = ClaimType.DerivesFrom;\n    }\n    static fromASTNode(astNode, handleConnectionMap) {\n        // Convert handle names into HandleConnectionSpec objects.\n        const parentHandle = handleConnectionMap.get(astNode.parentHandle);\n        if (!parentHandle) {\n            throw new Error(`Unknown \"derives from\" handle name: ${parentHandle}.`);\n        }\n        return new ClaimDerivesFrom(parentHandle);\n    }\n    toManifestString() {\n        return `derives from ${this.parentHandle.name}`;\n    }\n}\nexport function createParticleClaim(handle, astNode, handleConnectionMap) {\n    const claims = astNode.expression.map(claimNode => {\n        switch (claimNode.claimType) {\n            case ClaimType.IsTag:\n                return ClaimIsTag.fromASTNode(claimNode);\n            case ClaimType.DerivesFrom:\n                return ClaimDerivesFrom.fromASTNode(claimNode, handleConnectionMap);\n            default:\n                throw new Error('Unknown claim type.');\n        }\n    });\n    return new ParticleClaim(handle, claims);\n}\n//# sourceMappingURL=particle-claim.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A representation of a consumed slot. Retrieved from a particle using\n * particle.getSlot(name)\n */\nexport class SlotProxy {\n    constructor(apiPort, particle, slotName, providedSlots) {\n        // eslint-disable-next-line func-call-spacing\n        this.handlers = new Map();\n        this.requestedContentTypes = new Set();\n        this._isRendered = false;\n        this.apiPort = apiPort;\n        this.slotName = slotName;\n        this.particle = particle;\n        this.providedSlots = providedSlots;\n    }\n    get isRendered() {\n        return this._isRendered;\n    }\n    /**\n     * renders content to the slot.\n     */\n    render(content) {\n        this.apiPort.Render(this.particle, this.slotName, content);\n        Object.keys(content).forEach(key => { this.requestedContentTypes.delete(key); });\n        // Slot is considered rendered, if a non-empty content was sent and all requested content types were fullfilled.\n        this._isRendered = this.requestedContentTypes.size === 0 && (Object.keys(content).length > 0);\n    }\n    /**\n     * registers a callback to be invoked when 'name' event happens.\n     */\n    registerEventHandler(name, f) {\n        if (!this.handlers.has(name)) {\n            this.handlers.set(name, []);\n        }\n        this.handlers.get(name).push(f);\n    }\n    clearEventHandlers(name) {\n        this.handlers.set(name, []);\n    }\n    fireEvent(event) {\n        for (const handler of this.handlers.get(event.handler) || []) {\n            handler(event);\n        }\n    }\n    /**\n     * Called by PEC to remove all rendering capabilities to this slotProxy from the current\n     * particle and give them to the given particle.\n     */\n    rewire(particle) {\n        this.particle.removeSlotProxy(this.slotName);\n        this.particle = particle;\n        this._isRendered = false;\n        this.particle.addSlotProxy(this);\n        this.particle.renderSlot(this.slotName, ['model', 'template', 'templateName']);\n    }\n}\n//# sourceMappingURL=slot-proxy.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { Entity } from './entity.js';\nimport { Reference } from './reference.js';\nimport { EntityType, CollectionType, ReferenceType } from './type.js';\nimport { Particle } from './particle.js';\nimport { Singleton } from './handle.js';\nimport { UserException } from './arc-exceptions.js';\nimport { BiMap } from './bimap.js';\n// Encoders/decoders for the wire format for transferring entities over the wasm boundary.\n// Note that entities must have an id before serializing for use in a wasm particle.\n//\n//  <singleton> = <id-length>:<id>|<field-name>:<value>|<field-name>:<value>| ... |\n//  <value> depends on the field type:\n//    Text         T<length>:<text>\n//    URL          U<length>:<text>\n//    Number       N<number>:\n//    Boolean      B<zero-or-one>\n//    Reference    R<length>:<id>|<length>:<storage-key>|<type-index>:\n//    Dictionary   D<length>:<dictionary format>\n//    Array        A<length>:<array format>\n//\n//  <collection> = <num-entities>:<length>:<encoded><length>:<encoded> ...\n//\n// The encoder classes also supports two \"Dictionary\" formats of key:value string pairs.\n//\n// The first format supports only string-type values:\n//   <size>:<key-len>:<key><value-len>:<value><key-len>:<key><value-len>:<value>...\n// alternate format supports typed-values using <value> syntax defined above\n//   <size>:<key-len>:<key><value><key-len>:<key><value>...\n//\n// Examples:\n//   Singleton:   4:id05|txt:T3:abc|lnk:U10:http://def|num:N37:|flg:B1|\n//   Collection:  3:29:4:id12|txt:T4:qwer|num:N9.2:|18:6:id2670|num:N-7:|15:5:id501|flg:B0|\nexport class StringEncoder {\n    constructor(schema, typeMap) {\n        this.schema = schema;\n        this.typeMap = typeMap;\n    }\n    static create(type, typeMap) {\n        if (type instanceof CollectionType) {\n            type = type.getContainedType();\n        }\n        if (type instanceof EntityType) {\n            return new EntityEncoder(type.getEntitySchema(), typeMap);\n        }\n        if (type instanceof ReferenceType) {\n            return new ReferenceEncoder(type.getEntitySchema(), typeMap);\n        }\n        throw new Error(`Unsupported type for StringEncoder: ${type}`);\n    }\n    encodeCollection(entities) {\n        let encoded = entities.length + ':';\n        for (const entity of entities) {\n            encoded += StringEncoder.encodeStr(this.encodeSingleton(entity));\n        }\n        return encoded;\n    }\n    static encodeDictionary(dict) {\n        const entries = Object.entries(dict);\n        let encoded = entries.length + ':';\n        for (const [key, value] of entries) {\n            encoded += StringEncoder.encodeStr(key) + StringEncoder.encodeStr(value);\n        }\n        return encoded;\n    }\n    encodeField(field, name, value) {\n        switch (field.kind) {\n            case 'schema-primitive':\n                return name + ':' + field.type.substr(0, 1) + this.encodeValue(field.type, value) + '|';\n            case 'schema-reference':\n                return name + ':R' + this.encodeReference(value) + '|';\n            case 'schema-collection':\n            case 'schema-union':\n            case 'schema-tuple':\n                throw new Error(`'${field.kind}' not yet supported for entity packaging`);\n            default:\n                throw new Error(`Unknown field kind '${field.kind}' in schema`);\n        }\n    }\n    encodeReference(ref) {\n        const entityType = ref.type.referredType;\n        assert(entityType instanceof EntityType);\n        let index = this.typeMap.getR(entityType);\n        if (!index) {\n            index = this.typeMap.size + 1; // avoid index 0\n            this.typeMap.set(index, entityType);\n        }\n        const { id, storageKey } = ref.dataClone();\n        return StringEncoder.encodeStr(id) + '|' + StringEncoder.encodeStr(storageKey) + '|' + index + ':';\n    }\n    encodeValue(type, value) {\n        switch (type) {\n            case 'Text':\n            case 'URL':\n                return StringEncoder.encodeStr(value);\n            case 'Number':\n                return value + ':';\n            case 'Boolean':\n                return (value ? '1' : '0');\n            case 'Bytes':\n            case 'Object':\n                throw new Error(`'${type}' not yet supported for entity packaging`);\n            default:\n                throw new Error(`Unknown primitive value type '${type}' in schema`);\n        }\n    }\n    static encodeStr(str) {\n        if (!str) {\n            return '0:';\n        }\n        return str.length + ':' + str;\n    }\n}\nclass EntityEncoder extends StringEncoder {\n    encodeSingleton(entity) {\n        if (!(entity instanceof Entity)) {\n            throw new Error(`non-Entity passed to EntityEncoder: ${entity}`);\n        }\n        const id = Entity.id(entity);\n        let encoded = StringEncoder.encodeStr(id) + '|';\n        for (const [name, value] of Object.entries(entity)) {\n            encoded += this.encodeField(this.schema.fields[name], name, value);\n        }\n        return encoded;\n    }\n}\nclass ReferenceEncoder extends StringEncoder {\n    encodeSingleton(ref) {\n        if (!(ref instanceof Reference)) {\n            throw new Error(`non-Reference passed to EntityEncoder: ${ref}`);\n        }\n        return this.encodeReference(ref) + '|';\n    }\n}\nexport class StringDecoder {\n    constructor(schema, typeMap, pec) {\n        this.schema = schema;\n        this.typeMap = typeMap;\n        this.pec = pec;\n    }\n    static create(type, typeMap, pec) {\n        if (type instanceof CollectionType) {\n            type = type.getContainedType();\n        }\n        if (type instanceof EntityType) {\n            return new EntityDecoder(type.getEntitySchema(), typeMap, pec);\n        }\n        if (type instanceof ReferenceType) {\n            return new ReferenceDecoder(type.getEntitySchema(), typeMap, pec);\n        }\n        throw new Error(`Unsupported type for StringDecoder: ${type}`);\n    }\n    static decodeDictionary(str) {\n        const decoder = new EntityDecoder(null, null, null);\n        decoder.str = str;\n        const dict = {};\n        let num = Number(decoder.upTo(':'));\n        while (num--) {\n            const klen = Number(decoder.upTo(':'));\n            const key = decoder.chomp(klen);\n            // TODO(sjmiles): be backward compatible with encoders that only encode string values\n            const typeChar = decoder.chomp(1);\n            // if typeChar is a digit, it's part of a length specifier\n            if (typeChar >= '0' && typeChar <= '9') {\n                const vlen = Number(`${typeChar}${decoder.upTo(':')}`);\n                dict[key] = decoder.chomp(vlen);\n            }\n            else {\n                // otherwise typeChar is value-type specifier\n                dict[key] = decoder.decodeValue(typeChar);\n            }\n        }\n        return dict;\n    }\n    // TODO: make work in the new world.\n    static decodeArray(str) {\n        const decoder = new EntityDecoder(null, null, null);\n        decoder.str = str;\n        const arr = [];\n        let num = Number(decoder.upTo(':'));\n        while (num--) {\n            // TODO(sjmiles): be backward compatible with encoders that only encode string values\n            const typeChar = decoder.chomp(1);\n            // if typeChar is a digit, it's part of a length specifier\n            if (typeChar >= '0' && typeChar <= '9') {\n                const len = Number(`${typeChar}${decoder.upTo(':')}`);\n                arr.push(decoder.chomp(len));\n            }\n            // otherwise typeChar is value-type specifier\n            else {\n                arr.push(decoder.decodeValue(typeChar));\n            }\n        }\n        return arr;\n    }\n    upTo(char) {\n        const i = this.str.indexOf(char);\n        if (i < 0) {\n            throw new Error(`Packaged entity decoding fail: expected '${char}' separator in '${this.str}'`);\n        }\n        const token = this.str.slice(0, i);\n        this.str = this.str.slice(i + 1);\n        return token;\n    }\n    chomp(len) {\n        if (len > this.str.length) {\n            throw new Error(`Packaged entity decoding fail: expected '${len}' chars to remain in '${this.str}'`);\n        }\n        const token = this.str.slice(0, len);\n        this.str = this.str.slice(len);\n        return token;\n    }\n    validate(token) {\n        if (this.chomp(token.length) !== token) {\n            throw new Error(`Packaged entity decoding fail: expected '${token}' at start of '${this.str}'`);\n        }\n    }\n    decodeValue(typeChar) {\n        switch (typeChar) {\n            case 'T':\n            case 'U': {\n                const len = Number(this.upTo(':'));\n                return this.chomp(len);\n            }\n            case 'N':\n                return Number(this.upTo(':'));\n            case 'B':\n                return Boolean(this.chomp(1) === '1');\n            case 'R':\n                return this.decodeReference();\n            case 'D': {\n                const len = Number(this.upTo(':'));\n                const dictionary = this.chomp(len);\n                return StringDecoder.decodeDictionary(dictionary);\n            }\n            case 'A': {\n                const len = Number(this.upTo(':'));\n                const array = this.chomp(len);\n                return StringDecoder.decodeArray(array);\n            }\n            default:\n                throw new Error(`Packaged entity decoding fail: unknown or unsupported primitive value type '${typeChar}'`);\n        }\n    }\n    decodeReference() {\n        const ilen = Number(this.upTo(':'));\n        const id = this.chomp(ilen);\n        this.validate('|');\n        const klen = Number(this.upTo(':'));\n        const storageKey = this.chomp(klen);\n        this.validate('|');\n        const typeIndex = Number(this.upTo(':'));\n        const entityType = this.typeMap.getL(typeIndex);\n        if (!entityType) {\n            throw new Error(`Packaged entity decoding fail: invalid type index ${typeIndex} for reference '${id}|${storageKey}'`);\n        }\n        return new Reference({ id, storageKey }, new ReferenceType(entityType), this.pec);\n    }\n}\nclass EntityDecoder extends StringDecoder {\n    decodeSingleton(str) {\n        this.str = str;\n        const len = Number(this.upTo(':'));\n        const id = this.chomp(len);\n        this.validate('|');\n        const data = {};\n        while (this.str.length > 0) {\n            const name = this.upTo(':');\n            const typeChar = this.chomp(1);\n            data[name] = this.decodeValue(typeChar);\n            this.validate('|');\n        }\n        const entity = new (this.schema.entityClass())(data);\n        if (id !== '') {\n            Entity.identify(entity, id);\n        }\n        return entity;\n    }\n}\nclass ReferenceDecoder extends StringDecoder {\n    decodeSingleton(str) {\n        return this.decodeReference();\n    }\n}\nclass EmscriptenWasmDriver {\n    constructor(customSection) {\n        // Records file and line for console logging in C++. This is set by the console/error macros in\n        // arcs.h and used immediately in the following printf call (implemented by sysWritev() below).\n        this.logInfo = null;\n        // Wasm modules built by emscripten require some external memory configuration by the caller,\n        // which is usually built into the glue code generated alongside the module. We're not using\n        // the glue code, but if we set the EMIT_EMSCRIPTEN_METADATA flag when building, emscripten\n        // will provide a custom section in the module itself with the required values.\n        const METADATA_SIZE = 11;\n        const METADATA_MAJOR = 0;\n        const METADATA_MINOR = 2;\n        const ABI_MAJOR = 0;\n        const ABI_MINOR = 4;\n        // The logic for reading metadata values here was copied from the emscripten source.\n        const buffer = new Uint8Array(customSection);\n        const metadata = [];\n        let offset = 0;\n        while (offset < buffer.byteLength) {\n            let result = 0;\n            let shift = 0;\n            while (1) {\n                const byte = buffer[offset++];\n                result |= (byte & 0x7f) << shift;\n                if (!(byte & 0x80)) {\n                    break;\n                }\n                shift += 7;\n            }\n            metadata.push(result);\n        }\n        // The specifics of the section are not published anywhere official (yet). The values here\n        // correspond to emscripten version 1.38.42:\n        //   https://github.com/emscripten-core/emscripten/blob/1.38.42/tools/shared.py#L3051\n        if (metadata.length < 4) {\n            throw new Error(`emscripten metadata section should have at least 4 values; ` +\n                `got ${metadata.length}`);\n        }\n        if (metadata[0] !== METADATA_MAJOR || metadata[1] !== METADATA_MINOR) {\n            throw new Error(`emscripten metadata version should be ${METADATA_MAJOR}.${METADATA_MINOR}; ` +\n                `got ${metadata[0]}.${metadata[1]}`);\n        }\n        if (metadata[2] !== ABI_MAJOR || metadata[3] !== ABI_MINOR) {\n            throw new Error(`emscripten ABI version should be ${ABI_MAJOR}.${ABI_MINOR}; ` +\n                `got ${metadata[2]}.${metadata[3]}`);\n        }\n        if (metadata.length !== METADATA_SIZE) {\n            throw new Error(`emscripten metadata section should have ${METADATA_SIZE} values; ` +\n                `got ${metadata.length}`);\n        }\n        // metadata[4] is 'Settings.WASM_BACKEND'; whether the binary is from wasm backend or fastcomp.\n        // metadata[10] is 'tempdoublePtr'; appears to be related to pthreads and is not used here.\n        this.cfg = {\n            memSize: metadata[5],\n            tableSize: metadata[6],\n            globalBase: metadata[7],\n            dynamicBase: metadata[8],\n            dynamictopPtr: metadata[9],\n        };\n    }\n    configureEnvironment(module, container, env) {\n        container.memory = new WebAssembly.Memory({ initial: this.cfg.memSize, maximum: this.cfg.memSize });\n        container.heapU8 = new Uint8Array(container.memory.buffer);\n        container.heap32 = new Int32Array(container.memory.buffer);\n        // We need to poke the address of the heap base into the memory buffer prior to instantiating.\n        container.heap32[this.cfg.dynamictopPtr >> 2] = this.cfg.dynamicBase;\n        Object.assign(env, {\n            // Memory setup\n            memory: container.memory,\n            __memory_base: this.cfg.globalBase,\n            table: new WebAssembly.Table({ initial: this.cfg.tableSize, maximum: this.cfg.tableSize, element: 'anyfunc' }),\n            __table_base: 0,\n            DYNAMICTOP_PTR: this.cfg.dynamictopPtr,\n            // Heap management\n            _emscripten_get_heap_size: () => container.heapU8.length,\n            _emscripten_resize_heap: (size) => false,\n            _emscripten_memcpy_big: (dst, src, num) => container.heapU8.set(container.heapU8.subarray(src, src + num), dst),\n            // Error handling\n            _systemError: (msg) => { throw new Error(container.read(msg)); },\n            abortOnCannotGrowMemory: (size) => { throw new Error(`abortOnCannotGrowMemory(${size})`); },\n            // Logging\n            _setLogInfo: (file, line) => this.logInfo = [container.read(file).split(/[/\\\\]/).pop(), line],\n            ___syscall146: (which, varargs) => this.sysWritev(container, which, varargs),\n        });\n    }\n    initializeInstance(container, instance) {\n        // Emscripten doesn't need main() invoked\n    }\n    // C++ printf support cribbed from emscripten glue js - currently only supports ASCII\n    sysWritev(container, which, varargs) {\n        const get = () => {\n            varargs += 4;\n            return container.heap32[(((varargs) - (4)) >> 2)];\n        };\n        const output = (get() === 1) ? console.log : console.error;\n        const iov = get();\n        const iovcnt = get();\n        // TODO: does this need to be persistent across calls? (i.e. due to write buffering)\n        let str = this.logInfo ? `[${this.logInfo[0]}:${this.logInfo[1]}] ` : '';\n        let ret = 0;\n        for (let i = 0; i < iovcnt; i++) {\n            const ptr = container.heap32[(((iov) + (i * 8)) >> 2)];\n            const len = container.heap32[(((iov) + (i * 8 + 4)) >> 2)];\n            for (let j = 0; j < len; j++) {\n                const curr = container.heapU8[ptr + j];\n                if (curr === 0 || curr === 10) { // NUL or \\n\n                    output(str);\n                    str = '';\n                }\n                else {\n                    str += String.fromCharCode(curr);\n                }\n            }\n            ret += len;\n        }\n        this.logInfo = null;\n        return ret;\n    }\n}\nclass KotlinWasmDriver {\n    configureEnvironment(module, container, env) {\n        Object.assign(env, {\n            // These two are used by launcher.cpp\n            Konan_js_arg_size: (index) => 1,\n            Konan_js_fetch_arg: (index, ptr) => 'dummyArg',\n            // These two are imported, but never used\n            Konan_js_allocateArena: (array) => { },\n            Konan_js_freeArena: (arenaIndex) => { },\n            // These two are used by logging functions\n            write: (ptr) => console.log(container.read(ptr)),\n            flush: () => { },\n            // Apparently used by Kotlin Memory management\n            Konan_notify_memory_grow: () => this.updateMemoryViews(container),\n            // Kotlin's own glue for abort and exit\n            Konan_abort: (pointer) => { throw new Error('Konan_abort(' + container.read(pointer) + ')'); },\n            Konan_exit: (status) => { },\n            // Needed by some code that tries to get the current time in it's runtime\n            Konan_date_now: (pointer) => {\n                const now = Date.now();\n                const high = Math.floor(now / 0xffffffff);\n                const low = Math.floor(now % 0xffffffff);\n                container.heap32[pointer] = low;\n                container.heap32[pointer + 1] = high;\n            },\n        });\n    }\n    // Kotlin manages its own heap construction, as well as tables.\n    initializeInstance(container, instance) {\n        this.updateMemoryViews(container);\n        // Kotlin main() must be invoked before everything else.\n        // TODO(alxrsngtn): Work out how to give Konan_js_main a type signature.\n        instance.exports.Konan_js_main(1, 0);\n    }\n    updateMemoryViews(container) {\n        container.memory = container.exports.memory;\n        container.heapU8 = new Uint8Array(container.memory.buffer);\n        container.heap32 = new Int32Array(container.memory.buffer);\n    }\n}\n// Holds an instance of a running wasm module, which may contain multiple particles.\nexport class WasmContainer {\n    constructor(pec, loader, apiPort) {\n        this.particleMap = new Map();\n        this.pec = pec;\n        this.loader = loader;\n        this.apiPort = apiPort;\n    }\n    async initialize(buffer) {\n        // TODO: vet the imports/exports on 'module'\n        // TODO: use compileStreaming? requires passing the fetch() Response, not its ArrayBuffer\n        const module = await WebAssembly.compile(buffer);\n        const driver = this.driverForModule(module);\n        // Shared ENV between Emscripten and Kotlin\n        const env = {\n            abort: () => { throw new Error('Abort!'); },\n            // Inner particle API\n            // TODO: guard against null/empty args from the wasm side\n            _singletonSet: (p, h, entity) => this.getParticle(p).singletonSet(h, entity),\n            _singletonClear: (p, h) => this.getParticle(p).singletonClear(h),\n            _collectionStore: (p, h, entity) => this.getParticle(p).collectionStore(h, entity),\n            _collectionRemove: (p, h, entity) => this.getParticle(p).collectionRemove(h, entity),\n            _collectionClear: (p, h) => this.getParticle(p).collectionClear(h),\n            _onRenderOutput: (p, template, model) => this.getParticle(p).onRenderOutput(template, model),\n            _dereference: (p, id, key, typeIndex, cid) => this.getParticle(p).dereference(id, key, typeIndex, cid),\n            _render: (p, slot, template, model) => this.getParticle(p).renderImpl(slot, template, model),\n            _serviceRequest: (p, call, args, tag) => this.getParticle(p).serviceRequest(call, args, tag),\n            _resolveUrl: (url) => this.resolve(url),\n        };\n        driver.configureEnvironment(module, this, env);\n        const global = { 'NaN': NaN, 'Infinity': Infinity };\n        this.wasm = await WebAssembly.instantiate(module, { env, global });\n        this.exports = this.wasm.exports;\n        driver.initializeInstance(this, this.wasm);\n    }\n    driverForModule(module) {\n        const customSections = WebAssembly.Module.customSections(module, 'emscripten_metadata');\n        if (customSections.length === 1) {\n            return new EmscriptenWasmDriver(customSections[0]);\n        }\n        return new KotlinWasmDriver();\n    }\n    getParticle(innerParticle) {\n        return this.particleMap.get(innerParticle);\n    }\n    register(particle, innerParticle) {\n        this.particleMap.set(innerParticle, particle);\n    }\n    // Allocates memory in the wasm container; the calling particle is responsible for freeing.\n    resolve(urlPtr) {\n        return this.store(this.loader.resolve(this.read(urlPtr)));\n    }\n    // Allocates memory in the wasm container.\n    store(str) {\n        const p = this.exports._malloc(str.length + 1);\n        for (let i = 0; i < str.length; i++) {\n            this.heapU8[p + i] = str.charCodeAt(i);\n        }\n        this.heapU8[p + str.length] = 0;\n        return p;\n    }\n    // Convenience function for freeing one or more wasm memory allocations. Null pointers are ignored.\n    free(...ptrs) {\n        ptrs.forEach(p => p && this.exports._free(p));\n    }\n    // Currently only supports ASCII. TODO: unicode\n    read(idx) {\n        let str = '';\n        while (idx < this.heapU8.length && this.heapU8[idx] !== 0) {\n            str += String.fromCharCode(this.heapU8[idx++]);\n        }\n        return str;\n    }\n}\n// Creates and interfaces to a particle inside a WasmContainer's module.\nexport class WasmParticle extends Particle {\n    constructor(id, container) {\n        super();\n        this.handleMap = new BiMap();\n        this.encoders = new Map();\n        this.decoders = new Map();\n        // Map of type indexes given to wasm code to the EntityTypes used by Reference values.\n        this.typeMap = new BiMap();\n        this.id = id;\n        this.container = container;\n        this.exports = container.exports;\n        const fn = `_new${this.spec.name}`;\n        if (!(fn in this.exports)) {\n            throw new Error(`wasm module does not export instantiator function '${fn}' for particle '${this.spec.name}'`);\n        }\n        this.innerParticle = this.exports[fn]();\n        this.container.register(this, this.innerParticle);\n        // TODO(sjmiles): probably too soon: we need to render at least once, but we may have handle\n        // work pending. @shans says: if the particle has readable handles, onHandleUpdate is guaranteed\n        // to be called, otherwise we need `renderOutput` manually. Need to optimize this across all\n        // particle bases.\n        setTimeout(() => this.renderOutput(), 100);\n    }\n    renderOutput() {\n        // TODO(sjmiles): not yet implemented in CPP\n        if (this.exports['_renderOutput']) {\n            this.exports._renderOutput(this.innerParticle);\n        }\n    }\n    // TODO: for now we set up Handle objects with onDefineHandle and map them into the\n    // wasm container through this call, which creates corresponding Handle objects in there.\n    // That means entity transfer goes from the StorageProxy, deserializes at the outer Handle\n    // which then notifies this class (calling onHandle*), and we then serialize into the wasm\n    // transfer format. Obviously this can be improved.\n    async setHandles(handles) {\n        for (const [name, handle] of handles) {\n            const p = this.container.store(name);\n            const wasmHandle = this.exports._connectHandle(this.innerParticle, p, handle.canRead, handle.canWrite);\n            this.container.free(p);\n            if (wasmHandle === 0) {\n                throw new Error(`Wasm particle failed to connect handle '${name}'`);\n            }\n            this.handleMap.set(handle, wasmHandle);\n        }\n        this.exports._init(this.innerParticle);\n    }\n    async onHandleSync(handle, model) {\n        const wasmHandle = this.handleMap.getL(handle);\n        if (!model) {\n            this.exports._syncHandle(this.innerParticle, wasmHandle, 0);\n            return;\n        }\n        const encoder = this.getEncoder(handle.type);\n        let p;\n        if (handle instanceof Singleton) {\n            p = this.container.store(encoder.encodeSingleton(model));\n        }\n        else {\n            p = this.container.store(encoder.encodeCollection(model));\n        }\n        this.exports._syncHandle(this.innerParticle, wasmHandle, p);\n        this.container.free(p);\n    }\n    // tslint:disable-next-line: no-any\n    async onHandleUpdate(handle, update) {\n        if (update.originator) {\n            return;\n        }\n        const wasmHandle = this.handleMap.getL(handle);\n        const encoder = this.getEncoder(handle.type);\n        let p1 = 0;\n        let p2 = 0;\n        if (handle instanceof Singleton) {\n            if (update.data) {\n                p1 = this.container.store(encoder.encodeSingleton(update.data));\n            }\n        }\n        else {\n            p1 = this.container.store(encoder.encodeCollection(update.added || []));\n            p2 = this.container.store(encoder.encodeCollection(update.removed || []));\n        }\n        this.exports._updateHandle(this.innerParticle, wasmHandle, p1, p2);\n        this.container.free(p1, p2);\n    }\n    // Ignored for wasm particles.\n    async onHandleDesync(handle) { }\n    // Store API.\n    //\n    // Each of these calls an async storage method, but we don't want to await them because returning\n    // a Promise to wasm doesn't work, and control (surprisingly) returns to the calling wasm function\n    // at the first await point anyway. However, our CRDTs make it safe to fire-and-forget the storage\n    // updates, and the wasm handles already have the updated version of the stored data, so it's safe\n    // to leave the promises floating.\n    // If the given entity doesn't have an id, this will create one for it and return the new id\n    // in allocated memory that the wasm particle must free. If the entity already has an id this\n    // returns 0 (nulltpr).\n    singletonSet(wasmHandle, entityPtr) {\n        const singleton = this.getHandle(wasmHandle);\n        const decoder = this.getDecoder(singleton.type);\n        const entity = decoder.decodeSingleton(this.container.read(entityPtr));\n        const p = this.ensureIdentified(entity, singleton);\n        void singleton.set(entity);\n        return p;\n    }\n    singletonClear(wasmHandle) {\n        const singleton = this.getHandle(wasmHandle);\n        void singleton.clear();\n    }\n    // If the given entity doesn't have an id, this will create one for it and return the new id\n    // in allocated memory that the wasm particle must free. If the entity already has an id this\n    // returns 0 (nulltpr).\n    collectionStore(wasmHandle, entityPtr) {\n        const collection = this.getHandle(wasmHandle);\n        const decoder = this.getDecoder(collection.type);\n        const entity = decoder.decodeSingleton(this.container.read(entityPtr));\n        const p = this.ensureIdentified(entity, collection);\n        void collection.store(entity);\n        return p;\n    }\n    collectionRemove(wasmHandle, entityPtr) {\n        const collection = this.getHandle(wasmHandle);\n        const decoder = this.getDecoder(collection.type);\n        const entity = decoder.decodeSingleton(this.container.read(entityPtr));\n        void collection.remove(entity);\n    }\n    collectionClear(wasmHandle) {\n        const collection = this.getHandle(wasmHandle);\n        void collection.clear();\n    }\n    // Retrieves the entity held by a reference.\n    async dereference(idPtr, keyPtr, typeIndex, continuationId) {\n        const id = this.container.read(idPtr);\n        const storageKey = this.container.read(keyPtr);\n        const entityType = this.typeMap.getL(typeIndex);\n        const encoder = this.getEncoder(entityType);\n        const entity = await Reference.retrieve(this.container.pec, id, storageKey, entityType);\n        const p = this.container.store(encoder.encodeSingleton(entity));\n        this.exports._dereferenceResponse(this.innerParticle, continuationId, p);\n        this.container.free(p);\n    }\n    getEncoder(type) {\n        let encoder = this.encoders.get(type);\n        if (!encoder) {\n            encoder = StringEncoder.create(type, this.typeMap);\n            this.encoders.set(type, encoder);\n        }\n        return encoder;\n    }\n    getDecoder(type) {\n        let decoder = this.decoders.get(type);\n        if (!decoder) {\n            decoder = StringDecoder.create(type, this.typeMap, this.container.pec);\n            this.decoders.set(type, decoder);\n        }\n        return decoder;\n    }\n    getHandle(wasmHandle) {\n        const handle = this.handleMap.getR(wasmHandle);\n        if (!handle) {\n            const err = new Error(`wasm particle '${this.spec.name}' attempted to write to unconnected handle`);\n            const userException = new UserException(err, 'WasmParticle::getHandle', this.id, this.spec.name);\n            this.container.apiPort.ReportExceptionInHost(userException);\n            throw err;\n        }\n        return handle;\n    }\n    ensureIdentified(entity, handle) {\n        let p = 0;\n        // TODO: rework Reference/Entity internals to avoid this instance check?\n        if (entity instanceof Entity && !Entity.isIdentified(entity)) {\n            handle.createIdentityFor(entity);\n            p = this.container.store(Entity.id(entity));\n        }\n        return p;\n    }\n    // TODO(sjmiles): UiBroker changes ... we don't have `capabilities` yet,\n    // so just go straight to output\n    output(content) {\n        this.container.apiPort.Output(this, content);\n    }\n    // render request call-back from wasm\n    onRenderOutput(templatePtr, modelPtr) {\n        const content = { templateName: 'default' };\n        content.template = this.container.read(templatePtr);\n        content.model = StringDecoder.decodeDictionary(this.container.read(modelPtr));\n        this.output(content);\n    }\n    /**\n     * @deprecated for contexts using UiBroker (e.g Kotlin)\n     */\n    // Called by the shell to initiate rendering; the particle will call env._render in response.\n    renderSlot(slotName, contentTypes) {\n        const p = this.container.store(slotName);\n        const sendTemplate = contentTypes.includes('template');\n        const sendModel = contentTypes.includes('model');\n        this.exports._renderSlot(this.innerParticle, p, sendTemplate, sendModel);\n        this.container.free(p);\n    }\n    /**\n     * @deprecated for systems using UiBroker (e.g Kotlin)\n     */\n    // TODO\n    renderHostedSlot(slotName, hostedSlotId, content) {\n        throw new Error('renderHostedSlot not implemented for wasm particles');\n    }\n    /**\n     * @deprecated for systems using UiBroker (e.g Kotlin)\n     */\n    // Actually renders the slot. May be invoked due to an external request via renderSlot(),\n    // or directly from the wasm particle itself (e.g. in response to a data update).\n    // template is a string provided by the particle. model is an encoded Dictionary.\n    renderImpl(slotNamePtr, templatePtr, modelPtr) {\n        const slot = this.slotProxiesByName.get(this.container.read(slotNamePtr));\n        if (slot) {\n            const content = { templateName: 'default' };\n            if (templatePtr) {\n                content.template = this.container.read(templatePtr);\n                slot.requestedContentTypes.add('template');\n            }\n            if (modelPtr) {\n                content.model = StringDecoder.decodeDictionary(this.container.read(modelPtr));\n                slot.requestedContentTypes.add('model');\n            }\n            slot.render(content);\n        }\n    }\n    // Wasm particles can request service calls with a Dictionary of arguments and an optional string\n    // tag to disambiguate different requests to the same service call.\n    async serviceRequest(callPtr, argsPtr, tagPtr) {\n        const call = this.container.read(callPtr);\n        const args = StringDecoder.decodeDictionary(this.container.read(argsPtr));\n        const tag = this.container.read(tagPtr);\n        // tslint:disable-next-line: no-any\n        const response = await this.service({ call, ...args });\n        // Convert the arbitrary response object to key:value string pairs.\n        const dict = {};\n        if (typeof response === 'object') {\n            for (const entry of Object.entries(response)) {\n                // tslint:disable-next-line: no-any\n                const [key, value] = entry;\n                dict[key] = (typeof value === 'object') ? JSON.stringify(value) : (value + '');\n            }\n        }\n        else {\n            // Convert a plain value response to {value: 'string'}\n            dict['value'] = response + '';\n        }\n        // We can't re-use the string pointers passed in as args to this method, because the await\n        // point above means the call to internal::serviceRequest inside the wasm module will already\n        // have completed, and the memory for those args will have been freed.\n        const cp = this.container.store(call);\n        const rp = this.container.store(StringEncoder.encodeDictionary(dict));\n        const tp = this.container.store(tag);\n        this.exports._serviceResponse(this.innerParticle, cp, rp, tp);\n        this.container.free(cp, rp, tp);\n    }\n    fireEvent(slotName, event) {\n        const sp = this.container.store(slotName);\n        const hp = this.container.store(event.handler);\n        const data = this.container.store(StringEncoder.encodeDictionary(event.data || {}));\n        this.exports._fireEvent(this.innerParticle, sp, hp, data);\n        this.container.free(sp, hp, data);\n    }\n}\n//# sourceMappingURL=wasm.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { BigCollection } from './handle.js';\nimport { Collection } from './handle.js';\nimport { Entity } from './entity.js';\n/**\n * A basic particle. For particles that provide UI, you may like to\n * instead use DOMParticle.\n */\nexport class Particle {\n    constructor() {\n        this.relevances = [];\n        this._idle = Promise.resolve();\n        this._busy = 0;\n        this.slotProxiesByName = new Map();\n        // Typescript only sees this.constructor as a Function type.\n        // TODO(shans): move spec off the constructor\n        this.spec = this.constructor['spec'];\n        if (this.spec.inputs.length === 0) {\n            this.extraData = true;\n        }\n    }\n    /**\n     * Called after handles are synced, override to provide initial processing.\n     */\n    ready() {\n    }\n    /**\n     * This sets the capabilities for this particle.  This can only\n     * be called once.\n     */\n    setCapabilities(capabilities) {\n        if (this.capabilities) {\n            // Capabilities already set, throw an error.\n            throw new Error('capabilities should only be set once');\n        }\n        this.capabilities = capabilities || {};\n    }\n    // tslint:disable-next-line: no-any\n    async invokeSafely(fun, err) {\n        try {\n            this.startBusy();\n            return await fun(this);\n        }\n        catch (e) {\n            err(e);\n        }\n        finally {\n            this.doneBusy();\n        }\n    }\n    async callSetHandles(handles, onException) {\n        this.handles = handles;\n        await this.invokeSafely(async (p) => p.setHandles(handles), onException);\n        this._handlesToSync = this._countInputHandles(handles);\n        if (!this._handlesToSync) {\n            // onHandleSync is called IFF there are input handles, otherwise we are ready now\n            this.ready();\n        }\n    }\n    /**\n     * This method is invoked with a handle for each store this particle\n     * is registered to interact with, once those handles are ready for\n     * interaction. Override the method to register for events from\n     * the handles.\n     *\n     * @param handles a map from handle names to store handles.\n     */\n    async setHandles(handles) {\n    }\n    _countInputHandles(handles) {\n        let count = 0;\n        for (const [name, handle] of handles) {\n            if (handle.canRead) {\n                count++;\n            }\n        }\n        return count;\n    }\n    async callOnHandleSync(handle, model, onException) {\n        await this.invokeSafely(async (p) => p.onHandleSync(handle, model), onException);\n        // once we've synced each readable handle, we are ready to start\n        if (--this._handlesToSync === 0) {\n            this.ready();\n        }\n    }\n    /**\n     * Called for handles that are configured with both keepSynced and notifySync, when they are\n     * updated with the full model of their data. This will occur once after setHandles() and any time\n     * thereafter if the handle is resynchronized.\n     *\n     * @param handle The Handle instance that was updated.\n     * @param model For Singleton-backed Handles, the Entity data or null if the Singleton is not set.\n     *        For Collection-backed Handles, the Array of Entities, which may be empty.\n     */\n    async onHandleSync(handle, model) {\n    }\n    // tslint:disable-next-line: no-any\n    async callOnHandleUpdate(handle, update, onException) {\n        await this.invokeSafely(async (p) => p.onHandleUpdate(handle, update), onException);\n    }\n    /**\n     * Called for handles that are configued with notifyUpdate, when change events are received from\n     * the backing store. For handles also configured with keepSynced these events will be correctly\n     * ordered, with some potential skips if a desync occurs. For handles not configured with\n     * keepSynced, all change events will be passed through as they are received.\n     *\n     * @param handle The Handle instance that was updated.\n     * @param update An object containing one of the following fields:\n     *  - data: The full Entity for a Singleton-backed Handle.\n     *  - added: An Array of Entities added to a Collection-backed Handle.\n     *  - removed: An Array of Entities removed from a Collection-backed Handle.\n     *  - originator: whether the update originated from this particle.\n     */\n    // tslint:disable-next-line: no-any\n    async onHandleUpdate(handle, update) {\n    }\n    async callOnHandleDesync(handle, onException) {\n        await this.invokeSafely(async (p) => p.onHandleDesync(handle), onException);\n    }\n    /**\n     * Called for handles that are configured with both keepSynced and notifyDesync, when they are\n     * detected as being out-of-date against the backing store. For Singletons, the event that triggers\n     * this will also resync the data and thus this call may usually be ignored. For Collections, the\n     * underlying proxy will automatically request a full copy of the stored data to resynchronize.\n     * onHandleSync will be invoked when that is received.\n     *\n     * @param handle The Handle instance that was desynchronized.\n     */\n    async onHandleDesync(handle) {\n    }\n    async constructInnerArc() {\n        if (!this.capabilities.constructInnerArc) {\n            throw new Error('This particle is not allowed to construct inner arcs');\n        }\n        return this.capabilities.constructInnerArc(this);\n    }\n    get busy() {\n        return this._busy > 0;\n    }\n    get idle() {\n        return this._idle;\n    }\n    set relevance(r) {\n        this.relevances.push(r);\n    }\n    startBusy() {\n        if (this._busy === 0) {\n            this._idle = new Promise(resolve => this._idleResolver = () => resolve());\n        }\n        this._busy++;\n    }\n    doneBusy() {\n        this._busy--;\n        if (this._busy === 0) {\n            this._idleResolver();\n        }\n    }\n    inputs() {\n        return this.spec.inputs;\n    }\n    outputs() {\n        return this.spec.outputs;\n    }\n    hasSlotProxy(name) {\n        return this.slotProxiesByName.has(name);\n    }\n    addSlotProxy(slotlet) {\n        this.slotProxiesByName.set(slotlet.slotName, slotlet);\n    }\n    removeSlotProxy(name) {\n        this.slotProxiesByName.delete(name);\n    }\n    /**\n     * Request (outerPEC) service invocations.\n     */\n    // TODO(sjmiles): experimental services impl\n    async service(request) {\n        if (!this.capabilities.serviceRequest) {\n            console.warn(`${this.spec.name} has no service support.`);\n            return null;\n        }\n        return new Promise(resolve => {\n            this.capabilities.serviceRequest(this, request, response => resolve(response));\n        });\n    }\n    /**\n     * Returns the slot with provided name.\n     */\n    getSlot(name) {\n        return this.slotProxiesByName.get(name);\n    }\n    getSlotNames() {\n        return [...this.slotProxiesByName.keys()];\n    }\n    static buildManifest(strings, ...bits) {\n        const output = [];\n        for (let i = 0; i < bits.length; i++) {\n            const str = strings[i];\n            const indent = / *$/.exec(str)[0];\n            let bitStr;\n            if (typeof bits[i] === 'string') {\n                bitStr = bits[i];\n            }\n            else {\n                bitStr = bits[i].toManifestString();\n            }\n            bitStr = bitStr.replace(/(\\n)/g, '$1' + indent);\n            output.push(str);\n            output.push(bitStr);\n        }\n        if (strings.length > bits.length) {\n            output.push(strings[strings.length - 1]);\n        }\n        return output.join('');\n    }\n    async setParticleDescription(pattern) {\n        return this.setDescriptionPattern('pattern', pattern);\n    }\n    async setDescriptionPattern(connectionName, pattern) {\n        const descriptions = this.handles.get('descriptions');\n        if (descriptions) {\n            if (descriptions instanceof Collection || descriptions instanceof BigCollection) {\n                const entityClass = descriptions.entityClass;\n                await descriptions.store(new entityClass({ key: connectionName, value: pattern }, this.spec.name + '-' + connectionName));\n            }\n            return true;\n        }\n        throw new Error('A particle needs a description handle to set a decription pattern');\n    }\n    // Entity functions.\n    idFor(entity) {\n        return Entity.id(entity);\n    }\n    dataClone(entity) {\n        return Entity.dataClone(entity);\n    }\n    mutate(entity, mutation) {\n        Entity.mutate(entity, mutation);\n    }\n    // TODO(sjmiles): alternate render path for UiBroker\n    output(content) {\n        const { output } = this.capabilities;\n        if (output) {\n            output(this, content);\n        }\n    }\n    // abstract\n    renderSlot(slotName, contentTypes) { }\n    renderHostedSlot(slotName, hostedSlotId, content) { }\n    fireEvent(slotName, event) { }\n}\n//# sourceMappingURL=particle.js.map","/**\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class BiMap {\n    constructor(iterable) {\n        this.left2right = new Map();\n        this.right2left = new Map();\n        if (iterable) {\n            for (const [left, right] of iterable) {\n                this.set(left, right);\n            }\n        }\n    }\n    get size() { return this.left2right.size; }\n    set(left, right) {\n        if (this.hasL(left)) {\n            this.right2left.delete(this.getL(left));\n        }\n        if (this.hasR(right)) {\n            this.left2right.delete(this.getR(right));\n        }\n        this.left2right.set(left, right);\n        this.right2left.set(right, left);\n        return this;\n    }\n    hasL(left) {\n        return this.left2right.has(left);\n    }\n    hasR(right) {\n        return this.right2left.has(right);\n    }\n    getL(left) {\n        return this.left2right.get(left);\n    }\n    getR(right) {\n        return this.right2left.get(right);\n    }\n    deleteL(left) {\n        this.right2left.delete(this.getL(left));\n        return this.left2right.delete(left);\n    }\n    deleteR(right) {\n        this.left2right.delete(this.getR(right));\n        return this.right2left.delete(right);\n    }\n    clear() {\n        this.left2right.clear();\n        this.right2left.clear();\n    }\n    entries() {\n        return this.left2right.entries();\n    }\n    lefts() {\n        return this.left2right.keys();\n    }\n    rights() {\n        return this.right2left.keys();\n    }\n    forEach(callback) {\n        this.left2right.forEach((value, key) => callback(key, value, this));\n    }\n}\n//# sourceMappingURL=bimap.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport * from './loader-web.js';\n//# sourceMappingURL=loader.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { logsFactory } from './logs-factory.js';\nimport { LoaderBase } from './loader-base.js';\nconst { warn } = logsFactory('loader-web', 'green');\nexport class Loader extends LoaderBase {\n    clone() {\n        return new Loader(this.urlMap);\n    }\n    flushCaches() {\n        // punt object urls?\n    }\n    async loadFile(path) {\n        return this.loadUrl(path);\n    }\n    async loadBinaryFile(path) {\n        return this.loadBinaryUrl(path);\n    }\n    async provisionObjectUrl(fileName) {\n        // TODO(sjmiles): BLOB Urls don't work for binary content (.wasm), mime-type?\n        if (!fileName || fileName.endsWith('.wasm')) {\n            return null;\n        }\n        else {\n            const raw = await this.loadResource(fileName);\n            const path = this.resolve(fileName);\n            const code = `${raw}\\n//# sourceURL=${path}`;\n            return URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));\n        }\n    }\n    async requireParticle(unresolvedPath, blobUrl) {\n        // inject path to this particle into the UrlMap,\n        // allows Foo particle to invoke `importScripts(resolver('$here/othermodule.js'))`\n        this.mapParticleUrl(unresolvedPath);\n        // resolve path\n        const resolvedPath = this.resolve(unresolvedPath);\n        // resolve target\n        const url = blobUrl || resolvedPath;\n        // load wrapped particle\n        const wrapper = this.loadWrappedParticle(url, resolvedPath);\n        // unwrap particle wrapper, if we have one\n        if (wrapper) {\n            return this.unwrapParticle(wrapper, this.provisionLogger(unresolvedPath));\n        }\n    }\n    loadWrappedParticle(url, path) {\n        let result;\n        // MUST be synchronous from here until deletion\n        // of self.defineParticle because we share this\n        // scope with other particles\n        // TODO fix usage of quoted property\n        self['defineParticle'] = particleWrapper => {\n            if (result) {\n                warn('multiple particles not supported, last particle wins');\n            }\n            // multiple particles not supported: last particle wins\n            result = particleWrapper;\n        };\n        try {\n            // import (execute) particle code\n            importScripts(url);\n        }\n        catch (e) {\n            throw new Error(`Error loading Particle from '${path}': ${e.message}`);\n        }\n        finally {\n            // clean up\n            delete self['defineParticle'];\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=loader-web.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { logFactory } from './log-web.js';\nconst getGlobal = () => {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\nconst getLogLevel = () => {\n    // acquire global scope\n    const g = getGlobal();\n    // use specified logLevel otherwise 0\n    return ('logLevel' in g) ? g['logLevel'] : 0;\n};\nconsole.log(`log-factory: binding logFactory to level [${getLogLevel()}]`);\nconst stubFactory = () => () => { };\nexport const logsFactory = (preamble, color = '') => {\n    const level = getLogLevel();\n    const logs = {};\n    ['log', 'warn', 'error', 'group', 'groupCollapsed', 'groupEnd'].\n        forEach(log => logs[log] = (level > 0 ? logFactory(preamble, color, log) : stubFactory));\n    return logs;\n};\n//# sourceMappingURL=logs-factory.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport const logFactory = (preamble, color, log = 'log') => {\n    const style = `background: ${color || 'gray'}; color: white; padding: 1px 6px 2px 7px; border-radius: 6px;`;\n    return console[log].bind(console, `%c${preamble}`, style);\n};\n//# sourceMappingURL=log-web.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from './assert-web.js';\nimport { fetch } from './fetch-web.js';\nimport { JsonldToManifest } from '../runtime/converters/jsonldToManifest.js';\nimport { ClientReference } from '../runtime/reference.js';\nimport { Particle } from '../runtime/particle.js';\nimport { DomParticle } from '../runtime/dom-particle.js';\nimport { TransformationDomParticle } from '../runtime/transformation-dom-particle.js';\nimport { MultiplexerDomParticle } from '../runtime/multiplexer-dom-particle.js';\nimport { UiParticle } from '../runtime/ui-particle.js';\nimport { UiMultiplexerParticle } from '../runtime/ui-multiplexer-particle.js';\nimport { html } from '../runtime/html.js';\nimport { logsFactory } from '../platform/logs-factory.js';\nconst { warn } = logsFactory('Loader', 'green');\nconst isString = s => (typeof s === 'string');\nconst isSchemaOrgUrl = (s) => /\\/\\/schema.org\\//.test(s);\n// a qualified url is an absolute path with `https` protocol\nconst isQualifiedUrl = (s) => /^https?:\\/\\//.test(s);\n/**\n * Key public API:\n *   async loadResource(file: string): Promise<string>\n *   async loadBinaryResource(file: string): Promise<ArrayBuffer>\n *   async loadParticleClass(spec: ParticleSpec): Promise<typeof Particle>\n */\nexport class LoaderBase {\n    constructor(urlMap = {}, staticMap = {}) {\n        this.urlMap = urlMap;\n        this.staticMap = staticMap;\n        this.compileRegExp(urlMap);\n    }\n    setParticleExecutionContext(pec) {\n        this.pec = pec;\n    }\n    flushCaches() {\n        // as needed\n    }\n    // TODO(sjmiles): XXX and XXXBinary methods are forked for type-safety (is there a way to be more DRY?)\n    async loadResource(file) {\n        const content = this.loadStatic(file);\n        if (content) {\n            return content;\n        }\n        const path = this.resolve(file);\n        if (isQualifiedUrl(path)) {\n            return this.loadUrl(path);\n        }\n        return this.loadFile(path);\n    }\n    async loadBinaryResource(file) {\n        const content = this.loadStaticBinary(file);\n        if (content) {\n            return content;\n        }\n        const path = this.resolve(file);\n        if (isQualifiedUrl(path)) {\n            return this.loadBinaryUrl(path);\n        }\n        return this.loadBinaryFile(path);\n    }\n    loadStatic(path) {\n        const content = this.staticMap[path];\n        if (content && !isString(content)) {\n            throw new Error('Cannot load static binary content as string');\n        }\n        return content;\n    }\n    loadStaticBinary(path) {\n        const content = this.staticMap[path];\n        if (content) {\n            if (content instanceof ArrayBuffer) {\n                return content;\n            }\n            throw new Error('Cannot load static string content as binary');\n        }\n        return null;\n    }\n    async loadUrl(url) {\n        if (isSchemaOrgUrl(url)) {\n            return this.loadSchemaOrgUrl(url);\n        }\n        return this.fetchString(url);\n    }\n    async fetchString(url) {\n        const res = await fetch(url);\n        if (res.ok) {\n            return res.text();\n        }\n        return Promise.reject(new Error(`HTTP ${res.status}: ${res.statusText}`));\n    }\n    async loadBinaryUrl(url) {\n        return this.fetchBuffer(url);\n    }\n    async fetchBuffer(url) {\n        const res = await fetch(url);\n        if (res.ok) {\n            return res.arrayBuffer();\n        }\n        return Promise.reject(new Error(`HTTP ${res.status}: ${res.statusText} for ${url}`));\n    }\n    //\n    // TODO(sjmiles): public because it's used in manifest.ts, can we simplify?\n    join(prefix, path) {\n        if (isQualifiedUrl(path)) {\n            return path;\n        }\n        // TODO: replace this with something that isn't hacky\n        if (path[0] === '/' || path[1] === ':') {\n            return path;\n        }\n        prefix = this.path(prefix);\n        path = this.normalizeDots(`${prefix}${path}`);\n        return path;\n    }\n    // TODO(sjmiles): public because it's used in manifest.ts, can we simplify?\n    path(fileName) {\n        return fileName.replace(/[/][^/]+$/, '/');\n    }\n    // convert `././foo/bar/../baz` to `./foo/baz`\n    normalizeDots(path) {\n        path = path || '';\n        // only unix slashes\n        path = path.replace(/\\\\/g, '/');\n        // remove './'\n        path = path.replace(/\\/\\.\\//g, '/');\n        // remove 'foo/..'\n        const norm = s => s.replace(/(?:^|\\/)[^./]*\\/\\.\\./g, '');\n        // keep removing `<name>/..` until there are no more\n        for (let n = norm(path); n !== path; path = n, n = norm(path))\n            ;\n        // remove '//' except after `:`\n        path = path.replace(/([^:])(\\/\\/)/g, '$1/');\n        return path;\n    }\n    resolve(path) {\n        const resolved = this.resolvePath(path);\n        const compact = this.normalizeDots(resolved);\n        return compact;\n    }\n    resolvePath(path) {\n        let resolved = path;\n        // TODO(sjmiles): inefficient\n        // find longest key in urlMap that is a prefix of path\n        const macro = this.findUrlMapMacro(path);\n        if (macro) {\n            const config = this.urlMap[macro];\n            if (isString(config)) {\n                resolved = `${config}${path.slice(macro.length)}`;\n            }\n            else {\n                resolved = this.resolveConfiguredPath(path, macro, config);\n            }\n        }\n        return resolved;\n    }\n    findUrlMapMacro(path) {\n        // TODO(sjmiles): inefficient\n        // find longest key in urlMap that is a prefix of path\n        return Object.keys(this.urlMap).sort((a, b) => b.length - a.length).find(k => isString(path) && (path.slice(0, k.length) === k));\n    }\n    resolveConfiguredPath(path, macro, config) {\n        return [\n            config.root,\n            (path.match(config.compiledRegex) ? config.buildDir : ''),\n            (config.path || ''),\n            path.slice(macro.length)\n        ].join('');\n    }\n    mapParticleUrl(path) {\n        if (!path) {\n            return undefined;\n        }\n        const resolved = this.resolve(path);\n        const parts = resolved.split('/');\n        parts.pop();\n        const folder = parts.join('/');\n        this.urlMap['$here'] = folder;\n        this.urlMap['$module'] = folder;\n    }\n    async loadSchemaOrgUrl(url) {\n        let href = `${url}.jsonld`;\n        let opts = null;\n        if (url.endsWith('/Thing')) {\n            href = 'https://schema.org/Product.jsonld';\n            opts = { '@id': 'schema:Thing' };\n        }\n        const data = await this.fetchString(href);\n        return JsonldToManifest.convert(data, opts);\n    }\n    async provisionObjectUrl(fileName) {\n        // no facility for this by default\n        return null;\n    }\n    //\n    // Below here invoked from inside isolation scope (e.g. Worker)\n    //\n    /**\n     * Returns a particle class implementation by loading and executing\n     * the code defined by a particle.  In the following example `x.js`\n     * will be loaded and executed:\n     *\n     * ```\n     * Particle foo in 'x.js'\n     * ```\n     */\n    async loadParticleClass(spec) {\n        let particleClass = null;\n        const userClass = await this.requireParticle(spec.implFile || '', spec.implBlobUrl);\n        if (!userClass) {\n            warn(`[${spec.implFile}]::defineParticle() returned no particle.`);\n        }\n        else {\n            particleClass = userClass;\n            particleClass.spec = spec;\n        }\n        return particleClass;\n    }\n    /**\n     * executes the defineParticle() code and returns the results which should be a class definition.\n     */\n    unwrapParticle(particleWrapper, log) {\n        assert(this.pec);\n        return particleWrapper({\n            // Particle base\n            Particle,\n            // Dom-flavored Particles (deprecated?)\n            DomParticle,\n            MultiplexerDomParticle,\n            TransformationDomParticle,\n            // Ui-flavored Particles\n            UiParticle,\n            UiMultiplexerParticle,\n            // Aliases\n            ReactiveParticle: UiParticle,\n            SimpleParticle: UiParticle,\n            // utilities\n            Reference: ClientReference.newClientReference(this.pec),\n            resolver: this.resolve.bind(this),\n            log: log || (() => { }),\n            html\n        });\n    }\n    provisionLogger(fileName) {\n        return logsFactory(fileName.split('/').pop(), '#1faa00').log;\n    }\n    compileRegExp(urlMap) {\n        for (const config of Object.values(urlMap)) {\n            if (typeof config === 'string')\n                continue;\n            config.compiledRegex = RegExp(config.buildOutputRegex);\n        }\n    }\n}\n//# sourceMappingURL=loader-base.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// 'export default fetch' works because 'fetch' is evaluated as an expression, which finds the\n// appropriate global definition - but we don't want to use default exports.\n// 'export {fetch}' doesn't work because 'fetch' is just a name in that context and is not defined.\n// So we need to use an expression to find the global fetch function then map that for export.\nconst localFetch = fetch;\nexport { localFetch as fetch };\n//# sourceMappingURL=fetch-web.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport const supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];\nexport class JsonldToManifest {\n    static convert(jsonld, theClass = undefined) {\n        const obj = JSON.parse(jsonld);\n        const classes = {};\n        const properties = {};\n        if (!obj['@graph']) {\n            obj['@graph'] = [obj];\n        }\n        for (const item of obj['@graph']) {\n            if (item['@type'] === 'rdf:Property') {\n                properties[item['@id']] = item;\n            }\n            else if (item['@type'] === 'rdfs:Class') {\n                classes[item['@id']] = item;\n                item['subclasses'] = [];\n                item['superclass'] = null;\n            }\n        }\n        for (const clazz of Object.values(classes)) {\n            if (clazz['rdfs:subClassOf'] !== undefined) {\n                if (clazz['rdfs:subClassOf'].length == undefined) {\n                    clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];\n                }\n                for (const subClass of clazz['rdfs:subClassOf']) {\n                    const superclass = subClass['@id'];\n                    if (clazz['superclass'] == undefined) {\n                        clazz['superclass'] = [];\n                    }\n                    if (classes[superclass]) {\n                        classes[superclass].subclasses.push(clazz);\n                        clazz['superclass'].push(classes[superclass]);\n                    }\n                    else {\n                        clazz['superclass'].push({ '@id': superclass });\n                    }\n                }\n            }\n        }\n        for (const clazz of Object.values(classes)) {\n            if (clazz['subclasses'].length === 0 && theClass == undefined) {\n                theClass = clazz;\n            }\n        }\n        const relevantProperties = [];\n        for (const property of Object.values(properties)) {\n            let domains = property['schema:domainIncludes'];\n            if (!domains) {\n                domains = { '@id': theClass['@id'] };\n            }\n            if (!domains.length) {\n                domains = [domains];\n            }\n            domains = domains.map(a => a['@id']);\n            if (domains.includes(theClass['@id'])) {\n                const name = property['@id'].split(':')[1];\n                let type = property['schema:rangeIncludes'];\n                if (!type) {\n                    console.log(property);\n                }\n                if (!type.length) {\n                    type = [type];\n                }\n                type = type.map(a => a['@id'].split(':')[1]);\n                type = type.filter(type => supportedTypes.includes(type));\n                if (type.length > 0) {\n                    relevantProperties.push({ name, type });\n                }\n            }\n        }\n        const className = theClass['@id'].split(':')[1];\n        const superNames = theClass && theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];\n        let s = '';\n        for (const superName of superNames) {\n            s += `import 'https://schema.org/${superName}'\\n\\n`;\n        }\n        s += `schema ${className}`;\n        if (superNames.length > 0) {\n            s += ` extends ${superNames.join(', ')}`;\n        }\n        if (relevantProperties.length > 0) {\n            for (const property of relevantProperties) {\n                let type;\n                if (property.type.length > 1) {\n                    type = '(' + property.type.join(' or ') + ')';\n                }\n                else {\n                    type = property.type[0];\n                }\n                s += `\\n  ${type} ${property.name}`;\n            }\n        }\n        s += '\\n';\n        return s;\n    }\n}\n//# sourceMappingURL=jsonldToManifest.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { XenStateMixin } from '../../modalities/dom/components/xen/xen-state.js';\nimport { DomParticleBase } from './dom-particle-base.js';\n/**\n * Particle that interoperates with DOM and uses a simple state system\n * to handle updates.\n */\nexport class DomParticle extends XenStateMixin(DomParticleBase) {\n    /**\n     * Override if necessary, to do things when props change.\n     */\n    willReceiveProps(...args) {\n    }\n    /**\n     * Override if necessary, to modify superclass config.\n     */\n    update(...args) {\n    }\n    /**\n     * Override to return false if the Particle won't use\n     * it's slot.\n     */\n    shouldRender(...args) {\n        return true;\n    }\n    /**\n     * Override to return a dictionary to map into the template.\n     */\n    render(...args) {\n        return {};\n    }\n    /**\n     * Copy values from `state` into the particle's internal state,\n     * triggering an update cycle unless currently updating.\n     */\n    setState(state) {\n        return this._setState(state);\n    }\n    /**\n     * Getters and setters for working with state/props.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Syntactic sugar: `this.state = {state}` is equivalent to `this.setState(state)`.\n     */\n    set state(state) {\n        this.setState(state);\n    }\n    get props() {\n        return this._props;\n    }\n    /**\n     * Override if necessary, to modify superclass config.\n     */\n    get config() {\n        // TODO(sjmiles): getter that does work is a bad idea, this is temporary\n        return {\n            handleNames: this.spec.inputs.map(i => i.name),\n            // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from\n            // .arcs files, instead of .ptcl ones.\n            slotNames: this.spec.slandleConnectionNames()\n        };\n    }\n    // affordances for aliasing methods to remove `_`\n    _willReceiveProps(...args) {\n        this.willReceiveProps(...args);\n    }\n    _update(...args) {\n        this.update(...args);\n        if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?\n            this.relevance = 1; // TODO: improve relevance signal.\n        }\n        this.config.slotNames.forEach(s => this.renderSlot(s, ['model']));\n    }\n    _async(fn) {\n        // asynchrony in Particle code must be bookended with start/doneBusy\n        this.startBusy();\n        const done = () => {\n            try {\n                fn.call(this);\n            }\n            finally {\n                this.doneBusy();\n            }\n        };\n        // TODO(sjmiles): superclass uses Promise.resolve(),\n        // but here use a short timeout for a wider debounce\n        return setTimeout(done, 10);\n    }\n    async setHandles(handles) {\n        this.configureHandles(handles);\n        this.handles = handles;\n        // TODO(sjmiles): we must invalidate at least once, is there a way to know\n        // whether handleSync/update will be called?\n        this._invalidate();\n    }\n    /**\n     * This is called once during particle setup. Override to control sync and update\n     * configuration on specific handles (via their configure() method).\n     * `handles` is a map from names to handle instances.\n     */\n    configureHandles(handles) {\n        // Example: handles.get('foo').configure({keepSynced: false});\n    }\n    async onHandleSync(handle, model) {\n        this._setProperty(handle.name, model);\n    }\n    async onHandleUpdate({ name }, { data, added, removed }) {\n        if (data !== undefined) {\n            //console.log('update.data:', JSON.stringify(data, null, '  '));\n            this._setProps({ [name]: data });\n        }\n        if (added) {\n            //console.log('update.added:', JSON.stringify(added, null, '  '));\n            const prop = (this.props[name] || []).concat(added);\n            // TODO(sjmiles): generally improper to set `this._props` directly, this is a special case\n            this._props[name] = prop;\n            this._setProps({ [name]: prop });\n        }\n        if (removed) {\n            //console.log('update.removed:', JSON.stringify(removed, null, '  '));\n            const prop = this.props[name];\n            if (Array.isArray(prop)) {\n                removed.forEach(removed => {\n                    // TODO(sjmiles): linear search is inefficient\n                    const index = prop.findIndex(entry => this.idFor(entry) === this.idFor(removed));\n                    if (index >= 0) {\n                        prop.splice(index, 1);\n                    }\n                    else {\n                        console.warn(`dom-particle::onHandleUpdate: couldn't find item to remove`);\n                    }\n                });\n                this._setProps({ [name]: prop });\n            }\n        }\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            // TODO(sjmiles): remove `this._state` parameter\n            this[handler]({ data }, this._state);\n        }\n    }\n    debounce(key, func, delay) {\n        const subkey = `_debounce_${key}`;\n        const state = this.state;\n        if (!state[subkey]) {\n            state[subkey] = true;\n            this.startBusy();\n        }\n        const idleThenFunc = () => {\n            this.doneBusy();\n            func();\n            state[subkey] = null;\n        };\n        // TODO(sjmiles): rewrite Xen debounce so caller has idle control\n        super._debounce(key, idleThenFunc, delay);\n    }\n}\n//# sourceMappingURL=dom-particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst nob = () => Object.create(null);\n\nconst debounce = (key, action, delay) => {\n  if (key) {\n    clearTimeout(key);\n  }\n  if (action && delay) {\n    return setTimeout(action, delay);\n  }\n};\n\nconst XenStateMixin = Base => class extends Base {\n  constructor() {\n    super();\n    this._pendingProps = nob();\n    this._props = this._getInitialProps() || nob();\n    this._lastProps = nob();\n    this._state = this._getInitialState() || nob();\n    this._lastState = nob();\n  }\n  _getInitialProps() {\n  }\n  _getInitialState() {\n  }\n  _getProperty(name) {\n    return this._pendingProps[name] || this._props[name];\n  }\n  _setProperty(name, value) {\n    // dirty checking opportunity\n    if (this._validator || this._wouldChangeProp(name, value)) {\n      this._pendingProps[name] = value;\n      this._invalidateProps();\n    }\n  }\n  _wouldChangeValue(map, name, value) {\n    // Important dirty-checking behavior controlled here,\n    // can be overridden.\n    // The default implementation will use strict reference checking.\n    // To modify structured values one must create a new Object to\n    // replace the old one.\n    return (map[name] !== value);\n    // an example of dirty-checking that instead simply punts on structured data\n    //return (typeof value === 'object') || (map[name] !== value);\n  }\n  _wouldChangeProp(name, value) {\n    return this._wouldChangeValue(this._props, name, value);\n  }\n  _wouldChangeState(name, value) {\n    return this._wouldChangeValue(this._state, name, value);\n  }\n  _setProps(props) {\n    // TODO(sjmiles): should be a replace instead of a merge?\n    Object.assign(this._pendingProps, props);\n    this._invalidateProps();\n  }\n  _invalidateProps() {\n    this._propsInvalid = true;\n    this._invalidate();\n  }\n  _setState(object) {\n    let dirty = false;\n    const state = this._state;\n    for (const property in object) {\n      const value = object[property];\n      if (this._wouldChangeState(property, value)) {\n        dirty = true;\n        state[property] = value;\n      }\n    }\n    if (dirty) {\n      this._invalidate();\n      return true;\n    }\n  }\n  _async(fn) {\n    return Promise.resolve().then(fn.bind(this));\n  }\n  _invalidate() {\n    if (!this._validator) {\n      this._validator = this._async(this._validate);\n    }\n  }\n  _getStateArgs() {\n    return [this._props, this._state, this._lastProps, this._lastState];\n  }\n  _validate() {\n    const stateArgs = this._getStateArgs();\n    // try..catch to ensure we nullify `validator` before return\n    try {\n      // TODO(sjmiles): should be a replace instead of a merge\n      Object.assign(this._props, this._pendingProps);\n      if (this._propsInvalid) {\n        // TODO(sjmiles): should/can have different timing from rendering?\n        this._willReceiveProps(...stateArgs);\n        this._propsInvalid = false;\n      }\n      if (this._shouldUpdate(...stateArgs)) {\n        // TODO(sjmiles): consider throttling update to rAF\n        this._ensureMount();\n        this._doUpdate(...stateArgs);\n      }\n    } catch (x) {\n      console.error(x);\n    }\n    // nullify validator _after_ methods so state changes don't reschedule validation\n    this._validator = null;\n    // save the old props and state\n    this._lastProps = Object.assign(nob(), this._props);\n    this._lastState = Object.assign(nob(), this._state);\n  }\n  _doUpdate(...stateArgs) {\n    this._update(...stateArgs);\n    this._didUpdate(...stateArgs);\n  }\n  _ensureMount() {\n  }\n  _willReceiveProps() {\n  }\n  _shouldUpdate() {\n    return true;\n  }\n  _update() {\n  }\n  _didUpdate() {\n  }\n  _debounce(key, func, delay) {\n    key = `_debounce_${key}`;\n    this._state[key] = debounce(this._state[key], func, delay != null ? delay : 16);\n  }\n};\n\nexport {XenStateMixin, nob, debounce};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { BigCollection, Collection, Singleton } from './handle.js';\nimport { Particle } from './particle.js';\n/**\n * Particle that interoperates with DOM.\n */\nexport class DomParticleBase extends Particle {\n    /**\n     * Override to return a String defining primary markup.\n     */\n    get template() {\n        return '';\n    }\n    /**\n     * Override to return a String defining primary markup for the given slot name.\n     */\n    getTemplate(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return this.template;\n    }\n    /**\n     * Override to return a String defining the name of the template for the given slot name.\n     */\n    getTemplateName(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return `default`;\n    }\n    /**\n     * Override to return false if the Particle won't use it's slot.\n     */\n    shouldRender(stateArgs) {\n        return true;\n    }\n    /**\n     * Override to return a dictionary to map into the template.\n     */\n    render(stateArgs) {\n        return {};\n    }\n    renderSlot(slotName, contentTypes) {\n        const stateArgs = this._getStateArgs();\n        const slot = this.getSlot(slotName);\n        if (!slot) {\n            return; // didn't receive StartRender.\n        }\n        // Set this to support multiple slots consumed by a particle, without needing\n        // to pass slotName to particle's render method, where it useless in most cases.\n        this.currentSlotName = slotName;\n        contentTypes.forEach(ct => slot.requestedContentTypes.add(ct));\n        // TODO(sjmiles): redundant, same answer for every slot\n        if (this.shouldRender(...stateArgs)) {\n            const content = {};\n            if (slot.requestedContentTypes.has('template')) {\n                content.template = this.getTemplate(slot.slotName);\n            }\n            if (slot.requestedContentTypes.has('model')) {\n                content.model = this.render(...stateArgs);\n            }\n            content.templateName = this.getTemplateName(slot.slotName);\n            // Backwards-compatibility and convenience code:\n            //  - Rewrites slotid=\"slotName\" to slotid$=\"{{$slotName}}\" in templates.\n            //  - Enhances the model with `$slotName` fields.\n            if (slot.providedSlots.size > 0) {\n                if (content.template) {\n                    if (typeof content.template === 'string') {\n                        content.template = this.slotNamesToModelReferences(slot, content.template);\n                    }\n                    else {\n                        content.template = Object.entries(content.template).reduce((templateDictionary, [templateName, templateValue]) => {\n                            templateDictionary[templateName] = this.slotNamesToModelReferences(slot, templateValue);\n                            return templateDictionary;\n                        }, {});\n                    }\n                }\n                if (content.model) {\n                    const slotIDs = {};\n                    slot.providedSlots.forEach((slotId, slotName) => slotIDs[`$${slotName}`] = slotId);\n                    content.model = this.enhanceModelWithSlotIDs(content.model, slotIDs);\n                }\n            }\n            slot.render(content);\n        }\n        else if (slot.isRendered) {\n            // Send empty object, to clear rendered slot contents.\n            slot.render({});\n        }\n        this.currentSlotName = undefined;\n    }\n    slotNamesToModelReferences(slot, template) {\n        slot.providedSlots.forEach((slotId, slotName) => {\n            // TODO: This is a simple string replacement right now,\n            // ensuring that 'slotid' is an attribute on an HTML element would be an improvement.\n            // TODO(sjmiles): clone original id as `slotname` for human readability\n            template = template.replace(new RegExp(`slotid=\"${slotName}\"`, 'gi'), `slotname=\"${slotName}\" slotid$=\"{{$${slotName}}}\"`);\n        });\n        return template;\n    }\n    // We put slot IDs at the top-level of the model as well as in models for sub-templates.\n    // This is temporary and should go away when we move from sub-IDs to [(Entity, Slot)] constructs.\n    enhanceModelWithSlotIDs(model, slotIDs, topLevel = true) {\n        if (topLevel) {\n            model = { ...slotIDs, ...model };\n        }\n        if (model.hasOwnProperty('$template') && model.hasOwnProperty('models') && Array.isArray(model['models'])) {\n            model['models'] = model['models'].map(m => this.enhanceModelWithSlotIDs(m, slotIDs));\n        }\n        for (const [key, value] of Object.entries(model)) {\n            if (!!value && typeof value === 'object') {\n                model[key] = this.enhanceModelWithSlotIDs(value, slotIDs, false);\n            }\n        }\n        return model;\n    }\n    _getStateArgs() {\n        return [];\n    }\n    forceRenderTemplate(slotName = '') {\n        this.slotProxiesByName.forEach((slot, name) => {\n            if (!slotName || (name === slotName)) {\n                slot.requestedContentTypes.add('template');\n            }\n        });\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            this[handler]({ data });\n        }\n    }\n    async setParticleDescription(pattern) {\n        if (typeof pattern === 'string') {\n            return super.setParticleDescription(pattern);\n        }\n        if (pattern.template && pattern.model) {\n            await super.setDescriptionPattern('_template_', pattern.template);\n            await super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));\n            return undefined;\n        }\n        else {\n            throw new Error('Description pattern must either be string or have template and model');\n        }\n    }\n    /**\n     * Remove all entities from named handle.\n     */\n    async clearHandle(handleName) {\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Singleton || handle instanceof Collection) {\n            await handle.clear();\n        }\n        else {\n            throw new Error('Singleton/Collection required');\n        }\n    }\n    /**\n     * Merge entities from Array into named handle.\n     */\n    async mergeEntitiesToHandle(handleName, entities) {\n        const idMap = {};\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Collection) {\n            const handleEntities = await handle.toList();\n            handleEntities.forEach(entity => idMap[entity.id] = entity);\n            for (const entity of entities) {\n                if (!idMap[this.idFor(entity)]) {\n                    await handle.store(entity);\n                }\n            }\n        }\n        else {\n            throw new Error('Collection required');\n        }\n    }\n    /**\n     * Append entities from Array to named handle.\n     */\n    async appendEntitiesToHandle(handleName, entities) {\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                await Promise.all(entities.map(entity => handle.store(entity)));\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Create an entity from each rawData, and append to named handle.\n     */\n    async appendRawDataToHandle(handleName, rawDataArray) {\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Collection || handle instanceof BigCollection) {\n            const entityClass = handle.entityClass;\n            await Promise.all(rawDataArray.map(raw => handle.store(new entityClass(raw))));\n        }\n        else {\n            throw new Error('Collection required');\n        }\n    }\n    /**\n     * Modify value of named handle. A new entity is created\n     * from `rawData` (`new [EntityClass](rawData)`).\n     */\n    async updateSingleton(handleName, rawData) {\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Singleton) {\n                const entity = new handle.entityClass(rawData);\n                await handle.set(entity);\n                return entity;\n            }\n            else {\n                throw new Error('Singleton required');\n            }\n        }\n        else {\n            throw new Error(`Handle ${handleName} does not exist`);\n        }\n    }\n    /**\n     * Modify or insert `entity` into named handle.\n     * Modification is done by removing the old entity and reinserting the new one.\n     */\n    async updateCollection(handleName, entity) {\n        // Set the entity into the right place in the set. If we find it\n        // already present replace it, otherwise, add it.\n        // TODO(dstockwell): Replace this with happy entity mutation approach.\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                await handle.remove(entity);\n                await handle.store(entity);\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Return array of Entities dereferenced from array of Share-Type Entities\n     */\n    async derefShares(shares) {\n        let entities = [];\n        this.startBusy();\n        try {\n            const derefPromises = shares.map(async (share) => share.ref.dereference());\n            entities = await Promise.all(derefPromises);\n        }\n        finally {\n            this.doneBusy();\n        }\n        return entities;\n    }\n    /**\n     * Returns array of Entities found in BOXED data `box` that are owned by `userid`\n     */\n    async boxQuery(box, userid) {\n        if (!box) {\n            return [];\n        }\n        else {\n            const matches = box.filter(item => userid === item.fromKey);\n            return await this.derefShares(matches);\n        }\n    }\n}\n//# sourceMappingURL=dom-particle-base.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { DomParticle } from './dom-particle.js';\nimport { Entity } from './entity.js';\n// Regex to separate style and template.\nconst re = /<style>((?:.|[\\r\\n])*)<\\/style>((?:.|[\\r\\n])*)/;\n/**\n * Particle that does transformation stuff with DOM.\n */\nexport class TransformationDomParticle extends DomParticle {\n    getTemplate(slotName) {\n        // TODO: add support for multiple slots.\n        return this._state.template;\n    }\n    getTemplateName(slotName) {\n        // TODO: add support for multiple slots.\n        return this._state.templateName;\n    }\n    render(props, state) {\n        return state.renderModel;\n    }\n    shouldRender(props, state) {\n        return Boolean((state.template || state.templateName) && state.renderModel);\n    }\n    renderHostedSlot(slotName, hostedSlotId, content) {\n        this.combineHostedTemplate(slotName, hostedSlotId, content);\n        this.combineHostedModel(slotName, hostedSlotId, content);\n    }\n    // abstract\n    combineHostedTemplate(slotName, hostedSlotId, content) {\n    }\n    combineHostedModel(slotName, hostedSlotId, content) {\n    }\n    // Helper methods that may be reused in transformation particles to combine hosted content.\n    static propsToItems(propsValues) {\n        return propsValues ? propsValues.map(e => ({ subId: Entity.id(e), ...e })) : [];\n    }\n}\n//# sourceMappingURL=transformation-dom-particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { TransformationDomParticle } from './transformation-dom-particle.js';\nimport { Entity } from './entity.js';\nexport class MultiplexerDomParticle extends TransformationDomParticle {\n    constructor() {\n        super(...arguments);\n        this._itemSubIdByHostedSlotId = new Map();\n        this._connByHostedConn = new Map();\n    }\n    async _mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc) {\n        const otherMappedHandles = [];\n        const otherConnections = [];\n        let index = 2;\n        const skipConnectionNames = [listHandleName, particleHandleName];\n        for (const [connectionName, otherHandle] of handles) {\n            if (skipConnectionNames.includes(connectionName)) {\n                continue;\n            }\n            // TODO(wkorman): For items with embedded recipes we may need a map\n            // (perhaps id to index) to make sure we don't map a handle into the inner\n            // arc multiple times unnecessarily.\n            // TODO(lindner): type erasure to avoid mismatch of Store vs Handle in arc.mapHandle\n            // tslint:disable-next-line: no-any\n            const otherHandleStore = otherHandle.storage;\n            otherMappedHandles.push(`use '${await arc.mapHandle(otherHandleStore)}' as v${index}`);\n            const hostedOtherConnection = hostedParticle.handleConnections.find(conn => conn.isCompatibleType(otherHandle.type));\n            if (hostedOtherConnection) {\n                otherConnections.push(`${hostedOtherConnection.name} = v${index++}`);\n                // TODO(wkorman): For items with embedded recipes where we may have a\n                // different particle rendering each item, we need to track\n                // |connByHostedConn| keyed on the particle type.\n                this._connByHostedConn.set(hostedOtherConnection.name, connectionName);\n            }\n        }\n        return [otherMappedHandles, otherConnections];\n    }\n    async setHandles(handles) {\n        this.handleIds = {};\n        const arc = await this.constructInnerArc();\n        const listHandleName = 'list';\n        const particleHandleName = 'hostedParticle';\n        const particleHandle = handles.get(particleHandleName);\n        let hostedParticle = null;\n        let otherMappedHandles = [];\n        let otherConnections = [];\n        if (particleHandle) {\n            // Typecast to any; the get() method doesn't exist on raw Handles.\n            // tslint:disable-next-line: no-any\n            hostedParticle = await particleHandle.get();\n            if (hostedParticle) {\n                [otherMappedHandles, otherConnections] =\n                    await this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc);\n            }\n        }\n        this.setState({\n            arc,\n            type: handles.get(listHandleName).type,\n            hostedParticle,\n            otherMappedHandles,\n            otherConnections\n        });\n        await super.setHandles(handles);\n    }\n    async update({ list }, { arc, type, hostedParticle, otherMappedHandles, otherConnections }, oldProps, oldState) {\n        //console.warn(`[${this.spec.name}]::update`, list, arc);\n        if (!list || !arc) {\n            return;\n        }\n        if (oldProps.list === list && oldState.arc === arc) {\n            return;\n        }\n        if (list.length > 0) {\n            this.relevance = 0.1;\n        }\n        for (const [index, item] of this.getListEntries(list)) {\n            let resolvedHostedParticle = hostedParticle;\n            const id = Entity.id(item);\n            if (this.handleIds[id]) {\n                const itemHandle = await this.handleIds[id];\n                // tslint:disable-next-line: no-any\n                itemHandle.set(item);\n                continue;\n            }\n            const itemHandlePromise = arc.createHandle(type.getContainedType(), `item${index}`);\n            this.handleIds[id] = itemHandlePromise;\n            const itemHandle = await itemHandlePromise;\n            if (!resolvedHostedParticle) {\n                // If we're muxing on behalf of an item with an embedded recipe, the\n                // hosted particle should be retrievable from the item itself. Else we\n                // just skip this item.\n                if (!item.renderParticleSpec) {\n                    continue;\n                }\n                resolvedHostedParticle =\n                    ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));\n                // Re-map compatible handles and compute the connections specific\n                // to this item's render particle.\n                const listHandleName = 'list';\n                const particleHandleName = 'renderParticle';\n                [otherMappedHandles, otherConnections] =\n                    await this._mapParticleConnections(listHandleName, particleHandleName, resolvedHostedParticle, this.handles, arc);\n            }\n            // TODO(jopra): Using the [0] item may not be desired.\n            const hostedSlotName = resolvedHostedParticle.slandleConnectionNames()[0];\n            const slotNames = this.spec.slandleConnectionNames();\n            assert(slotNames.length > 0, 'there must be at least one slot');\n            // TODO(jopra): Using the [0] item may not be desired.\n            const slotName = slotNames[0];\n            const slotId = await arc.createSlot(this, slotName, itemHandle._id);\n            if (!slotId) {\n                continue;\n            }\n            this._itemSubIdByHostedSlotId.set(slotId, id);\n            try {\n                const recipe = this.constructInnerRecipe(resolvedHostedParticle, item, itemHandle, { name: hostedSlotName, id: slotId }, { connections: otherConnections, handles: otherMappedHandles });\n                await arc.loadRecipe(recipe);\n                // tslint:disable-next-line: no-any\n                itemHandle.set(item);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    }\n    combineHostedModel(slotName, hostedSlotId, content) {\n        const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n        if (!subId) {\n            return;\n        }\n        const items = this._state.renderModel ? this._state.renderModel.items : [];\n        const listIndex = items.findIndex(item => item.subId === subId);\n        const item = { ...content.model, subId };\n        if (listIndex >= 0 && listIndex < items.length) {\n            items[listIndex] = item;\n        }\n        else {\n            items.push(item);\n        }\n        this.setState({ renderModel: { items } });\n    }\n    combineHostedTemplate(slotName, hostedSlotId, content) {\n        const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n        if (!subId) {\n            return;\n        }\n        assert(content.templateName, `Template name is missing for slot '${slotName}' (hosted slot ID: '${hostedSlotId}')`);\n        const templateName = { ...this._state.templateName, [subId]: `${content.templateName}` };\n        this.setState({ templateName });\n        if (content.template) {\n            let template = content.template;\n            // Append subid$={{subid}} attribute to all provided slots, to make it usable for the transformation particle.\n            template = template.replace(new RegExp('slotid=\"[a-z]+\"', 'gi'), '$& subid$=\"{{subId}}\"');\n            // Replace hosted particle connection in template with the corresponding particle connection names.\n            // TODO: make this generic!\n            this._connByHostedConn.forEach((conn, hostedConn) => {\n                template = template.replace(new RegExp(`{{${hostedConn}.description}}`, 'g'), `{{${conn}.description}}`);\n            });\n            this.setState({ template: { ...this._state.template, [content.templateName]: template } });\n            this.forceRenderTemplate();\n        }\n    }\n    // Called with the list of items and by default returns the direct result of\n    // `Array.entries()`. Subclasses can override this method to alter the item\n    // order or otherwise permute the items as desired before their slots are\n    // created and contents are rendered.\n    // tslint:disable-next-line: no-any\n    getListEntries(list) {\n        return list.entries();\n    }\n}\n//# sourceMappingURL=multiplexer-dom-particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { XenStateMixin } from '../../modalities/dom/components/xen/xen-state.js';\nimport { UiParticleBase } from './ui-particle-base.js';\n/**\n * Particle that interoperates with DOM and uses a simple state system\n * to handle updates.\n */\n// TODO(sjmiles): seems like this is really `UiStatefulParticle` but it's\n// used so often, I went with the simpler name\nexport class UiParticle extends XenStateMixin(UiParticleBase) {\n    /**\n     * Override if necessary, to do things when props change.\n     * Avoid if possible, use `update` instead.\n     */\n    willReceiveProps(...args) {\n    }\n    // affordance so subclasses can avoid `_`\n    _willReceiveProps(...args) {\n        this.willReceiveProps(...args);\n    }\n    /**\n     * Override to do things when props or state change.\n     */\n    update(...args) {\n    }\n    /**\n     * Copy values from `state` into the particle's internal state,\n     * triggering an update cycle unless currently updating.\n     */\n    setState(state) {\n        return this._setState(state);\n    }\n    /**\n     * Getters and setters for working with state/props.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Syntactic sugar: `this.state = {state}` is equivalent to `this.setState(state)`.\n     * This is a merge, not an assignment.\n     */\n    set state(state) {\n        this.setState(state);\n    }\n    get props() {\n        return this._props;\n    }\n    _shouldUpdate() {\n        // do not update() unless all handles are sync'd\n        return this._handlesToSync <= 0;\n    }\n    _update(...args) {\n        /*const updateDirective =*/ this.update(...args);\n        if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?\n            this.relevance = 1; // TODO: improve relevance signal.\n            this.renderOutput(...args);\n        }\n    }\n    _async(fn) {\n        // asynchrony in Particle code must be bookended with start/doneBusy\n        this.startBusy();\n        const done = () => {\n            try {\n                fn.call(this);\n            }\n            finally {\n                this.doneBusy();\n            }\n        };\n        // TODO(sjmiles): superclass uses Promise.resolve(),\n        // but here use a short timeout for a wider debounce\n        return setTimeout(done, 10);\n    }\n    ready() {\n        // ensure we `update()` at least once\n        this._invalidate();\n    }\n    async onHandleSync(handle, model) {\n        this._setProperty(handle.name, model);\n    }\n    async onHandleUpdate({ name }, { data, added, removed }) {\n        if (data !== undefined) {\n            //console.log('update.data:', JSON.stringify(data, null, '  '));\n            this._setProps({ [name]: data });\n        }\n        if (added) {\n            //console.log('update.added:', JSON.stringify(added, null, '  '));\n            const prop = (this.props[name] || []).concat(added);\n            // TODO(sjmiles): generally improper to set `this._props` directly, this is a special case\n            this._props[name] = prop;\n            this._setProps({ [name]: prop });\n        }\n        if (removed) {\n            //console.log('update.removed:', JSON.stringify(removed, null, '  '));\n            const prop = this.props[name];\n            if (Array.isArray(prop)) {\n                removed.forEach(removed => {\n                    // TODO(sjmiles): linear search is inefficient\n                    const index = prop.findIndex(entry => this.idFor(entry) === this.idFor(removed));\n                    if (index >= 0) {\n                        prop.splice(index, 1);\n                    }\n                    else {\n                        console.warn(`dom-particle::onHandleUpdate: couldn't find item to remove`);\n                    }\n                });\n                this._setProps({ [name]: prop });\n            }\n        }\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            // TODO(sjmiles): remove deprecated `this._state` parameter\n            this[handler]({ data }, this._state);\n        }\n    }\n    debounce(key, func, delay) {\n        const subkey = `_debounce_${key}`;\n        const state = this.state;\n        if (!state[subkey]) {\n            state[subkey] = true;\n            this.startBusy();\n        }\n        const idleThenFunc = () => {\n            this.doneBusy();\n            func();\n            state[subkey] = null;\n        };\n        // TODO(sjmiles): rewrite Xen debounce so caller has idle control\n        super._debounce(key, idleThenFunc, delay);\n    }\n}\n//# sourceMappingURL=ui-particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Entity } from './entity.js';\nimport { Collection, Singleton } from './handle.js';\nimport { Particle } from './particle.js';\n/**\n * Particle that can render and process events.\n */\nexport class UiParticleBase extends Particle {\n    /**\n     * Override if necessary, to modify superclass config.\n     */\n    get config() {\n        // TODO(sjmiles): getter that does work is a bad idea, this is temporary\n        return {\n            handleNames: this.spec.inputs.map(i => i.name),\n            // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from\n            // .arcs files, instead of .ptcl ones.\n            slotNames: this.spec.slandleConnectionNames()\n        };\n    }\n    /**\n     * Override to return a template.\n     */\n    get template() {\n        return '';\n    }\n    /**\n     * Override to return false if the Particle isn't ready to `render()`\n     */\n    shouldRender(...args) {\n        return true;\n    }\n    renderOutput(...args) {\n        const renderModel = this.render(...args);\n        if (renderModel) {\n            this.renderModel(renderModel);\n        }\n    }\n    // This is the default output 'packet', other implementations (modalities) could\n    // output other things, or choose different output packets based on hints from 'model'\n    renderModel(model) {\n        this.output({\n            template: this.template,\n            model\n        });\n    }\n    /**\n     * Override to return a dictionary to map into the template.\n     */\n    render(...args) {\n        return {};\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            this[handler]({ data });\n        }\n    }\n    async setParticleDescription(pattern) {\n        if (typeof pattern === 'string') {\n            return super.setParticleDescription(pattern);\n        }\n        if (pattern.template && pattern.model) {\n            await super.setDescriptionPattern('_template_', pattern.template);\n            await super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));\n            return undefined;\n        }\n        else {\n            throw new Error('Description pattern must either be string or have template and model');\n        }\n    }\n    /**\n     * Invoke async function `task` with Particle busy-guard.\n     */\n    // tslint:disable-next-line: no-any\n    async await(task) {\n        return await this.invokeSafely(task, err => { throw err; });\n    }\n    /**\n     * Set a singleton value. Value can be an Entity or a POJO.\n     */\n    async set(handleName, value) {\n        const handle = this._requireHandle(handleName);\n        if (!(handle instanceof Singleton)) {\n            throw new Error(`Cannot set non-Singleton handle [${handleName}]`);\n        }\n        if (Array.isArray(value)) {\n            throw new Error(`Cannot set an Array to Singleton handle [${handleName}]`);\n        }\n        return this.await(async (p) => await handle.set(this._requireEntity(value, handle.entityClass)));\n    }\n    /**\n     * Add to a collection. Value can be an Entity or a POJO (or an Array of such values).\n     */\n    async add(handleName, value) {\n        const handle = this._requireHandle(handleName);\n        if (!(handle instanceof Collection)) {\n            throw new Error(`Cannot add to non-Collection handle [${handleName}]`);\n        }\n        const entityClass = handle.entityClass;\n        const data = Array.isArray(value) ? value : [value];\n        return this.await(async (p) => {\n            // remove pre-existing Entities (we will then re-add them, which is the mutation cycle)\n            await this._remove(handle, data);\n            // add (store) Entities, or Entities created from values\n            await Promise.all(data.map(value => handle.store(this._requireEntity(value, entityClass))));\n        });\n    }\n    _requireEntity(value, entityClass) {\n        return (value instanceof Entity) ? value : new (entityClass)(value);\n    }\n    /**\n     * Remove from a collection. Value must be an Entity or an array of Entities.\n     */\n    async remove(handleName, value) {\n        const handle = this._requireHandle(handleName);\n        if (!(handle instanceof Collection)) {\n            throw new Error(`Cannot remove from a non-Collection handle [${handleName}]`);\n        }\n        return this._remove(handle, value);\n    }\n    async _remove(handle, value) {\n        const data = Array.isArray(value) ? value : [value];\n        return this.await(async (p) => Promise.all(data.map(async (value) => {\n            if (value instanceof Entity) {\n                await handle.remove(value);\n            }\n        })));\n    }\n    /**\n     * Remove all entities from named handle.\n     */\n    async clear(handleName) {\n        const handle = this._requireHandle(handleName);\n        if (!(handle instanceof Singleton) && !(handle instanceof Collection)) {\n            throw new Error('Can only clear Singleton or Collection handles');\n        }\n        return this.await(p => handle.clear());\n    }\n    /**\n     * Return the named handle or throw.\n     */\n    _requireHandle(handleName) {\n        const handle = this.handles.get(handleName);\n        if (!handle) {\n            throw new Error(`Could not find handle [${handleName}]`);\n        }\n        return handle;\n    }\n    /**\n     * Return array of Entities dereferenced from array of Share-Type Entities\n     */\n    async derefShares(shares) {\n        return this.await(async (p) => {\n            const derefPromises = shares.map(async (share) => share.ref.dereference());\n            return await Promise.all(derefPromises);\n        });\n    }\n    /**\n     * Returns array of Entities found in BOXED data `box` that are owned by `userid`\n     */\n    async boxQuery(box, userid) {\n        if (!box) {\n            return [];\n        }\n        const matches = box.filter(item => userid === item.fromKey);\n        return await this.derefShares(matches);\n    }\n}\n//# sourceMappingURL=ui-particle-base.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { ParticleSpec } from './particle-spec.js';\nimport { UiTransformationParticle } from './ui-transformation-particle.js';\nexport class UiMultiplexerParticle extends UiTransformationParticle {\n    async setHandles(handles) {\n        this.plexeds = [];\n        const arc = await this.constructInnerArc();\n        const listHandleName = 'list';\n        const particleHandleName = 'hostedParticle';\n        const particleHandle = handles.get(particleHandleName);\n        let hostedParticle = null;\n        let otherMappedHandles = [];\n        let otherConnections = [];\n        if (particleHandle) {\n            hostedParticle = await particleHandle['get']();\n            if (hostedParticle) {\n                ({ otherMappedHandles, otherConnections } =\n                    await this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc));\n            }\n        }\n        this.setState({\n            arc,\n            type: handles.get(listHandleName).type,\n            hostedParticle,\n            otherMappedHandles,\n            otherConnections\n        });\n        await super.setHandles(handles);\n    }\n    async update({ list }, { arc, type, hostedParticle, otherMappedHandles, otherConnections }, oldProps, oldState) {\n        //console.warn(`[${this.spec.name}]::update`, list, arc);\n        if (!list || !arc) {\n            return;\n        }\n        if (oldProps.list === list && oldState.arc === arc) {\n            return;\n        }\n        if (list.length > 0) {\n            this.relevance = 0.1;\n        }\n        // TODO(sjmiles): needs safety for re-entrant update\n        //const slotIds = [];\n        for (const [index, item] of this.getListEntries(list)) {\n            //const id = await this.updateEntry(index, item, {arc, type, hostedParticle, otherConnections, otherMappedHandles});\n            //slotIds.push(id);\n            await this.updateEntry(index, item, { arc, type, hostedParticle, otherConnections, otherMappedHandles });\n        }\n        //console.warn('m-d-p', slotIds);\n        // clear data from unused particles/handles\n        for (let i = list.length, plexed; (plexed = this.plexeds[i]); i++) {\n            plexed.then(plexed => plexed.handle['clear']());\n        }\n    }\n    async updateEntry(index, item, { hostedParticle, arc, type, otherConnections, otherMappedHandles }) {\n        if (!hostedParticle && !item.renderParticleSpec) {\n            // If we're muxing on behalf of an item with an embedded recipe, the\n            // hosted particle should be retrievable from the item itself. Else we\n            // just skip this item.\n            return;\n        }\n        //console.log(`RenderEx:updateEntry: %c[${index}]`, 'color: #A00; font-weight: bold;');\n        // Map innerArc/slot by index. Index maps closely to rendering contexts.\n        // Rendering contexts are expensive, we want maximal coherence.\n        const plexed = await this.requirePlexed(index, item, { hostedParticle, arc, type, otherConnections, otherMappedHandles });\n        // TODO(sjmiles): work out a proper cast (and conditional), or fix upstream type\n        plexed.handle['set'](item);\n        return plexed.slotId;\n    }\n    async requirePlexed(index, item, { arc, type, hostedParticle, otherConnections, otherMappedHandles }) {\n        let promise = this.plexeds[index];\n        if (!promise) {\n            // eslint-disable-next-line no-async-promise-executor\n            promise = new Promise(async (resolve) => {\n                const handle = await this.acquireItemHandle(index, { arc, item, type });\n                const hosting = await this.resolveHosting(item, { arc, hostedParticle, otherConnections, otherMappedHandles });\n                const result = { arc, handle, hosting, slotId: null };\n                result.slotId = await this.createInnards(item, result);\n                resolve(result);\n            });\n            this.plexeds[index] = promise;\n        }\n        return await promise;\n    }\n    async resolveHosting(item, { arc, hostedParticle, otherConnections, otherMappedHandles }) {\n        return hostedParticle ?\n            { hostedParticle, otherConnections, otherMappedHandles }\n            : await this.resolveHostedParticle(item, arc);\n    }\n    async acquireItemHandle(index, { arc, item, type }) {\n        const handlePromise = arc.createHandle(type.getContainedType(), `item${index}`);\n        return await handlePromise;\n    }\n    async resolveHostedParticle(item, arc) {\n        const hostedParticle = ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));\n        // Re-map compatible handles and compute the connections specific\n        // to this item's render particle.\n        const listHandleName = 'list';\n        const particleHandleName = 'renderParticle';\n        const { otherConnections, otherMappedHandles } = await this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, this.handles, arc);\n        return { otherConnections, otherMappedHandles, hostedParticle };\n    }\n    async _mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc) {\n        const otherMappedHandles = [];\n        const otherConnections = [];\n        let index = 2;\n        const skipConnectionNames = [listHandleName, particleHandleName];\n        for (const [connectionName, otherHandle] of handles) {\n            if (!skipConnectionNames.includes(connectionName)) {\n                // TODO(wkorman): For items with embedded recipes we may need a map\n                // (perhaps id to index) to make sure we don't map a handle into the inner\n                // arc multiple times unnecessarily.\n                // TODO(lindner): type erasure to avoid mismatch of Store vs Handle in arc.mapHandle\n                // tslint:disable-next-line: no-any\n                const otherHandleStore = otherHandle.storage;\n                otherMappedHandles.push(`use '${await arc.mapHandle(otherHandleStore)}' as v${index}`);\n                //\n                const hostedOtherConnection = hostedParticle.handleConnections.find(conn => conn.isCompatibleType(otherHandle.type));\n                if (hostedOtherConnection) {\n                    otherConnections.push(`${hostedOtherConnection.name} = v${index++}`);\n                    // TODO(wkorman): For items with embedded recipes where we may have a\n                    // different particle rendering each item, we need to track\n                    // |connByHostedConn| keyed on the particle type.\n                    //this._connByHostedConn.set(hostedOtherConnection.name, connectionName);\n                }\n            }\n        }\n        return { otherMappedHandles, otherConnections };\n    }\n    async createInnards(item, { arc, handle, hosting: { hostedParticle, otherMappedHandles, otherConnections } }) {\n        const hostedSlotName = [...hostedParticle.slotConnections.keys()][0];\n        const slotName = [...this.spec.slotConnections.values()][0].name;\n        const slotId = await arc.createSlot(this, slotName, handle._id);\n        if (slotId) {\n            try {\n                const recipe = this.constructInnerRecipe(hostedParticle, item, handle, { name: hostedSlotName, id: slotId }, { connections: otherConnections, handles: otherMappedHandles });\n                await arc.loadRecipe(recipe);\n            }\n            catch (e) {\n                console.warn(e);\n            }\n        }\n        return slotId;\n    }\n    // Called with the list of items and by default returns the direct result of\n    // `Array.entries()`. Subclasses can override this method to alter the item\n    // order or otherwise permute the items as desired before their slots are\n    // created and contents are rendered.\n    getListEntries(list) {\n        return list.entries();\n    }\n}\n//# sourceMappingURL=ui-multiplexer-particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { UiParticle } from './ui-particle.js';\nimport { Entity } from './entity.js';\n/**\n * Particle that does transformation.\n */\nexport class UiTransformationParticle extends UiParticle {\n    getTemplate(slotName) {\n        // TODO: add support for multiple slots.\n        return this.state.template;\n    }\n    getTemplateName(slotName) {\n        // TODO: add support for multiple slots.\n        return this.state.templateName;\n    }\n    render(props, state) {\n        return state.renderModel;\n    }\n    shouldRender(props, state) {\n        return Boolean((state.template || state.templateName) && state.renderModel);\n    }\n    // Helper methods that may be reused in transformation particles to combine hosted content.\n    static propsToItems(propsValues) {\n        return propsValues ? propsValues.map(e => ({ subId: Entity.id(e), ...e })) : [];\n    }\n}\n//# sourceMappingURL=ui-transformation-particle.js.map","/**\n * @license\n * Copyright 2019 Google LLC.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// no-op html tagged template literal useful for hinting code-tools (e.g. highlighters)\n// about html content in strings. e.g. html`<span>this is html</span>`\nexport const html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\n//# sourceMappingURL=html.js.map"],"sourceRoot":""}