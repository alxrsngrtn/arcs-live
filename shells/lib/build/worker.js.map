{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./shells/lib/source/worker.js","webpack:///./build/runtime/particle-execution-context.js","webpack:///(webpack)/buildin/global.js","webpack:///./build/platform/assert-web.js","webpack:///./build/runtime/api-channel.js","webpack:///./build/runtime/debug/devtools-connection.js","webpack:///./devtools/shared/devtools-broker.js","webpack:///./build/platform/devtools-channel-stub.js","webpack:///./build/runtime/debug/abstract-devtools-channel.js","webpack:///./build/runtime/debug/testing/devtools-channel-stub.js","webpack:///./build/runtime/debug/outer-port-attachment.js","webpack:///./build/platform/sourcemapped-stacktrace-node.js","webpack:///./build/runtime/particle-spec.js","webpack:///./build/runtime/modality.js","webpack:///./build/runtime/recipe/type-checker.js","webpack:///./build/runtime/type.js","webpack:///./build/runtime/interface-info.js","webpack:///./build/runtime/schema.js","webpack:///./build/runtime/entity.js","webpack:///./build/runtime/symbols.js","webpack:///./build/runtime/reference.js","webpack:///./build/runtime/handle.js","webpack:///./build/runtime/slot-info.js","webpack:///./build/runtime/synthetic-types.js","webpack:///./build/runtime/type-variable-info.js","webpack:///./build/runtime/id.js","webpack:///./build/runtime/random.js","webpack:///./build/runtime/storage-proxy.js","webpack:///./build/runtime/storage/crdt-collection-model.js","webpack:///./build/platform/loader-web.js","webpack:///./build/runtime/loader.js","webpack:///./build/platform/fetch-web.js","webpack:///./build/platform/fs-web.js","webpack:///./build/platform/vm-web.js","webpack:///./build/runtime/converters/jsonldToManifest.js","webpack:///./build/runtime/dom-particle.js","webpack:///./modalities/dom/components/xen/xen-state.js","webpack:///./build/runtime/dom-particle-base.js","webpack:///./build/runtime/particle.js","webpack:///./build/runtime/multiplexer-dom-particle.js","webpack:///./build/runtime/transformation-dom-particle.js","webpack:///./build/platform/log-web.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8F;AACzB;;AAErE;AACA;AACA,SAAS,SAAS;AAClB,MAAM,qGAAwB,qBAAqB,4EAAc;AACjE;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACH;AACR;AACX;AAC4C;AAClE;AACP;AACA;AACA;AACA,6BAA6B,uEAAqB;AAClD;AACA;AACA,yCAAyC,4DAAY;AACrD;AACA,uBAAuB,8DAAY;AACnC;AACA;AACA,8BAA8B,8DAAY;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,8DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mCAAmC,EAAE;AAC3E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA,6DAA6D,wCAAwC,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAM,uEAAuE,mBAAmB,QAAQ,SAAS;AACjI;AACA;AACA,SAAS;AACT,sBAAsB,yCAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAS;AAC5C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,0GAA0G;AAC1G;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAS;AACpC;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD,SAAS;AACT;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;ACrPA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,aAAa;AACb;AACA;AACA;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,mCAAmC,oCAAoC;AACvE;AACmD;AACiB;AACG;AACrB;AACjB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC,YAAY,UAAU,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC,cAAc;AACrE;AACA;AACA;AACA;AACA,0DAA0D,gCAAgC;AAC1F;AACA;AACA,0DAA0D,iCAAiC;AAC3F;AACA;AACA;AACA;AACA;AACA,0DAA0D,+DAA+D;AACzH;AACA;AACA,0DAA0D,8CAA8C;AACxG;AACA;AACA,IAAI,sEAAM;AACV,IAAI,sEAAM;AACV,IAAI,sEAAM;AACV;AACA;AACA;AACA,IAAI,sEAAM;AACV,IAAI,sEAAM;AACV,IAAI,sEAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM,0BAA0B,sGAAsG,GAAG,GAAG;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM,kDAAkD,MAAM;AACtE;AACA;AACA;AACA,QAAQ,sEAAM,qCAAqC,GAAG;AACtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yCAAyC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,gFAAkB;AAC1B;AACA,wCAAwC,mFAAmB;AAC3D,SAAS;AACT;AACA,YAAY;AACZ,sCAAsC;AACtC,sDAAsD;AACtD,wCAAwC;AACxC,oCAAoC;AACpC,wBAAwB;AACxB,kEAAkE;AAClE,oCAAoC;AACpC,0EAA0E;AAC1E,yCAAyC;AACzC,4DAA4D;AAC5D,gDAAgD;AAChD,sDAAsD;AACtD,2FAA2F;AAC3F;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,2DAA2D,6CAAI;AAC/D;AACA;AACA,8FAA8F,8DAAY;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,6CAAI;AAChF;AACA;AACA;AACA;AACA;AACA,4EAA4E,6CAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uCAAuC;AACvC,wCAAwC;AACxC,iCAAiC;AACjC,oCAAoC;AACpC,kDAAkD;AAClD,8CAA8C;AAC9C,qDAAqD;AACrD,sDAAsD;AACtD,8DAA8D;AAC9D,uDAAuD;AACvD,kDAAkD;AAClD,yCAAyC;AACzC,8BAA8B;AAC9B,iDAAiD;AACjD,2CAA2C;AAC3C,gDAAgD;AAChD,yCAAyC;AACzC,4FAA4F;AAC5F,0CAA0C;AAC1C,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,6CAAI;AAC1E;AACA;AACA;AACA;AACA;AACA,4EAA4E,6CAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;AACxB,uC;;;;;;;AC3fA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;AACvB;AACmB;AACA;AACzE;AACA;AACA;AACA;AACA,kFAAc;AACd;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAe;AACzC;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,sBAAsB,qFAAmB;AACzC;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;ACvDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEyE;;AAE/E,8BAA8B,mGAAuB;AAC5D;AACA;AACA;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd;AACA,uBAAuB,MAAM,GAAG,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU,GAAG,gBAAgB;AACpF;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ,oBAAoB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B;AAC/B;AACA,qD;;;;;;;ACzFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;AC3BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8E;AACvE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAA8D;AACxF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAkE;AAC9F;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAa;AACzB,YAAY,8FAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA,6BAA6B;AAC7B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,mCAAmC;AACpD;AACA;AACA;AACA;AACA,iD;;;;;;;ACxFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;;;;;;;ACRP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACV;AACc;AACP;AAChD;AACA,yBAAyB,6CAAI,QAAQ,6CAAI;AACzC;AACA;AACA,yBAAyB,6CAAI;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAW,eAAe,OAAO,GAAG,6CAA6C;AAChG;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,qDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAM;AAC9C,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E,sCAAsC,0DAA0D,OAAO,8HAA8H;AACrO;AACA,gBAAgB;AAChB;AACA;AACA,aAAa,4DAA4D;AACzE,wCAAwC,0DAA0D,OAAO,qJAAqJ;AAC9P;AACA,iCAAiC,yEAAyE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM,yGAAyG,EAAE;AAC7H,SAAS;AACT;AACA;AACA;AACA,QAAQ,sEAAM;AACd,8CAA8C,wBAAwB,OAAO,sCAAsC;AACnH;AACA,eAAe,sDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA,iCAAiC,UAAU,EAAE,MAAM,OAAO,cAAc;AACxE;AACA;AACA,2DAA2D,IAAI;AAC/D,4BAA4B,OAAO,EAAE,qBAAqB,EAAE,iCAAiC,GAAG,2BAA2B,GAAG,gBAAgB,EAAE,KAAK;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA,8BAA8B,kBAAkB;AAChD;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA,oCAAoC,kBAAkB;AACtD;AACA,qDAAqD,cAAc;AACnE;AACA,0EAA0E,OAAO;AACjF,aAAa;AACb,SAAS;AACT;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,wCAAwC,QAAQ,KAAK,WAAW;AAChE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;AC9PA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA,QAAQ,sEAAM,qFAAqF,MAAM;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;AC3CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACuI;AAChI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C;AACA;AACA;AACA,iCAAiC,0DAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6CAAI;AACnD,qCAAqC,qDAAY;AACjD,yCAAyC,qDAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAa,6BAA6B,sDAAa;AACjG;AACA;AACA;AACA;AACA,uBAAuB,sDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D,6DAA6D,6CAAI;AACjE,2CAA2C,qDAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAY;AAC3C,uDAAuD,uDAAc;AACrE,kEAAkE,uDAAc;AAChF;AACA,4DAA4D,0DAAiB;AAC7E,kEAAkE,0DAAiB;AACnF;AACA;AACA,kEAAkE,sDAAa;AAC/E;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sCAAsC,6CAAI;AAC1C;AACA,gCAAgC,qDAAY;AAC5C;AACA;AACA,iCAAiC,qDAAY;AAC7C;AACA;AACA,gCAAgC,qDAAY,yBAAyB,qDAAY;AACjF;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA,gCAAgC,sDAAa,yBAAyB,sDAAa;AACnF;AACA;AACA;AACA;AACA,kCAAkC,mDAAU,4BAA4B,mDAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;AC7QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACG;AAClB;AACK;AACK;AACY;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAM;AAC5C;AACA,wCAAwC,uEAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAa;AACtD;AACA,oCAAoC,sDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA,4FAA4F,wBAAwB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAW,eAAe,aAAa,GAAG,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,KAAK;AACrE;AACA;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,wFAAwF,mBAAmB;AAC3G;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAsC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,GAAG,eAAe;AACrD;AACA;AACA;AACA;AACA,8BAA8B,EAAE,mBAAmB;AACnD;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,GAAG,eAAe;AACrD;AACA;AACA;AACA;AACA,8BAA8B,EAAE,mBAAmB;AACnD;AACA,sBAAsB,aAAa;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAO;AAC1B;AACA;AACA,gBAAgB;AAChB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gC;;;;;;;AC9mBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACI;AACR;AAC/C;AACA,wCAAwC,6CAAI;AAC5C,eAAe,6CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C,EAAE,gBAAgB,GAAG,gCAAgC;AAC5H,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,eAAe,GAAG,4BAA4B,EAAE,iCAAiC;AAC/G;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,EAAE;AACF,EAAE;AACF;AACA;AACA;AACA,qDAAqD,8GAA8G;AACnK,+CAA+C,qJAAqJ;AACpM;AACA;AACA;AACA,qDAAqD,wGAAwG;AAC7J,+CAA+C,6IAA6I;AAC5L,gBAAgB;AAChB;AACA;AACA,2CAA2C,wBAAwB,OAAO,oEAAoE;AAC9I,uCAAuC,qCAAqC,OAAO,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB,OAAO,oFAAoF;AAC9J,uCAAuC,qCAAqC,OAAO,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,0GAA0G;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gHAAgH;AAC7I;AACA,uCAAuC,qCAAqC,OAAO,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAI,6CAA6C,qDAAY;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAI;AAClC,4BAA4B,qDAAY;AACxC,qBAAqB,gEAAgE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,qDAAqD;AAC7I;AACA;AACA;AACA,gCAAgC,gHAAgH;AAChJ;AACA,oCAAoC,8FAA8F;AAClI,aAAa;AACb,SAAS;AACT;AACA,2EAA2E,4BAA4B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qDAAY;AAC/E;AACA;AACA,qBAAqB,mEAAW;AAChC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;ACjWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACd;AACkB;AACZ;AACiB;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC,qDAAqD;AACjH;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,+BAA+B,WAAW,4BAA4B,EAAE;AACxE;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC,2BAA2B,6CAAI,4BAA4B;AACvH;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,2BAA2B,sBAAsB;AACjD;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA,qDAAqD,UAAU,aAAa,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,aAAa,UAAU;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG,SAAS,MAAM,iBAAiB,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG,aAAa,KAAK,SAAS,UAAU,EAAE;AACnG,kCAAkC,MAAM,YAAY,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG,aAAa,KAAK,WAAW,gBAAgB,GAAG;AAC5G,kCAAkC,MAAM,YAAY,eAAe;AACnE;AACA;AACA;AACA,sDAAsD,GAAG,SAAS,KAAK,yBAAyB,MAAM;AACtG;AACA;AACA,+DAA+D,GAAG,aAAa,KAAK;AACpF,gCAAgC,gBAAgB,gBAAgB,MAAM;AACtE;AACA;AACA;AACA;AACA,iEAAiE,GAAG,aAAa,KAAK,WAAW,gBAAgB,GAAG;AACpH,0CAA0C,MAAM,aAAa,kBAAkB,YAAY,EAAE;AAC7F;AACA,qBAAqB;AACrB;AACA;AACA,2CAA2C,uDAAS;AACpD,sDAAsD,GAAG,aAAa,KAAK,uBAAuB,MAAM;AACxG;AACA,yBAAyB,mEAAW,eAAe,mBAAmB,GAAG,WAAW,sDAAa,0BAA0B;AAC3H,sDAAsD,GAAG,aAAa,KAAK,eAAe,MAAM;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,GAAG,cAAc,KAAK,iBAAiB,MAAM;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,eAAe,aAAa,UAAU;AAC1F;AACA;AACA,oCAAoC,iDAAM;AAC1C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAS,YAAY,sDAAa;AACrE;AACA;AACA,oEAAoE,KAAK,uBAAuB,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK,wBAAwB,MAAM;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA,wBAAwB;AACxB;AACA;AACA,8CAA8C,mBAAmB;AACjE,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4EAA4E,yBAAyB,GAAG,KAAK;AAC7G,kBAAkB,MAAM,EAAE,EAAE,qEAAqE;AACjG;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,+EAA+E,yBAAyB,GAAG,KAAK;AAChH;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA,wCAAwC,KAAK,KAAK,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACjXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACZ;AAChC;AACP;AACA,QAAQ,sEAAM;AACd,aAAa,mDAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAO;AAC3B;AACA;AACA;AACA,QAAQ,sEAAM;AACd,oBAAoB,mDAAO;AAC3B;AACA;AACA,QAAQ,sEAAM;AACd,aAAa,mDAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA,oBAAoB,gBAAgB,OAAO,qBAAqB;AAChE;AACA;AACA,oBAAoB,gBAAgB,GAAG,uBAAuB;AAC9D;AACA,aAAa,mDAAO;AACpB;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACpDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB;AACxB,mC;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACX;AACE;AAC1C;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAS;AACnC;AACA,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC,MAAM,sDAAa;AAC5E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACD;AACP;AACJ;AACiE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAM;AACV,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,yEAAyE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,0BAA0B,mDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA,yDAAyD,oCAAoC;AAC7F;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA,iCAAiC,sDAAa;AAC9C,mBAAmB,8DAAY;AAC/B;AACA,iCAAiC,sDAAa;AAC9C,uBAAuB,uDAAS;AAChC;AACA,QAAQ,sEAAM,yDAAyD,UAAU;AACjF;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,4CAA4C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,uDAAc;AAC5C;AACA;AACA,mCAAmC,0DAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAU;AAClC;AACA;AACA;AACA;AACA,kC;;;;;;;AC5YA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;ACnBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACd;AACgC;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAQ,0BAA0B,iDAAQ;AACpF;AACA;AACA;AACA,6BAA6B,iDAAM;AACnC;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAQ,0BAA0B,iDAAQ;AACvF;AACA;AACA;AACA,6BAA6B,iDAAM;AACnC;AACA;AACA;AACA,oCAAoC,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAU,uBAAuB,mDAAU;AAC/E,uEAAuE,KAAK,OAAO,KAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAY;AAC/C,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,sEAAM;AACd;AACA,QAAQ,sEAAM;AACd;AACA;AACA,mCAAmC,qDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB,4CAA4C,qDAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA,YAAY,sEAAM;AAClB,4CAA4C,qDAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,6CAAI,iEAAiE,6CAAI;AAChJ;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;AC3LA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACrC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa,GAAG,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;ACjEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kC;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACwB;AACF;AACX;AAC9D;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAc;AAC1C;AACA;AACA,4BAA4B,0DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,+DAA+D,uBAAuB;AACtF,aAAa,sFAAa;AAC1B;AACA;AACA;AACA,YAAY,8FAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,0CAA0C,QAAQ,iCAAiC,SAAS;AAC5F,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ,kCAAkC,gBAAgB;AACpG,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB,GAAG,wBAAwB;AAC/D;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,qFAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uBAAuB;AAClG;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,wDAAwD,EAAE;AAC1D;AACA,sDAAsD,iDAAiD;AACvG,oDAAoD,EAAE;AACtD,4BAA4B,WAAW,OAAO,qDAAqD;AACnG;AACA;AACA,oCAAoC,0CAA0C;AAC9E;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;AC1iBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA,yBAAyB,cAAc;AACvC,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;ACtHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;AACI;AACO;AACuB;AACM;AAClC;;AAElD;;AAEA;;AAEO,6BAA6B,yDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,MAAM,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uEAAU;AACrB;AACA;AACA;AACA;AACA,MAAM,uEAAQ;AACd,MAAM,iFAAW;AACjB,MAAM,mHAAsB;AAC5B,sBAAsB,oEAAW;AACjC,MAAM,4HAAyB;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACF;AACN;AACA;AACyB;AACpB;AACuB;AAC9B;AACE;AACkC;AAC7E;AACA;AACA,0BAA0B,KAAK;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO,EAAE,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,oEAAK,2EAA2E,gFAAgB,gBAAgB,wBAAwB;AAC/J;AACA,mBAAmB,oEAAK,uDAAuD,gFAAgB;AAC/F;AACA,eAAe,oEAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAE,cAAc,0CAA0C;AACrF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY,mEAAK;AACjB;AACA,0FAA0F,EAAE;AAC5F;AACA,sCAAsC,0CAA0C;AAChF,QAAQ,sEAAM,iHAAiH,SAAS;AACxI;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd,gCAAgC,CAAC,+DAAQ,EAAE,yEAAW,EAAE,oHAAyB,EAAE,2GAAsB,aAAa,uDAAS,qCAAqC;AACpK;AACA;AACA,kC;;;;;;;AC/GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;;AAEA;AAC8B;;;;;;;;ACb9B;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;;;;;;ACPP;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;;;;;;ACPP;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA,uBAAuB,UAAU;AACjC;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK,GAAG,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEkE;AACxB;;AAEvD;AACA;AACA;AACA;AACO,0BAA0B,iGAAa,CAAC,qEAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3KA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;;AAEsC;;;;;;;;AC7JtC;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACP;AACH;AACF;AACE;AACzC;AACA;AACA;AACO,8BAA8B,qDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,iFAAiF,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS,yBAAyB,SAAS,aAAa,GAAG,WAAW;AACrI,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,gBAAgB;AACzC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAQ,sBAAsB,qDAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAU,sBAAsB,wDAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAU,sBAAsB,wDAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAU,sBAAsB,wDAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;ACpQA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACH;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAU,4BAA4B,wDAAa;AAC3F,oDAAoD,sCAAsC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,uDAAuD;AACvD,gCAAgC;AAChC;AACA,oC;;;;;;;ACpKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEoC;AACD;AAC2B;;AAEpE,qCAAqC,yFAAyB;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wCAAwC,QAAQ,MAAM;AACxE;AACA;AACA;AACA,iCAAiC,2BAA2B,MAAM,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,OAAO,KAAK;AACZ,OAAO,gEAAgE;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB,MAAM;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,cAAc,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAM,6DAA6D,SAAS,sBAAsB,aAAa;AACnH,oBAAoB,0DAA0D,GAAG,YAAY,qBAAqB,EAAE,EAAE;;AAEtH;AACA;AACA,yBAAyB,OAAO;AAChC,qFAAqF,OAAO;;AAE5F;AACA;AACA;AACA;AACA,0BAA0B,EAAE,WAAW,cAAc;AACrD,eAAe,EAAE,KAAK,cAAc;AACpC,OAAO;AACP,sBAAsB,kDAAkD,GAAG,iCAAiC,EAAE;;AAE9G;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEiC;;AAE9C;AACA;;AAEA;AACA;AACA;AACO,wCAAwC,4DAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,YAAY,qBAAqB,YAAY,UAAU;AAClG;AACA;;;;;;;;AChDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;;AAEA,iFAAiF,SAAS,kBAAkB,OAAO,cAAc,0BAA0B,oBAAoB;AAC/K;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEoB","file":"worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*\n * @license\n * Copyright (c) 2019 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {ParticleExecutionContext} from '../../../build/runtime/particle-execution-context.js';\nimport {PlatformLoader} from '../../../build/platform/loader-web.js';\n\nself.onmessage = function(e) {\n  self.onmessage = null;\n  const {id, base} = e.data;\n  new ParticleExecutionContext(e.ports[0], id, new PlatformLoader(base));\n};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { PECInnerPort } from './api-channel.js';\nimport { handleFor } from './handle.js';\nimport { Id } from './id.js';\nimport { StorageProxy, StorageProxyScheduler } from './storage-proxy.js';\nexport class ParticleExecutionContext {\n    constructor(port, idBase, loader) {\n        this.particles = [];\n        this.pendingLoads = [];\n        this.scheduler = new StorageProxyScheduler();\n        this.keyedProxies = {};\n        const pec = this;\n        this.apiPort = new class extends PECInnerPort {\n            onDefineHandle(identifier, type, name) {\n                return StorageProxy.newProxy(identifier, type, this, pec, pec.scheduler, name);\n            }\n            onGetBackingStoreCallback(callback, type, name, id, storageKey) {\n                const proxy = StorageProxy.newProxy(id, type, this, pec, pec.scheduler, name);\n                proxy.storageKey = storageKey;\n                return [proxy, () => callback(proxy, storageKey)];\n            }\n            onCreateHandleCallback(callback, type, name, id) {\n                const proxy = StorageProxy.newProxy(id, type, this, pec, pec.scheduler, name);\n                return [proxy, () => callback(proxy)];\n            }\n            onMapHandleCallback(callback, id) {\n                return [id, () => callback(id)];\n            }\n            onCreateSlotCallback(callback, hostedSlotId) {\n                return [hostedSlotId, () => callback(hostedSlotId)];\n            }\n            onInnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) {\n                transformationParticle.renderHostedSlot(transformationSlotName, hostedSlotId, content);\n            }\n            onStop() {\n                if (global['close']) {\n                    global['close']();\n                }\n            }\n            onInstantiateParticle(id, spec, handles) {\n                return pec._instantiateParticle(id, spec, handles);\n            }\n            onSimpleCallback(callback, data) {\n                callback(data);\n            }\n            onConstructArcCallback(callback, arc) {\n                callback(arc);\n            }\n            onAwaitIdle(version) {\n                pec.idle.then(a => {\n                    // TODO: dom-particles update is async, this is a workaround to allow dom-particles to\n                    // update relevance, after handles are updated. Needs better idle signal.\n                    setTimeout(() => { this.Idle(version, pec.relevance); }, 0);\n                });\n            }\n            onUIEvent(particle, slotName, event) {\n                particle.fireEvent(slotName, event);\n            }\n            onStartRender(particle, slotName, providedSlots, contentTypes) {\n                const apiPort = this;\n                /**\n                 * A representation of a consumed slot. Retrieved from a particle using\n                 * particle.getSlot(name)\n                 */\n                class Slotlet {\n                    constructor(particle, slotName, providedSlots) {\n                        this.handlers = new Map();\n                        this.requestedContentTypes = new Set();\n                        this._isRendered = false;\n                        this.slotName = slotName;\n                        this.particle = particle;\n                        this.providedSlots = providedSlots;\n                    }\n                    get isRendered() { return this._isRendered; }\n                    /**\n                     * renders content to the slot.\n                     */\n                    render(content) {\n                        apiPort.Render(particle, slotName, content);\n                        Object.keys(content).forEach(key => { this.requestedContentTypes.delete(key); });\n                        // Slot is considered rendered, if a non-empty content was sent and all requested content types were fullfilled.\n                        this._isRendered = this.requestedContentTypes.size === 0 && (Object.keys(content).length > 0);\n                    }\n                    /** @method registerEventHandler(name, f)\n                     * registers a callback to be invoked when 'name' event happens.\n                     */\n                    registerEventHandler(name, f) {\n                        if (!this.handlers.has(name)) {\n                            this.handlers.set(name, []);\n                        }\n                        this.handlers.get(name).push(f);\n                    }\n                    clearEventHandlers(name) {\n                        this.handlers.set(name, []);\n                    }\n                    fireEvent(event) {\n                        for (const handler of this.handlers.get(event.handler) || []) {\n                            handler(event);\n                        }\n                    }\n                }\n                particle.slotByName.set(slotName, new Slotlet(particle, slotName, providedSlots));\n                particle.renderSlot(slotName, contentTypes);\n            }\n            onStopRender(particle, slotName) {\n                assert(particle.slotByName.has(slotName), `Stop render called for particle ${particle.spec.name} slot ${slotName} without start render being called.`);\n                particle.slotByName.delete(slotName);\n            }\n        }(port);\n        this.idBase = Id.newSessionId().fromString(idBase);\n        this.loader = loader;\n        loader.setParticleExecutionContext(this);\n        /*\n         * This code ensures that the relevant types are known\n         * in the scope object, because otherwise we can't do\n         * particleSpec resolution, which is currently a necessary\n         * part of particle construction.\n         *\n         * Possibly we should eventually consider having particle\n         * specifications separated from particle classes - and\n         * only keeping type information on the arc side.\n         */\n    }\n    generateID() {\n        return this.idBase.createId().toString();\n    }\n    innerArcHandle(arcId, particleId) {\n        const pec = this;\n        return {\n            createHandle(type, name, hostParticle) {\n                return new Promise((resolve, reject) => pec.apiPort.ArcCreateHandle(proxy => {\n                    const handle = handleFor(proxy, name, particleId);\n                    resolve(handle);\n                    if (hostParticle) {\n                        proxy.register(hostParticle, handle);\n                    }\n                }, arcId, type, name));\n            },\n            mapHandle(handle) {\n                return new Promise((resolve, reject) => pec.apiPort.ArcMapHandle(id => {\n                    resolve(id);\n                }, arcId, handle));\n            },\n            createSlot(transformationParticle, transformationSlotName, handleId) {\n                // handleId: the ID of a handle (returned by `createHandle` above) this slot is rendering; null - if not applicable.\n                // TODO: support multiple handle IDs.\n                return new Promise((resolve, reject) => pec.apiPort.ArcCreateSlot(hostedSlotId => resolve(hostedSlotId), arcId, transformationParticle, transformationSlotName, handleId));\n            },\n            loadRecipe(recipe) {\n                // TODO: do we want to return a promise on completion?\n                return new Promise((resolve, reject) => pec.apiPort.ArcLoadRecipe(arcId, recipe, response => {\n                    if (response.error) {\n                        reject(response.error);\n                    }\n                    else {\n                        resolve(response);\n                    }\n                }));\n            }\n        };\n    }\n    getStorageProxy(storageKey, type) {\n        if (!this.keyedProxies[storageKey]) {\n            this.keyedProxies[storageKey] = new Promise((resolve, reject) => {\n                this.apiPort.GetBackingStore((proxy, storageKey) => {\n                    this.keyedProxies[storageKey] = proxy;\n                    resolve(proxy);\n                }, storageKey, type);\n            });\n        }\n        return this.keyedProxies[storageKey];\n    }\n    defaultCapabilitySet() {\n        return {\n            constructInnerArc: particle => {\n                return new Promise((resolve, reject) => this.apiPort.ConstructInnerArc(arcId => resolve(this.innerArcHandle(arcId, particle.id)), particle));\n            }\n        };\n    }\n    async _instantiateParticle(id, spec, proxies) {\n        const name = spec.name;\n        let resolve = null;\n        const p = new Promise(res => resolve = res);\n        this.pendingLoads.push(p);\n        const clazz = await this.loader.loadParticleClass(spec);\n        const capabilities = this.defaultCapabilitySet();\n        const particle = new clazz(); // TODO: how can i add an argument to DomParticle ctor?\n        particle.id = id;\n        particle.capabilities = capabilities;\n        this.particles.push(particle);\n        const handleMap = new Map();\n        const registerList = [];\n        proxies.forEach((proxy, name) => {\n            const connSpec = spec.connectionMap.get(name);\n            const handle = handleFor(proxy, name, id, connSpec.isInput, connSpec.isOutput);\n            handleMap.set(name, handle);\n            // Defer registration of handles with proxies until after particles have a chance to\n            // configure them in setHandles.\n            registerList.push({ proxy, particle, handle });\n        });\n        return [particle, async () => {\n                await particle.setHandles(handleMap);\n                registerList.forEach(({ proxy, particle, handle }) => proxy.register(particle, handle));\n                const idx = this.pendingLoads.indexOf(p);\n                this.pendingLoads.splice(idx, 1);\n                resolve();\n            }];\n    }\n    get relevance() {\n        const rMap = new Map();\n        this.particles.forEach(p => {\n            if (p.relevances.length === 0) {\n                return;\n            }\n            rMap.set(p, p.relevances);\n            p.relevances = [];\n        });\n        return rMap;\n    }\n    get busy() {\n        if (this.pendingLoads.length > 0 || this.scheduler.busy) {\n            return true;\n        }\n        if (this.particles.filter(particle => particle.busy).length > 0) {\n            return true;\n        }\n        return false;\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        const busyParticlePromises = this.particles.filter(particle => particle.busy).map(particle => particle.idle);\n        return Promise.all([this.scheduler.idle, ...this.pendingLoads, ...busyParticlePromises]).then(() => this.idle);\n    }\n}\n//# sourceMappingURL=particle-execution-context.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport function assert(test, message) {\n  if (!test) {\n    debugger; // eslint-disable-line no-debugger\n    throw new Error(message);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { assert } from '../platform/assert-web.js';\nimport { DevtoolsConnection } from './debug/devtools-connection.js';\nimport { OuterPortAttachment } from './debug/outer-port-attachment.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { Type } from './type.js';\nvar MappingType;\n(function (MappingType) {\n    MappingType[MappingType[\"Mapped\"] = 0] = \"Mapped\";\n    MappingType[MappingType[\"LocalMapped\"] = 1] = \"LocalMapped\";\n    MappingType[MappingType[\"RemoteMapped\"] = 2] = \"RemoteMapped\";\n    MappingType[MappingType[\"Direct\"] = 3] = \"Direct\";\n    MappingType[MappingType[\"ObjectMap\"] = 4] = \"ObjectMap\";\n    MappingType[MappingType[\"List\"] = 5] = \"List\";\n    MappingType[MappingType[\"ByLiteral\"] = 6] = \"ByLiteral\";\n})(MappingType || (MappingType = {}));\nconst targets = new Map();\nfunction setPropertyKey(target, propertyKey) {\n    if (!targets.has(target)) {\n        targets.set(target, new Map());\n    }\n    if (!targets.get(target).has(propertyKey)) {\n        targets.get(target).set(propertyKey, []);\n    }\n}\nfunction set(target, propertyKey, parameterIndex, info) {\n    setPropertyKey(target, propertyKey);\n    targets.get(target).get(propertyKey)[parameterIndex] = info;\n}\nfunction Direct(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct });\n}\nfunction Mapped(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Mapped });\n}\nfunction ByLiteral(constructor) {\n    return (target, propertyKey, parameterIndex) => {\n        const info = { type: MappingType.ByLiteral, converter: constructor };\n        set(target.constructor, propertyKey, parameterIndex, info);\n    };\n}\nfunction ObjectMap(key, value) {\n    return (target, propertyKey, parameterIndex) => {\n        const info = { type: MappingType.ObjectMap, key: { type: key }, value: { type: value } };\n        set(target.constructor, propertyKey, parameterIndex, info);\n    };\n}\nfunction List(value) {\n    return (target, propertyKey, parameterIndex) => {\n        const info = { type: MappingType.List, value: { type: value } };\n        set(target.constructor, propertyKey, parameterIndex, info);\n    };\n}\nfunction LocalMapped(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.LocalMapped });\n}\nfunction RemoteMapped(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.RemoteMapped });\n}\nfunction NoArgs(target, propertyKey) {\n    setPropertyKey(target.constructor, propertyKey);\n}\nfunction RedundantInitializer(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, redundant: true });\n}\nfunction Initializer(target, propertyKey, parameterIndex) {\n    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true });\n}\nfunction Identifier(target, propertyKey, parameterIndex) {\n    assert(targets.get(target.constructor));\n    assert(targets.get(target.constructor).get(propertyKey));\n    assert(targets.get(target.constructor).get(propertyKey)[parameterIndex]);\n    targets.get(target.constructor).get(propertyKey)[parameterIndex].identifier = true;\n}\nfunction RemoteIgnore(target, propertyKey, parameterIndex) {\n    assert(targets.get(target.constructor));\n    assert(targets.get(target.constructor).get(propertyKey));\n    assert(targets.get(target.constructor).get(propertyKey)[parameterIndex]);\n    targets.get(target.constructor).get(propertyKey)[parameterIndex].ignore = true;\n}\nclass ThingMapper {\n    constructor(prefix) {\n        this._prefix = prefix;\n        this._nextIdentifier = 0;\n        this._idMap = new Map();\n        this._reverseIdMap = new Map();\n    }\n    _newIdentifier() {\n        return this._prefix + (this._nextIdentifier++);\n    }\n    createMappingForThing(thing, requestedId = undefined) {\n        assert(!this._reverseIdMap.has(thing));\n        let id;\n        if (requestedId) {\n            id = requestedId;\n        }\n        else if (thing.apiChannelMappingId) {\n            id = thing.apiChannelMappingId;\n        }\n        else {\n            id = this._newIdentifier();\n        }\n        assert(!this._idMap.has(id), `${requestedId ? 'requestedId' : (thing.apiChannelMappingId ? 'apiChannelMappingId' : 'newIdentifier()')} ${id} already in use`);\n        this.establishThingMapping(id, thing);\n        return id;\n    }\n    maybeCreateMappingForThing(thing) {\n        if (this.hasMappingForThing(thing)) {\n            return this.identifierForThing(thing);\n        }\n        return this.createMappingForThing(thing);\n    }\n    async establishThingMapping(id, thing) {\n        let continuation;\n        if (Array.isArray(thing)) {\n            [thing, continuation] = thing;\n        }\n        this._idMap.set(id, thing);\n        if (thing instanceof Promise) {\n            assert(continuation == null);\n            await this.establishThingMapping(id, await thing);\n        }\n        else {\n            this._reverseIdMap.set(thing, id);\n            if (continuation) {\n                await continuation();\n            }\n        }\n    }\n    hasMappingForThing(thing) {\n        return this._reverseIdMap.has(thing);\n    }\n    identifierForThing(thing) {\n        assert(this._reverseIdMap.has(thing), `Missing thing [${thing}]`);\n        return this._reverseIdMap.get(thing);\n    }\n    thingForIdentifier(id) {\n        assert(this._idMap.has(id), `Missing id: ${id}`);\n        return this._idMap.get(id);\n    }\n}\nexport class APIPort {\n    constructor(messagePort, prefix) {\n        this._port = messagePort;\n        this._mapper = new ThingMapper(prefix);\n        this._port.onmessage = async (e) => this._processMessage(e);\n        this._debugAttachment = null;\n        this._attachStack = false;\n        this.messageCount = 0;\n        this._testingHook();\n    }\n    // Overridden by unit tests.\n    _testingHook() {\n    }\n    close() {\n        this._port.close();\n    }\n    async _processMessage(e) {\n        assert(this['before' + e.data.messageType] !== undefined);\n        const count = this.messageCount++;\n        if (this._debugAttachment) {\n            this._debugAttachment.handlePecMessage('on' + e.data.messageType, e.data.messageBody, count, e.data.stack);\n        }\n        this['before' + e.data.messageType](e.data.messageBody);\n    }\n    send(name, args) {\n        const call = { messageType: name, messageBody: args, stack: this._attachStack ? new Error().stack : undefined };\n        const count = this.messageCount++;\n        if (this._debugAttachment) {\n            this._debugAttachment.handlePecMessage(name, args, count, new Error().stack);\n        }\n        this._port.postMessage(call);\n    }\n}\n// The horror. From https://davidwalsh.name/javascript-arguments\nfunction getArgs(func) {\n    // First match everything inside the function argument parens.\n    const args = func.toString().match(/.*?\\(([^)]*)\\)/)[1];\n    // Split the arguments string into an array comma delimited.\n    return args.split(',').map((arg) => {\n        // Ensure no inline comments are parsed and trim the whitespace.\n        return arg.replace(/\\/\\*.*\\*\\//, '').trim();\n        // Ensure no undefined values are added.\n    }).filter((arg) => arg);\n}\n// value is covariant with info, and errors will be found\n// at start of runtime. \n// tslint:disable-next-line: no-any\nfunction convert(info, value, mapper) {\n    switch (info.type) {\n        case MappingType.Mapped:\n            return mapper.identifierForThing(value);\n        case MappingType.LocalMapped:\n            return mapper.maybeCreateMappingForThing(value);\n        case MappingType.RemoteMapped:\n            // This is on the local side, so we don't do anything here.\n            return value;\n        case MappingType.Direct:\n            return value;\n        case MappingType.ObjectMap:\n            const r = {};\n            value.forEach((childvalue, key) => r[convert(info.key, key, mapper)] = convert(info.value, childvalue, mapper));\n            return r;\n        case MappingType.List:\n            return value.map(v => convert(info.value, v, mapper));\n        case MappingType.ByLiteral:\n            return value.toLiteral();\n        default:\n            throw new Error(`Can't yet send MappingType ${info.type}`);\n    }\n}\n// value is covariant with info, and errors will be found\n// at start of runtime. \n// tslint:disable-next-line: no-any\nfunction unconvert(info, value, mapper) {\n    switch (info.type) {\n        case MappingType.Mapped:\n            return mapper.thingForIdentifier(value);\n        case MappingType.LocalMapped:\n            // This is on the remote side, so we don't do anything here.\n            return value;\n        case MappingType.RemoteMapped:\n            return mapper.thingForIdentifier(value);\n        case MappingType.Direct:\n            return value;\n        case MappingType.ObjectMap:\n            const r = new Map();\n            for (const key of Object.keys(value)) {\n                r.set(unconvert(info.key, key, mapper), unconvert(info.value, value[key], mapper));\n            }\n            return r;\n        case MappingType.List:\n            return value.map(v => unconvert(info.value, v, mapper));\n        case MappingType.ByLiteral:\n            return info.converter.fromLiteral(value);\n        default:\n            throw new Error(`Can't yet recieve MappingType ${info.type}`);\n    }\n}\nfunction AutoConstruct(target) {\n    return (constructor) => {\n        const doConstruct = (me, other) => {\n            const functions = targets.get(me);\n            for (const f of functions.keys()) {\n                const argNames = getArgs(me.prototype[f]);\n                const descriptor = functions.get(f);\n                // If this descriptor is for an initializer, record that fact and we'll process it after\n                // the rest of the arguments.\n                const initializer = descriptor.findIndex(d => d.initializer);\n                // If this descriptor records that this argument is the identifier, record it\n                // as the requestedId for mapping below.\n                const requestedId = descriptor.findIndex(d => d.identifier);\n                function impl(...args) {\n                    const messageBody = {};\n                    for (let i = 0; i < descriptor.length; i++) {\n                        if (i === initializer) {\n                            continue;\n                        }\n                        // Process this argument.\n                        messageBody[argNames[i]] = convert(descriptor[i], args[i], this._mapper);\n                    }\n                    // Process the initializer if present.\n                    if (initializer !== -1) {\n                        if (descriptor[initializer].redundant) {\n                            assert(requestedId === -1);\n                            messageBody['identifier'] = this._mapper.maybeCreateMappingForThing(args[initializer]);\n                        }\n                        else {\n                            messageBody['identifier'] = this._mapper.createMappingForThing(args[initializer], args[requestedId]);\n                        }\n                    }\n                    this.send(f, messageBody);\n                }\n                async function before(messageBody) {\n                    const args = [];\n                    const promises = [];\n                    for (let i = 0; i < descriptor.length; i++) {\n                        // If there's a requestedId then the receiving end won't expect to\n                        // see the identifier as well.\n                        if (i === initializer && (requestedId !== -1 || descriptor[i].ignore)) {\n                            continue;\n                        }\n                        const argName = i === initializer ? 'identifier' : argNames[i];\n                        const result = unconvert(descriptor[i], messageBody[argName], this._mapper);\n                        if (result instanceof Promise) {\n                            promises.push({ promise: result, position: args.length });\n                            args.push(() => unconvert(descriptor[i], messageBody[argName], this._mapper));\n                        }\n                        else {\n                            args.push(result);\n                        }\n                    }\n                    if (promises.length > 0) {\n                        await Promise.all(promises.map(a => a.promise));\n                        promises.forEach(a => args[a.position] = args[a.position]());\n                    }\n                    const result = this['on' + f](...args);\n                    // If this message is an initializer, need to establish a mapping\n                    // with the result of processing the message.\n                    if (initializer > -1) {\n                        assert(messageBody['identifier']);\n                        await this._mapper.establishThingMapping(messageBody['identifier'], result);\n                    }\n                }\n                Object.defineProperty(me.prototype, f, {\n                    get() {\n                        return impl;\n                    }\n                });\n                Object.defineProperty(other.prototype, 'before' + f, {\n                    get() {\n                        return before;\n                    }\n                });\n            }\n        };\n        doConstruct(constructor, target);\n        doConstruct(target, constructor);\n    };\n}\nexport class PECOuterPort extends APIPort {\n    constructor(messagePort, arc) {\n        super(messagePort, 'o');\n        DevtoolsConnection.onceConnected.then(devtoolsChannel => {\n            this.DevToolsConnected();\n            this._debugAttachment = new OuterPortAttachment(arc, devtoolsChannel);\n        });\n    }\n    Stop() { }\n    DefineHandle(handle, type, name) { }\n    InstantiateParticle(particle, id, spec, handles) { }\n    UIEvent(particle, slotName, event) { }\n    SimpleCallback(callback, data) { }\n    AwaitIdle(version) { }\n    StartRender(particle, slotName, providedSlots, contentTypes) { }\n    StopRender(particle, slotName) { }\n    GetBackingStoreCallback(store, callback, type, name, id, storageKey) { }\n    ConstructArcCallback(callback, arc) { }\n    CreateHandleCallback(handle, callback, type, name, id) { }\n    MapHandleCallback(newHandle, callback, id) { }\n    CreateSlotCallback(slot, callback, hostedSlotId) { }\n    InnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) { }\n    // We need an API call to tell the context side that DevTools has been connected, so it can start sending\n    // stack traces attached to the API calls made from that side.\n    DevToolsConnected() { }\n}\n__decorate([\n    NoArgs\n], PECOuterPort.prototype, \"Stop\", null);\n__decorate([\n    __param(0, RedundantInitializer), __param(1, ByLiteral(Type)), __param(2, Direct)\n], PECOuterPort.prototype, \"DefineHandle\", null);\n__decorate([\n    __param(0, Initializer), __param(1, Identifier), __param(1, Direct), __param(2, ByLiteral(ParticleSpec)), __param(3, ObjectMap(MappingType.Direct, MappingType.Mapped))\n], PECOuterPort.prototype, \"InstantiateParticle\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct)\n], PECOuterPort.prototype, \"UIEvent\", null);\n__decorate([\n    __param(0, RemoteMapped), __param(1, Direct)\n], PECOuterPort.prototype, \"SimpleCallback\", null);\n__decorate([\n    __param(0, Direct)\n], PECOuterPort.prototype, \"AwaitIdle\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, ObjectMap(MappingType.Direct, MappingType.Direct)), __param(3, List(MappingType.Direct))\n], PECOuterPort.prototype, \"StartRender\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct)\n], PECOuterPort.prototype, \"StopRender\", null);\n__decorate([\n    __param(0, Initializer), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct), __param(4, Identifier), __param(4, Direct), __param(5, Direct)\n], PECOuterPort.prototype, \"GetBackingStoreCallback\", null);\n__decorate([\n    __param(0, RemoteMapped), __param(1, LocalMapped)\n], PECOuterPort.prototype, \"ConstructArcCallback\", null);\n__decorate([\n    __param(0, Initializer), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct), __param(4, Identifier), __param(4, Direct)\n], PECOuterPort.prototype, \"CreateHandleCallback\", null);\n__decorate([\n    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)\n], PECOuterPort.prototype, \"MapHandleCallback\", null);\n__decorate([\n    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)\n], PECOuterPort.prototype, \"CreateSlotCallback\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct), __param(3, Direct)\n], PECOuterPort.prototype, \"InnerArcRender\", null);\n__decorate([\n    NoArgs\n], PECOuterPort.prototype, \"DevToolsConnected\", null);\nlet PECInnerPort = class PECInnerPort extends APIPort {\n    constructor(messagePort) {\n        super(messagePort, 'i');\n    }\n    Render(particle, slotName, content) { }\n    InitializeProxy(handle, callback) { }\n    SynchronizeProxy(handle, callback) { }\n    HandleGet(handle, callback) { }\n    HandleToList(handle, callback) { }\n    HandleSet(handle, data, particleId, barrier) { }\n    HandleClear(handle, particleId, barrier) { }\n    HandleStore(handle, callback, data, particleId) { }\n    HandleRemove(handle, callback, data, particleId) { }\n    HandleRemoveMultiple(handle, callback, data, particleId) { }\n    HandleStream(handle, callback, pageSize, forward) { }\n    StreamCursorNext(handle, callback, cursorId) { }\n    StreamCursorClose(handle, cursorId) { }\n    Idle(version, relevance) { }\n    GetBackingStore(callback, storageKey, type) { }\n    ConstructInnerArc(callback, particle) { }\n    ArcCreateHandle(callback, arc, type, name) { }\n    ArcMapHandle(callback, arc, handle) { }\n    ArcCreateSlot(callback, arc, transformationParticle, transformationSlotName, handleId) { }\n    ArcLoadRecipe(arc, recipe, callback) { }\n    RaiseSystemException(exception, methodName, particleId) { }\n    // To show stack traces for calls made inside the context, we need to capture the trace at the call point and\n    // send it along with the message. We only want to do this after a DevTools connection has been detected, which\n    // we can't directly detect inside a worker context, so the PECOuterPort will send an API message instead.\n    onDevToolsConnected() {\n        this._attachStack = true;\n    }\n};\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct)\n], PECInnerPort.prototype, \"Render\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"InitializeProxy\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"SynchronizeProxy\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"HandleGet\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped)\n], PECInnerPort.prototype, \"HandleToList\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleSet\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct), __param(2, Direct)\n], PECInnerPort.prototype, \"HandleClear\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleStore\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleRemove\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleRemoveMultiple\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)\n], PECInnerPort.prototype, \"HandleStream\", null);\n__decorate([\n    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct)\n], PECInnerPort.prototype, \"StreamCursorNext\", null);\n__decorate([\n    __param(0, Mapped), __param(1, Direct)\n], PECInnerPort.prototype, \"StreamCursorClose\", null);\n__decorate([\n    __param(0, Direct), __param(1, ObjectMap(MappingType.Mapped, MappingType.Direct))\n], PECInnerPort.prototype, \"Idle\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, Direct), __param(2, ByLiteral(Type))\n], PECInnerPort.prototype, \"GetBackingStore\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, Mapped)\n], PECInnerPort.prototype, \"ConstructInnerArc\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct)\n], PECInnerPort.prototype, \"ArcCreateHandle\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped)\n], PECInnerPort.prototype, \"ArcMapHandle\", null);\n__decorate([\n    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped), __param(3, Direct), __param(4, Direct)\n], PECInnerPort.prototype, \"ArcCreateSlot\", null);\n__decorate([\n    __param(0, RemoteMapped), __param(1, Direct), __param(2, LocalMapped)\n], PECInnerPort.prototype, \"ArcLoadRecipe\", null);\n__decorate([\n    __param(0, Direct), __param(1, Direct), __param(2, Direct)\n], PECInnerPort.prototype, \"RaiseSystemException\", null);\nPECInnerPort = __decorate([\n    AutoConstruct(PECOuterPort)\n], PECInnerPort);\nexport { PECInnerPort };\n//# sourceMappingURL=api-channel.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { DevtoolsBroker } from '../../../devtools/shared/devtools-broker.js';\nimport { assert } from '../../platform/assert-web.js';\nimport { DevtoolsChannel } from '../../platform/devtools-channel-web.js';\nimport { DevtoolsChannelStub } from './testing/devtools-channel-stub.js';\nlet channel = null;\nlet isConnected = false;\nlet onceConnectedResolve = null;\nlet onceConnected = new Promise(resolve => onceConnectedResolve = resolve);\nDevtoolsBroker.onceConnected.then(() => {\n    DevtoolsConnection.ensure();\n    onceConnectedResolve(channel);\n    isConnected = true;\n});\nexport class DevtoolsConnection {\n    static get isConnected() {\n        return isConnected;\n    }\n    static get onceConnected() {\n        return onceConnected;\n    }\n    static get() {\n        return channel;\n    }\n    static ensure() {\n        if (!channel)\n            channel = new DevtoolsChannel();\n    }\n}\nexport class DevtoolsForTests {\n    static get channel() {\n        return channel;\n    }\n    static ensureStub() {\n        assert(!channel);\n        channel = new DevtoolsChannelStub();\n        onceConnectedResolve(channel);\n        isConnected = true;\n    }\n    static reset() {\n        assert(channel);\n        isConnected = false;\n        onceConnectedResolve = null;\n        onceConnected = new Promise(resolve => onceConnectedResolve = resolve);\n        channel = null;\n    }\n}\n//# sourceMappingURL=devtools-connection.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// Debugging is initialized either by /devtools/src/run-mark-connected.js, which is\n// injected by the devtools extension content script in the browser env,\n// or used directly when debugging nodeJS.\n\n// Data needs to be referenced via a global object, otherwise extension and\n// Arcs have different instances.\nconst root = typeof window === 'object' ? window : global;\n\nif (!root._arcDebugPromise) {\n  root._arcDebugPromise = new Promise(resolve => {\n    root._arcDebugPromiseResolve = resolve;\n  });\n}\n\nexport class DevtoolsBroker {\n  static get onceConnected() {\n    return root._arcDebugPromise;\n  }\n  static markConnected() {\n    root._arcDebugPromiseResolve();\n  }\n}\n","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {AbstractDevtoolsChannel} from '../runtime/debug/abstract-devtools-channel.js';\n\nexport class DevtoolsChannel extends AbstractDevtoolsChannel {\n  _flush(messages) {\n  }\n}\n","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nexport class AbstractDevtoolsChannel {\n    constructor() {\n        this.debouncedMessages = [];\n        this.messageListeners = new Map();\n        this.timer = null;\n    }\n    send(message) {\n        this.ensureNoCycle(message);\n        this.debouncedMessages.push(message);\n        // Temporary workaround for WebRTC slicing messages above 2^18 characters.\n        // Need to find a proper fix. Is there some config in WebRTC to fix this?\n        // If not prefer to slice messages based on their serialized form.\n        // Maybe zip them for transport?\n        if (this.debouncedMessages.length > 10) {\n            this._empty();\n        }\n        else if (!this.timer) {\n            this.timer = setTimeout(() => this._empty(), 100);\n        }\n    }\n    listen(arcOrId, messageType, callback) {\n        assert(messageType);\n        assert(arcOrId);\n        const arcId = typeof arcOrId === 'string' ? arcOrId : arcOrId.id.toString();\n        const key = `${arcId}/${messageType}`;\n        let listeners = this.messageListeners.get(key);\n        if (!listeners)\n            this.messageListeners.set(key, listeners = []);\n        listeners.push(callback);\n    }\n    forArc(arc) {\n        return new ArcDevtoolsChannel(arc, this);\n    }\n    _handleMessage(msg) {\n        const listeners = this.messageListeners.get(`${msg.arcId}/${msg.messageType}`);\n        if (!listeners) {\n            console.warn(`No one is listening to ${msg.messageType} message`);\n        }\n        else {\n            for (const listener of listeners)\n                listener(msg);\n        }\n    }\n    _empty() {\n        this._flush(this.debouncedMessages);\n        this.debouncedMessages = [];\n        clearTimeout(this.timer);\n        this.timer = null;\n    }\n    _flush(messages) {\n        throw new Error('Not implemented in an abstract class');\n    }\n    ensureNoCycle(object, objectPath = []) {\n        if (!object || typeof object !== 'object')\n            return;\n        assert(objectPath.indexOf(object) === -1, 'Message cannot contain a cycle');\n        objectPath.push(object);\n        (Array.isArray(object) ? object : Object.values(object)).forEach(element => this.ensureNoCycle(element, objectPath));\n        objectPath.pop();\n    }\n}\nexport class ArcDevtoolsChannel {\n    constructor(arc, channel) {\n        this.channel = channel;\n        this.arcId = arc.id.toString();\n    }\n    send(message) {\n        this.channel.send(Object.assign({ meta: { arcId: this.arcId } }, message));\n    }\n    listen(messageType, callback) {\n        this.channel.listen(this.arcId, messageType, callback);\n    }\n    static instantiateListener(listenerClass, arc, channel) {\n        return new listenerClass(arc, channel);\n    }\n}\nexport class ArcDebugListener {\n    constructor(arc, channel) { }\n}\n//# sourceMappingURL=abstract-devtools-channel.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class DevtoolsChannelStub {\n    constructor() {\n        this._messages = [];\n    }\n    get messages() {\n        return this._messages;\n    }\n    send(message) {\n        this._messages.push(JSON.parse(JSON.stringify(message)));\n    }\n    listen(arcOrId, messageType, callback) { }\n    clear() {\n        this._messages.length = 0;\n    }\n    forArc(arc) {\n        return this;\n    }\n}\n//# sourceMappingURL=devtools-channel-stub.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { mapStackTrace } from '../../platform/sourcemapped-stacktrace-web.js';\nexport class OuterPortAttachment {\n    constructor(arc, devtoolsChannel) {\n        this.arcDevtoolsChannel = devtoolsChannel.forArc(arc);\n    }\n    handlePecMessage(name, pecMsgBody, pecMsgCount, stackString) {\n        const stack = this._extractStackFrames(stackString);\n        this.arcDevtoolsChannel.send({\n            messageType: 'PecLog',\n            messageBody: { name, pecMsgBody, pecMsgCount, timestamp: Date.now(), stack },\n        });\n    }\n    _extractStackFrames(stackString) {\n        const stack = [];\n        if (!stackString)\n            return stack;\n        // File refs should appear only in stack traces generated by tests run with\n        // --explore set.\n        if (stackString.includes('(file:///')) {\n            // The slice discards the 'Error' text and the the stack frame\n            // corresponding to the API channel function, which is already being\n            // displayed in the log entry.\n            for (const frameString of stackString.split('\\n    at ').slice(2)) {\n                let match = frameString.match(/^(.*) \\((.*)\\)$/);\n                if (match === null) {\n                    match = { 1: '<unknown>', 2: frameString };\n                }\n                let location = match[2].replace(/:[0-9]+$/, '');\n                if (location.startsWith('file')) {\n                    // 'file:///<path>/arcs.*/runtime/file.js:84'\n                    // -> location: 'runtime/file.js:150'\n                    location = location.replace(/^.*\\/arcs[^/]*\\//, '');\n                }\n                stack.push({ method: match[1], location, target: null, targetClass: 'noLink' });\n            }\n            return stack;\n        }\n        // The slice discards the stack frame corresponding to the API channel\n        // function, which is already being displayed in the log entry.\n        if (mapStackTrace) {\n            mapStackTrace(stackString, mapped => mapped.slice(1).map(frameString => {\n                // Each frame has the form '    at function (source:line:column)'.\n                // Extract the function name and source:line:column text, then set up\n                // a frame object with the following fields:\n                //   location: text to display as the source in devtools Arcs panel\n                //   target: URL to open in devtools Sources panel\n                //   targetClass: CSS class specifier to attach to the location text\n                let match = frameString.match(/^ {4}at (.*) \\((.*)\\)$/);\n                if (match === null) {\n                    match = { 1: '<unknown>', 2: frameString.replace(/^ *at */, '') };\n                }\n                const frame = { method: match[1] };\n                const source = match[2].replace(/:[0-9]+$/, '');\n                if (source.startsWith('http')) {\n                    // 'http://<url>/arcs.*/shell/file.js:150'\n                    // -> location: 'shell/file.js:150', target: same as source\n                    frame.location = source.replace(/^.*\\/arcs[^/]*\\//, '');\n                    frame.target = source;\n                    frame.targetClass = 'link';\n                }\n                else if (source.startsWith('webpack')) {\n                    // 'webpack:///runtime/sub/file.js:18'\n                    // -> location: 'runtime/sub/file.js:18', target: 'webpack:///./runtime/sub/file.js:18'\n                    frame.location = source.slice(11);\n                    frame.target = `webpack:///./${frame.location}`;\n                    frame.targetClass = 'link';\n                }\n                else {\n                    // '<anonymous>' (or similar)\n                    frame.location = source;\n                    frame.target = null;\n                    frame.targetClass = 'noLink';\n                }\n                stack.push(frame);\n            }), { sync: false, cacheGlobally: true });\n        }\n        return stack;\n    }\n}\n//# sourceMappingURL=outer-port-attachment.js.map","// Copyright (c) 2018 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n// This is only relevant in the web devtools.\nexport const mapStackTrace = () => {};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { Modality } from './modality.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { InterfaceType, Type } from './type.js';\nfunction asType(t) {\n    return (t instanceof Type) ? t : Type.fromLiteral(t);\n}\nfunction asTypeLiteral(t) {\n    return (t instanceof Type) ? t.toLiteral() : t;\n}\nexport class ConnectionSpec {\n    constructor(rawData, typeVarMap) {\n        this.parentConnection = null;\n        this.rawData = rawData;\n        this.direction = rawData.direction;\n        this.name = rawData.name;\n        this.type = asType(rawData.type).mergeTypeVariablesByName(typeVarMap);\n        this.isOptional = rawData.isOptional;\n        this.tags = rawData.tags || [];\n        this.dependentConnections = [];\n    }\n    instantiateDependentConnections(particle, typeVarMap) {\n        for (const dependentArg of this.rawData.dependentConnections) {\n            const dependentConnection = particle.createConnection(dependentArg, typeVarMap);\n            dependentConnection.parentConnection = this;\n            this.dependentConnections.push(dependentConnection);\n        }\n    }\n    get isInput() {\n        // TODO: we probably don't really want host to be here.\n        return this.direction === 'in' || this.direction === 'inout' || this.direction === 'host';\n    }\n    get isOutput() {\n        return this.direction === 'out' || this.direction === 'inout';\n    }\n    isCompatibleType(type) {\n        return TypeChecker.compareTypes({ type }, { type: this.type, direction: this.direction });\n    }\n}\nexport class SlotSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired;\n        this.isSet = slotModel.isSet;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.providedSlots = [];\n        if (!slotModel.providedSlots) {\n            return;\n        }\n        slotModel.providedSlots.forEach(ps => {\n            this.providedSlots.push(new ProvidedSlotSpec(ps));\n        });\n    }\n    getProvidedSlotSpec(name) {\n        return this.providedSlots.find(ps => ps.name === name);\n    }\n}\nexport class ProvidedSlotSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired || false;\n        this.isSet = slotModel.isSet || false;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.handles = slotModel.handles || [];\n    }\n}\nexport class ParticleSpec {\n    constructor(model) {\n        this.model = model;\n        this.name = model.name;\n        this.verbs = model.verbs;\n        const typeVarMap = new Map();\n        this.connections = [];\n        model.args.forEach(arg => this.createConnection(arg, typeVarMap));\n        this.connectionMap = new Map();\n        this.connections.forEach(a => this.connectionMap.set(a.name, a));\n        this.inputs = this.connections.filter(a => a.isInput);\n        this.outputs = this.connections.filter(a => a.isOutput);\n        // initialize descriptions patterns.\n        model.description = model.description || {};\n        this.validateDescription(model.description);\n        this.pattern = model.description['pattern'];\n        this.connections.forEach(connectionSpec => {\n            connectionSpec.pattern = model.description[connectionSpec.name];\n        });\n        this.implFile = model.implFile;\n        this.modality = Modality.create(model.modality || []);\n        this.slots = new Map();\n        if (model.slots) {\n            model.slots.forEach(s => this.slots.set(s.name, new SlotSpec(s)));\n        }\n        // Verify provided slots use valid handle connection names.\n        this.slots.forEach(slot => {\n            slot.providedSlots.forEach(ps => {\n                ps.handles.forEach(v => assert(this.connectionMap.has(v), 'Cannot provide slot for nonexistent handle constraint ', v));\n            });\n        });\n    }\n    createConnection(arg, typeVarMap) {\n        const connection = new ConnectionSpec(arg, typeVarMap);\n        this.connections.push(connection);\n        connection.instantiateDependentConnections(this, typeVarMap);\n        return connection;\n    }\n    isInput(param) {\n        for (const input of this.inputs)\n            if (input.name === param)\n                return true;\n        return false;\n    }\n    isOutput(param) {\n        for (const outputs of this.outputs)\n            if (outputs.name === param)\n                return true;\n        return false;\n    }\n    getConnectionByName(name) {\n        return this.connectionMap.get(name);\n    }\n    getSlotSpec(slotName) {\n        return this.slots.get(slotName);\n    }\n    get primaryVerb() {\n        return (this.verbs.length > 0) ? this.verbs[0] : undefined;\n    }\n    isCompatible(modality) {\n        return this.slots.size === 0 || this.modality.intersection(modality).isResolved();\n    }\n    toLiteral() {\n        const { args, name, verbs, description, implFile, modality, slots } = this.model;\n        const connectionToLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: asTypeLiteral(type), direction, name, isOptional, dependentConnections: dependentConnections.map(connectionToLiteral) });\n        const argsLiteral = args.map(a => connectionToLiteral(a));\n        return { args: argsLiteral, name, verbs, description, implFile, modality, slots };\n    }\n    static fromLiteral(literal) {\n        let { args, name, verbs, description, implFile, modality, slots } = literal;\n        const connectionFromLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: asType(type), direction, name, isOptional, dependentConnections: dependentConnections ? dependentConnections.map(connectionFromLiteral) : [] });\n        args = args.map(connectionFromLiteral);\n        return new ParticleSpec({ args, name, verbs: verbs || [], description, implFile, modality, slots });\n    }\n    // Note: this method shouldn't be called directly.\n    clone() {\n        return ParticleSpec.fromLiteral(this.toLiteral());\n    }\n    // Note: this method shouldn't be called directly (only as part of particle copying).\n    cloneWithResolutions(variableMap) {\n        const spec = this.clone();\n        this.connectionMap.forEach((conn, name) => {\n            spec.connectionMap.get(name).type = conn.type._cloneWithResolutions(variableMap);\n        });\n        return spec;\n    }\n    equals(other) {\n        return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());\n    }\n    validateDescription(description) {\n        Object.keys(description || []).forEach(d => {\n            assert(['kind', 'location', 'pattern'].includes(d) || this.connectionMap.has(d), `Unexpected description for ${d}`);\n        });\n    }\n    toInterface() {\n        // TODO: wat do?\n        assert(!this.slots.size, 'please implement slots toInterface');\n        const handles = this.model.args.map(({ type, name, direction }) => ({ type: asType(type), name, direction }));\n        const slots = [];\n        return InterfaceType.make(this.name, handles, slots);\n    }\n    toString() {\n        const results = [];\n        let verbs = '';\n        if (this.verbs.length > 0) {\n            verbs = ' ' + this.verbs.map(verb => `&${verb}`).join(' ');\n        }\n        results.push(`particle ${this.name}${verbs} in '${this.implFile}'`.trim());\n        const indent = '  ';\n        const writeConnection = (connection, indent) => {\n            const tags = connection.tags.map((tag) => ` #${tag}`).join('');\n            results.push(`${indent}${connection.direction}${connection.isOptional ? '?' : ''} ${connection.type.toString()} ${connection.name}${tags}`);\n            for (const dependent of connection.dependentConnections) {\n                writeConnection(dependent, indent + '  ');\n            }\n        };\n        for (const connection of this.connections) {\n            if (connection.parentConnection) {\n                continue;\n            }\n            writeConnection(connection, indent);\n        }\n        this.modality.names.forEach(a => results.push(`  modality ${a}`));\n        this.slots.forEach(s => {\n            // Consume slot.\n            const consume = [];\n            if (s.isRequired) {\n                consume.push('must');\n            }\n            consume.push('consume');\n            if (s.isSet) {\n                consume.push('set of');\n            }\n            consume.push(s.name);\n            if (s.tags.length > 0) {\n                consume.push(s.tags.map(a => `#${a}`).join(' '));\n            }\n            results.push(`  ${consume.join(' ')}`);\n            if (s.formFactor) {\n                results.push(`    formFactor ${s.formFactor}`);\n            }\n            // Provided slots.\n            s.providedSlots.forEach(ps => {\n                const provide = [];\n                if (ps.isRequired) {\n                    provide.push('must');\n                }\n                provide.push('provide');\n                if (ps.isSet) {\n                    provide.push('set of');\n                }\n                provide.push(ps.name);\n                if (ps.tags.length > 0) {\n                    provide.push(ps.tags.map(a => `#${a}`).join(' '));\n                }\n                results.push(`    ${provide.join(' ')}`);\n                if (ps.formFactor) {\n                    results.push(`      formFactor ${ps.formFactor}`);\n                }\n                ps.handles.forEach(handle => results.push(`      handle ${handle}`));\n            });\n        });\n        // Description\n        if (this.pattern) {\n            results.push(`  description \\`${this.pattern}\\``);\n            this.connections.forEach(cs => {\n                if (cs.pattern) {\n                    results.push(`    ${cs.name} \\`${cs.pattern}\\``);\n                }\n            });\n        }\n        return results.join('\\n');\n    }\n    toManifestString() {\n        return this.toString();\n    }\n}\n//# sourceMappingURL=particle-spec.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nvar ModalityName;\n(function (ModalityName) {\n    ModalityName[\"Dom\"] = \"dom\";\n    ModalityName[\"DomTouch\"] = \"dom-touch\";\n    ModalityName[\"Vr\"] = \"vr\";\n    ModalityName[\"Voice\"] = \"voice\";\n})(ModalityName || (ModalityName = {}));\nexport class Modality {\n    constructor(names) {\n        this.names = names;\n    }\n    static create(names) {\n        assert(names.every(name => Modality.all.names.includes(name)), `Unsupported modality in: ${names}`);\n        return new Modality(names);\n    }\n    intersection(other) {\n        return new Modality(this.names.filter(name => other.names.includes(name)));\n    }\n    isResolved() {\n        return this.names.length > 0;\n    }\n    isCompatible(names) {\n        return this.intersection(Modality.create(names)).isResolved();\n    }\n    static get Name() { return ModalityName; }\n}\nModality.all = new Modality([\n    Modality.Name.Dom, Modality.Name.DomTouch, Modality.Name.Vr, Modality.Name.Voice\n]);\nModality.dom = new Modality([Modality.Name.Dom]);\nModality.domTouch = new Modality([Modality.Name.DomTouch]);\nModality.voice = new Modality([Modality.Name.Voice]);\nModality.vr = new Modality([Modality.Name.Vr]);\n//# sourceMappingURL=modality.js.map","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { BigCollectionType, CollectionType, EntityType, InterfaceType, ReferenceType, SlotType, Type, TypeVariable } from '../type.js';\nexport class TypeChecker {\n    // resolve a list of handleConnection types against a handle\n    // base type. This is the core type resolution mechanism, but should only\n    // be used when types can actually be associated with each other / constrained.\n    //\n    // By design this function is called exactly once per handle in a recipe during\n    // normalization, and should provide the same final answers regardless of the\n    // ordering of handles within that recipe\n    //\n    // NOTE: you probably don't want to call this function, if you think you\n    // do, talk to shans@.\n    static processTypeList(baseType, list) {\n        const newBaseType = TypeVariable.make('', null, null);\n        if (baseType) {\n            newBaseType.variable.resolution = baseType;\n        }\n        baseType = newBaseType;\n        const concreteTypes = [];\n        // baseType might be a variable (and is definitely a variable if no baseType was available).\n        // Some of the list might contain variables too.\n        // First attempt to merge all the variables into the baseType\n        //\n        // If the baseType is a variable then this results in a single place to manipulate the constraints\n        // of all the other connected variables at the same time.\n        for (const item of list) {\n            if (item.type.resolvedType().hasVariable) {\n                baseType = TypeChecker._tryMergeTypeVariable(baseType, item.type);\n                if (baseType == null) {\n                    return null;\n                }\n            }\n            else {\n                concreteTypes.push(item);\n            }\n        }\n        for (const item of concreteTypes) {\n            if (!TypeChecker._tryMergeConstraints(baseType, item)) {\n                return null;\n            }\n        }\n        const getResolution = candidate => {\n            if (!(candidate instanceof TypeVariable)) {\n                return candidate;\n            }\n            if (candidate.canReadSubset == null || candidate.canWriteSuperset == null) {\n                return candidate;\n            }\n            if (candidate.canReadSubset.isMoreSpecificThan(candidate.canWriteSuperset)) {\n                if (candidate.canWriteSuperset.isMoreSpecificThan(candidate.canReadSubset)) {\n                    candidate.variable.resolution = candidate.canReadSubset;\n                }\n                return candidate;\n            }\n            return null;\n        };\n        const candidate = baseType.resolvedType();\n        if (candidate instanceof CollectionType) {\n            const resolution = getResolution(candidate.collectionType);\n            return (resolution !== null) ? resolution.collectionOf() : null;\n        }\n        if (candidate instanceof BigCollectionType) {\n            const resolution = getResolution(candidate.bigCollectionType);\n            return (resolution !== null) ? resolution.bigCollectionOf() : null;\n        }\n        return getResolution(candidate);\n    }\n    static _tryMergeTypeVariable(base, onto) {\n        const [primitiveBase, primitiveOnto] = Type.unwrapPair(base.resolvedType(), onto.resolvedType());\n        if (primitiveBase instanceof TypeVariable) {\n            if (primitiveOnto instanceof TypeVariable) {\n                // base, onto both variables.\n                const result = primitiveBase.variable.maybeMergeConstraints(primitiveOnto.variable);\n                if (result === false) {\n                    return null;\n                }\n                primitiveOnto.variable.resolution = primitiveBase;\n            }\n            else {\n                // base variable, onto not.\n                if (!primitiveBase.variable.isValidResolutionCandidate(primitiveOnto).result) {\n                    return null;\n                }\n                primitiveBase.variable.resolution = primitiveOnto;\n            }\n            return base;\n        }\n        else if (primitiveOnto instanceof TypeVariable) {\n            // onto variable, base not.\n            if (!primitiveOnto.variable.isValidResolutionCandidate(primitiveBase).result) {\n                return null;\n            }\n            primitiveOnto.variable.resolution = primitiveBase;\n            return onto;\n        }\n        else if (primitiveBase instanceof InterfaceType && primitiveOnto instanceof InterfaceType) {\n            const result = primitiveBase.interfaceInfo.tryMergeTypeVariablesWith(primitiveOnto.interfaceInfo);\n            if (result == null) {\n                return null;\n            }\n            return new InterfaceType(result);\n        }\n        else if ((primitiveBase.isTypeContainer() && primitiveBase.hasVariable)\n            || (primitiveOnto.isTypeContainer() && primitiveOnto.hasVariable)) {\n            // Cannot merge [~a] with a type that is not a variable and not a collection.\n            return null;\n        }\n        throw new Error('tryMergeTypeVariable shouldn\\'t be called on two types without any type variables');\n    }\n    static _tryMergeConstraints(handleType, { type, direction }) {\n        let [primitiveHandleType, primitiveConnectionType] = Type.unwrapPair(handleType.resolvedType(), type.resolvedType());\n        if (primitiveHandleType instanceof TypeVariable) {\n            while (primitiveConnectionType.isTypeContainer()) {\n                if (primitiveHandleType.variable.resolution != null\n                    || primitiveHandleType.variable.canReadSubset != null\n                    || primitiveHandleType.variable.canWriteSuperset != null) {\n                    // Resolved and/or constrained variables can only represent Entities, not sets.\n                    return false;\n                }\n                // If this is an undifferentiated variable then we need to create structure to match against. That's\n                // allowed because this variable could represent anything, and it needs to represent this structure\n                // in order for type resolution to succeed.\n                const newVar = TypeVariable.make('a', null, null);\n                if (primitiveConnectionType instanceof CollectionType) {\n                    primitiveHandleType.variable.resolution = new CollectionType(newVar);\n                }\n                else if (primitiveConnectionType instanceof BigCollectionType) {\n                    primitiveHandleType.variable.resolution = new BigCollectionType(newVar);\n                }\n                else {\n                    primitiveHandleType.variable.resolution = new ReferenceType(newVar);\n                }\n                const unwrap = Type.unwrapPair(primitiveHandleType.resolvedType(), primitiveConnectionType);\n                [primitiveHandleType, primitiveConnectionType] = unwrap;\n            }\n            if (direction === 'out' || direction === 'inout' || direction === '`provide') {\n                // the canReadSubset of the handle represents the maximal type that can be read from the\n                // handle, so we need to intersect out any type that is more specific than the maximal type\n                // that could be written.\n                if (!primitiveHandleType.variable.maybeMergeCanReadSubset(primitiveConnectionType.canWriteSuperset)) {\n                    return false;\n                }\n            }\n            if (direction === 'in' || direction === 'inout' || direction === '`consume') {\n                // the canWriteSuperset of the handle represents the maximum lower-bound type that is read from the handle,\n                // so we need to union it with the type that wants to be read here.\n                if (!primitiveHandleType.variable.maybeMergeCanWriteSuperset(primitiveConnectionType.canReadSubset)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (primitiveConnectionType.tag !== primitiveHandleType.tag) {\n                return false;\n            }\n            if (direction === 'out' || direction === 'inout') {\n                if (!TypeChecker._writeConstraintsApply(primitiveHandleType, primitiveConnectionType)) {\n                    return false;\n                }\n            }\n            if (direction === 'in' || direction === 'inout') {\n                if (!TypeChecker._readConstraintsApply(primitiveHandleType, primitiveConnectionType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _writeConstraintsApply(handleType, connectionType) {\n        // this connection wants to write to this handle. If the written type is\n        // more specific than the canReadSubset then it isn't violating the maximal type\n        // that can be read.\n        const writtenType = connectionType.canWriteSuperset;\n        if (writtenType == null || handleType.canReadSubset == null) {\n            return true;\n        }\n        if (writtenType.isMoreSpecificThan(handleType.canReadSubset)) {\n            return true;\n        }\n        return false;\n    }\n    static _readConstraintsApply(handleType, connectionType) {\n        // this connection wants to read from this handle. If the read type\n        // is less specific than the canWriteSuperset, then it isn't violating\n        // the maximum lower-bound read type.\n        const readType = connectionType.canReadSubset;\n        if (readType == null || handleType.canWriteSuperset == null) {\n            return true;\n        }\n        if (handleType.canWriteSuperset.isMoreSpecificThan(readType)) {\n            return true;\n        }\n        return false;\n    }\n    // Compare two types to see if they could be potentially resolved (in the absence of other\n    // information). This is used as a filter when selecting compatible handles or checking\n    // validity of recipes. This function returning true never implies that full type resolution\n    // will succeed, but if the function returns false for a pair of types that are associated\n    // then type resolution is guaranteed to fail.\n    //\n    // left, right: {type, direction, connection}\n    static compareTypes(left, right) {\n        const resolvedLeft = left.type.resolvedType();\n        const resolvedRight = right.type.resolvedType();\n        const [leftType, rightType] = Type.unwrapPair(resolvedLeft, resolvedRight);\n        // a variable is compatible with a set only if it is unconstrained.\n        if (leftType instanceof TypeVariable && rightType.isTypeContainer()) {\n            return !(leftType.variable.canReadSubset || leftType.variable.canWriteSuperset);\n        }\n        if (rightType instanceof TypeVariable && leftType.isTypeContainer()) {\n            return !(rightType.variable.canReadSubset || rightType.variable.canWriteSuperset);\n        }\n        if (leftType instanceof TypeVariable || rightType instanceof TypeVariable) {\n            // TODO: everything should use this, eventually. Need to implement the\n            // right functionality in Interfaces first, though.\n            return Type.canMergeConstraints(leftType, rightType);\n        }\n        if ((leftType === undefined) !== (rightType === undefined)) {\n            return false;\n        }\n        if (leftType === rightType) {\n            return true;\n        }\n        if (leftType.tag !== rightType.tag) {\n            return false;\n        }\n        if (leftType instanceof SlotType) {\n            return true;\n        }\n        // TODO: we need a generic way to evaluate type compatibility\n        //       interfaces + entities + etc\n        if (leftType instanceof InterfaceType && rightType instanceof InterfaceType) {\n            if (leftType.interfaceInfo.equals(rightType.interfaceInfo)) {\n                return true;\n            }\n        }\n        if (!(leftType instanceof EntityType) || !(rightType instanceof EntityType)) {\n            return false;\n        }\n        const leftIsSub = leftType.entitySchema.isMoreSpecificThan(rightType.entitySchema);\n        const leftIsSuper = rightType.entitySchema.isMoreSpecificThan(leftType.entitySchema);\n        if (leftIsSuper && leftIsSub) {\n            return true;\n        }\n        if (!leftIsSuper && !leftIsSub) {\n            return false;\n        }\n        const [superclass, subclass] = leftIsSuper ? [left, right] : [right, left];\n        // treat handle types as if they were 'inout' connections. Note that this\n        // guarantees that the handle's type will be preserved, and that the fact\n        // that the type comes from a handle rather than a connection will also\n        // be preserved.\n        const superDirection = superclass.direction || (superclass.connection ? superclass.connection.direction : 'inout');\n        const subDirection = subclass.direction || (subclass.connection ? subclass.connection.direction : 'inout');\n        if (superDirection === 'in') {\n            return true;\n        }\n        if (subDirection === 'out') {\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=type-checker.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { InterfaceInfo } from './interface-info.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Schema } from './schema.js';\nimport { SlotInfo } from './slot-info.js';\nimport { ArcInfo } from './synthetic-types.js';\nimport { TypeVariableInfo } from './type-variable-info.js';\nexport class Type {\n    constructor(tag) {\n        this.tag = tag;\n    }\n    static fromLiteral(literal) {\n        switch (literal.tag) {\n            case 'Entity':\n                return new EntityType(Schema.fromLiteral(literal.data));\n            case 'TypeVariable':\n                return new TypeVariable(TypeVariableInfo.fromLiteral(literal.data));\n            case 'Collection':\n                return new CollectionType(Type.fromLiteral(literal.data));\n            case 'BigCollection':\n                return new BigCollectionType(Type.fromLiteral(literal.data));\n            case 'Relation':\n                return new RelationType(literal.data.map(t => Type.fromLiteral(t)));\n            case 'Interface':\n                return new InterfaceType(InterfaceInfo.fromLiteral(literal.data));\n            case 'Slot':\n                return new SlotType(SlotInfo.fromLiteral(literal.data));\n            case 'Reference':\n                return new ReferenceType(Type.fromLiteral(literal.data));\n            case 'Arc':\n                return new ArcType();\n            case 'Handle':\n                return new HandleType();\n            default:\n                throw new Error(`fromLiteral: unknown type ${literal}`);\n        }\n    }\n    static unwrapPair(type1, type2) {\n        if (type1.tag === type2.tag) {\n            const contained1 = type1.getContainedType();\n            if (contained1 !== null) {\n                return Type.unwrapPair(contained1, type2.getContainedType());\n            }\n        }\n        return [type1, type2];\n    }\n    /** Tests whether two types' constraints are compatible with each other. */\n    static canMergeConstraints(type1, type2) {\n        return Type._canMergeCanReadSubset(type1, type2) && Type._canMergeCanWriteSuperset(type1, type2);\n    }\n    static _canMergeCanReadSubset(type1, type2) {\n        if (type1.canReadSubset && type2.canReadSubset) {\n            if (type1.canReadSubset.tag !== type2.canReadSubset.tag) {\n                return false;\n            }\n            if (type1.canReadSubset instanceof EntityType) {\n                return Schema.intersect(type1.canReadSubset.entitySchema, type2.canReadSubset.entitySchema) !== null;\n            }\n            throw new Error(`_canMergeCanReadSubset not implemented for types tagged with ${type1.canReadSubset.tag}`);\n        }\n        return true;\n    }\n    static _canMergeCanWriteSuperset(type1, type2) {\n        if (type1.canWriteSuperset && type2.canWriteSuperset) {\n            if (type1.canWriteSuperset.tag !== type2.canWriteSuperset.tag) {\n                return false;\n            }\n            if (type1.canWriteSuperset instanceof EntityType) {\n                return Schema.union(type1.canWriteSuperset.entitySchema, type2.canWriteSuperset.entitySchema) !== null;\n            }\n        }\n        return true;\n    }\n    // TODO: update call sites to use the type checker instead (since they will\n    // have additional information about direction etc.)\n    equals(type) {\n        return TypeChecker.compareTypes({ type: this }, { type });\n    }\n    isResolved() {\n        // TODO: one of these should not exist.\n        return !this.hasUnresolvedVariable;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        return this;\n    }\n    _applyExistenceTypeTest(test) {\n        return test(this);\n    }\n    get hasVariable() {\n        return this._applyExistenceTypeTest(type => type instanceof TypeVariable);\n    }\n    get hasUnresolvedVariable() {\n        return this._applyExistenceTypeTest(type => type instanceof TypeVariable && !type.variable.isResolved());\n    }\n    getContainedType() {\n        return null;\n    }\n    isTypeContainer() {\n        return false;\n    }\n    collectionOf() {\n        return new CollectionType(this);\n    }\n    bigCollectionOf() {\n        return new BigCollectionType(this);\n    }\n    resolvedType() {\n        return this;\n    }\n    canEnsureResolved() {\n        return this.isResolved() || this._canEnsureResolved();\n    }\n    _canEnsureResolved() {\n        return true;\n    }\n    maybeEnsureResolved() {\n        return true;\n    }\n    get canWriteSuperset() {\n        throw new Error(`canWriteSuperset not implemented for ${this}`);\n    }\n    get canReadSubset() {\n        throw new Error(`canReadSubset not implemented for ${this}`);\n    }\n    isMoreSpecificThan(type) {\n        return this.tag === type.tag && this._isMoreSpecificThan(type);\n    }\n    _isMoreSpecificThan(type) {\n        throw new Error(`isMoreSpecificThan not implemented for ${this}`);\n    }\n    /**\n     * Clone a type object.\n     * When cloning multiple types, variables that were associated with the same name\n     * before cloning should still be associated after cloning. To maintain this\n     * property, create a Map() and pass it into all clone calls in the group.\n     */\n    clone(variableMap) {\n        return this.resolvedType()._clone(variableMap);\n    }\n    _clone(variableMap) {\n        return Type.fromLiteral(this.toLiteral());\n    }\n    /**\n     * Clone a type object, maintaining resolution information.\n     * This function SHOULD NOT BE USED at the type level. In order for type variable\n     * information to be maintained correctly, an entire context root needs to be\n     * cloned.\n     */\n    _cloneWithResolutions(variableMap) {\n        return Type.fromLiteral(this.toLiteral());\n    }\n    // TODO: is this the same as _applyExistenceTypeTest\n    hasProperty(property) {\n        return property(this) || this._hasProperty(property);\n    }\n    _hasProperty(property) {\n        return false;\n    }\n    toString(options = undefined) {\n        return this.tag;\n    }\n    getEntitySchema() {\n        return null;\n    }\n    toPrettyString() {\n        return null;\n    }\n}\nexport class EntityType extends Type {\n    constructor(schema) {\n        super('Entity');\n        this.entitySchema = schema;\n    }\n    static make(names, fields, description) {\n        return new EntityType(new Schema(names, fields, description));\n    }\n    // These type identifier methods are being left in place for non-runtime code.\n    get isEntity() {\n        return true;\n    }\n    get canWriteSuperset() {\n        return this;\n    }\n    get canReadSubset() {\n        return this;\n    }\n    _isMoreSpecificThan(type) {\n        return this.entitySchema.isMoreSpecificThan(type.entitySchema);\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.entitySchema.toLiteral() };\n    }\n    toString(options = undefined) {\n        return this.entitySchema.toInlineSchemaString(options);\n    }\n    getEntitySchema() {\n        return this.entitySchema;\n    }\n    _cloneWithResolutions(variableMap) {\n        if (variableMap.has(this.entitySchema)) {\n            return variableMap.get(this.entitySchema);\n        }\n        const clonedEntityType = new EntityType(this.entitySchema);\n        variableMap.set(this.entitySchema, clonedEntityType);\n        return clonedEntityType;\n    }\n    toPrettyString() {\n        if (this.entitySchema.description.pattern) {\n            return this.entitySchema.description.pattern;\n        }\n        // Spit MyTypeFOO to My Type FOO\n        if (this.entitySchema.name) {\n            return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2')\n                .replace(/([A-Z][^A-Z])/g, ' $1')\n                .replace(/[\\s]+/g, ' ')\n                .trim();\n        }\n        return JSON.stringify(this.entitySchema.toLiteral());\n    }\n}\nexport class TypeVariable extends Type {\n    constructor(variable) {\n        super('TypeVariable');\n        this.variable = variable;\n    }\n    static make(name, canWriteSuperset, canReadSubset) {\n        return new TypeVariable(new TypeVariableInfo(name, canWriteSuperset, canReadSubset));\n    }\n    get isVariable() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const name = this.variable.name;\n        let variable = variableMap.get(name);\n        if (!variable) {\n            variable = this;\n            variableMap.set(name, this);\n        }\n        else if (variable instanceof TypeVariable) {\n            if (variable.variable.hasConstraint || this.variable.hasConstraint) {\n                const mergedConstraint = variable.variable.maybeMergeConstraints(this.variable);\n                if (!mergedConstraint) {\n                    throw new Error('could not merge type variables');\n                }\n            }\n        }\n        return variable;\n    }\n    resolvedType() {\n        return this.variable.resolution || this;\n    }\n    _canEnsureResolved() {\n        return this.variable.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.variable.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return this.variable.canWriteSuperset;\n    }\n    get canReadSubset() {\n        return this.variable.canReadSubset;\n    }\n    _clone(variableMap) {\n        const name = this.variable.name;\n        if (variableMap.has(name)) {\n            return new TypeVariable(variableMap.get(name));\n        }\n        else {\n            const newTypeVariable = TypeVariableInfo.fromLiteral(this.variable.toLiteral());\n            variableMap.set(name, newTypeVariable);\n            return new TypeVariable(newTypeVariable);\n        }\n    }\n    _cloneWithResolutions(variableMap) {\n        if (variableMap.has(this.variable)) {\n            return new TypeVariable(variableMap.get(this.variable));\n        }\n        else {\n            const newTypeVariable = TypeVariableInfo.fromLiteral(this.variable.toLiteralIgnoringResolutions());\n            if (this.variable.resolution) {\n                newTypeVariable._resolution = this.variable._resolution._cloneWithResolutions(variableMap);\n            }\n            if (this.variable._canReadSubset) {\n                newTypeVariable.canReadSubset = this.variable.canReadSubset._cloneWithResolutions(variableMap);\n            }\n            if (this.variable._canWriteSuperset) {\n                newTypeVariable.canWriteSuperset = this.variable.canWriteSuperset._cloneWithResolutions(variableMap);\n            }\n            variableMap.set(this.variable, newTypeVariable);\n            return new TypeVariable(newTypeVariable);\n        }\n    }\n    toLiteral() {\n        return this.variable.resolution ? this.variable.resolution.toLiteral()\n            : { tag: this.tag, data: this.variable.toLiteral() };\n    }\n    toString(options = undefined) {\n        return `~${this.variable.name}`;\n    }\n    getEntitySchema() {\n        return this.variable.isResolved() ? this.resolvedType().getEntitySchema() : null;\n    }\n    toPrettyString() {\n        return this.variable.isResolved() ? this.resolvedType().toPrettyString() : `[~${this.variable.name}]`;\n    }\n}\nexport class CollectionType extends Type {\n    constructor(collectionType) {\n        super('Collection');\n        this.collectionType = collectionType;\n    }\n    get isCollection() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const collectionType = this.collectionType;\n        const result = collectionType.mergeTypeVariablesByName(variableMap);\n        return (result === collectionType) ? this : result.collectionOf();\n    }\n    _applyExistenceTypeTest(test) {\n        return this.collectionType._applyExistenceTypeTest(test);\n    }\n    getContainedType() {\n        return this.collectionType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const collectionType = this.collectionType;\n        const resolvedCollectionType = collectionType.resolvedType();\n        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.collectionOf() : this;\n    }\n    _canEnsureResolved() {\n        return this.collectionType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.collectionType.maybeEnsureResolved();\n    }\n    _clone(variableMap) {\n        const data = this.collectionType.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new CollectionType(this.collectionType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.collectionType.toLiteral() };\n    }\n    _hasProperty(property) {\n        return this.collectionType.hasProperty(property);\n    }\n    toString(options = undefined) {\n        return `[${this.collectionType.toString(options)}]`;\n    }\n    getEntitySchema() {\n        return this.collectionType.getEntitySchema();\n    }\n    toPrettyString() {\n        const entitySchema = this.getEntitySchema();\n        if (entitySchema && entitySchema.description.plural) {\n            return entitySchema.description.plural;\n        }\n        return `${this.collectionType.toPrettyString()} List`;\n    }\n}\nexport class BigCollectionType extends Type {\n    constructor(bigCollectionType) {\n        super('BigCollection');\n        this.bigCollectionType = bigCollectionType;\n    }\n    get isBigCollection() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const collectionType = this.bigCollectionType;\n        const result = collectionType.mergeTypeVariablesByName(variableMap);\n        return (result === collectionType) ? this : result.bigCollectionOf();\n    }\n    _applyExistenceTypeTest(test) {\n        return this.bigCollectionType._applyExistenceTypeTest(test);\n    }\n    getContainedType() {\n        return this.bigCollectionType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const collectionType = this.bigCollectionType;\n        const resolvedCollectionType = collectionType.resolvedType();\n        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.bigCollectionOf() : this;\n    }\n    _canEnsureResolved() {\n        return this.bigCollectionType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.bigCollectionType.maybeEnsureResolved();\n    }\n    _clone(variableMap) {\n        const data = this.bigCollectionType.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new BigCollectionType(this.bigCollectionType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.bigCollectionType.toLiteral() };\n    }\n    _hasProperty(property) {\n        return this.bigCollectionType.hasProperty(property);\n    }\n    toString(options = undefined) {\n        return `BigCollection<${this.bigCollectionType.toString(options)}>`;\n    }\n    getEntitySchema() {\n        return this.bigCollectionType.getEntitySchema();\n    }\n    toPrettyString() {\n        const entitySchema = this.getEntitySchema();\n        if (entitySchema && entitySchema.description.plural) {\n            return entitySchema.description.plural;\n        }\n        return `Collection of ${this.bigCollectionType.toPrettyString()}`;\n    }\n}\nexport class RelationType extends Type {\n    constructor(relation) {\n        super('Relation');\n        this.relationEntities = relation;\n    }\n    get isRelation() {\n        return true;\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.relationEntities.map(t => t.toLiteral()) };\n    }\n    toPrettyString() {\n        return JSON.stringify(this.relationEntities);\n    }\n}\nexport class InterfaceType extends Type {\n    constructor(iface) {\n        super('Interface');\n        this.interfaceInfo = iface;\n    }\n    // TODO: export InterfaceInfo's Handle and Slot interfaces to type check here?\n    static make(name, handles, slots) {\n        return new InterfaceType(new InterfaceInfo(name, handles, slots));\n    }\n    get isInterface() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const interfaceInfo = this.interfaceInfo.clone(new Map());\n        interfaceInfo.mergeTypeVariablesByName(variableMap);\n        // TODO: only build a new type when a variable is modified\n        return new InterfaceType(interfaceInfo);\n    }\n    _applyExistenceTypeTest(test) {\n        return this.interfaceInfo._applyExistenceTypeTest(test);\n    }\n    resolvedType() {\n        return new InterfaceType(this.interfaceInfo.resolvedType());\n    }\n    _canEnsureResolved() {\n        return this.interfaceInfo.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.interfaceInfo.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return new InterfaceType(this.interfaceInfo.canWriteSuperset);\n    }\n    get canReadSubset() {\n        return new InterfaceType(this.interfaceInfo.canReadSubset);\n    }\n    _isMoreSpecificThan(type) {\n        return this.interfaceInfo.isMoreSpecificThan(type.interfaceInfo);\n    }\n    _clone(variableMap) {\n        const data = this.interfaceInfo.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new InterfaceType(this.interfaceInfo._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.interfaceInfo.toLiteral() };\n    }\n    toString(options = undefined) {\n        return this.interfaceInfo.name;\n    }\n    toPrettyString() {\n        return this.interfaceInfo.toPrettyString();\n    }\n}\nexport class SlotType extends Type {\n    constructor(slot) {\n        super('Slot');\n        this.slot = slot;\n    }\n    static make(formFactor, handle) {\n        return new SlotType(new SlotInfo(formFactor, handle));\n    }\n    get isSlot() {\n        return true;\n    }\n    get canWriteSuperset() {\n        return this;\n    }\n    get canReadSubset() {\n        return this;\n    }\n    _isMoreSpecificThan(type) {\n        // TODO: formFactor checking, etc.\n        return true;\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.slot.toLiteral() };\n    }\n    toString(options = undefined) {\n        const fields = [];\n        for (const key of Object.keys(this.slot)) {\n            if (this.slot[key] !== undefined) {\n                fields.push(`${key}:${this.slot[key]}`);\n            }\n        }\n        let fieldsString = '';\n        if (fields.length !== 0) {\n            fieldsString = ` {${fields.join(', ')}}`;\n        }\n        return `Slot${fieldsString}`;\n    }\n    toPrettyString() {\n        const fields = [];\n        for (const key of Object.keys(this.slot)) {\n            if (this.slot[key] !== undefined) {\n                fields.push(`${key}:${this.slot[key]}`);\n            }\n        }\n        let fieldsString = '';\n        if (fields.length !== 0) {\n            fieldsString = ` {${fields.join(', ')}}`;\n        }\n        return `Slot${fieldsString}`;\n    }\n}\nexport class ReferenceType extends Type {\n    constructor(reference) {\n        super('Reference');\n        this.referredType = reference;\n    }\n    get isReference() {\n        return true;\n    }\n    getContainedType() {\n        return this.referredType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const referredType = this.referredType;\n        const resolvedReferredType = referredType.resolvedType();\n        return (referredType !== resolvedReferredType) ? new ReferenceType(resolvedReferredType) : this;\n    }\n    _canEnsureResolved() {\n        return this.referredType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.referredType.maybeEnsureResolved();\n    }\n    get canReadSubset() {\n        return this.referredType.canReadSubset;\n    }\n    _clone(variableMap) {\n        const data = this.referredType.clone(variableMap).toLiteral();\n        return Type.fromLiteral({ tag: this.tag, data });\n    }\n    _cloneWithResolutions(variableMap) {\n        return new ReferenceType(this.referredType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.referredType.toLiteral() };\n    }\n    toString(options = undefined) {\n        return 'Reference<' + this.referredType.toString() + '>';\n    }\n}\nexport class ArcType extends Type {\n    constructor() {\n        super('Arc');\n    }\n    get isArc() {\n        return true;\n    }\n    newInstance(arcId, serialization) {\n        return new ArcInfo(arcId, serialization);\n    }\n    toLiteral() {\n        return { tag: this.tag };\n    }\n}\nexport class HandleType extends Type {\n    constructor() {\n        super('Handle');\n    }\n    get isHandle() {\n        return true;\n    }\n    toLiteral() {\n        return { tag: this.tag };\n    }\n}\n//# sourceMappingURL=type.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Type, TypeVariable } from './type.js';\nfunction _fromLiteral(member) {\n    if (!!member && !(member instanceof Type) && typeof member === 'object') {\n        return Type.fromLiteral(member);\n    }\n    return member;\n}\nfunction _toLiteral(member) {\n    if (!!member && member.toLiteral) {\n        return member.toLiteral();\n    }\n    return member;\n}\nconst handleFields = ['type', 'name', 'direction'];\nconst slotFields = ['name', 'direction', 'isRequired', 'isSet'];\nexport class InterfaceInfo {\n    constructor(name, handles, slots) {\n        assert(name);\n        assert(handles !== undefined);\n        assert(slots !== undefined);\n        this.name = name;\n        this.handles = handles;\n        this.slots = slots;\n        this.typeVars = [];\n        for (const handle of handles) {\n            for (const field of handleFields) {\n                if (InterfaceInfo.isTypeVar(handle[field])) {\n                    this.typeVars.push({ object: handle, field });\n                }\n            }\n        }\n        for (const slot of slots) {\n            for (const field of slotFields) {\n                if (InterfaceInfo.isTypeVar(slot[field])) {\n                    this.typeVars.push({ object: slot, field });\n                }\n            }\n        }\n    }\n    toPrettyString() {\n        return 'InterfaceInfo';\n    }\n    mergeTypeVariablesByName(variableMap) {\n        this.typeVars.map(({ object, field }) => object[field] = object[field].mergeTypeVariablesByName(variableMap));\n    }\n    get canReadSubset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canReadSubset);\n    }\n    get canWriteSuperset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canWriteSuperset);\n    }\n    isMoreSpecificThan(other) {\n        if (this.handles.length !== other.handles.length ||\n            this.slots.length !== other.slots.length) {\n            return false;\n        }\n        // TODO: should probably confirm that handles and slots actually match.\n        for (let i = 0; i < this.typeVars.length; i++) {\n            const thisTypeVar = this.typeVars[i];\n            const otherTypeVar = other.typeVars[i];\n            if (!thisTypeVar.object[thisTypeVar.field].isMoreSpecificThan(otherTypeVar.object[otherTypeVar.field])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _applyExistenceTypeTest(test) {\n        for (const typeRef of this.typeVars) {\n            if (test(typeRef.object[typeRef.field])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _handlesToManifestString() {\n        return this.handles\n            .map(handle => {\n            const type = handle.type.resolvedType();\n            return `  ${handle.direction ? handle.direction + ' ' : ''}${type.toString()} ${handle.name ? handle.name : '*'}`;\n        }).join('\\n');\n    }\n    _slotsToManifestString() {\n        // TODO deal with isRequired\n        return this.slots\n            .map(slot => `  ${slot.direction} ${slot.isSet ? 'set of ' : ''}${slot.name ? slot.name + ' ' : ''}`)\n            .join('\\n');\n    }\n    // TODO: Include name as a property of the interface and normalize this to just toString()\n    toString() {\n        return `interface ${this.name}\n${this._handlesToManifestString()}\n${this._slotsToManifestString()}\n`;\n    }\n    static fromLiteral(data) {\n        const handles = data.handles.map(handle => ({ type: _fromLiteral(handle.type), name: _fromLiteral(handle.name), direction: _fromLiteral(handle.direction) }));\n        const slots = data.slots.map(slot => ({ name: _fromLiteral(slot.name), direction: _fromLiteral(slot.direction), isRequired: _fromLiteral(slot.isRequired), isSet: _fromLiteral(slot.isSet) }));\n        return new InterfaceInfo(data.name, handles, slots);\n    }\n    toLiteral() {\n        const handles = this.handles.map(handle => ({ type: _toLiteral(handle.type), name: _toLiteral(handle.name), direction: _toLiteral(handle.direction) }));\n        const slots = this.slots.map(slot => ({ name: _toLiteral(slot.name), direction: _toLiteral(slot.direction), isRequired: _toLiteral(slot.isRequired), isSet: _toLiteral(slot.isSet) }));\n        return { name: this.name, handles, slots };\n    }\n    clone(variableMap) {\n        const handles = this.handles.map(({ name, direction, type }) => ({ name, direction, type: type ? type.clone(variableMap) : undefined }));\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new InterfaceInfo(this.name, handles, slots);\n    }\n    cloneWithResolutions(variableMap) {\n        return this._cloneWithResolutions(variableMap);\n    }\n    _cloneWithResolutions(variableMap) {\n        const handles = this.handles.map(({ name, direction, type }) => ({ name, direction, type: type ? type._cloneWithResolutions(variableMap) : undefined }));\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new InterfaceInfo(this.name, handles, slots);\n    }\n    canEnsureResolved() {\n        for (const typeVar of this.typeVars) {\n            if (!typeVar.object[typeVar.field].canEnsureResolved()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    maybeEnsureResolved() {\n        for (const typeVar of this.typeVars) {\n            let variable = typeVar.object[typeVar.field];\n            variable = variable.clone(new Map());\n            if (!variable.maybeEnsureResolved())\n                return false;\n        }\n        for (const typeVar of this.typeVars) {\n            typeVar.object[typeVar.field].maybeEnsureResolved();\n        }\n        return true;\n    }\n    tryMergeTypeVariablesWith(other) {\n        // Type variable enabled slot matching will Just Work when we\n        // unify slots and handles.\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return null;\n        }\n        if (other.handles.length !== this.handles.length) {\n            return null;\n        }\n        const handles = new Set(this.handles);\n        const otherHandles = new Set(other.handles);\n        const handleMap = new Map();\n        let sizeCheck = handles.size;\n        while (handles.size > 0) {\n            const handleMatches = [...handles.values()].map(handle => ({ handle, match: [...otherHandles.values()].filter(otherHandle => this._equalHandle(handle, otherHandle)) }));\n            for (const handleMatch of handleMatches) {\n                // no match!\n                if (handleMatch.match.length === 0) {\n                    return null;\n                }\n                if (handleMatch.match.length === 1) {\n                    handleMap.set(handleMatch.handle, handleMatch.match[0]);\n                    otherHandles.delete(handleMatch.match[0]);\n                    handles.delete(handleMatch.handle);\n                }\n            }\n            // no progress!\n            if (handles.size === sizeCheck) {\n                return null;\n            }\n            sizeCheck = handles.size;\n        }\n        const handleList = [];\n        for (const handle of this.handles) {\n            const otherHandle = handleMap.get(handle);\n            let resultType;\n            if (handle.type.hasVariable || otherHandle.type.hasVariable) {\n                resultType = TypeChecker._tryMergeTypeVariable(handle.type, otherHandle.type);\n                if (!resultType) {\n                    return null;\n                }\n            }\n            else {\n                resultType = handle.type || otherHandle.type;\n            }\n            handleList.push({ name: handle.name || otherHandle.name, direction: handle.direction || otherHandle.direction, type: resultType });\n        }\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new InterfaceInfo(this.name, handleList, slots);\n    }\n    resolvedType() {\n        return this._cloneAndUpdate(typeVar => typeVar.resolvedType());\n    }\n    equals(other) {\n        if (this.handles.length !== other.handles.length) {\n            return false;\n        }\n        // TODO: this isn't quite right as it doesn't deal with duplicates properly\n        if (!this._equalItems(other.handles, this.handles, this._equalHandle)) {\n            return false;\n        }\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return false;\n        }\n        return true;\n    }\n    _equalHandle(handle, otherHandle) {\n        return handle.name === otherHandle.name && handle.direction === otherHandle.direction && handle.type.equals(otherHandle.type);\n    }\n    _equalSlot(slot, otherSlot) {\n        return slot.name === otherSlot.name && slot.direction === otherSlot.direction && slot.isRequired === otherSlot.isRequired && slot.isSet === otherSlot.isSet;\n    }\n    _equalItems(otherItems, items, compareItem) {\n        for (const otherItem of otherItems) {\n            let exists = false;\n            for (const item of items) {\n                if (compareItem(item, otherItem)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _cloneAndUpdate(update) {\n        const copy = this.clone(new Map());\n        copy.typeVars.forEach(typeVar => InterfaceInfo._updateTypeVar(typeVar, update));\n        return copy;\n    }\n    static _updateTypeVar(typeVar, update) {\n        typeVar.object[typeVar.field] = update(typeVar.object[typeVar.field]);\n    }\n    static isTypeVar(reference) {\n        return (reference instanceof Type) && reference.hasProperty(r => r instanceof TypeVariable);\n    }\n    static mustMatch(reference) {\n        return !(reference == undefined || InterfaceInfo.isTypeVar(reference));\n    }\n    static handlesMatch(interfaceHandle, particleHandle) {\n        if (InterfaceInfo.mustMatch(interfaceHandle.name) &&\n            interfaceHandle.name !== particleHandle.name) {\n            return false;\n        }\n        // TODO: direction subsetting?\n        if (InterfaceInfo.mustMatch(interfaceHandle.direction) &&\n            interfaceHandle.direction !== particleHandle.direction) {\n            return false;\n        }\n        if (interfaceHandle.type == undefined) {\n            return true;\n        }\n        const [left, right] = Type.unwrapPair(interfaceHandle.type, particleHandle.type);\n        if (left instanceof TypeVariable) {\n            return [{ var: left, value: right, direction: interfaceHandle.direction }];\n        }\n        else {\n            return left.equals(right);\n        }\n    }\n    static slotsMatch(interfaceSlot, particleSlot) {\n        if (InterfaceInfo.mustMatch(interfaceSlot.name) &&\n            interfaceSlot.name !== particleSlot.name) {\n            return false;\n        }\n        if (InterfaceInfo.mustMatch(interfaceSlot.direction) &&\n            interfaceSlot.direction !== particleSlot.direction) {\n            return false;\n        }\n        if (InterfaceInfo.mustMatch(interfaceSlot.isRequired) &&\n            interfaceSlot.isRequired !== particleSlot.isRequired) {\n            return false;\n        }\n        if (InterfaceInfo.mustMatch(interfaceSlot.isSet) &&\n            interfaceSlot.isSet !== particleSlot.isSet) {\n            return false;\n        }\n        return true;\n    }\n    particleMatches(particleSpec) {\n        const interfaceInfo = this.cloneWithResolutions(new Map());\n        return interfaceInfo.restrictType(particleSpec) !== false;\n    }\n    restrictType(particleSpec) {\n        return this._restrictThis(particleSpec);\n    }\n    _restrictThis(particleSpec) {\n        const handleMatches = this.handles.map(h => particleSpec.connections.map(c => ({ match: c, result: InterfaceInfo.handlesMatch(h, c) }))\n            .filter(a => a.result !== false));\n        const particleSlots = [];\n        particleSpec.slots.forEach(consumedSlot => {\n            particleSlots.push({ name: consumedSlot.name, direction: 'consume', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet });\n            consumedSlot.providedSlots.forEach(providedSlot => {\n                particleSlots.push({ name: providedSlot.name, direction: 'provide', isRequired: false, isSet: providedSlot.isSet });\n            });\n        });\n        let slotMatches = this.slots.map(slot => particleSlots.filter(particleSlot => InterfaceInfo.slotsMatch(slot, particleSlot)));\n        slotMatches = slotMatches.map(matchList => matchList.map(slot => ({ match: slot, result: true })));\n        const exclusions = [];\n        // TODO: this probably doesn't deal with multiple match options.\n        function choose(list, exclusions) {\n            if (list.length === 0) {\n                return [];\n            }\n            const thisLevel = list.pop();\n            for (const connection of thisLevel) {\n                if (exclusions.includes(connection.match)) {\n                    continue;\n                }\n                const newExclusions = exclusions.slice();\n                newExclusions.push(connection.match);\n                const constraints = choose(list, newExclusions);\n                if (constraints !== false) {\n                    return connection.result.length ? constraints.concat(connection.result) : constraints;\n                }\n            }\n            return false;\n        }\n        const handleOptions = choose(handleMatches, []);\n        const slotOptions = choose(slotMatches, []);\n        if (handleOptions === false || slotOptions === false) {\n            return false;\n        }\n        for (const constraint of handleOptions) {\n            if (!constraint.var.variable.resolution) {\n                constraint.var.variable.resolution = constraint.value;\n            }\n            else if (constraint.var.variable.resolution instanceof TypeVariable) {\n                // TODO(shans): revisit how this should be done,\n                // consider reusing tryMergeTypeVariablesWith(other).\n                if (!TypeChecker.processTypeList(constraint.var, [{\n                        type: constraint.value, direction: constraint.direction\n                    }]))\n                    return false;\n            }\n            else {\n                if (!constraint.var.variable.resolution.equals(constraint.value))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=interface-info.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { Entity } from './entity.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Reference } from './reference.js';\nimport { EntityType, ReferenceType, Type } from './type.js';\nexport class Schema {\n    // tslint:disable-next-line: no-any\n    constructor(names, fields, description) {\n        this.names = names;\n        this.fields = fields;\n        this.description = {};\n        if (description) {\n            description.description.forEach(desc => this.description[desc.name] = desc.pattern || desc.patterns[0]);\n        }\n    }\n    toLiteral() {\n        const fields = {};\n        const updateField = field => {\n            if (field.kind === 'schema-reference') {\n                const schema = field.schema;\n                return { kind: 'schema-reference', schema: { kind: schema.kind, model: schema.model.toLiteral() } };\n            }\n            else if (field.kind === 'schema-collection') {\n                return { kind: 'schema-collection', schema: updateField(field.schema) };\n            }\n            else {\n                return field;\n            }\n        };\n        for (const key of Object.keys(this.fields)) {\n            fields[key] = updateField(this.fields[key]);\n        }\n        return { names: this.names, fields, description: this.description };\n    }\n    static fromLiteral(data = { fields: {}, names: [], description: {} }) {\n        const fields = {};\n        const updateField = field => {\n            if (field.kind === 'schema-reference') {\n                const schema = field.schema;\n                return { kind: 'schema-reference', schema: { kind: schema.kind, model: Type.fromLiteral(schema.model) } };\n            }\n            else if (field.kind === 'schema-collection') {\n                return { kind: 'schema-collection', schema: updateField(field.schema) };\n            }\n            else {\n                return field;\n            }\n        };\n        for (const key of Object.keys(data.fields)) {\n            fields[key] = updateField(data.fields[key]);\n        }\n        const result = new Schema(data.names, fields);\n        result.description = data.description || {};\n        return result;\n    }\n    // TODO: This should only be an ident used in manifest parsing.\n    get name() {\n        return this.names[0];\n    }\n    static typesEqual(fieldType1, fieldType2) {\n        // TODO: structural check instead of stringification.\n        return Schema._typeString(fieldType1) === Schema._typeString(fieldType2);\n    }\n    static _typeString(type) {\n        if (typeof (type) !== 'object') {\n            assert(typeof type === 'string');\n            return type;\n        }\n        switch (type.kind) {\n            case 'schema-union':\n                return `(${type.types.join(' or ')})`;\n            case 'schema-tuple':\n                return `(${type.types.join(', ')})`;\n            case 'schema-reference':\n                return `Reference<${Schema._typeString(type.schema)}>`;\n            case 'type-name':\n            case 'schema-inline':\n                return type.model.entitySchema.toInlineSchemaString();\n            case 'schema-collection':\n                return `[${Schema._typeString(type.schema)}]`;\n            default:\n                throw new Error(`Unknown type kind ${type.kind} in schema ${this.name}`);\n        }\n    }\n    static union(schema1, schema2) {\n        const names = [...new Set([...schema1.names, ...schema2.names])];\n        const fields = {};\n        for (const [field, type] of [...Object.entries(schema1.fields), ...Object.entries(schema2.fields)]) {\n            if (fields[field]) {\n                if (!Schema.typesEqual(fields[field], type)) {\n                    return null;\n                }\n            }\n            else {\n                fields[field] = type;\n            }\n        }\n        return new Schema(names, fields);\n    }\n    static intersect(schema1, schema2) {\n        const names = [...schema1.names].filter(name => schema2.names.includes(name));\n        const fields = {};\n        for (const [field, type] of Object.entries(schema1.fields)) {\n            const otherType = schema2.fields[field];\n            if (otherType && Schema.typesEqual(type, otherType)) {\n                fields[field] = type;\n            }\n        }\n        return new Schema(names, fields);\n    }\n    equals(otherSchema) {\n        return this === otherSchema || (this.name === otherSchema.name\n            // TODO: Check equality without calling contains.\n            && this.isMoreSpecificThan(otherSchema)\n            && otherSchema.isMoreSpecificThan(this));\n    }\n    isMoreSpecificThan(otherSchema) {\n        const names = new Set(this.names);\n        for (const name of otherSchema.names) {\n            if (!names.has(name)) {\n                return false;\n            }\n        }\n        const fields = {};\n        for (const [name, type] of Object.entries(this.fields)) {\n            fields[name] = type;\n        }\n        for (const [name, type] of Object.entries(otherSchema.fields)) {\n            if (fields[name] == undefined) {\n                return false;\n            }\n            if (!Schema.typesEqual(fields[name], type)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    get type() {\n        return new EntityType(this);\n    }\n    entityClass(context = null) {\n        const schema = this;\n        const className = this.name;\n        const classJunk = ['toJSON', 'prototype', 'toString', 'inspect'];\n        const convertToJsType = fieldType => {\n            switch (fieldType) {\n                case 'Text':\n                    return 'string';\n                case 'URL':\n                    return 'string';\n                case 'Number':\n                    return 'number';\n                case 'Boolean':\n                    return 'boolean';\n                case 'Object':\n                    return 'object';\n                default:\n                    throw new Error(`Unknown field type ${fieldType} in schema ${className}`);\n            }\n        };\n        const fieldTypes = this.fields;\n        const validateFieldAndTypes = (op, name, value) => _validateFieldAndTypes(op, name, fieldTypes[name], value);\n        const _validateFieldAndTypes = (op, name, fieldType, value) => {\n            if (fieldType === undefined) {\n                throw new Error(`Can't ${op} field ${name}; not in schema ${className}`);\n            }\n            if (value === undefined || value === null) {\n                return;\n            }\n            if (typeof (fieldType) !== 'object') {\n                // Primitive fields.\n                if (typeof (value) !== convertToJsType(fieldType)) {\n                    throw new TypeError(`Type mismatch ${op}ting field ${name} (type ${fieldType}); ` +\n                        `value '${value}' is type ${typeof (value)}`);\n                }\n                return;\n            }\n            switch (fieldType.kind) {\n                case 'schema-union':\n                    // Value must be a primitive that matches one of the union types.\n                    for (const innerType of fieldType.types) {\n                        if (typeof (value) === convertToJsType(innerType)) {\n                            return;\n                        }\n                    }\n                    throw new TypeError(`Type mismatch ${op}ting field ${name} (union [${fieldType.types}]); ` +\n                        `value '${value}' is type ${typeof (value)}`);\n                case 'schema-tuple':\n                    // Value must be an array whose contents match each of the tuple types.\n                    if (!Array.isArray(value)) {\n                        throw new TypeError(`Cannot ${op} tuple ${name} with non-array value '${value}'`);\n                    }\n                    if (value.length !== fieldType.types.length) {\n                        throw new TypeError(`Length mismatch ${op}ting tuple ${name} ` +\n                            `[${fieldType.types}] with value '${value}'`);\n                    }\n                    fieldType.types.map((innerType, i) => {\n                        if (value[i] !== undefined && value[i] !== null &&\n                            typeof (value[i]) !== convertToJsType(innerType)) {\n                            throw new TypeError(`Type mismatch ${op}ting field ${name} (tuple [${fieldType.types}]); ` +\n                                `value '${value}' has type ${typeof (value[i])} at index ${i}`);\n                        }\n                    });\n                    break;\n                case 'schema-reference':\n                    if (!(value instanceof Reference)) {\n                        throw new TypeError(`Cannot ${op} reference ${name} with non-reference '${value}'`);\n                    }\n                    if (!TypeChecker.compareTypes({ type: value.type }, { type: new ReferenceType(fieldType.schema.model) })) {\n                        throw new TypeError(`Cannot ${op} reference ${name} with value '${value}' of mismatched type`);\n                    }\n                    break;\n                case 'schema-collection':\n                    // WTF?! value instanceof Set is returning false sometimes here because the Set in\n                    // this environment (a native code constructor) isn't equal to the Set that the value\n                    // has been constructed with (another native code constructor)...\n                    if (value.constructor.name !== 'Set') {\n                        throw new TypeError(`Cannot ${op} collection ${name} with non-Set '${value}'`);\n                    }\n                    for (const element of value) {\n                        _validateFieldAndTypes(op, name, fieldType.schema, element);\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown kind ${fieldType.kind} in schema ${className}`);\n            }\n        };\n        const clazz = class extends Entity {\n            constructor(data, userIDComponent) {\n                super(userIDComponent);\n                this.rawData = new Proxy({}, {\n                    get: (target, name) => {\n                        if (classJunk.includes(name) || name.constructor === Symbol) {\n                            return undefined;\n                        }\n                        const value = target[name];\n                        validateFieldAndTypes('get', name, value);\n                        return value;\n                    },\n                    set: (target, name, value) => {\n                        validateFieldAndTypes('set', name, value);\n                        target[name] = value;\n                        return true;\n                    }\n                });\n                assert(data, `can't construct entity with null data`);\n                // TODO: figure out how to do this only on wire-created entities.\n                const sanitizedData = this.sanitizeData(data);\n                for (const [name, value] of Object.entries(sanitizedData)) {\n                    this.rawData[name] = value;\n                }\n            }\n            sanitizeData(data) {\n                const sanitizedData = {};\n                for (const [name, value] of Object.entries(data)) {\n                    sanitizedData[name] = this.sanitizeEntry(fieldTypes[name], value, name);\n                }\n                return sanitizedData;\n            }\n            sanitizeEntry(type, value, name) {\n                if (!type) {\n                    // If there isn't a field type for this, the proxy will pick up\n                    // that fact and report a meaningful error.\n                    return value;\n                }\n                if (type.kind === 'schema-reference' && value) {\n                    if (value instanceof Reference) {\n                        // Setting value as Reference (Particle side). This will enforce that the type provided for\n                        // the handle matches the type of the reference.\n                        return value;\n                    }\n                    else if (value.id && value.storageKey) {\n                        // Setting value from raw data (Channel side).\n                        // TODO(shans): This can't enforce type safety here as there isn't any type data available.\n                        // Maybe this is OK because there's type checking on the other side of the channel?\n                        return new Reference(value, new ReferenceType(type.schema.model), context);\n                    }\n                    else {\n                        throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);\n                    }\n                }\n                else if (type.kind === 'schema-collection' && value) {\n                    // WTF?! value instanceof Set is returning false sometimes here because the Set in\n                    // this environment (a native code constructor) isn't equal to the Set that the value\n                    // has been constructed with (another native code constructor)...\n                    if (value.constructor.name === 'Set') {\n                        return value;\n                    }\n                    else if (value.length && value instanceof Object) {\n                        return new Set(value.map(v => this.sanitizeEntry(type.schema, v, name)));\n                    }\n                    else {\n                        throw new TypeError(`Cannot set collection ${name} with non-collection '${value}'`);\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n            dataClone() {\n                const clone = {};\n                for (const name of Object.keys(schema.fields)) {\n                    if (this.rawData[name] !== undefined) {\n                        if (fieldTypes[name] && fieldTypes[name].kind === 'schema-reference') {\n                            clone[name] = this.rawData[name].dataClone();\n                        }\n                        else if (fieldTypes[name] && fieldTypes[name].kind === 'schema-collection') {\n                            clone[name] = [...this.rawData[name]].map(a => a.dataClone());\n                        }\n                        else {\n                            clone[name] = this.rawData[name];\n                        }\n                    }\n                }\n                return clone;\n            }\n            static get type() {\n                // TODO: should the entity's key just be its type?\n                // Should it just be called type in that case?\n                return new EntityType(this.key.schema);\n            }\n            static get key() {\n                return { tag: 'entity', schema };\n            }\n        };\n        Object.defineProperty(clazz, 'type', { value: this.type });\n        Object.defineProperty(clazz, 'name', { value: this.name });\n        // TODO: add query / getter functions for user properties\n        for (const name of Object.keys(this.fields)) {\n            Object.defineProperty(clazz.prototype, name, {\n                get() {\n                    return this.rawData[name];\n                },\n                set(v) {\n                    this.rawData[name] = v;\n                }\n            });\n        }\n        return clazz;\n    }\n    toInlineSchemaString(options) {\n        const names = this.names.join(' ') || '*';\n        const fields = Object.entries(this.fields).map(([name, type]) => `${Schema._typeString(type)} ${name}`).join(', ');\n        return `${names} {${fields.length > 0 && options && options.hideFields ? '...' : fields}}`;\n    }\n    toManifestString() {\n        const results = [];\n        results.push(`schema ${this.names.join(' ')}`);\n        results.push(...Object.entries(this.fields).map(([name, type]) => `  ${Schema._typeString(type)} ${name}`));\n        if (Object.keys(this.description).length > 0) {\n            results.push(`  description \\`${this.description.pattern}\\``);\n            for (const name of Object.keys(this.description)) {\n                if (name !== 'pattern') {\n                    results.push(`    ${name} \\`${this.description[name]}\\``);\n                }\n            }\n        }\n        return results.join('\\n');\n    }\n}\n//# sourceMappingURL=schema.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { assert } from '../platform/assert-web.js';\nimport { Symbols } from './symbols.js';\nexport class Entity {\n    constructor(userIDComponent) {\n        assert(!userIDComponent || userIDComponent.indexOf(':') === -1, 'user IDs must not contain the \\':\\' character');\n        this[Symbols.identifier] = undefined;\n        this.userIDComponent = userIDComponent;\n    }\n    get data() {\n        return undefined;\n    }\n    getUserID() {\n        return this.userIDComponent;\n    }\n    isIdentified() {\n        return this[Symbols.identifier] !== undefined;\n    }\n    // TODO: entity should not be exposing its IDs.\n    get id() {\n        assert(!!this.isIdentified());\n        return this[Symbols.identifier];\n    }\n    identify(identifier) {\n        assert(!this.isIdentified());\n        this[Symbols.identifier] = identifier;\n        const components = identifier.split(':');\n        if (components[components.length - 2] === 'uid') {\n            this.userIDComponent = components[components.length - 1];\n        }\n    }\n    createIdentity(components) {\n        assert(!this.isIdentified());\n        let id;\n        if (this.userIDComponent) {\n            id = `${components.base}:uid:${this.userIDComponent}`;\n        }\n        else {\n            id = `${components.base}:${components.component()}`;\n        }\n        this[Symbols.identifier] = id;\n    }\n    toLiteral() {\n        return this.rawData;\n    }\n}\n//# sourceMappingURL=entity.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n// tslint:disable-next-line: variable-name\nexport const Symbols = { identifier: Symbol('id') };\n//# sourceMappingURL=symbols.js.map","/** @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { handleFor } from './handle.js';\nimport { ReferenceType } from './type.js';\nvar ReferenceMode;\n(function (ReferenceMode) {\n    ReferenceMode[ReferenceMode[\"Unstored\"] = 0] = \"Unstored\";\n    ReferenceMode[ReferenceMode[\"Stored\"] = 1] = \"Stored\";\n})(ReferenceMode || (ReferenceMode = {}));\nexport class Reference {\n    constructor(data, type, context) {\n        this.entity = null;\n        this.storageProxy = null;\n        this.handle = null;\n        this.id = data.id;\n        this.storageKey = data.storageKey;\n        this.context = context;\n        this.type = type;\n    }\n    async ensureStorageProxy() {\n        if (this.storageProxy == null) {\n            this.storageProxy = await this.context.getStorageProxy(this.storageKey, this.type.referredType);\n            this.handle = handleFor(this.storageProxy);\n            if (this.storageKey) {\n                assert(this.storageKey === this.storageProxy.storageKey);\n            }\n            else {\n                this.storageKey = this.storageProxy.storageKey;\n            }\n        }\n    }\n    async dereference() {\n        assert(this.context, \"Must have context to dereference\");\n        if (this.entity) {\n            return this.entity;\n        }\n        await this.ensureStorageProxy();\n        this.entity = await this.handle.get(this.id);\n        return this.entity;\n    }\n    dataClone() {\n        return { storageKey: this.storageKey, id: this.id };\n    }\n    static newClientReference(context) {\n        return class extends Reference {\n            constructor(entity) {\n                // TODO(shans): start carrying storageKey information around on Entity objects\n                super({ id: entity.id, storageKey: null }, new ReferenceType(entity.constructor.type), context);\n                this.mode = ReferenceMode.Unstored;\n                this.entity = entity;\n                this.stored = new Promise(async (resolve, reject) => {\n                    await this.storeReference(entity);\n                    resolve();\n                });\n            }\n            async storeReference(entity) {\n                await this.ensureStorageProxy();\n                await this.handle.store(entity);\n                this.mode = ReferenceMode.Stored;\n            }\n            async dereference() {\n                if (this.mode === ReferenceMode.Unstored) {\n                    return null;\n                }\n                return super.dereference();\n            }\n            isIdentified() {\n                return this.entity.isIdentified();\n            }\n        };\n    }\n}\n//# sourceMappingURL=reference.js.map","/** @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { Reference } from './reference.js';\nimport { Symbols } from './symbols.js';\nimport { BigCollectionType, CollectionType, EntityType, InterfaceType, ReferenceType } from './type.js';\n// TODO: This won't be needed once runtime is transferred between contexts.\nfunction cloneData(data) {\n    return data;\n    //return JSON.parse(JSON.stringify(data));\n}\nfunction restore(entry, entityClass) {\n    assert(entityClass, 'Handles need entity classes for deserialization');\n    const { id, rawData } = entry;\n    const entity = new entityClass(cloneData(rawData));\n    if (entry.id) {\n        entity.identify(entry.id);\n    }\n    // TODO some relation magic, somewhere, at some point.\n    return entity;\n}\n/**\n * Base class for Collections and Variables.\n */\nexport class Handle {\n    // TODO type particleId, marked as string, but called with number\n    constructor(proxy, name, particleId, canRead, canWrite) {\n        assert(!(proxy instanceof Handle));\n        this._proxy = proxy;\n        this.name = name || this._proxy.name;\n        this.canRead = canRead;\n        this.canWrite = canWrite;\n        this._particleId = particleId;\n        this.options = {\n            keepSynced: true,\n            notifySync: true,\n            notifyUpdate: true,\n            notifyDesync: false,\n        };\n    }\n    raiseSystemException(exception, method) {\n        this._proxy.raiseSystemException(exception, method, this._particleId);\n    }\n    // `options` may contain any of:\n    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required\n    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received\n    // - notifyUpdate (bool): call onHandleUpdate for every change event received\n    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected\n    configure(options) {\n        assert(this.canRead, 'configure can only be called on readable Handles');\n        try {\n            const keys = Object.keys(this.options);\n            const badKeys = Object.keys(options).filter(o => !keys.includes(o));\n            if (badKeys.length > 0) {\n                throw new Error(`Invalid option in Handle.configure(): ${badKeys}`);\n            }\n            Object.assign(this.options, options);\n        }\n        catch (e) {\n            this.raiseSystemException(e, 'Handle::configure');\n            throw e;\n        }\n    }\n    _serialize(entity) {\n        assert(entity, 'can\\'t serialize a null entity');\n        if (!entity.isIdentified()) {\n            entity.createIdentity(this._proxy.generateIDComponents());\n        }\n        const id = entity[Symbols.identifier];\n        const rawData = entity.dataClone();\n        return {\n            id,\n            rawData\n        };\n    }\n    get type() {\n        return this._proxy.type;\n    }\n    get _id() {\n        return this._proxy.id;\n    }\n    toManifestString() {\n        return `'${this._id}'`;\n    }\n}\n/**\n * A handle on a set of Entity data. Note that, as a set, a Collection can only\n * contain a single version of an Entity for each given ID. Further, no order is\n * implied by the set. A particle's manifest dictates the types of handles that\n * need to be connected to that particle, and the current recipe identifies\n * which handles are connected.\n */\nexport class Collection extends Handle {\n    _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                particle.onHandleSync(this, this._restore(details));\n                return;\n            case 'update': {\n                // tslint:disable-next-line: no-any\n                const update = {};\n                if ('add' in details) {\n                    update.added = this._restore(details.add);\n                }\n                if ('remove' in details) {\n                    update.removed = this._restore(details.remove);\n                }\n                update.originator = details.originatorId === this._particleId;\n                particle.onHandleUpdate(this, update);\n                return;\n            }\n            case 'desync':\n                particle.onHandleDesync(this);\n                return;\n            default:\n                throw new Error('unsupported');\n        }\n    }\n    /**\n     * Returns the Entity specified by id contained by the handle, or null if this id is not\n     * contained by the handle.\n     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async get(id) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        return this._restore([await this._proxy.get(id, this._particleId)])[0];\n    }\n    /**\n     * @returns a list of the Entities contained by the handle.\n     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async toList() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        return this._restore(await this._proxy.toList());\n    }\n    _restore(list) {\n        return (list !== null) ? list.map(a => restore(a, this.entityClass)) : null;\n    }\n    /**\n     * Stores a new entity into the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async store(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        const keys = [this._proxy.generateID() + 'key'];\n        return this._proxy.store(serialization, keys, this._particleId);\n    }\n    /**\n     * Removes all known entities from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        return this._proxy.clear(this._particleId);\n    }\n    /**\n     * Removes an entity from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        // Remove the keys that exist at storage/proxy.\n        const keys = [];\n        this._proxy.remove(serialization.id, keys, this._particleId);\n    }\n}\n/**\n * A handle on a single entity. A particle's manifest dictates\n * the types of handles that need to be connected to that particle, and\n * the current recipe identifies which handles are connected.\n */\nexport class Variable extends Handle {\n    // Called by StorageProxy.\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                try {\n                    await particle.onHandleSync(this, this._restore(details));\n                }\n                catch (e) {\n                    this.raiseSystemException(e, `${particle.spec.name}::onHandleSync`);\n                }\n                return;\n            case 'update': {\n                try {\n                    await particle.onHandleUpdate(this, { data: this._restore(details.data) });\n                }\n                catch (e) {\n                    this.raiseSystemException(e, `${particle.spec.name}::onHandleUpdate`);\n                }\n                return;\n            }\n            case 'desync':\n                try {\n                    await particle.onHandleDesync(this);\n                }\n                catch (e) {\n                    this.raiseSystemException(e, `${particle.spec.name}::onHandleDesync`);\n                }\n                return;\n            default:\n                throw new Error('unsupported');\n        }\n    }\n    /**\n     * @returns the Entity contained by the Variable, or undefined if the Variable\n     * is cleared.\n     * @throws {Error} if this variable is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async get() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        const model = await this._proxy.get();\n        return this._restore(model);\n    }\n    _restore(model) {\n        if (model === null) {\n            return null;\n        }\n        if (this.type instanceof EntityType) {\n            return restore(model, this.entityClass);\n        }\n        if (this.type instanceof InterfaceType) {\n            return ParticleSpec.fromLiteral(model);\n        }\n        if (this.type instanceof ReferenceType) {\n            return new Reference(model, this.type, this._proxy.pec);\n        }\n        assert(false, `Don't know how to deliver handle data of type ${this.type}`);\n    }\n    /**\n     * Stores a new entity into the Variable, replacing any existing entity.\n     * @throws {Error} if this variable is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async set(entity) {\n        try {\n            if (!this.canWrite) {\n                throw new Error('Handle not writeable');\n            }\n            return this._proxy.set(this._serialize(entity), this._particleId);\n        }\n        catch (e) {\n            this.raiseSystemException(e, 'Handle::set');\n            throw e;\n        }\n    }\n    /**\n     * Clears any entity currently in the Variable.\n     * @throws {Error} if this variable is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        return this._proxy.clear(this._particleId);\n    }\n}\n/**\n * Provides paginated read access to a BigCollection. Conforms to the javascript iterator protocol\n * but is not marked as iterable because next() is async, which is currently not supported by\n * implicit iteration in Javascript.\n */\nclass Cursor {\n    constructor(parent, cursorId) {\n        this._parent = parent;\n        this._cursorId = cursorId;\n    }\n    /**\n     * Returns {value: [items], done: false} while there are items still available, or {done: true}\n     * when the cursor has completed reading the collection.\n     */\n    async next() {\n        const data = await this._parent._proxy.cursorNext(this._cursorId);\n        if (!data.done) {\n            data.value = data.value.map(a => restore(a, this._parent.entityClass));\n        }\n        return data;\n    }\n    /**\n     * Terminates the streamed read. This must be called if a cursor is no longer needed but has not\n     * yet completed streaming (i.e. next() hasn't returned {done: true}).\n     */\n    close() {\n        this._parent._proxy.cursorClose(this._cursorId);\n    }\n}\n/**\n * A handle on a large set of Entity data. Similar to Collection, except the complete set of\n * entities is not available directly; use stream() to read the full set. Particles wanting to\n * operate on BigCollections should do so in the setHandles() call, since BigCollections do not\n * trigger onHandleSync() or onHandleUpdate().\n */\nexport class BigCollection extends Handle {\n    configure(options) {\n        throw new Error('BigCollections do not support sync/update configuration');\n    }\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        assert(kind === 'sync', 'BigCollection._notify only supports sync events');\n        await particle.onHandleSync(this, []);\n    }\n    /**\n     * Stores a new entity into the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async store(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        const keys = [this._proxy.generateID() + 'key'];\n        return this._proxy.store(serialization, keys, this._particleId);\n    }\n    /**\n     * Removes an entity from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        this._proxy.remove(serialization.id, this._particleId);\n    }\n    /**\n     * @returns a Cursor instance that iterates over the full set of entities, reading `pageSize`\n     * entities at a time. The cursor views a snapshot of the collection, locked to the version\n     * at which the cursor is created.\n     *\n     * By default items are returned in order of original insertion into the collection (with the\n     * caveat that items removed during a streamed read may be returned at the end). Set `forward`\n     * to false to return items in reverse insertion order.\n     *\n     * @throws {Error} if this variable is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async stream({ pageSize, forward = true }) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        if (isNaN(pageSize) || pageSize < 1) {\n            throw new Error('Streamed reads require a positive pageSize');\n        }\n        const cursorId = await this._proxy.stream(pageSize, forward);\n        return new Cursor(this, cursorId);\n    }\n}\nexport function handleFor(proxy, name = null, particleId = '', canRead = true, canWrite = true) {\n    let handle;\n    if (proxy.type instanceof CollectionType) {\n        handle = new Collection(proxy, name, particleId, canRead, canWrite);\n    }\n    else if (proxy.type instanceof BigCollectionType) {\n        handle = new BigCollection(proxy, name, particleId, canRead, canWrite);\n    }\n    else {\n        handle = new Variable(proxy, name, particleId, canRead, canWrite);\n    }\n    const type = proxy.type.getContainedType() || proxy.type;\n    if (type instanceof EntityType) {\n        handle.entityClass = type.entitySchema.entityClass(proxy.pec);\n    }\n    return handle;\n}\n//# sourceMappingURL=handle.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nexport class SlotInfo {\n    constructor(formFactor, handle) {\n        this.formFactor = formFactor;\n        this.handle = handle;\n    }\n    toLiteral() {\n        return this;\n    }\n    static fromLiteral(data) {\n        return new SlotInfo(data.formFactor, data.handle);\n    }\n}\n//# sourceMappingURL=slot-info.js.map","// @license\n// Copyright (c) 2018 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n// Equivalent to an Entity with Schema { serialization Text }\nexport class ArcInfo {\n    constructor(arcId, serialization) {\n        this.id = arcId.toString();\n        // TODO: remove the import-removal hack when import statements no longer appear\n        // in serialized manifests, or deal with them correctly if they end up staying\n        this.serialization = serialization.replace(/\\bimport .*\\n/g, '');\n    }\n    // Retrieves the serialized string from a stored instance of ArcInfo.\n    static extractSerialization(data) {\n        return data.serialization.replace(/\\bimport .*\\n/g, '');\n    }\n}\nexport class ArcHandle {\n    constructor(storageKey, type, tags) {\n        this.storageKey = storageKey;\n        this.type = type;\n        this.tags = tags;\n    }\n}\n//# sourceMappingURL=synthetic-types.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { assert } from '../platform/assert-web.js';\nimport { Schema } from './schema.js';\nimport { EntityType, SlotType, Type, TypeVariable } from './type.js';\nexport class TypeVariableInfo {\n    constructor(name, canWriteSuperset, canReadSubset) {\n        this.name = name;\n        this._canWriteSuperset = canWriteSuperset;\n        this._canReadSubset = canReadSubset;\n        this._resolution = null;\n    }\n    /**\n     * Merge both the read subset (upper bound) and write superset (lower bound) constraints\n     * of two variables together. Use this when two separate type variables need to resolve\n     * to the same value.\n     */\n    maybeMergeConstraints(variable) {\n        if (!this.maybeMergeCanReadSubset(variable.canReadSubset)) {\n            return false;\n        }\n        return this.maybeMergeCanWriteSuperset(variable.canWriteSuperset);\n    }\n    /**\n     * Merge a type variable's read subset (upper bound) constraints into this variable.\n     * This is used to accumulate read constraints when resolving a handle's type.\n     */\n    maybeMergeCanReadSubset(constraint) {\n        if (constraint == null) {\n            return true;\n        }\n        if (this.canReadSubset == null) {\n            this.canReadSubset = constraint;\n            return true;\n        }\n        if (this.canReadSubset instanceof SlotType && constraint instanceof SlotType) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        const mergedSchema = Schema.intersect(this.canReadSubset.entitySchema, constraint.entitySchema);\n        if (!mergedSchema) {\n            return false;\n        }\n        this.canReadSubset = new EntityType(mergedSchema);\n        return true;\n    }\n    /**\n     * merge a type variable's write superset (lower bound) constraints into this variable.\n     * This is used to accumulate write constraints when resolving a handle's type.\n     */\n    maybeMergeCanWriteSuperset(constraint) {\n        if (constraint == null) {\n            return true;\n        }\n        if (this.canWriteSuperset == null) {\n            this.canWriteSuperset = constraint;\n            return true;\n        }\n        if (this.canWriteSuperset instanceof SlotType && constraint instanceof SlotType) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        const mergedSchema = Schema.union(this.canWriteSuperset.entitySchema, constraint.entitySchema);\n        if (!mergedSchema) {\n            return false;\n        }\n        this.canWriteSuperset = new EntityType(mergedSchema);\n        return true;\n    }\n    isSatisfiedBy(type) {\n        const constraint = this._canWriteSuperset;\n        if (!constraint) {\n            return true;\n        }\n        if (!(constraint instanceof EntityType) || !(type instanceof EntityType)) {\n            throw new Error(`constraint checking not implemented for ${this} and ${type}`);\n        }\n        return type.getEntitySchema().isMoreSpecificThan(constraint.getEntitySchema());\n    }\n    get resolution() {\n        if (this._resolution) {\n            return this._resolution.resolvedType();\n        }\n        return null;\n    }\n    isValidResolutionCandidate(value) {\n        const elementType = value.resolvedType().getContainedType();\n        if (elementType instanceof TypeVariable && elementType.variable === this) {\n            return { result: false, detail: 'variable cannot resolve to collection of itself' };\n        }\n        return { result: true };\n    }\n    set resolution(value) {\n        assert(!this._resolution);\n        const isValid = this.isValidResolutionCandidate(value);\n        assert(isValid.result, isValid.detail);\n        let probe = value;\n        while (probe) {\n            if (!(probe instanceof TypeVariable)) {\n                break;\n            }\n            if (probe.variable === this) {\n                return;\n            }\n            probe = probe.variable.resolution;\n        }\n        this._resolution = value;\n        this._canWriteSuperset = null;\n        this._canReadSubset = null;\n    }\n    get canWriteSuperset() {\n        if (this._resolution) {\n            assert(!this._canWriteSuperset);\n            if (this._resolution instanceof TypeVariable) {\n                return this._resolution.variable.canWriteSuperset;\n            }\n            return null;\n        }\n        return this._canWriteSuperset;\n    }\n    set canWriteSuperset(value) {\n        assert(!this._resolution);\n        this._canWriteSuperset = value;\n    }\n    get canReadSubset() {\n        if (this._resolution) {\n            assert(!this._canReadSubset);\n            if (this._resolution instanceof TypeVariable) {\n                return this._resolution.variable.canReadSubset;\n            }\n            return null;\n        }\n        return this._canReadSubset;\n    }\n    set canReadSubset(value) {\n        assert(!this._resolution);\n        this._canReadSubset = value;\n    }\n    get hasConstraint() {\n        return this._canReadSubset !== null || this._canWriteSuperset !== null;\n    }\n    canEnsureResolved() {\n        if (this._resolution) {\n            return this._resolution.canEnsureResolved();\n        }\n        if (this._canWriteSuperset || this._canReadSubset) {\n            return true;\n        }\n        return false;\n    }\n    maybeEnsureResolved() {\n        if (this._resolution) {\n            return this._resolution.maybeEnsureResolved();\n        }\n        if (this._canWriteSuperset) {\n            this.resolution = this._canWriteSuperset;\n            return true;\n        }\n        if (this._canReadSubset) {\n            this.resolution = this._canReadSubset;\n            return true;\n        }\n        return false;\n    }\n    toLiteral() {\n        assert(this.resolution == null);\n        return this.toLiteralIgnoringResolutions();\n    }\n    toLiteralIgnoringResolutions() {\n        return {\n            name: this.name,\n            canWriteSuperset: this._canWriteSuperset && this._canWriteSuperset.toLiteral(),\n            canReadSubset: this._canReadSubset && this._canReadSubset.toLiteral()\n        };\n    }\n    static fromLiteral(data) {\n        return new TypeVariableInfo(data.name, data.canWriteSuperset ? Type.fromLiteral(data.canWriteSuperset) : null, data.canReadSubset ? Type.fromLiteral(data.canReadSubset) : null);\n    }\n    isResolved() {\n        return (this._resolution && this._resolution.isResolved());\n    }\n}\n//# sourceMappingURL=type-variable-info.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Random } from './random.js';\n// Id consists of 2 component: a session and an idTree.\nexport class Id {\n    constructor(currentSession, components = []) {\n        this.nextIdComponent = 0;\n        this.components = [];\n        this.session = currentSession;\n        this.currentSession = currentSession;\n        this.components = components;\n    }\n    static newSessionId() {\n        const session = Math.floor(Random.next() * Math.pow(2, 50)) + '';\n        return new Id(session);\n    }\n    /**\n     * When used in the following way:\n     *   const id = Id.newSessionId().fromString(stringId);\n     *\n     * The resulting id will receive a newly generated session id in the currentSession field,\n     * while maintaining an original session from the string representation in the session field.\n     */\n    fromString(str) {\n        const newId = new Id(this.currentSession);\n        let components = str.split(':');\n        if (components[0][0] === '!') {\n            newId.session = components[0].slice(1);\n            components = components.slice(1);\n        }\n        newId.components.push(...components);\n        return newId;\n    }\n    // Returns the full Id string.\n    toString() {\n        return `!${this.session}:${this.components.join(':')}`;\n    }\n    // Returns the idTree as string (without the session component).\n    idTreeAsString() {\n        return this.components.join(':');\n    }\n    createId(component = '') {\n        const id = new Id(this.currentSession, this.components.slice());\n        id.components.push(component + this.nextIdComponent++);\n        return id;\n    }\n    equal(id) {\n        if (id.session !== this.session || id.components.length !== this.components.length) {\n            return false;\n        }\n        for (let i = 0; i < id.components.length; i++) {\n            if (id.components[i] !== this.components[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=id.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nclass RNG {\n}\n/**\n * A basic random number generator using Math.random();\n */\nclass MathRandomRNG extends RNG {\n    next() {\n        return Math.random();\n    }\n}\n// Singleton Pattern\nconst random = new MathRandomRNG();\nexport class Random {\n    static next() {\n        return random.next();\n    }\n}\n//# sourceMappingURL=random.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { mapStackTrace } from '../platform/sourcemapped-stacktrace-web.js';\nimport { CrdtCollectionModel } from './storage/crdt-collection-model.js';\nimport { BigCollectionType, CollectionType } from './type.js';\nvar SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"none\"] = 0] = \"none\";\n    SyncState[SyncState[\"pending\"] = 1] = \"pending\";\n    SyncState[SyncState[\"full\"] = 2] = \"full\";\n})(SyncState || (SyncState = {}));\n/**\n * Mediates between one or more Handles and the backing store outside the PEC.\n *\n * This can operate in two modes, based on how observing handles are configured:\n * - synchronized: the proxy maintains a copy of the full data held by the backing store, keeping\n *                 it in sync by listening to change events from the store.\n * - unsynchronized: the proxy simply passes through calls from Handles to the backing store.\n *\n * In synchronized mode we maintain a queue of sorted update events received from the backing store.\n * While events are received correctly - each update is one version ahead of our stored model - they\n * are processed immediately and observing handles are notified accordingly. If we receive an update\n * with a \"future\" version, the proxy is desynchronized:\n * - a request for the full data is sent to the backing store;\n * - any update events received after that (and before the response) are added to the queue;\n * - any new updates that can be applied will be (which may cause the proxy to \"catch up\" and resync\n *   before the full data response arrives);\n * - once the resync response is received, stale queued updates are discarded and any remaining ones\n *   are applied.\n */\nexport class StorageProxy {\n    constructor(id, type, port, pec, scheduler, name) {\n        this.localIDComponent = 0;\n        this.version = undefined;\n        this.listenerAttached = false;\n        this.keepSynced = false;\n        this.synchronized = SyncState.none;\n        this.observers = [];\n        this.updates = [];\n        this.barrier = null;\n        this.id = id;\n        this.type = type;\n        this.port = port;\n        this.scheduler = scheduler;\n        this.name = name;\n        this.baseForNewID = pec.generateID();\n        this.updates = [];\n        this.pec = pec;\n    }\n    static newProxy(id, type, port, pec, scheduler, name) {\n        if (type instanceof CollectionType) {\n            return new CollectionProxy(id, type, port, pec, scheduler, name);\n        }\n        if (type instanceof BigCollectionType) {\n            return new BigCollectionProxy(id, type, port, pec, scheduler, name);\n        }\n        return new VariableProxy(id, type, port, pec, scheduler, name);\n    }\n    raiseSystemException(exception, methodName, particleId) {\n        // TODO: Encapsulate source-mapping of the stack trace once there are more users of the port.RaiseSystemException() call.\n        const { message, stack, name } = exception;\n        const raise = stack => this.port.RaiseSystemException({ message, stack, name }, methodName, particleId);\n        if (!mapStackTrace) {\n            raise(stack);\n        }\n        else {\n            mapStackTrace(stack, mappedStack => raise(mappedStack.join('\\n')));\n        }\n    }\n    /**\n     *  Called by ParticleExecutionContext to associate (potentially multiple) particle/handle pairs with this proxy.\n     */\n    register(particle, handle) {\n        if (!handle.canRead) {\n            return;\n        }\n        this.observers.push({ particle, handle });\n        // Attach an event listener to the backing store when the first readable handle is registered.\n        if (!this.listenerAttached) {\n            this.port.InitializeProxy(this, x => this._onUpdate(x));\n            this.listenerAttached = true;\n        }\n        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send\n        // a request to get the full model (once).\n        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced\n        if (handle.options.keepSynced) {\n            if (!this.keepSynced) {\n                this.port.SynchronizeProxy(this, x => this._onSynchronize(x));\n                this.keepSynced = true;\n            }\n            // If a handle configured for sync notifications registers after we've received the full\n            // model, notify it immediately.\n            if (handle.options.notifySync && this.synchronized === SyncState.full) {\n                const syncModel = this._getModelForSync();\n                this.scheduler.enqueue(particle, handle, ['sync', particle, syncModel]);\n            }\n        }\n    }\n    _onSynchronize({ version, model }) {\n        if (this.version !== undefined && version <= this.version) {\n            console.warn(`StorageProxy '${this.id}' received stale model version ${version}; ` +\n                `current is ${this.version}`);\n            return;\n        }\n        // Replace the stored data with the new one and notify handles that are configured for it.\n        if (!this._synchronizeModel(version, model)) {\n            return;\n        }\n        // We may have queued updates that were received after a desync; discard any that are stale\n        // with respect to the received model.\n        this.synchronized = SyncState.full;\n        while (this.updates.length > 0 && this.updates[0].version <= version) {\n            this.updates.shift();\n        }\n        const syncModel = this._getModelForSync();\n        this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n        this._processUpdates();\n    }\n    _onUpdate(update) {\n        // Immediately notify any handles that are not configured with keepSynced but do want updates.\n        if (this.observers.find(({ handle }) => !handle.options.keepSynced && handle.options.notifyUpdate)) {\n            const handleUpdate = this._processUpdate(update, false);\n            this._notify('update', handleUpdate, options => !options.keepSynced && options.notifyUpdate);\n        }\n        // Bail if we're not in synchronized mode or this is a stale event.\n        if (!this.keepSynced) {\n            return;\n        }\n        if (update.version <= this.version) {\n            console.warn(`StorageProxy '${this.id}' received stale update version ${update.version}; ` +\n                `current is ${this.version}`);\n            return;\n        }\n        // Add the update to the queue and process. Most of the time the queue should be empty and\n        // _processUpdates will consume this event immediately.\n        this.updates.push(update);\n        this.updates.sort((a, b) => a.version - b.version);\n        this._processUpdates();\n    }\n    _notify(kind, details, predicate = (ignored) => true) {\n        for (const { handle, particle } of this.observers) {\n            if (predicate(handle.options)) {\n                this.scheduler.enqueue(particle, handle, [kind, particle, details]);\n            }\n        }\n    }\n    _processUpdates() {\n        const updateIsNext = update => {\n            if (update.version === this.version + 1) {\n                return true;\n            }\n            // Holy Layering Violation Batman\n            //\n            // If we are a variable waiting for a barriered set response\n            // then that set response *is* the next thing we're waiting for,\n            // regardless of version numbers.\n            //\n            // TODO(shans): refactor this code so we don't need to layer-violate.\n            if (this.barrier && update.barrier === this.barrier) {\n                return true;\n            }\n            return false;\n        };\n        // Consume all queued updates whose versions are monotonically increasing from our stored one.\n        while (this.updates.length > 0 && updateIsNext(this.updates[0])) {\n            const update = this.updates.shift();\n            // Fold the update into our stored model.\n            const handleUpdate = this._processUpdate(update);\n            this.version = update.version;\n            // Notify handles configured with keepSynced and notifyUpdates (non-keepSynced handles are\n            // notified as updates are received).\n            if (handleUpdate) {\n                this._notify('update', handleUpdate, options => options.keepSynced && options.notifyUpdate);\n            }\n        }\n        // If we still have update events queued, we must have received a future version are are now\n        // desynchronized. Send a request for the full model and notify handles configured for it.\n        if (this.updates.length > 0) {\n            if (this.synchronized !== SyncState.none) {\n                this.synchronized = SyncState.none;\n                this.port.SynchronizeProxy(this, x => this._onSynchronize(x));\n                for (const { handle, particle } of this.observers) {\n                    if (handle.options.notifyDesync) {\n                        this.scheduler.enqueue(particle, handle, ['desync', particle]);\n                    }\n                }\n            }\n        }\n        else if (this.synchronized !== SyncState.full) {\n            // If we were desynced but have now consumed all update events, we've caught up.\n            this.synchronized = SyncState.full;\n        }\n    }\n    generateID() {\n        return `${this.baseForNewID}:${this.localIDComponent++}`;\n    }\n    generateIDComponents() {\n        return { base: this.baseForNewID, component: () => this.localIDComponent++ };\n    }\n}\n/**\n * Collections are synchronized in a CRDT Observed/Removed scheme.\n * Each value is identified by an ID and a set of membership keys.\n * Concurrent adds of the same value will specify the same ID but different\n * keys. A value is removed by removing all of the observed keys. A value\n * is considered to be removed if all of it's keys have been removed.\n *\n * In synchronized mode mutation takes place synchronously inside the proxy.\n * The proxy uses the originatorId to skip over redundant events sent back\n * by the storage object.\n *\n * In unsynchronized mode removal is not based on the keys observed at the\n * proxy, since the proxy does not remember the state, but instead the set\n * of keys that exist at the storage object at the time it receives the\n * request.\n */\nexport class CollectionProxy extends StorageProxy {\n    constructor() {\n        super(...arguments);\n        this.model = new CrdtCollectionModel();\n    }\n    _getModelForSync() {\n        return this.model.toList();\n    }\n    _synchronizeModel(version, model) {\n        this.version = version;\n        this.model = new CrdtCollectionModel(model);\n        return true;\n    }\n    _processUpdate(update, apply = true) {\n        if (this.synchronized === SyncState.full) {\n            // If we're synchronized, then any updates we sent have\n            // already been applied/notified.\n            for (const { handle } of this.observers) {\n                if (update.originatorId === handle._particleId) {\n                    return null;\n                }\n            }\n        }\n        const added = [];\n        const removed = [];\n        if ('add' in update) {\n            for (const { value, keys, effective } of update.add) {\n                if (apply && this.model.add(value.id, value, keys) || !apply && effective) {\n                    added.push(value);\n                }\n            }\n        }\n        else if ('remove' in update) {\n            for (const { value, keys, effective } of update.remove) {\n                const localValue = this.model.getValue(value.id);\n                if (apply && this.model.remove(value.id, keys) || !apply && effective) {\n                    removed.push(localValue);\n                }\n            }\n        }\n        else {\n            throw new Error(`StorageProxy received invalid update event: ${JSON.stringify(update)}`);\n        }\n        if (added.length || removed.length) {\n            const result = { originatorId: update.originatorId };\n            if (added.length)\n                result.add = added;\n            if (removed.length)\n                result.remove = removed;\n            return result;\n        }\n        return null;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    toList() {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model.toList());\n        }\n        else {\n            // TODO: in synchronized mode, this should integrate with SynchronizeProxy rather than\n            //       sending a parallel request\n            return new Promise(resolve => this.port.HandleToList(this, resolve));\n        }\n    }\n    get(id, particleId) {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model.getValue(id));\n        }\n        else {\n            return new Promise((resolve, reject) => this.port.HandleToList(this, r => resolve(r.find(entity => entity.id === id))));\n        }\n    }\n    store(value, keys, particleId) {\n        const id = value.id;\n        const data = { value, keys };\n        this.port.HandleStore(this, () => { }, data, particleId);\n        if (this.synchronized !== SyncState.full) {\n            return;\n        }\n        if (!this.model.add(id, value, keys)) {\n            return;\n        }\n        const update = { originatorId: particleId, add: [value] };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n    clear(particleId) {\n        if (this.synchronized !== SyncState.full) {\n            this.port.HandleRemoveMultiple(this, () => { }, [], particleId);\n        }\n        let items = this.model.toList().map(item => ({ id: item.id, keys: this.model.getKeys(item.id) }));\n        this.port.HandleRemoveMultiple(this, () => { }, items, particleId);\n        items = items.map(({ id, keys }) => ({ rawData: this.model.getValue(id).rawData, id, keys }));\n        items = items.filter(item => this.model.remove(item.id, item.keys));\n        if (items.length > 0) {\n            this._notify('update', { originatorId: particleId, remove: items }, options => options.notifyUpdate);\n        }\n    }\n    remove(id, keys, particleId) {\n        if (this.synchronized !== SyncState.full) {\n            const data = { id, keys: [] };\n            this.port.HandleRemove(this, () => { }, data, particleId);\n            return;\n        }\n        const value = this.model.getValue(id);\n        if (!value) {\n            return;\n        }\n        if (keys.length === 0) {\n            keys = this.model.getKeys(id);\n        }\n        const data = { id, keys };\n        this.port.HandleRemove(this, () => { }, data, particleId);\n        if (!this.model.remove(id, keys)) {\n            return;\n        }\n        const update = { originatorId: particleId, remove: [value] };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n}\n/**\n * Variables are synchronized in a 'last-writer-wins' scheme. When the\n * VariableProxy mutates the model, it sets a barrier and expects to\n * receive the barrier value echoed back in a subsequent update event.\n * Between those two points in time updates are not applied or\n * notified about as these reflect concurrent writes that did not 'win'.\n */\nexport class VariableProxy extends StorageProxy {\n    constructor() {\n        super(...arguments);\n        this.model = null;\n    }\n    _getModelForSync() {\n        return this.model;\n    }\n    _synchronizeModel(version, model) {\n        // If there's an active barrier then we shouldn't apply the model here, because\n        // there is a more recent write from the particle side that is still in flight.\n        if (this.barrier != null) {\n            return false;\n        }\n        this.version = version;\n        this.model = model.length === 0 ? null : model[0].value;\n        assert(this.model !== undefined);\n        return true;\n    }\n    _processUpdate(update, apply = true) {\n        assert('data' in update);\n        if (!apply) {\n            return update;\n        }\n        // If we have set a barrier, suppress updates until after\n        // we have seen the barrier return via an update.\n        if (this.barrier != null) {\n            if (update.barrier === this.barrier) {\n                this.barrier = null;\n                // HOLY LAYERING VIOLATION BATMAN\n                //\n                // We just cleared a barrier which means we are now synchronized. If we weren't\n                // synchronized already, then we need to tell the handles.\n                //\n                // TODO(shans): refactor this code so we don't need to layer-violate.\n                if (this.synchronized !== SyncState.full) {\n                    this.synchronized = SyncState.full;\n                    const syncModel = this._getModelForSync();\n                    this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n                }\n            }\n            return null;\n        }\n        this.model = update.data;\n        return update;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    // TODO: in synchronized mode, these should integrate with SynchronizeProxy rather than\n    //       sending a parallel request\n    get() {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model);\n        }\n        else {\n            return new Promise(resolve => this.port.HandleGet(this, resolve));\n        }\n    }\n    set(entity, particleId) {\n        assert(entity !== undefined);\n        if (JSON.stringify(this.model) === JSON.stringify(entity)) {\n            return;\n        }\n        let barrier;\n        // If we're setting to this handle but we aren't listening to firebase,\n        // then there's no point creating a barrier. In fact, if the response\n        // to the set comes back before a listener is registered then this proxy will\n        // end up locked waiting for a barrier that will never arrive.\n        if (this.listenerAttached) {\n            // TODO(shans): this.generateID() used to take a parameter. Is this the\n            // cause of some of the key collisions we're seeing?\n            barrier = this.generateID( /* 'barrier' */);\n        }\n        else {\n            barrier = null;\n        }\n        // TODO: is this already a clone?\n        this.model = JSON.parse(JSON.stringify(entity));\n        this.barrier = barrier;\n        this.port.HandleSet(this, entity, particleId, barrier);\n        const update = { originatorId: particleId, data: entity };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n    clear(particleId) {\n        if (this.model == null) {\n            return;\n        }\n        const barrier = this.generateID( /* 'barrier' */);\n        this.model = null;\n        this.barrier = barrier;\n        this.port.HandleClear(this, particleId, barrier);\n        const update = { originatorId: particleId, data: null };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n}\n// BigCollections are never synchronized. No local state is held and all operations are passed\n// directly through to the backing store.\nexport class BigCollectionProxy extends StorageProxy {\n    register(particle, handle) {\n        if (handle.canRead) {\n            this.scheduler.enqueue(particle, handle, ['sync', particle, {}]);\n        }\n    }\n    // tslint:disable-next-line: no-any\n    _getModelForSync() {\n        throw new Error(\"_getModelForSync not implemented for BigCollectionProxy\");\n    }\n    _processUpdate() {\n        throw new Error(\"_processUpdate not implemented for BigCollectionProxy\");\n    }\n    _synchronizeModel() {\n        throw new Error(\"_synchronizeModel not implemented for BigCollectionProxy\");\n    }\n    // TODO: surface get()\n    async store(value, keys, particleId) {\n        return new Promise(resolve => this.port.HandleStore(this, resolve, { value, keys }, particleId));\n    }\n    async remove(id, particleId) {\n        return new Promise(resolve => this.port.HandleRemove(this, resolve, { id, keys: [] }, particleId));\n    }\n    async stream(pageSize, forward) {\n        return new Promise(resolve => this.port.HandleStream(this, resolve, pageSize, forward));\n    }\n    async cursorNext(cursorId) {\n        return new Promise(resolve => this.port.StreamCursorNext(this, resolve, cursorId));\n    }\n    cursorClose(cursorId) {\n        this.port.StreamCursorClose(this, cursorId);\n    }\n}\nexport class StorageProxyScheduler {\n    constructor() {\n        this._scheduled = false;\n        this._queues = new Map();\n        this._idleResolver = null;\n        this._idle = null;\n        this._scheduled = false;\n        // Particle -> {Handle -> [Queue of events]}\n        this._queues = new Map();\n    }\n    // TODO: break apart args here, sync events should flush the queue.\n    enqueue(particle, handle, args) {\n        if (!this._queues.has(particle)) {\n            this._queues.set(particle, new Map());\n        }\n        const byHandle = this._queues.get(particle);\n        if (!byHandle.has(handle)) {\n            byHandle.set(handle, []);\n        }\n        const queue = byHandle.get(handle);\n        queue.push(args);\n        this._schedule();\n    }\n    get busy() {\n        return this._queues.size > 0;\n    }\n    _updateIdle() {\n        if (this._idleResolver && !this.busy) {\n            this._idleResolver();\n            this._idle = null;\n            this._idleResolver = null;\n        }\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        if (!this._idle) {\n            this._idle = new Promise(resolve => this._idleResolver = resolve);\n        }\n        return this._idle;\n    }\n    _schedule() {\n        if (this._scheduled) {\n            return;\n        }\n        this._scheduled = true;\n        setTimeout(() => {\n            this._scheduled = false;\n            this._dispatch();\n        }, 0);\n    }\n    _dispatch() {\n        // TODO: should we process just one particle per task?\n        while (this._queues.size > 0) {\n            const particle = [...this._queues.keys()][0];\n            const byHandle = this._queues.get(particle);\n            this._queues.delete(particle);\n            for (const [handle, queue] of byHandle.entries()) {\n                for (const args of queue) {\n                    try {\n                        handle._notify(...args);\n                    }\n                    catch (e) {\n                        console.error('Error dispatching to particle', e);\n                        handle._proxy.raiseSystemException(e, 'StorageProxyScheduler::_dispatch', handle._particleId);\n                    }\n                }\n            }\n        }\n        this._updateIdle();\n    }\n}\n//# sourceMappingURL=storage-proxy.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { assert } from '../../platform/assert-web.js';\nexport class CrdtCollectionModel {\n    constructor(model = undefined) {\n        // id => {value, Set[keys]}\n        this.items = new Map();\n        if (model) {\n            for (let { id, value, keys } of model) {\n                if (!keys) {\n                    keys = [];\n                }\n                this.items.set(id, { value, keys: new Set(keys) });\n            }\n        }\n    }\n    /**\n     * Adds membership, `keys`, of `value` indexed by `id` to this collection.\n     * Returns whether the change is effective (`id` is new to the collection,\n     * or `value` is different to the value previously stored).\n     */\n    add(id, value, keys) {\n        // Ensure that keys is actually an array, not a single string.\n        // TODO(shans): remove this when all callers are implemented in typeScript.\n        assert(keys.length > 0 && typeof keys === 'object', 'add requires a list of keys');\n        let item = this.items.get(id);\n        let effective = false;\n        if (!item) {\n            item = { value, keys: new Set(keys) };\n            this.items.set(id, item);\n            effective = true;\n        }\n        else {\n            let newKeys = false;\n            for (const key of keys) {\n                if (!item.keys.has(key)) {\n                    newKeys = true;\n                }\n                item.keys.add(key);\n            }\n            if (!this._equals(item.value, value)) {\n                assert(newKeys, 'cannot add without new keys. incoming=' + keys.join(',') + ' existing=' + [...item.keys].join(','));\n                item.value = value;\n                effective = true;\n            }\n        }\n        return effective;\n    }\n    _equals(value1, value2) {\n        if (Boolean(value1) !== Boolean(value2)) {\n            return false;\n        }\n        if (!value1) {\n            return true;\n        }\n        const type1 = typeof (value1);\n        if (type1 !== typeof (value2)) {\n            return false;\n        }\n        if (type1 === 'object') {\n            const keys = Object.keys(value1);\n            if (keys.length !== Object.keys(value2).length) {\n                return false;\n            }\n            return keys.every(key => this._equals(value1[key], value2[key]));\n        }\n        return JSON.stringify(value1) === JSON.stringify(value2);\n    }\n    /**\n     * Removes the membership, `keys`, of the value indexed by `id` from this collection.\n     * Returns whether the change is effective (the value is no longer present\n     * in the collection because all of the keys have been removed).\n     */\n    remove(id, keys) {\n        const item = this.items.get(id);\n        if (!item) {\n            return false;\n        }\n        for (const key of keys) {\n            item.keys.delete(key);\n        }\n        const effective = item.keys.size === 0;\n        if (effective) {\n            this.items.delete(id);\n        }\n        return effective;\n    }\n    // [{id, value, keys: []}]\n    toLiteral() {\n        const result = [];\n        for (const [id, { value, keys }] of this.items.entries()) {\n            result.push({ id, value, keys: [...keys] });\n        }\n        return result;\n    }\n    toList() {\n        return [...this.items.values()].map(item => item.value);\n    }\n    has(id) {\n        return this.items.has(id);\n    }\n    getKeys(id) {\n        const item = this.items.get(id);\n        return item ? [...item.keys] : [];\n    }\n    getValue(id) {\n        const item = this.items.get(id);\n        return item ? item.value : null;\n    }\n    get size() {\n        return this.items.size;\n    }\n}\n//# sourceMappingURL=crdt-collection-model.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {Loader} from '../runtime/loader.js';\nimport {Particle} from '../runtime/particle.js';\nimport {DomParticle} from '../runtime/dom-particle.js';\nimport {MultiplexerDomParticle} from '../runtime/multiplexer-dom-particle.js';\nimport {TransformationDomParticle} from '../runtime/transformation-dom-particle.js';\nimport {logFactory} from '../platform/log-web.js';\n\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\n\nlet dumbCache = {};\n\nexport class PlatformLoader extends Loader {\n  constructor(urlMap) {\n    super();\n    this._urlMap = urlMap || [];\n  }\n  flushCaches() {\n    dumbCache = {};\n  }\n  _loadURL(url) {\n    const resolved = this._resolve(url);\n    const cacheKey = this.normalizeDots(url);\n    const resource = dumbCache[cacheKey];\n    return resource || (dumbCache[cacheKey] = super._loadURL(resolved));\n  }\n  loadResource(name) {\n    // subclass impl differentiates paths and URLs,\n    // for browser env we can feed both kinds into _loadURL\n    return this._loadURL(name);\n  }\n  _resolve(path) {\n    let url = this._urlMap[path];\n    if (!url && path) {\n      // TODO(sjmiles): inefficient!\n      const macro = Object.keys(this._urlMap).sort((a, b) => b.length - a.length).find(k => path.slice(0, k.length) == k);\n      if (macro) {\n        url = this._urlMap[macro] + path.slice(macro.length);\n      }\n    }\n    url = url || path;\n    //console.log(`loader-web: resolve(${path}) = ${url}`);\n    return url;\n  }\n  // Below here invoked from inside Worker\n  async requireParticle(fileName) {\n    // inject path to this particle into the UrlMap,\n    // allows \"foo.js\" particle to invoke \"importScripts(resolver('foo/othermodule.js'))\"\n    this.mapParticleUrl(fileName);\n    // load wrapped particle\n    const result = [];\n    self.defineParticle = function(particleWrapper) {\n      result.push(particleWrapper);\n    };\n    // determine URL to load fileName\n    const url = await this._resolve(fileName);\n    importScripts(url);\n    // clean up\n    delete self.defineParticle;\n    // execute particle wrapper\n    return this.unwrapParticle(result[0], this.provisionLogger(fileName));\n  }\n  mapParticleUrl(fileName) {\n    const path = this._resolve(fileName);\n    const parts = path.split('/');\n    const suffix = parts.pop();\n    const folder = parts.join('/');\n    const name = suffix.split('.').shift();\n    this._urlMap[name] = folder;\n  }\n  provisionLogger(fileName) {\n    return logFactory(fileName.split('/').pop(), '#1faa00');\n  }\n  unwrapParticle(particleWrapper, log) {\n    const resolver = this._resolve.bind(this);\n    return particleWrapper({\n      Particle,\n      DomParticle,\n      MultiplexerDomParticle,\n      SimpleParticle: DomParticle,\n      TransformationDomParticle,\n      resolver,\n      log,\n      html\n    });\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { fetch } from '../platform/fetch-web.js';\nimport { fs } from '../platform/fs-web.js';\nimport { vm } from '../platform/vm-web.js';\nimport { JsonldToManifest } from './converters/jsonldToManifest.js';\nimport { DomParticle } from './dom-particle.js';\nimport { MultiplexerDomParticle } from './multiplexer-dom-particle.js';\nimport { Particle } from './particle.js';\nimport { Reference } from './reference.js';\nimport { TransformationDomParticle } from './transformation-dom-particle.js';\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\nfunction schemaLocationFor(name) {\n    return `../entities/${name}.schema`;\n}\nexport class Loader {\n    path(fileName) {\n        return fileName.replace(/[/][^/]+$/, '/');\n    }\n    join(prefix, path) {\n        if (/^https?:\\/\\//.test(path)) {\n            return path;\n        }\n        // TODO: replace this with something that isn't hacky\n        if (path[0] === '/' || path[1] === ':') {\n            return path;\n        }\n        prefix = this.path(prefix);\n        path = this.normalizeDots(`${prefix}${path}`);\n        return path;\n    }\n    // convert `././foo/bar/../baz` to `./foo/baz`\n    normalizeDots(path) {\n        // only unix slashes\n        path = path.replace(/\\\\/g, '/');\n        // remove './'\n        path = path.replace(/\\/\\.\\//g, '/');\n        // remove 'foo/..'\n        const norm = s => s.replace(/(?:^|\\/)[^./]*\\/\\.\\./g, '');\n        for (let n = norm(path); n !== path; path = n, n = norm(path))\n            ;\n        return path;\n    }\n    loadResource(file) {\n        if (/^https?:\\/\\//.test(file)) {\n            return this._loadURL(file);\n        }\n        return this._loadFile(file);\n    }\n    _loadFile(file) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(file, (err, data) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data.toString('utf-8'));\n                }\n            });\n        });\n    }\n    _loadURL(url) {\n        if (/\\/\\/schema.org\\//.test(url)) {\n            if (url.endsWith('/Thing')) {\n                return fetch('https://schema.org/Product.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data, { '@id': 'schema:Thing' }));\n            }\n            return fetch(url + '.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data));\n        }\n        return fetch(url).then(res => res.text());\n    }\n    async loadParticleClass(spec) {\n        const clazz = await this.requireParticle(spec.implFile);\n        clazz.spec = spec;\n        return clazz;\n    }\n    async requireParticle(fileName) {\n        if (fileName === null)\n            fileName = '';\n        const src = await this.loadResource(fileName);\n        // Note. This is not real isolation.\n        const script = new vm.Script(src, { filename: fileName, displayErrors: true });\n        const result = [];\n        const self = {\n            defineParticle(particleWrapper) {\n                result.push(particleWrapper);\n            },\n            console,\n            fetch,\n            setTimeout,\n            importScripts: s => null //console.log(`(skipping browser-space import for [${s}])`)\n        };\n        script.runInNewContext(self, { filename: fileName, displayErrors: true });\n        assert(result.length > 0 && typeof result[0] === 'function', `Error while instantiating particle implementation from ${fileName}`);\n        return this.unwrapParticle(result[0]);\n    }\n    setParticleExecutionContext(pec) {\n        this.pec = pec;\n    }\n    unwrapParticle(particleWrapper) {\n        assert(this.pec);\n        return particleWrapper({ Particle, DomParticle, TransformationDomParticle, MultiplexerDomParticle, Reference: Reference.newClientReference(this.pec), html });\n    }\n}\n//# sourceMappingURL=loader.js.map","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n// 'export default fetch' works because 'fetch' is evaluated as an expression, which finds the\n// appropriate global definition - but we don't want to use default exports.\n// 'export {fetch}' doesn't work because 'fetch' is just a name in that context and is not defined.\n// So we need to use an expression to find the global fetch function then map that for export.\n\nconst local_fetch = fetch;\nexport {local_fetch as fetch};\n","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport const fs = {};\n","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport const vm = {};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];\nexport class JsonldToManifest {\n    static convert(jsonld, theClass = undefined) {\n        const obj = JSON.parse(jsonld);\n        const classes = {};\n        const properties = {};\n        if (!obj['@graph']) {\n            obj['@graph'] = [obj];\n        }\n        for (const item of obj['@graph']) {\n            if (item['@type'] === 'rdf:Property') {\n                properties[item['@id']] = item;\n            }\n            else if (item['@type'] === 'rdfs:Class') {\n                classes[item['@id']] = item;\n                item['subclasses'] = [];\n                item['superclass'] = null;\n            }\n        }\n        for (const clazz of Object.values(classes)) {\n            if (clazz['rdfs:subClassOf'] !== undefined) {\n                if (clazz['rdfs:subClassOf'].length == undefined) {\n                    clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];\n                }\n                for (const subClass of clazz['rdfs:subClassOf']) {\n                    const superclass = subClass['@id'];\n                    if (clazz['superclass'] == undefined) {\n                        clazz['superclass'] = [];\n                    }\n                    if (classes[superclass]) {\n                        classes[superclass].subclasses.push(clazz);\n                        clazz['superclass'].push(classes[superclass]);\n                    }\n                    else {\n                        clazz['superclass'].push({ '@id': superclass });\n                    }\n                }\n            }\n        }\n        for (const clazz of Object.values(classes)) {\n            if (clazz['subclasses'].length === 0 && theClass == undefined) {\n                theClass = clazz;\n            }\n        }\n        const relevantProperties = [];\n        for (const property of Object.values(properties)) {\n            let domains = property['schema:domainIncludes'];\n            if (!domains) {\n                domains = { '@id': theClass['@id'] };\n            }\n            if (!domains.length) {\n                domains = [domains];\n            }\n            domains = domains.map(a => a['@id']);\n            if (domains.includes(theClass['@id'])) {\n                const name = property['@id'].split(':')[1];\n                let type = property['schema:rangeIncludes'];\n                if (!type) {\n                    console.log(property);\n                }\n                if (!type.length) {\n                    type = [type];\n                }\n                type = type.map(a => a['@id'].split(':')[1]);\n                type = type.filter(type => supportedTypes.includes(type));\n                if (type.length > 0) {\n                    relevantProperties.push({ name, type });\n                }\n            }\n        }\n        const className = theClass['@id'].split(':')[1];\n        const superNames = theClass && theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];\n        let s = '';\n        for (const superName of superNames) {\n            s += `import 'https://schema.org/${superName}'\\n\\n`;\n        }\n        s += `schema ${className}`;\n        if (superNames.length > 0) {\n            s += ` extends ${superNames.join(', ')}`;\n        }\n        if (relevantProperties.length > 0) {\n            for (const property of relevantProperties) {\n                let type;\n                if (property.type.length > 1) {\n                    type = '(' + property.type.join(' or ') + ')';\n                }\n                else {\n                    type = property.type[0];\n                }\n                s += `\\n  ${type} ${property.name}`;\n            }\n        }\n        s += '\\n';\n        return s;\n    }\n}\n//# sourceMappingURL=jsonldToManifest.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {XenStateMixin} from '../../modalities/dom/components/xen/xen-state.js';\nimport {DomParticleBase} from './dom-particle-base.js';\n\n/** @class DomParticle\n * Particle that interoperates with DOM and uses a simple state system\n * to handle updates.\n */\nexport class DomParticle extends XenStateMixin(DomParticleBase) {\n  constructor() {\n    super();\n    // alias properties to remove `_`\n    this.state = this._state;\n    this.props = this._props;\n  }\n  /** @method willReceiveProps(props, state, oldProps, oldState)\n   * Override if necessary, to do things when props change.\n   */\n  willReceiveProps() {\n  }\n  /** @method update(props, state, oldProps, oldState)\n   * Override if necessary, to modify superclass config.\n   */\n  update() {\n  }\n  /** @method shouldRender(props, state, oldProps, oldState)\n   * Override to return false if the Particle won't use\n   * it's slot.\n   */\n  shouldRender() {\n    return true;\n  }\n  /** @method render(props, state, oldProps, oldState)\n   * Override to return a dictionary to map into the template.\n   */\n  render() {\n    return {};\n  }\n  /** @method setState(state)\n   * Copy values from `state` into the particle's internal state,\n   * triggering an update cycle unless currently updating.\n   */\n  setState(state) {\n    return this._setState(state);\n  }\n  // TODO(sjmiles): deprecated, just use setState\n  setIfDirty(state) {\n    console.warn('DomParticle: `setIfDirty` is deprecated, please use `setState` instead');\n    return this._setState(state);\n  }\n  /** @method configureHandles(handles)\n   * This is called once during particle setup. Override to control sync and update\n   * configuration on specific handles (via their configure() method).\n   * `handles` is a map from names to handle instances.\n   */\n  configureHandles(handles) {\n    // Example: handles.get('foo').configure({keepSynced: false});\n  }\n  /** @method get config()\n   * Override if necessary, to modify superclass config.\n   */\n  get config() {\n    // TODO(sjmiles): getter that does work is a bad idea, this is temporary\n    return {\n      handleNames: this.spec.inputs.map(i => i.name),\n      // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from\n      // .manifest files, instead of .ptcl ones.\n      slotNames: [...this.spec.slots.values()].map(s => s.name)\n    };\n  }\n  // affordances for aliasing methods to remove `_`\n  _willReceiveProps(...args) {\n    this.willReceiveProps(...args);\n  }\n  _update(...args) {\n    this.update(...args);\n    if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?\n      this.relevance = 1; // TODO: improve relevance signal.\n    }\n    this.config.slotNames.forEach(s => this.renderSlot(s, ['model']));\n  }\n  //\n  // deprecated\n  get _views() {\n    console.warn(`Particle ${this.spec.name} uses deprecated _views getter.`);\n    return this.handles;\n  }\n  async setViews(views) {\n    console.warn(`Particle ${this.spec.name} uses deprecated setViews method.`);\n    return this.setHandles(views);\n  }\n  // end deprecated\n  //\n  async setHandles(handles) {\n    this.configureHandles(handles);\n    this.handles = handles;\n    this._handlesToSync = new Set();\n    for (const name of this.config.handleNames) {\n      const handle = handles.get(name);\n      if (handle && handle.options.keepSynced && handle.options.notifySync) {\n        this._handlesToSync.add(name);\n      }\n    }\n    // TODO(sjmiles): we must invalidate at least once, but we don't know if\n    // _handlesToProps will ever be called. If we wait we can avoid an extra\n    // invalidation, but then we potentially waste cycles.\n    //setTimeout(() => !this._hasProps && this._invalidate(), 20);\n    this._invalidate();\n  }\n  async onHandleSync(handle, model) {\n    this._handlesToSync.delete(handle.name);\n    if (this._handlesToSync.size == 0) {\n      await this._handlesToProps();\n    }\n  }\n  async onHandleUpdate(handle, update) {\n    // TODO(sjmiles): debounce handles updates\n    const work = () => {\n      //console.warn(handle, update);\n      this._handlesToProps();\n    };\n    this._debounce('handleUpdateDebounce', work, 300);\n  }\n  async _handlesToProps() {\n    const config = this.config;\n    // acquire (async) list data from handles; BigCollections map to the handle itself\n    const data = await Promise.all(\n      config.handleNames\n      .map(name => this.handles.get(name))\n      .map(handle => {\n        if (handle.toList) return handle.toList();\n        if (handle.get) return handle.get();\n        return handle;\n      })\n    );\n    // convert handle data (array) into props (dictionary)\n    const props = Object.create(null);\n    config.handleNames.forEach((name, i) => {\n      props[name] = data[i];\n    });\n    this._hasProps = true;\n    this._setProps(props);\n  }\n  fireEvent(slotName, {handler, data}) {\n    if (this[handler]) {\n      // TODO(sjmiles): remove `this._state` parameter\n      this[handler]({data}, this._state);\n    }\n  }\n  _debounce(key, func, delay) {\n    const subkey = `_debounce_${key}`;\n    if (!this._state[subkey]) {\n      this.startBusy();\n    }\n    const idleThenFunc = () => {\n      this.doneBusy();\n      func();\n      this._state[subkey] = null;\n    };\n    super._debounce(key, idleThenFunc, delay);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst nob = () => Object.create(null);\n\nconst debounce = (key, action, delay) => {\n  if (key) {\n    clearTimeout(key);\n  }\n  if (action && delay) {\n    return setTimeout(action, delay);\n  }\n};\n\nconst XenStateMixin = Base => class extends Base {\n  constructor() {\n    super();\n    this._pendingProps = nob();\n    this._props = this._getInitialProps() || nob();\n    this._lastProps = nob();\n    this._state = this._getInitialState() || nob();\n    this._lastState = nob();\n  }\n  _getInitialProps() {\n  }\n  _getInitialState() {\n  }\n  _getProperty(name) {\n    return this._pendingProps[name] || this._props[name];\n  }\n  _setProperty(name, value) {\n    // dirty checking opportunity\n    if (this._validator || this._wouldChangeProp(name, value)) {\n      this._pendingProps[name] = value;\n      this._invalidateProps();\n    }\n  }\n  _wouldChangeValue(map, name, value) {\n    // TODO(sjmiles): fundamental dirty-checking issue here. Can be overridden to change\n    // behavior, but the default implementation will use strict reference checking.\n    // To modify structured values one must create a new Object with the new values.\n    // See `_setImmutableState`.\n    return (map[name] !== value);\n    // TODO(sjmiles): an example of dirty-checking that instead simply punts on structured data\n    //return (typeof value === 'object') || (map[name] !== value);\n  }\n  _wouldChangeProp(name, value) {\n    return this._wouldChangeValue(this._props, name, value);\n  }\n  _wouldChangeState(name, value) {\n    return this._wouldChangeValue(this._state, name, value);\n  }\n  _setProps(props) {\n    // TODO(sjmiles): should be a replace instead of a merge?\n    Object.assign(this._pendingProps, props);\n    this._invalidateProps();\n  }\n  _invalidateProps() {\n    this._propsInvalid = true;\n    this._invalidate();\n  }\n  _setImmutableState(name, value) {\n    if (typeof name === 'object') {\n      console.warn('Xen:: _setImmutableState takes name and value args for a single property, dictionaries not supported.');\n      value = Object.values(name)[0];\n      name = Object.names(name)[0];\n    }\n    if (typeof value === 'object') {\n      value = Object.assign(Object.create(null), value);\n    }\n    this._state[name] = value;\n    this._invalidate();\n  }\n  _setState(object) {\n    let dirty = false;\n    const state = this._state;\n    for (const property in object) {\n      const value = object[property];\n      if (this._wouldChangeState(property, value)) {\n        dirty = true;\n        state[property] = value;\n      }\n    }\n    if (dirty) {\n      this._invalidate();\n      return true;\n    }\n  }\n  // TODO(sjmiles): deprecated\n  _setIfDirty(object) {\n    return this._setState(object);\n  }\n  _async(fn) {\n    return Promise.resolve().then(fn.bind(this));\n    //return setTimeout(fn.bind(this), 10);\n  }\n  _invalidate() {\n    if (!this._validator) {\n      this._validator = this._async(this._validate);\n    }\n  }\n  _getStateArgs() {\n    return [this._props, this._state, this._lastProps, this._lastState];\n  }\n  _validate() {\n    const stateArgs = this._getStateArgs();\n    // try..catch to ensure we nullify `validator` before return\n    try {\n      // TODO(sjmiles): should be a replace instead of a merge\n      Object.assign(this._props, this._pendingProps);\n      if (this._propsInvalid) {\n        // TODO(sjmiles): should/can have different timing from rendering?\n        this._willReceiveProps(...stateArgs);\n        this._propsInvalid = false;\n      }\n      if (this._shouldUpdate(...stateArgs)) {\n        // TODO(sjmiles): consider throttling update to rAF\n        this._ensureMount();\n        this._doUpdate(...stateArgs);\n      }\n    } catch (x) {\n      console.error(x);\n    }\n    // nullify validator _after_ methods so state changes don't reschedule validation\n    this._validator = null;\n    // save the old props and state\n    this._lastProps = Object.assign(nob(), this._props);\n    this._lastState = Object.assign(nob(), this._state);\n  }\n  _doUpdate(...stateArgs) {\n    this._update(...stateArgs);\n    this._didUpdate(...stateArgs);\n  }\n  _ensureMount() {\n  }\n  _willReceiveProps() {\n  }\n  _shouldUpdate() {\n    return true;\n  }\n  _update() {\n  }\n  _didUpdate() {\n  }\n  _debounce(key, func, delay) {\n    key = `_debounce_${key}`;\n    this._state[key] = debounce(this._state[key], func, delay != null ? delay : 16);\n  }\n};\n\nexport {XenStateMixin, nob, debounce};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { BigCollection } from './handle.js';\nimport { Collection } from './handle.js';\nimport { Variable } from './handle.js';\nimport { Particle } from './particle.js';\n/**\n * Particle that interoperates with DOM.\n */\nexport class DomParticleBase extends Particle {\n    constructor() {\n        super();\n    }\n    /**\n     * Override to return a String defining primary markup.\n     */\n    get template() {\n        return '';\n    }\n    /**\n     * Override to return a String defining primary markup for the given slot name.\n     */\n    getTemplate(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return this.template;\n    }\n    /**\n     * Override to return a String defining the name of the template for the given slot name.\n     */\n    getTemplateName(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return `default`;\n    }\n    /**\n     * Override to return false if the Particle won't use it's slot.\n     */\n    shouldRender(stateArgs) {\n        return true;\n    }\n    /**\n     * Override to return a dictionary to map into the template.\n     */\n    render(stateArgs) {\n        return {};\n    }\n    renderSlot(slotName, contentTypes) {\n        const stateArgs = this._getStateArgs();\n        const slot = this.getSlot(slotName);\n        if (!slot) {\n            return; // didn't receive StartRender.\n        }\n        // Set this to support multiple slots consumed by a particle, without needing\n        // to pass slotName to particle's render method, where it useless in most cases.\n        this.currentSlotName = slotName;\n        contentTypes.forEach(ct => slot.requestedContentTypes.add(ct));\n        // TODO(sjmiles): redundant, same answer for every slot\n        if (this.shouldRender(...stateArgs)) {\n            const content = {};\n            if (slot.requestedContentTypes.has('template')) {\n                content.template = this.getTemplate(slot.slotName);\n            }\n            if (slot.requestedContentTypes.has('model')) {\n                content.model = this.render(...stateArgs);\n            }\n            content.templateName = this.getTemplateName(slot.slotName);\n            // Backwards-compatibility and convenience code:\n            //  - Rewrites slotid=\"slotName\" to slotid$=\"{{$slotName}}\" in templates.\n            //  - Enhances the model with `$slotName` fields.\n            if (slot.providedSlots.size > 0) {\n                if (content.template) {\n                    if (typeof content.template === 'string') {\n                        content.template = this.slotNamesToModelReferences(slot, content.template);\n                    }\n                    else {\n                        content.template = Object.entries(content.template).reduce((templateDictionary, [templateName, templateValue]) => {\n                            templateDictionary[templateName] = this.slotNamesToModelReferences(slot, templateValue);\n                            return templateDictionary;\n                        }, {});\n                    }\n                }\n                if (content.model) {\n                    const slotIDs = {};\n                    slot.providedSlots.forEach((slotId, slotName) => slotIDs[`$${slotName}`] = slotId);\n                    content.model = this.enhanceModelWithSlotIDs(content.model, slotIDs);\n                }\n            }\n            slot.render(content);\n        }\n        else if (slot.isRendered) {\n            // Send empty object, to clear rendered slot contents.\n            slot.render({});\n        }\n        this.currentSlotName = undefined;\n    }\n    slotNamesToModelReferences(slot, template) {\n        slot.providedSlots.forEach((slotId, slotName) => {\n            // TODO: This is a simple string replacement right now,\n            // ensuring that 'slotid' is an attribute on an HTML element would be an improvement.\n            // TODO(sjmiles): clone original id as `slotname` for human readability\n            template = template.replace(new RegExp(`slotid=\\\"${slotName}\\\"`, 'gi'), `slotname=\"${slotName}\" slotid$=\"{{$${slotName}}}\"`);\n        });\n        return template;\n    }\n    // We put slot IDs at the top-level of the model as well as in models for sub-templates.\n    // This is temporary and should go away when we move from sub-IDs to [(Entity, Slot)] constructs.\n    enhanceModelWithSlotIDs(model = {}, slotIDs, topLevel = true) {\n        if (topLevel) {\n            model = Object.assign({}, slotIDs, model);\n        }\n        if (model.hasOwnProperty('$template') && model.hasOwnProperty('models') && Array.isArray(model['models'])) {\n            model['models'] = model['models'].map(m => this.enhanceModelWithSlotIDs(m, slotIDs));\n        }\n        for (const [key, value] of Object.entries(model)) {\n            if (!!value && typeof value === 'object') {\n                model[key] = this.enhanceModelWithSlotIDs(value, slotIDs, false);\n            }\n        }\n        return model;\n    }\n    _getStateArgs() {\n        return [];\n    }\n    forceRenderTemplate(slotName) {\n        this.slotByName.forEach((slot, name) => {\n            if (!slotName || (name === slotName)) {\n                slot.requestedContentTypes.add('template');\n            }\n        });\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            this[handler]({ data });\n        }\n    }\n    setParticleDescription(pattern) {\n        if (typeof pattern === 'string') {\n            return super.setParticleDescription(pattern);\n        }\n        assert(!!pattern.template && !!pattern.model, 'Description pattern must either be string or have template and model');\n        super.setDescriptionPattern('_template_', pattern.template);\n        super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));\n        return undefined;\n    }\n    /**\n     * Remove all entities from named handle.\n     */\n    async clearHandle(handleName) {\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Variable || handle instanceof Collection) {\n            handle.clear();\n        }\n        else {\n            throw new Error('Variable/Collection required');\n        }\n    }\n    /**\n     * Merge entities from Array into named handle.\n     */\n    async mergeEntitiesToHandle(handleName, entities) {\n        const idMap = {};\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Collection) {\n            const handleEntities = await handle.toList();\n            handleEntities.forEach(entity => idMap[entity.id] = entity);\n            for (const entity of entities) {\n                if (!idMap[entity.id]) {\n                    handle.store(entity);\n                }\n            }\n        }\n        else {\n            throw new Error('Collection required');\n        }\n    }\n    /**\n     * Append entities from Array to named handle.\n     */\n    async appendEntitiesToHandle(handleName, entities) {\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                Promise.all(entities.map(entity => handle.store(entity)));\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Create an entity from each rawData, and append to named handle.\n     */\n    async appendRawDataToHandle(handleName, rawDataArray) {\n        const handle = this.handles.get(handleName);\n        if (handle && handle.entityClass) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                // Typescript can't infer the type here and fails with TS2351\n                // tslint:disable-next-line: no-any\n                const entityClass = handle.entityClass;\n                Promise.all(rawDataArray.map(raw => handle.store(new entityClass(raw))));\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Modify value of named handle. A new entity is created\n     * from `rawData` (`new [EntityClass](rawData)`).\n     */\n    updateVariable(handleName, rawData) {\n        const handle = this.handles.get(handleName);\n        if (handle && handle.entityClass) {\n            if (handle instanceof Variable) {\n                // Typescript can't infer the type here and fails with TS2351\n                // tslint:disable-next-line: no-any\n                const entityClass = handle.entityClass;\n                const entity = new entityClass(rawData);\n                handle.set(entity);\n                return entity;\n            }\n            else {\n                throw new Error('Variable required');\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Modify or insert `entity` into named handle.\n     * Modification is done by removing the old entity and reinserting the new one.\n     */\n    async updateSet(handleName, entity) {\n        // Set the entity into the right place in the set. If we find it\n        // already present replace it, otherwise, add it.\n        // TODO(dstockwell): Replace this with happy entity mutation approach.\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                await handle.remove(entity);\n                await handle.store(entity);\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Returns array of Entities found in BOXED data `box` that are owned by `userid`\n     */\n    boxQuery(box, userid) {\n        return box.filter(item => userid === item.getUserID().split('|')[0]);\n    }\n}\n//# sourceMappingURL=dom-particle-base.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { BigCollection } from './handle.js';\nimport { Collection } from './handle.js';\n/**\n * A basic particle. For particles that provide UI, you may like to\n * instead use DOMParticle.\n */\nexport class Particle {\n    constructor(capabilities) {\n        this.relevances = [];\n        this._idle = Promise.resolve();\n        this._busy = 0;\n        // Only used by a Slotlet class in particle-execution-context\n        // tslint:disable-next-line: no-any\n        this.slotByName = new Map();\n        // Typescript only sees this.constructor as a Function type.\n        // TODO(shans): move spec off the constructor\n        this.spec = this.constructor['spec'];\n        if (this.spec.inputs.length === 0) {\n            this.extraData = true;\n        }\n        this.capabilities = capabilities || {};\n    }\n    /**\n     * This method is invoked with a handle for each store this particle\n     * is registered to interact with, once those handles are ready for\n     * interaction. Override the method to register for events from\n     * the handles.\n     *\n     * @param handles a map from handle names to store handles.\n     */\n    setHandles(handles) {\n    }\n    /**\n     * This method is deprecated. Use setHandles instead.\n     */\n    setViews(views) {\n    }\n    /**\n     * Called for handles that are configured with both keepSynced and notifySync, when they are\n     * updated with the full model of their data. This will occur once after setHandles() and any time\n     * thereafter if the handle is resynchronized.\n     *\n     * @param handle The Handle instance that was updated.\n     * @param model For Variable-backed Handles, the Entity data or null if the Variable is not set.\n     *        For Collection-backed Handles, the Array of Entities, which may be empty.\n     */\n    onHandleSync(handle, model) {\n    }\n    /**\n     * Called for handles that are configued with notifyUpdate, when change events are received from\n     * the backing store. For handles also configured with keepSynced these events will be correctly\n     * ordered, with some potential skips if a desync occurs. For handles not configured with\n     * keepSynced, all change events will be passed through as they are received.\n     *\n     * @param handle The Handle instance that was updated.\n     * @param update An object containing one of the following fields:\n     *  - data: The full Entity for a Variable-backed Handle.\n     *  - added: An Array of Entities added to a Collection-backed Handle.\n     *  - removed: An Array of Entities removed from a Collection-backed Handle.\n     */\n    // tslint:disable-next-line: no-any\n    onHandleUpdate(handle, update) {\n    }\n    /**\n     * Called for handles that are configured with both keepSynced and notifyDesync, when they are\n     * detected as being out-of-date against the backing store. For Variables, the event that triggers\n     * this will also resync the data and thus this call may usually be ignored. For Collections, the\n     * underlying proxy will automatically request a full copy of the stored data to resynchronize.\n     * onHandleSync will be invoked when that is received.\n     *\n     * @param handle The Handle instance that was desynchronized.\n     */\n    onHandleDesync(handle) {\n    }\n    constructInnerArc() {\n        if (!this.capabilities.constructInnerArc) {\n            throw new Error('This particle is not allowed to construct inner arcs');\n        }\n        return this.capabilities.constructInnerArc(this);\n    }\n    get busy() {\n        return this._busy > 0;\n    }\n    get idle() {\n        return this._idle;\n    }\n    set relevance(r) {\n        this.relevances.push(r);\n    }\n    startBusy() {\n        if (this._busy === 0) {\n            this._idle = new Promise(resolve => this._idleResolver = resolve);\n        }\n        this._busy++;\n    }\n    doneBusy() {\n        this._busy--;\n        if (this._busy === 0) {\n            this._idleResolver();\n        }\n    }\n    inputs() {\n        return this.spec.inputs;\n    }\n    outputs() {\n        return this.spec.outputs;\n    }\n    /**\n     * Returns the slot with provided name.\n     */\n    getSlot(name) {\n        return this.slotByName.get(name);\n    }\n    static buildManifest(strings, ...bits) {\n        const output = [];\n        for (let i = 0; i < bits.length; i++) {\n            const str = strings[i];\n            const indent = / *$/.exec(str)[0];\n            let bitStr;\n            if (typeof bits[i] === 'string') {\n                bitStr = bits[i];\n            }\n            else {\n                bitStr = bits[i].toManifestString();\n            }\n            bitStr = bitStr.replace(/(\\n)/g, '$1' + indent);\n            output.push(str);\n            output.push(bitStr);\n        }\n        if (strings.length > bits.length) {\n            output.push(strings[strings.length - 1]);\n        }\n        return output.join('');\n    }\n    setParticleDescription(pattern) {\n        return this.setDescriptionPattern('pattern', pattern);\n    }\n    setDescriptionPattern(connectionName, pattern) {\n        const descriptions = this.handles.get('descriptions');\n        if (descriptions) {\n            // Typescript can't infer the type here and fails with TS2351\n            // tslint:disable-next-line: no-any\n            const entityClass = descriptions.entityClass;\n            if (descriptions instanceof Collection || descriptions instanceof BigCollection) {\n                descriptions.store(new entityClass({ key: connectionName, value: pattern }, this.spec.name + '-' + connectionName));\n            }\n            return true;\n        }\n        throw new Error('A particle needs a description handle to set a decription pattern');\n    }\n    // abstract\n    renderSlot(slotName, contentTypes) { }\n    renderHostedSlot(slotName, hostedSlotId, content) { }\n    fireEvent(slotName, event) { }\n}\n//# sourceMappingURL=particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {assert} from '../platform/assert-web.js';\nimport {ParticleSpec} from './particle-spec.js';\nimport {TransformationDomParticle} from './transformation-dom-particle.js';\n\nexport class MultiplexerDomParticle extends TransformationDomParticle {\n  constructor() {\n    super();\n    this._itemSubIdByHostedSlotId = new Map();\n    this._connByHostedConn = new Map();\n  }\n\n  async _mapParticleConnections(\n      listHandleName,\n      particleHandleName,\n      hostedParticle,\n      handles,\n      arc) {\n    const otherMappedHandles = [];\n    const otherConnections = [];\n    let index = 2;\n    const skipConnectionNames = [listHandleName, particleHandleName];\n    for (const [connectionName, otherHandle] of handles) {\n      if (skipConnectionNames.includes(connectionName)) {\n        continue;\n      }\n      // TODO(wkorman): For items with embedded recipes we may need a map\n      // (perhaps id to index) to make sure we don't map a handle into the inner\n      // arc multiple times unnecessarily.\n      otherMappedHandles.push(\n          `use '${await arc.mapHandle(otherHandle._proxy)}' as v${index}`);\n      const hostedOtherConnection = hostedParticle.connections.find(\n          conn => conn.isCompatibleType(otherHandle.type));\n      if (hostedOtherConnection) {\n        otherConnections.push(`${hostedOtherConnection.name} = v${index++}`);\n        // TODO(wkorman): For items with embedded recipes where we may have a\n        // different particle rendering each item, we need to track\n        // |connByHostedConn| keyed on the particle type.\n        this._connByHostedConn.set(hostedOtherConnection.name, connectionName);\n      }\n    }\n    return [otherMappedHandles, otherConnections];\n  }\n\n  async setHandles(handles) {\n    this.handleIds = {};\n    const arc = await this.constructInnerArc();\n    const listHandleName = 'list';\n    const particleHandleName = 'hostedParticle';\n    const particleHandle = handles.get(particleHandleName);\n    let hostedParticle = null;\n    let otherMappedHandles = [];\n    let otherConnections = [];\n    if (particleHandle) {\n      hostedParticle = await particleHandle.get();\n      if (hostedParticle) {\n        [otherMappedHandles, otherConnections] =\n            await this._mapParticleConnections(\n                listHandleName, particleHandleName, hostedParticle, handles, arc);\n      }\n    }\n    this.setState({\n      arc,\n      type: handles.get(listHandleName).type,\n      hostedParticle,\n      otherMappedHandles,\n      otherConnections\n    });\n\n    super.setHandles(handles);\n  }\n\n  async willReceiveProps(\n      {list},\n      {arc, type, hostedParticle, otherMappedHandles, otherConnections}) {\n    if (list.length > 0) {\n      this.relevance = 0.1;\n    }\n\n    for (const [index, item] of this.getListEntries(list)) {\n      let resolvedHostedParticle = hostedParticle;\n      if (this.handleIds[item.id]) {\n        const itemHandle = await this.handleIds[item.id];\n        itemHandle.set(item);\n        continue;\n      }\n\n      const itemHandlePromise =\n          arc.createHandle(type.getContainedType(), 'item' + index);\n      this.handleIds[item.id] = itemHandlePromise;\n\n      const itemHandle = await itemHandlePromise;\n\n      if (!resolvedHostedParticle) {\n        // If we're muxing on behalf of an item with an embedded recipe, the\n        // hosted particle should be retrievable from the item itself. Else we\n        // just skip this item.\n        if (!item.renderParticleSpec) {\n          continue;\n        }\n        resolvedHostedParticle =\n            ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));\n        // Re-map compatible handles and compute the connections specific\n        // to this item's render particle.\n        const listHandleName = 'list';\n        const particleHandleName = 'renderParticle';\n        [otherMappedHandles, otherConnections] =\n            await this._mapParticleConnections(\n                listHandleName,\n                particleHandleName,\n                resolvedHostedParticle,\n                this.handles,\n                arc);\n      }\n      const hostedSlotName = [...resolvedHostedParticle.slots.keys()][0];\n      const slotName = [...this.spec.slots.values()][0].name;\n      const slotId = await arc.createSlot(this, slotName, itemHandle._id);\n\n      if (!slotId) {\n        continue;\n      }\n\n      this._itemSubIdByHostedSlotId.set(slotId, item.id);\n\n      try {\n        const recipe = this.constructInnerRecipe(\n          resolvedHostedParticle,\n          item,\n          itemHandle,\n          {name: hostedSlotName, id: slotId},\n          {connections: otherConnections, handles: otherMappedHandles}\n        );\n        await arc.loadRecipe(recipe, this);\n        itemHandle.set(item);\n      } catch (e) {\n        console.log(e);\n      }\n    }\n  }\n\n  combineHostedModel(slotName, hostedSlotId, content) {\n    const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n    if (!subId) {\n      return;\n    }\n    const items = this._state.renderModel ? this._state.renderModel.items : [];\n    const listIndex = items.findIndex(item => item.subId == subId);\n    const item = Object.assign({}, content.model, {subId});\n    if (listIndex >= 0 && listIndex < items.length) {\n      items[listIndex] = item;\n    } else {\n      items.push(item);\n    }\n    this._setState({renderModel: {items}});\n  }\n\n  combineHostedTemplate(slotName, hostedSlotId, content) {\n    const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n    if (!subId) {\n      return;\n    }\n    assert(content.templateName, `Template name is missing for slot '${slotName}' (hosted slot ID: '${hostedSlotId}')`);\n    this._setState({templateName: Object.assign(this._state.templateName || {}, {[subId]: `${content.templateName}`})});\n\n    if (content.template) {\n      let template = content.template;\n      // Append subid$={{subid}} attribute to all provided slots, to make it usable for the transformation particle.\n      template = template.replace(new RegExp('slotid=\"[a-z]+\"', 'gi'), '$& subid$=\"{{subId}}\"');\n\n      // Replace hosted particle connection in template with the corresponding particle connection names.\n      // TODO: make this generic!\n      this._connByHostedConn.forEach((conn, hostedConn) => {\n        template = template.replace(\n            new RegExp(`{{${hostedConn}.description}}`, 'g'),\n            `{{${conn}.description}}`);\n      });\n      this._setState({template: Object.assign(this._state.template || {}, {[content.templateName]: template})});\n\n      this.forceRenderTemplate();\n    }\n  }\n\n  // Abstract methods below.\n\n  // Called to produce a full interpolated recipe for loading into an inner\n  // arc for each item. Subclasses should override this method as by default\n  // it does nothing and so no recipe will be returned and content will not\n  // be loaded successfully into the inner arc.\n  constructInnerRecipe(hostedParticle, item, itemHandle, slot, other) {}\n\n  // Called with the list of items and by default returns the direct result of\n  // `Array.entries()`. Subclasses can override this method to alter the item\n  // order or otherwise permute the items as desired before their slots are\n  // created and contents are rendered.\n  getListEntries(list) {\n    return list.entries();\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {DomParticle} from './dom-particle.js';\n\n// Regex to separate style and template.\nconst re = /<style>((?:.|[\\r\\n])*)<\\/style>((?:.|[\\r\\n])*)/;\n\n/** @class TransformationDomParticle\n * Particle that does transformation stuff with DOM.\n */\nexport class TransformationDomParticle extends DomParticle {\n  getTemplate(slotName) {\n    // TODO: add support for multiple slots.\n    return this._state.template;\n  }\n  getTemplateName(slotName) {\n    // TODO: add support for multiple slots.\n    return this._state.templateName;\n  }\n  render(props, state) {\n    return state.renderModel;\n  }\n  shouldRender(props, state) {\n    return Boolean((state.template || state.templateName) && state.renderModel);\n  }\n\n  renderHostedSlot(slotName, hostedSlotId, content) {\n    this.combineHostedTemplate(slotName, hostedSlotId, content);\n    this.combineHostedModel(slotName, hostedSlotId, content);\n  }\n\n  // abstract\n  combineHostedTemplate(slotName, hostedSlotId, content) {}\n  combineHostedModel(slotName, hostedSlotId, content) {}\n\n  // Helper methods that may be reused in transformation particles to combine hosted content.\n  static propsToItems(propsValues) {\n    return propsValues ? propsValues.map(({rawData, id}) => Object.assign({}, rawData, {subId: id})) : [];\n  }\n}\n","// Copyright (c) 2018 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nlet logLevel = 0;\nif (typeof window !== 'undefined') {\n  logLevel = ('logLevel' in window) ? window.logLevel : logLevel;\n  console.log(`log-web: binding logFactory to level [${logLevel}]`);\n}\n\nconst _factory = (preamble, color, log='log') => console[log].bind(console, `%c${preamble}`, `background: ${color}; color: white; padding: 1px 6px 2px 7px; border-radius: 6px;`);\nconst factory = logLevel > 0 ? _factory : () => () => {};\nlet logFactory;\nlogFactory = (...args) => factory(...args);\n\nif (typeof window !== 'undefined') {\n  //logFactory = () => (...args) => document.body.appendChild(document.createElement('div')).innerText = args.join();\n} else {\n  logFactory = () => (...args) => postMessage(args.join());\n}\n\nexport {logFactory};\n"],"sourceRoot":""}