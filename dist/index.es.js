import assert from 'assert';
import crypto$1 from 'crypto';
import fetch from 'node-fetch';
import fs from 'fs';
import vm from 'vm';
import idb from 'idb';
import rs from 'jsrsasign';
import WebCrypto from 'node-webcrypto-ossl';
import WebSocket from 'ws';
import os from 'os';

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var ModalityName;
(function (ModalityName) {
    ModalityName["Dom"] = "dom";
    ModalityName["DomTouch"] = "domTouch";
    ModalityName["Vr"] = "vr";
    ModalityName["Voice"] = "voice";
})(ModalityName || (ModalityName = {}));
class Modality {
    // `all` true means modality is non restricted and any modality is compatible.
    // Otherwise, the `names` field in Modality contains the restrictive list of
    // modalities (an empty list stands for no suitable modalities being available).
    constructor(all, names = []) {
        this.all = all;
        this.names = names;
    }
    static create(names) {
        assert(names != null);
        return new Modality(false, names);
    }
    intersection(other) {
        if (this.all && other.all) {
            return new Modality(true, []);
        }
        if (this.all) {
            return new Modality(false, other.names);
        }
        return new Modality(false, this.names.filter(name => other.all || other.names.includes(name)));
    }
    static intersection(modalities) {
        return modalities.reduce((modality, total) => modality.intersection(total), Modality.all);
    }
    union(other) {
        if (this.all || other.all) {
            return Modality.all;
        }
        return new Modality(false, [...new Set(this.names.concat(other.names))]);
    }
    static union(modalities) {
        return modalities.length === 0
            ? Modality.all
            : modalities.reduce((modality, total) => modality.union(total), Modality.create([]));
    }
    isResolved() {
        return this.all || this.names.length > 0;
    }
    isCompatible(names) {
        return this.intersection(Modality.create(names)).isResolved();
    }
    static get Name() { return ModalityName; }
}
Modality.all = new Modality(true, []);
Modality.dom = new Modality(false, [Modality.Name.Dom]);
Modality.domTouch = new Modality(false, [Modality.Name.DomTouch]);
Modality.voice = new Modality(false, [Modality.Name.Voice]);
Modality.vr = new Modality(false, [Modality.Name.Vr]);

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function _typeFromLiteral(member) {
    return Type.fromLiteral(member);
}
function _typeVarOrStringFromLiteral(member) {
    if (typeof member === 'object') {
        return _typeFromLiteral(member);
    }
    return member;
}
function _HandleConnectionFromLiteral({ type, name, direction }) {
    return {
        type: type ? _typeFromLiteral(type) : undefined,
        name: name ? _typeVarOrStringFromLiteral(name) : undefined,
        direction: direction || 'any'
    };
}
function _SlotFromLiteral({ name, direction, isRequired, isSet }) {
    return {
        name: name ? _typeVarOrStringFromLiteral(name) : undefined,
        direction, isRequired, isSet
    };
}
function _typeToLiteral(member) {
    return member.toLiteral();
}
function _typeVarOrStringToLiteral(member) {
    if (member instanceof TypeVariable) {
        return member.toLiteral();
    }
    return member;
}
function _HandleConnectionToLiteral({ type, name, direction }) {
    return {
        type: type && _typeToLiteral(type),
        name: name && _typeVarOrStringToLiteral(name),
        direction
    };
}
function _SlotToLiteral({ name, direction, isRequired, isSet }) {
    return {
        name: name && _typeVarOrStringToLiteral(name),
        direction,
        isRequired,
        isSet
    };
}
const handleConnectionFields = ['type', 'name', 'direction'];
const slotFields = ['name', 'direction', 'isRequired', 'isSet'];
class InterfaceInfo {
    constructor(name, handleConnections, slots) {
        assert(name);
        assert(handleConnections !== undefined);
        assert(slots !== undefined);
        this.name = name;
        this.handleConnections = handleConnections;
        this.slots = slots;
        this.typeVars = [];
        for (const handleConnection of handleConnections) {
            for (const field of handleConnectionFields) {
                if (InterfaceInfo.isTypeVar(handleConnection[field])) {
                    this.typeVars.push({ object: handleConnection, field });
                }
            }
        }
        for (const slot of slots) {
            for (const field of slotFields) {
                if (InterfaceInfo.isTypeVar(slot[field])) {
                    this.typeVars.push({ object: slot, field });
                }
            }
        }
    }
    toPrettyString() {
        return 'InterfaceInfo';
    }
    mergeTypeVariablesByName(variableMap) {
        this.typeVars.forEach(({ object, field }) => object[field] = object[field].mergeTypeVariablesByName(variableMap));
    }
    get canReadSubset() {
        return this._cloneAndUpdate(typeVar => typeVar.canReadSubset);
    }
    get canWriteSuperset() {
        return this._cloneAndUpdate(typeVar => typeVar.canWriteSuperset);
    }
    isMoreSpecificThan(other) {
        if (this.handleConnections.length !== other.handleConnections.length ||
            this.slots.length !== other.slots.length) {
            return false;
        }
        // TODO: should probably confirm that handleConnections and slots actually match.
        for (let i = 0; i < this.typeVars.length; i++) {
            const thisTypeVar = this.typeVars[i];
            const otherTypeVar = other.typeVars[i];
            if (!thisTypeVar.object[thisTypeVar.field].isMoreSpecificThan(otherTypeVar.object[otherTypeVar.field])) {
                return false;
            }
        }
        return true;
    }
    _applyExistenceTypeTest(test) {
        for (const typeRef of this.typeVars) {
            if (test(typeRef.object[typeRef.field])) {
                return true;
            }
        }
        return false;
    }
    _handleConnectionsToManifestString() {
        return this.handleConnections
            .map(h => `  ${h.direction || 'any'} ${h.type.toString()} ${h.name ? h.name : '*'}`)
            .join('\n');
    }
    _slotsToManifestString() {
        // TODO deal with isRequired
        return this.slots
            .map(slot => `  ${slot.direction} ${slot.isSet ? 'set of ' : ''}${slot.name ? slot.name + ' ' : ''}`)
            .join('\n');
    }
    // TODO: Include name as a property of the interface and normalize this to just toString()
    toString() {
        return `interface ${this.name}
${this._handleConnectionsToManifestString()}
${this._slotsToManifestString()}`;
    }
    static fromLiteral(data) {
        const handleConnections = data.handleConnections.map(_HandleConnectionFromLiteral);
        const slots = data.slots.map(_SlotFromLiteral);
        return new InterfaceInfo(data.name, handleConnections, slots);
    }
    toLiteral() {
        const handleConnections = this.handleConnections.map(_HandleConnectionToLiteral);
        const slots = this.slots.map(_SlotToLiteral);
        return { name: this.name, handleConnections, slots };
    }
    clone(variableMap) {
        const handleConnections = this.handleConnections.map(({ name, direction, type }) => ({ name, direction, type: type ? type.clone(variableMap) : undefined }));
        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));
        return new InterfaceInfo(this.name, handleConnections, slots);
    }
    cloneWithResolutions(variableMap) {
        return this._cloneWithResolutions(variableMap);
    }
    _cloneWithResolutions(variableMap) {
        const handleConnections = this.handleConnections.map(({ name, direction, type }) => ({ name, direction, type: type ? type._cloneWithResolutions(variableMap) : undefined }));
        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));
        return new InterfaceInfo(this.name, handleConnections, slots);
    }
    canEnsureResolved() {
        for (const typeVar of this.typeVars) {
            if (!typeVar.object[typeVar.field].canEnsureResolved()) {
                return false;
            }
        }
        return true;
    }
    maybeEnsureResolved() {
        for (const typeVar of this.typeVars) {
            let variable = typeVar.object[typeVar.field];
            variable = variable.clone(new Map());
            if (!variable.maybeEnsureResolved())
                return false;
        }
        for (const typeVar of this.typeVars) {
            typeVar.object[typeVar.field].maybeEnsureResolved();
        }
        return true;
    }
    tryMergeTypeVariablesWith(other) {
        // Type variable enabled slot matching will Just Work when we
        // unify slots and handleConnections.
        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {
            return null;
        }
        if (other.handleConnections.length !== this.handleConnections.length) {
            return null;
        }
        const handleConnections = new Set(this.handleConnections);
        const otherHandleConnections = new Set(other.handleConnections);
        const handleConnectionMap = new Map();
        let sizeCheck = handleConnections.size;
        while (handleConnections.size > 0) {
            const handleConnectionMatches = [...handleConnections.values()].map(handleConnection => ({ handleConnection, match: [...otherHandleConnections.values()].filter(otherHandleConnection => this._equalHandleConnection(handleConnection, otherHandleConnection)) }));
            for (const handleConnectionMatch of handleConnectionMatches) {
                // no match!
                if (handleConnectionMatch.match.length === 0) {
                    return null;
                }
                if (handleConnectionMatch.match.length === 1) {
                    handleConnectionMap.set(handleConnectionMatch.handleConnection, handleConnectionMatch.match[0]);
                    otherHandleConnections.delete(handleConnectionMatch.match[0]);
                    handleConnections.delete(handleConnectionMatch.handleConnection);
                }
            }
            // no progress!
            if (handleConnections.size === sizeCheck) {
                return null;
            }
            sizeCheck = handleConnections.size;
        }
        const handleConnectionList = [];
        for (const handleConnection of this.handleConnections) {
            const otherHandleConnection = handleConnectionMap.get(handleConnection);
            let resultType;
            if (handleConnection.type.hasVariable || otherHandleConnection.type.hasVariable) {
                resultType = TypeChecker._tryMergeTypeVariable(handleConnection.type, otherHandleConnection.type);
                if (!resultType) {
                    return null;
                }
            }
            else {
                resultType = handleConnection.type || otherHandleConnection.type;
            }
            handleConnectionList.push({ name: handleConnection.name || otherHandleConnection.name, direction: handleConnection.direction || otherHandleConnection.direction, type: resultType });
        }
        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));
        return new InterfaceInfo(this.name, handleConnectionList, slots);
    }
    resolvedType() {
        return this._cloneAndUpdate(typeVar => typeVar.resolvedType());
    }
    equals(other) {
        if (this.handleConnections.length !== other.handleConnections.length) {
            return false;
        }
        // TODO: this isn't quite right as it doesn't deal with duplicates properly
        if (!this._equalItems(other.handleConnections, this.handleConnections, this._equalHandleConnection)) {
            return false;
        }
        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {
            return false;
        }
        return true;
    }
    _equalHandleConnection(handleConnection, otherHandleConnection) {
        return handleConnection.name === otherHandleConnection.name
            && handleConnection.direction === otherHandleConnection.direction
            && TypeChecker.compareTypes({ type: handleConnection.type }, { type: otherHandleConnection.type });
    }
    _equalSlot(slot, otherSlot) {
        return slot.name === otherSlot.name && slot.direction === otherSlot.direction && slot.isRequired === otherSlot.isRequired && slot.isSet === otherSlot.isSet;
    }
    _equalItems(otherItems, items, compareItem) {
        for (const otherItem of otherItems) {
            let exists = false;
            for (const item of items) {
                if (compareItem(item, otherItem)) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                return false;
            }
        }
        return true;
    }
    _cloneAndUpdate(update) {
        const copy = this.clone(new Map());
        copy.typeVars.forEach(typeVar => InterfaceInfo._updateTypeVar(typeVar, update));
        return copy;
    }
    static _updateTypeVar(typeVar, update) {
        typeVar.object[typeVar.field] = update(typeVar.object[typeVar.field]);
    }
    static isTypeVar(reference) {
        return reference instanceof TypeVariable || reference instanceof Type && reference.hasVariable;
    }
    static mustMatch(reference) {
        return !(reference == undefined || InterfaceInfo.isTypeVar(reference));
    }
    static handleConnectionsMatch(interfaceHandleConnection, particleHandleConnection) {
        if (InterfaceInfo.mustMatch(interfaceHandleConnection.name) &&
            interfaceHandleConnection.name !== particleHandleConnection.name) {
            return false;
        }
        // TODO: FIXME direction subsetting?
        if (InterfaceInfo.mustMatch(interfaceHandleConnection.direction)
            && interfaceHandleConnection.direction !== 'any'
            && particleHandleConnection.direction !== 'any'
            && interfaceHandleConnection.direction !== particleHandleConnection.direction) {
            return false;
        }
        if (interfaceHandleConnection.type == undefined) {
            return true;
        }
        const [left, right] = Type.unwrapPair(interfaceHandleConnection.type, particleHandleConnection.type);
        if (left instanceof TypeVariable) {
            return [{ var: left, value: right, direction: interfaceHandleConnection.direction }];
        }
        else {
            return TypeChecker.compareTypes({ type: left }, { type: right });
        }
    }
    static slotsMatch(interfaceSlot, particleSlot) {
        if (InterfaceInfo.mustMatch(interfaceSlot.name) &&
            interfaceSlot.name !== particleSlot.name) {
            return false;
        }
        if (InterfaceInfo.mustMatch(interfaceSlot.direction) &&
            interfaceSlot.direction !== particleSlot.direction) {
            return false;
        }
        if (InterfaceInfo.mustMatch(interfaceSlot.isRequired) &&
            interfaceSlot.isRequired !== particleSlot.isRequired) {
            return false;
        }
        if (InterfaceInfo.mustMatch(interfaceSlot.isSet) &&
            interfaceSlot.isSet !== particleSlot.isSet) {
            return false;
        }
        return true;
    }
    particleMatches(particleSpec) {
        const interfaceInfo = this.cloneWithResolutions(new Map());
        return interfaceInfo.restrictType(particleSpec) !== false;
    }
    restrictType(particleSpec) {
        return this._restrictThis(particleSpec);
    }
    _restrictThis(particleSpec) {
        const handleConnectionMatches = this.handleConnections.map(h => particleSpec.handleConnections.map(c => ({ match: c, result: InterfaceInfo.handleConnectionsMatch(h, c) }))
            .filter(a => a.result !== false));
        const particleSlots = [];
        particleSpec.slotConnections.forEach(consumedSlot => {
            particleSlots.push({ name: consumedSlot.name, direction: 'consume', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet });
            consumedSlot.provideSlotConnections.forEach(providedSlot => {
                particleSlots.push({ name: providedSlot.name, direction: 'provide', isRequired: false, isSet: providedSlot.isSet });
            });
        });
        const slotsThatMatch = this.slots.map(slot => particleSlots.filter(particleSlot => InterfaceInfo.slotsMatch(slot, particleSlot)));
        const slotMatches = slotsThatMatch.map(matchList => matchList.map(slot => ({ match: slot, result: true })));
        // TODO: this probably doesn't deal with multiple match options.
        function choose(list, exclusions) {
            if (list.length === 0) {
                return [];
            }
            const thisLevel = list.pop();
            for (const connection of thisLevel) {
                if (exclusions.includes(connection.match)) {
                    continue;
                }
                const newExclusions = exclusions.slice();
                newExclusions.push(connection.match);
                const constraints = choose(list, newExclusions);
                if (constraints !== false) {
                    if (typeof connection.result === 'boolean') {
                        return constraints;
                    }
                    return constraints.concat(connection.result);
                }
            }
            return false;
        }
        const handleConnectionOptions = choose(handleConnectionMatches, []);
        const slotOptions = choose(slotMatches, []);
        if (handleConnectionOptions === false || slotOptions === false) {
            return false;
        }
        for (const constraint of handleConnectionOptions) {
            if (!constraint.var.variable.resolution) {
                constraint.var.variable.resolution = constraint.value;
            }
            else if (constraint.var.variable.resolution instanceof TypeVariable) {
                // TODO(shans): revisit how this should be done,
                // consider reusing tryMergeTypeVariablesWith(other).
                if (!TypeChecker.processTypeList(constraint.var, [{
                        type: constraint.value, direction: constraint.direction
                    }]))
                    return false;
            }
            else {
                if (!TypeChecker.compareTypes({ type: constraint.var.variable.resolution }, { type: constraint.value })) {
                    return false;
                }
            }
        }
        return true;
    }
}

/** An exception that is to be propagated back to the host. */
class PropagatedException extends Error {
    constructor(cause, method, particleId, particleName) {
        super();
        this.cause = cause;
        this.method = method;
        this.particleId = particleId;
        this.particleName = particleName;
        this.stack += `\nCaused by: ${this.cause.stack}`;
    }
    toLiteral() {
        return {
            exceptionType: this.constructor.name,
            cause: {
                name: this.cause.name,
                message: this.cause.message,
                stack: this.cause.stack,
            },
            method: this.method,
            particleId: this.particleId,
            particleName: this.particleName,
            stack: this.stack,
        };
    }
    static fromLiteral(literal) {
        const cause = literal.cause;
        let exception;
        switch (literal.exceptionType) {
            case SystemException.name:
                exception = new SystemException(cause, literal.method, literal.particleId, literal.particleName);
                break;
            case UserException.name:
                exception = new UserException(cause, literal.method, literal.particleId, literal.particleName);
                break;
            default:
                throw new Error(`Unknown exception type: ${literal.exceptionType}`);
        }
        exception.stack = literal.stack;
        return exception;
    }
}
/** An exception thrown in Arcs runtime code. */
class SystemException extends PropagatedException {
    get message() {
        const particleName = this.particleName ? this.particleName : this.particleId;
        return `SystemException: exception ${this.cause.name} raised when invoking system function ${this.method} on behalf of particle ${particleName}: ${this.cause.message}`;
    }
}
/** An exception thrown in the user particle code (as opposed to an error in the Arcs runtime). */
class UserException extends PropagatedException {
    get message() {
        const particleName = this.particleName ? this.particleName : this.particleId;
        return `UserException: exception ${this.cause.name} raised when invoking function ${this.method} on particle ${particleName}: ${this.cause.message}`;
    }
}
const systemHandlers = [];
function reportSystemException(exception) {
    for (const handler of systemHandlers) {
        handler(exception);
    }
}
function registerSystemExceptionHandler(handler) {
    if (!systemHandlers.includes(handler)) {
        systemHandlers.push(handler);
    }
}
registerSystemExceptionHandler((exception) => {
    console.log(exception.method, exception.particleName);
    throw exception;
});

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// This is only relevant in the web devtools, but we need to
// ensure that the stack trace is passed through on node
// so that system exceptions are plumbed properly.
const mapStackTrace = (x, f) => f([x]);

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class CrdtCollectionModel {
    constructor(model) {
        // id => {value, Set[keys]}
        this.items = new Map();
        if (model) {
            for (let { id, value, keys } of model) {
                if (!keys) {
                    keys = [];
                }
                this.items.set(id, { value, keys: new Set(keys) });
            }
        }
    }
    /**
     * Adds membership, `keys`, of `value` indexed by `id` to this collection.
     * Returns whether the change is effective (`id` is new to the collection,
     * or `value` is different to the value previously stored).
     */
    add(id, value, keys) {
        // Ensure that keys is actually an array, not a single string.
        // TODO(shans): remove this when all callers are implemented in typeScript.
        assert(keys.length > 0 && typeof keys === 'object', 'add requires a list of keys');
        let item = this.items.get(id);
        let effective = false;
        if (!item) {
            item = { value, keys: new Set(keys) };
            this.items.set(id, item);
            effective = true;
        }
        else {
            let newKeys = false;
            for (const key of keys) {
                if (!item.keys.has(key)) {
                    newKeys = true;
                }
                item.keys.add(key);
            }
            if (!this._equals(item.value, value)) {
                assert(newKeys, 'cannot add without new keys. incoming=' + keys.join(',') + ' existing=' + [...item.keys].join(','));
                item.value = value;
                effective = true;
            }
        }
        return effective;
    }
    _equals(value1, value2) {
        if (Boolean(value1) !== Boolean(value2)) {
            return false;
        }
        if (!value1) {
            return true;
        }
        const type1 = typeof (value1);
        if (type1 !== typeof (value2)) {
            return false;
        }
        if (type1 === 'object') {
            const keys = Object.keys(value1);
            if (keys.length !== Object.keys(value2).length) {
                return false;
            }
            return keys.every(key => this._equals(value1[key], value2[key]));
        }
        return JSON.stringify(value1) === JSON.stringify(value2);
    }
    /**
     * Removes the membership, `keys`, of the value indexed by `id` from this collection.
     * Returns whether the change is effective (the value is no longer present
     * in the collection because all of the keys have been removed).
     */
    remove(id, keys) {
        const item = this.items.get(id);
        if (!item) {
            return false;
        }
        for (const key of keys) {
            item.keys.delete(key);
        }
        const effective = item.keys.size === 0;
        if (effective) {
            this.items.delete(id);
        }
        return effective;
    }
    toLiteral() {
        const result = [];
        for (const [id, { value, keys }] of this.items.entries()) {
            result.push({ id, value, keys: [...keys] });
        }
        return result;
    }
    toList() {
        return [...this.items.values()].map(item => item.value);
    }
    has(id) {
        return this.items.has(id);
    }
    getKeys(id) {
        const item = this.items.get(id);
        return item ? [...item.keys] : [];
    }
    getValue(id) {
        const item = this.items.get(id);
        return item ? item.value : null;
    }
    get size() {
        return this.items.size;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class RNG {
}
/**
 * A basic random number generator using Math.random();
 */
class MathRandomRNG extends RNG {
    next() {
        return Math.random();
    }
}
// Singleton Pattern
const random = new MathRandomRNG();
class Random {
    static next() {
        return random.next();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Generates new IDs which are rooted in the current session. Only one IdGenerator should be instantiated for each running Arc, and all of the
 * IDs created should be created using that same IdGenerator instance.
 */
class IdGenerator {
    /** Use the newSession factory method instead. */
    constructor(currentSessionId) {
        this._nextComponentId = 0;
        this._currentSessionId = currentSessionId;
    }
    /** Generates a new random session ID to use when creating new IDs. */
    static newSession() {
        const sessionId = Math.floor(Random.next() * Math.pow(2, 50)) + '';
        return new IdGenerator(sessionId);
    }
    /**
     * Intended only for testing the IdGenerator class itself. Lets you specify the session ID manually. Prefer using the real
     * IdGenerator.newSession() method when testing other classes.
     */
    static createWithSessionIdForTesting(sessionId) {
        return new IdGenerator(sessionId);
    }
    newArcId(name) {
        return ArcId._newArcIdInternal(this._currentSessionId, name);
    }
    /**
     * Creates a new ID, as a child of the given parentId. The given subcomponent will be appended to the component hierarchy of the given ID, but
     * the generator's random session ID will be used as the ID's root.
     */
    newChildId(parentId, subcomponent = '') {
        // Append (and increment) a counter to the subcomponent, to ensure that it is unique.
        subcomponent += this._nextComponentId++;
        return Id._newIdInternal(this._currentSessionId, [...parentId.idTree, subcomponent]);
    }
    get currentSessionIdForTesting() {
        return this._currentSessionId;
    }
}
/**
 * An immutable object consisting of two components: a root, and an idTree. The root is the session ID from the particular session in which the
 * ID was constructed (see the IdGenerator class). The idTree is a list of subcomponents, forming a hierarchy of IDs (child IDs are created by
 * appending subcomponents to their parent ID's idTree).
 */
class Id {
    /** Protected constructor. Use IdGenerator to create new IDs instead. */
    constructor(root, idTree = []) {
        /** The components of the idTree. */
        this.idTree = [];
        this.root = root;
        this.idTree = idTree;
    }
    /** Creates a new ID. Use IdGenerator to create new IDs instead. */
    static _newIdInternal(root, idTree = []) {
        return new Id(root, idTree);
    }
    /** Parses a string representation of an ID (see toString). */
    static fromString(str) {
        const bits = str.split(':');
        if (bits[0].startsWith('!')) {
            const root = bits[0].slice(1);
            const idTree = bits.slice(1).filter(component => component.length > 0);
            return new Id(root, idTree);
        }
        else {
            return new Id('', bits);
        }
    }
    /** Returns the full ID string. */
    toString() {
        return `!${this.root}:${this.idTree.join(':')}`;
    }
    /** Returns the idTree as as string (without the root). */
    idTreeAsString() {
        return this.idTree.join(':');
    }
    equal(id) {
        if (id.root !== this.root || id.idTree.length !== this.idTree.length) {
            return false;
        }
        for (let i = 0; i < id.idTree.length; i++) {
            if (id.idTree[i] !== this.idTree[i]) {
                return false;
            }
        }
        return true;
    }
}
class ArcId extends Id {
    /** Creates a new Arc ID. Use IdGenerator to create new IDs instead. */
    static _newArcIdInternal(root, name) {
        return new ArcId(root, [name]);
    }
    /** Creates a new Arc ID with the given name. For convenience in unit testing only; otherwise use IdGenerator to create new IDs instead. */
    static newForTest(id) {
        return IdGenerator.newSession().newArcId(id);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var SyncState;
(function (SyncState) {
    SyncState[SyncState["none"] = 0] = "none";
    SyncState[SyncState["pending"] = 1] = "pending";
    SyncState[SyncState["full"] = 2] = "full";
})(SyncState || (SyncState = {}));
/**
 * Mediates between one or more Handles and the backing store outside the PEC.
 *
 * This can operate in two modes, based on how observing handles are configured:
 * - synchronized: the proxy maintains a copy of the full data held by the backing store, keeping
 *                 it in sync by listening to change events from the store.
 * - unsynchronized: the proxy simply passes through calls from Handles to the backing store.
 *
 * In synchronized mode we maintain a queue of sorted update events received from the backing store.
 * While events are received correctly - each update is one version ahead of our stored model - they
 * are processed immediately and observing handles are notified accordingly. If we receive an update
 * with a "future" version, the proxy is desynchronized:
 * - a request for the full data is sent to the backing store;
 * - any update events received after that (and before the response) are added to the queue;
 * - any new updates that can be applied will be (which may cause the proxy to "catch up" and resync
 *   before the full data response arrives);
 * - once the resync response is received, stale queued updates are discarded and any remaining ones
 *   are applied.
 */
class StorageProxy {
    constructor(id, type, port, pec, scheduler, name) {
        this.version = undefined;
        this.listenerAttached = false;
        this.keepSynced = false;
        this.synchronized = SyncState.none;
        this.observers = [];
        this.updates = [];
        this.barrier = null;
        this.id = id;
        this.type = type;
        this.port = port;
        this.scheduler = scheduler;
        this.name = name;
        this.updates = [];
        this.pec = pec;
    }
    static newProxy(id, type, port, pec, scheduler, name) {
        if (type instanceof CollectionType) {
            return new CollectionProxy(id, type, port, pec, scheduler, name);
        }
        if (type instanceof BigCollectionType) {
            return new BigCollectionProxy(id, type, port, pec, scheduler, name);
        }
        return new SingletonProxy(id, type, port, pec, scheduler, name);
    }
    static newNoOpProxy(id, type) {
        return new NoOpStorageProxy(id, type, null, null, null, 'NoOpStorage');
    }
    reportExceptionInHost(exception) {
        // TODO: Encapsulate source-mapping of the stack trace once there are more users of the port.RaiseSystemException() call.
        if (mapStackTrace) {
            mapStackTrace(exception.cause.stack, mappedStack => {
                exception.cause.stack = mappedStack;
                this.port.ReportExceptionInHost(exception);
            });
        }
        else {
            this.port.ReportExceptionInHost(exception);
        }
    }
    /**
     *  Called by ParticleExecutionContext to associate (potentially multiple) particle/handle pairs with this proxy.
     */
    register(particle, handle) {
        if (!handle.canRead) {
            return;
        }
        assert(handle instanceof HandleOld);
        this.observers.push({ particle, handle: handle });
        // Attach an event listener to the backing store when the first readable handle is registered.
        if (!this.listenerAttached) {
            this.port.InitializeProxy(this, x => this._onUpdate(x));
            this.listenerAttached = true;
        }
        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send
        // a request to get the full model (once).
        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced
        if (handle.options.keepSynced) {
            if (!this.keepSynced) {
                this.port.SynchronizeProxy(this, x => this._onSynchronize(x));
                this.keepSynced = true;
            }
            // If a handle configured for sync notifications registers after we've received the full
            // model, notify it immediately.
            if (handle.options.notifySync && this.synchronized === SyncState.full) {
                const syncModel = this._getModelForSync();
                this.scheduler.enqueue(particle, handle, ['sync', particle, syncModel]);
            }
        }
    }
    /**
     * Called by Handle to dissociate particle/handle pair associated with this proxy
     */
    deregister(particleIn, handleIn) {
        this.observers = this.observers.filter(({ particle, handle }) => particle !== particleIn || handle !== handleIn);
    }
    _onSynchronize({ version, model }) {
        if (this.version !== undefined && version <= this.version) {
            console.warn(`StorageProxy '${this.id}' received stale model version ${version}; ` +
                `current is ${this.version}`);
            return;
        }
        // Replace the stored data with the new one and notify handles that are configured for it.
        if (!this._synchronizeModel(version, model)) {
            return;
        }
        // We may have queued updates that were received after a desync; discard any that are stale
        // with respect to the received model.
        this.synchronized = SyncState.full;
        while (this.updates.length > 0 && this.updates[0].version <= version) {
            this.updates.shift();
        }
        const syncModel = this._getModelForSync();
        this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);
        this._processUpdates();
    }
    _onUpdate(update) {
        // Immediately notify any handles that are not configured with keepSynced but do want updates.
        if (this.observers.find(({ handle }) => !handle.options.keepSynced && handle.options.notifyUpdate)) {
            const handleUpdate = this._processUpdate(update, false);
            this._notify('update', handleUpdate, options => !options.keepSynced && options.notifyUpdate);
        }
        // Bail if we're not in synchronized mode or this is a stale event.
        if (!this.keepSynced) {
            return;
        }
        if (update.version <= this.version) {
            console.warn(`StorageProxy '${this.id}' received stale update version ${update.version}; ` +
                `current is ${this.version}`);
            return;
        }
        // Add the update to the queue and process. Most of the time the queue should be empty and
        // _processUpdates will consume this event immediately.
        this.updates.push(update);
        this.updates.sort((a, b) => a.version - b.version);
        this._processUpdates();
    }
    _notify(kind, details, predicate = (ignored) => true) {
        for (const { handle, particle } of this.observers) {
            if (predicate(handle.options)) {
                this.scheduler.enqueue(particle, handle, [kind, particle, details]);
            }
        }
    }
    _processUpdates() {
        const updateIsNext = update => {
            if (update.version === this.version + 1) {
                return true;
            }
            // Holy Layering Violation Batman
            //
            // If we are a singleton waiting for a barriered set response
            // then that set response *is* the next thing we're waiting for,
            // regardless of version numbers.
            //
            // TODO(shans): refactor this code so we don't need to layer-violate.
            if (this.barrier && update.barrier === this.barrier) {
                return true;
            }
            return false;
        };
        // Consume all queued updates whose versions are monotonically increasing from our stored one.
        while (this.updates.length > 0 && updateIsNext(this.updates[0])) {
            const update = this.updates.shift();
            // Fold the update into our stored model.
            const handleUpdate = this._processUpdate(update);
            this.version = update.version;
            // Notify handles configured with keepSynced and notifyUpdates (non-keepSynced handles are
            // notified as updates are received).
            if (handleUpdate) {
                this._notify('update', handleUpdate, options => options.keepSynced && options.notifyUpdate);
            }
        }
        // If we still have update events queued, we must have received a future version are are now
        // desynchronized. Send a request for the full model and notify handles configured for it.
        if (this.updates.length > 0) {
            if (this.synchronized !== SyncState.none) {
                this.synchronized = SyncState.none;
                this.port.SynchronizeProxy(this, x => this._onSynchronize(x));
                for (const { handle, particle } of this.observers) {
                    if (handle.options.notifyDesync) {
                        this.scheduler.enqueue(particle, handle, ['desync', particle, {}]);
                    }
                }
            }
        }
        else if (this.synchronized !== SyncState.full) {
            // If we were desynced but have now consumed all update events, we've caught up.
            this.synchronized = SyncState.full;
        }
    }
    generateBarrier() {
        return this.pec.idGenerator.newChildId(Id.fromString(this.id), 'barrier').toString();
    }
}
/**
 * Collections are synchronized in a CRDT Observed/Removed scheme.
 * Each value is identified by an ID and a set of membership keys.
 * Concurrent adds of the same value will specify the same ID but different
 * keys. A value is removed by removing all of the observed keys. A value
 * is considered to be removed if all of it's keys have been removed.
 *
 * In synchronized mode mutation takes place synchronously inside the proxy.
 * The proxy uses the originatorId to skip over redundant events sent back
 * by the storage object.
 *
 * In unsynchronized mode removal is not based on the keys observed at the
 * proxy, since the proxy does not remember the state, but instead the set
 * of keys that exist at the storage object at the time it receives the
 * request.
 */
class CollectionProxy extends StorageProxy {
    constructor() {
        super(...arguments);
        this.model = new CrdtCollectionModel();
    }
    _getModelForSync() {
        return this.model.toList();
    }
    _synchronizeModel(version, model) {
        this.version = version;
        this.model = new CrdtCollectionModel(model);
        return true;
    }
    _processUpdate(update, apply = true) {
        if (this.synchronized === SyncState.full) {
            // If we're synchronized, then any updates we sent have
            // already been applied/notified.
            for (const { handle } of this.observers) {
                if (update.originatorId === handle._particleId) {
                    return null;
                }
            }
        }
        const added = [];
        const removed = [];
        if ('add' in update) {
            for (const { value, keys, effective } of update.add) {
                if (apply && this.model.add(value.id, value, keys) || !apply && effective) {
                    added.push(value);
                }
            }
        }
        else if ('remove' in update) {
            for (const { value, keys, effective } of update.remove) {
                const localValue = this.model.getValue(value.id);
                if (apply && this.model.remove(value.id, keys) || !apply && effective) {
                    removed.push(localValue);
                }
            }
        }
        else {
            throw new Error(`StorageProxy received invalid update event: ${JSON.stringify(update)}`);
        }
        if (added.length || removed.length) {
            const result = { originatorId: update.originatorId };
            if (added.length)
                result.add = added;
            if (removed.length)
                result.remove = removed;
            return result;
        }
        return null;
    }
    // Read ops: if we're synchronized we can just return the local copy of the data.
    // Otherwise, send a request to the backing store.
    async toList() {
        if (this.synchronized === SyncState.full) {
            return Promise.resolve(this.model.toList());
        }
        else {
            // TODO: in synchronized mode, this should integrate with SynchronizeProxy rather than
            //       sending a parallel request
            return new Promise(resolve => this.port.HandleToList(this, resolve));
        }
    }
    async get(id) {
        if (this.synchronized === SyncState.full) {
            return Promise.resolve(this.model.getValue(id));
        }
        else {
            return new Promise((resolve, reject) => this.port.HandleToList(this, r => resolve(r.find(entity => entity.id === id))));
        }
    }
    // tslint:disable-next-line: no-any
    async store(value, keys, particleId) {
        const id = value.id;
        const data = { value, keys };
        this.port.HandleStore(this, () => { }, data, particleId);
        if (this.synchronized !== SyncState.full) {
            return Promise.resolve();
        }
        if (!this.model.add(id, value, keys)) {
            return Promise.resolve();
        }
        const update = { originatorId: particleId, add: [value] };
        this._notify('update', update, options => options.notifyUpdate);
        return Promise.resolve();
    }
    async clear(particleId) {
        if (this.synchronized !== SyncState.full) {
            this.port.HandleRemoveMultiple(this, () => { }, [], particleId);
        }
        let items = this.model.toList().map(item => ({ id: item.id, keys: this.model.getKeys(item.id) }));
        this.port.HandleRemoveMultiple(this, () => { }, items, particleId);
        items = items.map(({ id, keys }) => ({ rawData: this.model.getValue(id).rawData, id, keys }));
        items = items.filter(item => this.model.remove(item.id, item.keys));
        if (items.length > 0) {
            this._notify('update', { originatorId: particleId, remove: items }, options => options.notifyUpdate);
        }
        return Promise.resolve();
    }
    async remove(id, keys, particleId) {
        if (this.synchronized !== SyncState.full) {
            const data = { id, keys: [] };
            this.port.HandleRemove(this, () => { }, data, particleId);
            return Promise.resolve();
        }
        const value = this.model.getValue(id);
        if (!value) {
            return Promise.resolve();
        }
        if (keys.length === 0) {
            keys = this.model.getKeys(id);
        }
        const data = { id, keys };
        this.port.HandleRemove(this, () => { }, data, particleId);
        if (!this.model.remove(id, keys)) {
            return Promise.resolve();
        }
        const update = { originatorId: particleId, remove: [value] };
        this._notify('update', update, options => options.notifyUpdate);
        return Promise.resolve();
    }
}
/**
 * Variables are synchronized in a 'last-writer-wins' scheme. When the
 * SingletonProxy mutates the model, it sets a barrier and expects to
 * receive the barrier value echoed back in a subsequent update event.
 * Between those two points in time updates are not applied or
 * notified about as these reflect concurrent writes that did not 'win'.
 */
class SingletonProxy extends StorageProxy {
    constructor() {
        super(...arguments);
        this.model = null;
    }
    _getModelForSync() {
        return this.model;
    }
    _synchronizeModel(version, model) {
        // If there's an active barrier then we shouldn't apply the model here, because
        // there is a more recent write from the particle side that is still in flight.
        if (this.barrier != null) {
            return false;
        }
        this.version = version;
        this.model = model.length === 0 ? null : model[0].value;
        assert(this.model !== undefined);
        return true;
    }
    _processUpdate(update, apply = true) {
        assert('data' in update);
        if (!apply) {
            return update;
        }
        // If we have set a barrier, suppress updates until after
        // we have seen the barrier return via an update.
        if (this.barrier != null) {
            if (update.barrier === this.barrier) {
                this.barrier = null;
                // HOLY LAYERING VIOLATION BATMAN
                //
                // We just cleared a barrier which means we are now synchronized. If we weren't
                // synchronized already, then we need to tell the handles.
                //
                // TODO(shans): refactor this code so we don't need to layer-violate.
                if (this.synchronized !== SyncState.full) {
                    this.synchronized = SyncState.full;
                    const syncModel = this._getModelForSync();
                    this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);
                }
            }
            return null;
        }
        const oldData = this.model;
        this.model = update.data;
        return { ...update, oldData };
    }
    // Read ops: if we're synchronized we can just return the local copy of the data.
    // Otherwise, send a request to the backing store.
    // TODO: in synchronized mode, these should integrate with SynchronizeProxy rather than
    //       sending a parallel request
    async get() {
        if (this.synchronized === SyncState.full) {
            return Promise.resolve(this.model);
        }
        else {
            return new Promise(resolve => this.port.HandleGet(this, resolve));
        }
    }
    async set(entity, particleId) {
        assert(entity !== undefined);
        if (JSON.stringify(this.model) === JSON.stringify(entity)) {
            return Promise.resolve();
        }
        let barrier;
        // If we're setting to this handle but we aren't listening to firebase,
        // then there's no point creating a barrier. In fact, if the response
        // to the set comes back before a listener is registered then this proxy will
        // end up locked waiting for a barrier that will never arrive.
        if (this.listenerAttached) {
            barrier = this.generateBarrier();
        }
        else {
            barrier = null;
        }
        const oldData = this.model;
        // TODO: is this already a clone?
        this.model = JSON.parse(JSON.stringify(entity));
        this.barrier = barrier;
        this.port.HandleSet(this, entity, particleId, barrier);
        const update = { originatorId: particleId, data: entity, oldData };
        this._notify('update', update, options => options.notifyUpdate);
        return Promise.resolve();
    }
    async clear(particleId) {
        if (this.model == null) {
            return Promise.resolve();
        }
        const barrier = this.generateBarrier();
        const oldData = this.model;
        this.model = null;
        this.barrier = barrier;
        this.port.HandleClear(this, particleId, barrier);
        const update = { originatorId: particleId, data: null, oldData };
        this._notify('update', update, options => options.notifyUpdate);
        return Promise.resolve();
    }
}
// BigCollections are never synchronized. No local state is held and all operations are passed
// directly through to the backing store.
class BigCollectionProxy extends StorageProxy {
    register(particle, handle) {
        if (handle.canRead) {
            this.scheduler.enqueue(particle, handle, ['sync', particle, {}]);
        }
    }
    _getModelForSync() {
        throw new Error('_getModelForSync not implemented for BigCollectionProxy');
    }
    _processUpdate() {
        throw new Error('_processUpdate not implemented for BigCollectionProxy');
    }
    _synchronizeModel() {
        throw new Error('_synchronizeModel not implemented for BigCollectionProxy');
    }
    // TODO: surface get()
    async get(id) {
        throw new Error('unimplemented');
    }
    async store(value, keys, particleId) {
        return new Promise(resolve => this.port.HandleStore(this, resolve, { value, keys }, particleId));
    }
    async remove(id, keys, particleId) {
        return new Promise(resolve => this.port.HandleRemove(this, resolve, { id, keys: [] }, particleId));
    }
    async stream(pageSize, forward) {
        return new Promise(resolve => this.port.HandleStream(this, resolve, pageSize, forward));
    }
    // tslint:disable-next-line: no-any
    async cursorNext(cursorId) {
        return new Promise(resolve => this.port.StreamCursorNext(this, resolve, cursorId));
    }
    async cursorClose(cursorId) {
        this.port.StreamCursorClose(this, cursorId);
        return Promise.resolve();
    }
}
/**
 * NoOpStorageProxy is an implementation of StorageProxy that does no operations. It silently
 * absorbs and throws away all changes without creating any logging, warnings or any other visible
 * behaviors or persistent changes.
 *
 * It is aimed to be used by disabled particles to finish their job without causing any post-disabled
 * async errors, etc.
 *
 * TODO(sherrypra): Add a unit test to ensure this stays in sync with the real storage APIs
 */
class NoOpStorageProxy extends StorageProxy {
    _getModelForSync() {
        return null;
    }
    _synchronizeModel(version, model) {
        return true;
    }
    _processUpdate(update, apply) {
        return null;
    }
    reportExceptionInHost(exception) { }
    deregister() { }
    register() { }
    _onSynchronize({ version, model }) { }
    _onUpdate(update) { }
    _notify(kind, details, predicate = (ignored) => true) { }
    _processUpdates() { }
    generateBarrier() {
        return null;
    }
    async get(id) {
        return new Promise(resolve => { });
    }
    // tslint:disable-next-line: no-any
    async store(value, keys, particleId) {
        return new Promise(resolve => { });
    }
    async clear(particleId) {
        return new Promise(resolve => { });
    }
    async remove(id, keys, particleId) {
        return new Promise(resolve => { });
    }
    async toList() {
        return new Promise(resolve => { });
    }
    async stream(pageSize, forward) {
        return new Promise(resolve => { });
    }
    // tslint:disable-next-line: no-any
    async cursorNext(cursorId) {
        return new Promise(resolve => { });
    }
    async cursorClose(cursorId) {
        return new Promise(resolve => { });
    }
    async set(entity, particleId) {
        return new Promise(resolve => { });
    }
}
class StorageProxyScheduler {
    constructor() {
        this._scheduled = false;
        this._queues = new Map();
        this._idleResolver = null;
        this._idle = null;
        this._scheduled = false;
        // Particle -> {Handle -> [Queue of events]}
        this._queues = new Map();
    }
    // TODO: break apart args here, sync events should flush the queue.
    enqueue(particle, handle, args) {
        if (!this._queues.has(particle)) {
            this._queues.set(particle, new Map());
        }
        const byHandle = this._queues.get(particle);
        if (!byHandle.has(handle)) {
            byHandle.set(handle, []);
        }
        const queue = byHandle.get(handle);
        queue.push(args);
        this._schedule();
    }
    get busy() {
        return this._queues.size > 0;
    }
    _updateIdle() {
        if (this._idleResolver && !this.busy) {
            this._idleResolver();
            this._idle = null;
            this._idleResolver = null;
        }
    }
    get idle() {
        if (!this.busy) {
            return Promise.resolve();
        }
        if (!this._idle) {
            this._idle = new Promise(resolve => this._idleResolver = resolve);
        }
        return this._idle;
    }
    _schedule() {
        if (this._scheduled) {
            return;
        }
        this._scheduled = true;
        setTimeout(() => {
            this._scheduled = false;
            this._dispatch();
        }, 0);
    }
    _dispatch() {
        // TODO: should we process just one particle per task?
        while (this._queues.size > 0) {
            const particle = [...this._queues.keys()][0];
            const byHandle = this._queues.get(particle);
            this._queues.delete(particle);
            for (const [handle, queue] of byHandle.entries()) {
                for (const args of queue) {
                    try {
                        handle._notify(...args);
                    }
                    catch (e) {
                        console.error('Error dispatching to particle', e);
                        handle.storage.reportExceptionInHost(new SystemException(e, handle._particleId, 'StorageProxyScheduler::_dispatch'));
                    }
                }
            }
        }
        this._updateIdle();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TypeScript seems to lose the necessary type info if this symbol is wrapped in an object and then
// used as an interface key (e.g. 'interface Foo { [Symbols.internals]: {...} }'), so we just have
// to export it as a standard variable. See the EntityInternals class for the usage of this symbol.
const SYMBOL_INTERNALS = Symbol('internals');

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TODO: This won't be needed once runtime is transferred between contexts.
function cloneData(data) {
    return data;
    //return JSON.parse(JSON.stringify(data));
}
function restore(entry, entityClass) {
    assert(entityClass, 'Handles need entity classes for deserialization');
    const { id, rawData } = entry;
    const entity = new entityClass(cloneData(rawData));
    if (entry.id) {
        Entity.identify(entity, entry.id);
    }
    // TODO some relation magic, somewhere, at some point.
    return entity;
}
/**
 * Base class for Collections and Singletons.
 */
class HandleOld {
    // TODO type particleId, marked as string, but called with number
    constructor(storage, idGenerator, name, particleId, canRead, canWrite) {
        assert(!(storage instanceof HandleOld));
        this._storage = storage;
        this.idGenerator = idGenerator;
        this.name = name || this.storage.name;
        this.canRead = canRead;
        this.canWrite = canWrite;
        this._particleId = particleId;
        this.options = {
            keepSynced: true,
            notifySync: true,
            notifyUpdate: true,
            notifyDesync: false,
        };
    }
    reportUserExceptionInHost(exception, particle, method) {
        this.storage.reportExceptionInHost(new UserException(exception, method, this._particleId, particle.spec.name));
    }
    reportSystemExceptionInHost(exception, method) {
        this.storage.reportExceptionInHost(new SystemException(exception, method, this._particleId));
    }
    // `options` may contain any of:
    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required
    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received
    // - notifyUpdate (bool): call onHandleUpdate for every change event received
    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected
    configure(options) {
        assert(this.canRead, 'configure can only be called on readable Handles');
        try {
            const keys = Object.keys(this.options);
            const badKeys = Object.keys(options).filter(o => !keys.includes(o));
            if (badKeys.length > 0) {
                throw new Error(`Invalid option in Handle.configure(): ${badKeys}`);
            }
            Object.assign(this.options, options);
        }
        catch (e) {
            this.reportSystemExceptionInHost(e, 'Handle::configure');
            throw e;
        }
    }
    _serialize(entity) {
        assert(entity, `can't serialize a null entity`);
        if (entity instanceof Entity) {
            if (!Entity.isIdentified(entity)) {
                this.createIdentityFor(entity);
            }
        }
        return entity[SYMBOL_INTERNALS].serialize();
    }
    createIdentityFor(entity) {
        Entity.createIdentity(entity, Id.fromString(this._id), this.idGenerator);
    }
    get type() {
        return this.storage.type;
    }
    get _id() {
        return this.storage.id;
    }
    get storage() {
        return this._storage;
    }
    toManifestString() {
        return `'${this._id}'`;
    }
    generateKey() {
        return this.idGenerator.newChildId(Id.fromString(this._id), 'key').toString();
    }
    /**
     * Disables this handle so that it is no longer able to make changes or receive updates from the
     * storage proxy
     */
    disable(particle) {
        if (this.storage instanceof StorageProxy) {
            this.storage.deregister(particle, this);
        }
        // Set this handle's storage to a no-operation storage proxy so any actions that need to be
        // taken by this handle in the future (due to some async operations) will do nothing and finish quietly
        this._storage = StorageProxy.newNoOpProxy(this.storage.id, this.storage.type);
    }
}
/**
 * A handle on a set of Entity data. Note that, as a set, a Collection can only
 * contain a single version of an Entity for each given ID. Further, no order is
 * implied by the set. A particle's manifest dictates the types of handles that
 * need to be connected to that particle, and the current recipe identifies
 * which handles are connected.
 */
class Collection extends HandleOld {
    async _notify(kind, particle, details) {
        assert(this.canRead, '_notify should not be called for non-readable handles');
        switch (kind) {
            case 'sync':
                await particle.callOnHandleSync(this, this._restore(details), e => this.reportUserExceptionInHost(e, particle, 'onHandleSync'));
                return;
            case 'update': {
                // tslint:disable-next-line: no-any
                const update = {};
                if ('add' in details) {
                    update.added = this._restore(details.add);
                }
                if ('remove' in details) {
                    update.removed = this._restore(details.remove);
                }
                update.originator = details.originatorId === this._particleId;
                await particle.callOnHandleUpdate(this, update, e => this.reportUserExceptionInHost(e, particle, 'onHandleUpdate'));
                return;
            }
            case 'desync':
                await particle.callOnHandleDesync(this, e => this.reportUserExceptionInHost(e, particle, 'onHandleUpdate'));
                return;
            default:
                throw new Error('unsupported');
        }
    }
    /**
     * Returns the Entity specified by id contained by the handle, or null if this id is not
     * contained by the handle.
     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')
     * in the particle's manifest.
     */
    async get(id) {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        return this._restore([await this.storage.get(id)])[0];
    }
    /**
     * @returns a list of the Entities contained by the handle.
     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')
     * in the particle's manifest.
     */
    async toList() {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        return this._restore(await this.storage.toList());
    }
    _restore(list) {
        if (list == null) {
            return null;
        }
        const containedType = this.type.getContainedType();
        if (containedType instanceof EntityType) {
            return list.map(e => restore(e, this.entityClass));
        }
        if (containedType instanceof ReferenceType) {
            return list.map(r => new Reference(r, containedType, this.storage.pec));
        }
        throw new Error(`Don't know how to deliver handle data of type ${this.type}`);
    }
    /**
     * Stores a new entity into the Handle.
     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async store(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        const serialization = this._serialize(entity);
        const keys = [this.generateKey()];
        return this.storage.store(serialization, keys, this._particleId);
    }
    /**
     * Removes all known entities from the Handle.
     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async clear() {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        if (this.storage.clear) {
            return this.storage.clear(this._particleId);
        }
        else {
            throw new Error('clear not implemented by storage');
        }
    }
    /**
     * Removes an entity from the Handle.
     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async remove(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        const serialization = this._serialize(entity);
        // Remove the keys that exist at storage/proxy.
        const keys = [];
        await this.storage.remove(serialization.id, keys, this._particleId);
    }
    get storage() {
        return this._storage;
    }
}
/**
 * A handle on a single entity. A particle's manifest dictates
 * the types of handles that need to be connected to that particle, and
 * the current recipe identifies which handles are connected.
 */
class Singleton extends HandleOld {
    // Called by StorageProxy.
    async _notify(kind, particle, details) {
        assert(this.canRead, '_notify should not be called for non-readable handles');
        switch (kind) {
            case 'sync':
                await particle.callOnHandleSync(this, this._restore(details), e => this.reportUserExceptionInHost(e, particle, 'onHandleSync'));
                return;
            case 'update': {
                const data = this._restore(details.data);
                const oldData = this._restore(details.oldData);
                await particle.callOnHandleUpdate(this, { data, oldData }, e => this.reportUserExceptionInHost(e, particle, 'onHandleUpdate'));
                return;
            }
            case 'desync':
                await particle.callOnHandleDesync(this, e => this.reportUserExceptionInHost(e, particle, 'onHandleDesync'));
                return;
            default:
                throw new Error('unsupported');
        }
    }
    /**
     * @returns the Entity contained by the Singleton, or undefined if the Singleton is cleared.
     * @throws {Error} if this Singleton is not configured as a readable handle (i.e. 'in' or 'inout')
     * in the particle's manifest.
     */
    async get() {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        const model = await this.storage.get();
        return this._restore(model);
    }
    _restore(model) {
        if (model == null) {
            return null;
        }
        if (this.type instanceof EntityType) {
            return restore(model, this.entityClass);
        }
        if (this.type instanceof InterfaceType) {
            return ParticleSpec.fromLiteral(model);
        }
        if (this.type instanceof ReferenceType) {
            return new Reference(model, this.type, this.storage.pec);
        }
        throw new Error(`Don't know how to deliver handle data of type ${this.type}`);
    }
    /**
     * Stores a new entity into the Singleton, replacing any existing entity.
     * @throws {Error} if this Singleton is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async set(entity) {
        try {
            if (!this.canWrite) {
                throw new Error('Handle not writeable');
            }
            const serialization = this._serialize(entity);
            return this.storage.set(serialization, this._particleId);
        }
        catch (e) {
            this.reportSystemExceptionInHost(e, 'Handle::set');
            throw e;
        }
    }
    /**
     * Clears any entity currently in the Singleton.
     * @throws {Error} if this Singleton is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async clear() {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        return this.storage.clear(this._particleId);
    }
    get storage() {
        return this._storage;
    }
}
/**
 * Provides paginated read access to a BigCollection. Conforms to the javascript iterator protocol
 * but is not marked as iterable because next() is async, which is currently not supported by
 * implicit iteration in Javascript.
 */
class Cursor {
    constructor(parent, cursorId) {
        this._parent = parent;
        this._cursorId = cursorId;
    }
    /**
     * Returns {value: [items], done: false} while there are items still available, or {done: true}
     * when the cursor has completed reading the collection.
     */
    async next() {
        const data = await this._parent.storage.cursorNext(this._cursorId);
        if (!data.done) {
            data.value = data.value.map(a => restore(a, this._parent.entityClass));
        }
        return data;
    }
    /**
     * Terminates the streamed read. This must be called if a cursor is no longer needed but has not
     * yet completed streaming (i.e. next() hasn't returned {done: true}).
     */
    close() {
        this._parent.storage.cursorClose(this._cursorId);
    }
}
/**
 * A handle on a large set of Entity data. Similar to Collection, except the complete set of
 * entities is not available directly; use stream() to read the full set. Particles wanting to
 * operate on BigCollections should do so in the setHandles() call, since BigCollections do not
 * trigger onHandleSync() or onHandleUpdate().
 */
class BigCollection extends HandleOld {
    configure(options) {
        throw new Error('BigCollections do not support sync/update configuration');
    }
    async _notify(kind, particle, details) {
        assert(this.canRead, '_notify should not be called for non-readable handles');
        assert(kind === 'sync', 'BigCollection._notify only supports sync events');
        await particle.callOnHandleSync(this, [], e => this.reportUserExceptionInHost(e, particle, 'onHandleSync'));
    }
    /**
     * Stores a new entity into the Handle.
     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async store(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        const serialization = this._serialize(entity);
        const keys = [this.generateKey()];
        return this.storage.store(serialization, keys, this._particleId);
    }
    /**
     * Removes an entity from the Handle.
     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')
     * in the particle's manifest.
     */
    async remove(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        const serialization = this._serialize(entity);
        await this.storage.remove(serialization.id, [], this._particleId);
    }
    /**
     * @returns a Cursor instance that iterates over the full set of entities, reading `pageSize`
     * entities at a time. The cursor views a snapshot of the collection, locked to the version
     * at which the cursor is created.
     *
     * By default items are returned in order of original insertion into the collection (with the
     * caveat that items removed during a streamed read may be returned at the end). Set `forward`
     * to false to return items in reverse insertion order.
     *
     * @throws {Error} if this Singleton is not configured as a readable handle (i.e. 'in' or 'inout')
     * in the particle's manifest.
     */
    async stream({ pageSize, forward = true }) {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        if (isNaN(pageSize) || pageSize < 1) {
            throw new Error('Streamed reads require a positive pageSize');
        }
        const cursorId = await this.storage.stream(pageSize, forward);
        return new Cursor(this, cursorId);
    }
    get storage() {
        return this._storage;
    }
}
function handleFor(storage, idGenerator, name = null, particleId = '', canRead = true, canWrite = true) {
    let handle;
    if (storage.type instanceof CollectionType) {
        handle = new Collection(storage, idGenerator, name, particleId, canRead, canWrite);
    }
    else if (storage.type instanceof BigCollectionType) {
        handle = new BigCollection(storage, idGenerator, name, particleId, canRead, canWrite);
    }
    else {
        handle = new Singleton(storage, idGenerator, name, particleId, canRead, canWrite);
    }
    const schema = storage.type.getEntitySchema();
    if (schema) {
        handle.entityClass = schema.entityClass(storage.pec);
    }
    return handle;
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var ReferenceMode;
(function (ReferenceMode) {
    ReferenceMode[ReferenceMode["Unstored"] = 0] = "Unstored";
    ReferenceMode[ReferenceMode["Stored"] = 1] = "Stored";
})(ReferenceMode || (ReferenceMode = {}));
class Reference {
    constructor(data, type, context) {
        this.entity = null;
        this.storageProxy = null;
        this.handle = null;
        this.id = data.id;
        this.storageKey = data.storageKey;
        this.context = context;
        this.type = type;
        this[SYMBOL_INTERNALS] = {
            serialize: () => ({ id: this.id, rawData: this.dataClone() })
        };
    }
    async ensureStorageProxy() {
        if (this.storageProxy == null) {
            this.storageProxy = await this.context.getStorageProxy(this.storageKey, this.type.referredType);
            this.handle = handleFor(this.storageProxy, this.context.idGenerator);
            if (this.storageKey) {
                assert(this.storageKey === this.storageProxy.storageKey);
            }
            else {
                this.storageKey = this.storageProxy.storageKey;
            }
        }
    }
    async dereference() {
        assert(this.context, 'Must have context to dereference');
        if (this.entity) {
            return this.entity;
        }
        await this.ensureStorageProxy();
        this.entity = await this.handle.get(this.id);
        return this.entity;
    }
    dataClone() {
        return { storageKey: this.storageKey, id: this.id };
    }
}
/** A subclass of Reference that clients can create. */
class ClientReference extends Reference {
    /** Use the newClientReference factory method instead. */
    constructor(entity, context) {
        // TODO(shans): start carrying storageKey information around on Entity objects
        super({ id: Entity.id(entity), storageKey: null }, new ReferenceType(Entity.entityClass(entity).type), context);
        this.mode = ReferenceMode.Unstored;
        this.entity = entity;
        this.stored = this.storeReference(entity);
    }
    async storeReference(entity) {
        await this.ensureStorageProxy();
        await this.handle.store(entity);
        this.mode = ReferenceMode.Stored;
    }
    async dereference() {
        if (this.mode === ReferenceMode.Unstored) {
            return null;
        }
        return super.dereference();
    }
    isIdentified() {
        return Entity.isIdentified(this.entity);
    }
    static newClientReference(context) {
        return class extends ClientReference {
            constructor(entity) {
                super(entity, context);
            }
        };
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// This class holds extra entity-related fields used by the runtime. Instances of this are stored
// in their parent Entity via a Symbol-based key. This allows Entities to hold whatever field names
// their Schemas describe without any possibility of names clashing. For example, an Entity can have
// an 'id' field that is distinct (in both value and type) from the id field here. Access to this
// class should be via the static helpers in Entity.
class EntityInternals {
    constructor(entity, entityClass, schema, context, userIDComponent) {
        // TODO: Only the Arc that "owns" this Entity should be allowed to mutate it.
        this.mutable = true;
        this.entity = entity;
        this.entityClass = entityClass;
        this.schema = schema;
        this.context = context;
        this.userIDComponent = userIDComponent;
    }
    getId() {
        if (this.id === undefined) {
            throw new Error('no id');
        }
        return this.id;
    }
    getEntityClass() {
        return this.entityClass;
    }
    isIdentified() {
        return this.id !== undefined;
    }
    identify(identifier) {
        assert(!this.isIdentified(), 'identify() called on already identified entity');
        this.id = identifier;
        const components = identifier.split(':');
        const uid = components.lastIndexOf('uid');
        this.userIDComponent = uid > 0 ? components.slice(uid + 1).join(':') : '';
    }
    createIdentity(parentId, idGenerator) {
        assert(!this.isIdentified(), 'createIdentity() called on already identified entity');
        let id;
        if (this.userIDComponent) {
            // TODO: Stop creating IDs by manually concatenating strings.
            id = `${parentId.toString()}:uid:${this.userIDComponent}`;
        }
        else {
            id = idGenerator.newChildId(parentId).toString();
        }
        this.id = id;
    }
    isMutable() {
        return this.mutable;
    }
    /**
     * Prevents further mutation of this Entity instance. Note that calling this method only affects
     * this particular Entity instance; the entity it represents (in a data store somewhere) can
     * still be mutated by others. Also note that this doesn't necessarily offer any security against
     * malicious developers.
     */
    makeImmutable() {
        this.mutable = false;
    }
    /**
     * Mutates the entity. Supply either the new data for the entity, which replaces the existing
     * entity's data entirely, or a mutation function. The supplied mutation function will be called
     * with a mutable copy of the entity's data. The mutations performed by that function will be
     * reflected in the original entity instance (i.e. mutations applied in place).
     */
    mutate(mutation) {
        if (!this.mutable) {
            throw new Error('Entity is immutable.');
        }
        let newData;
        // Using typeof instead of instanceof here, because apparently sometimes lambdas aren't an instance of Function... :-/
        if (typeof mutation === 'function') {
            newData = this.dataClone();
            mutation(newData);
        }
        else {
            newData = mutation;
        }
        // Note that this does *not* trigger the error in the Entity's Proxy 'set' trap, because we're
        // applying the field updates directly to the original Entity instance (this.entity), not the
        // Proxied version returned by the Entity constructor. Not confusing at all!
        sanitizeAndApply(this.entity, newData, this.schema, this.context);
        // TODO: Send mutations to data store.
    }
    toLiteral() {
        return JSON.parse(JSON.stringify(this.entity));
    }
    dataClone() {
        const clone = {};
        const fieldTypes = this.schema.fields;
        for (const name of Object.keys(fieldTypes)) {
            if (this.entity[name] !== undefined) {
                if (fieldTypes[name] && fieldTypes[name].kind === 'schema-reference') {
                    if (this.entity[name]) {
                        clone[name] = this.entity[name].dataClone();
                    }
                }
                else if (fieldTypes[name] && fieldTypes[name].kind === 'schema-collection') {
                    if (this.entity[name]) {
                        clone[name] = [...this.entity[name]].map(a => a.dataClone());
                    }
                }
                else {
                    clone[name] = this.entity[name];
                }
            }
        }
        return clone;
    }
    serialize() {
        return { id: this.id, rawData: this.dataClone() };
    }
    debugLog() {
        // Here be dragons! Create a copy of the entity class but with an enumerable version of this
        // internals object so it will appear in the log output, with a few tweaks for better display.
        const original = this.entity;
        const copy = new EntityInternals(null, this.entityClass, this.schema, this.context, this.userIDComponent);
        copy.id = this.id;
        // Force 'entity' to show as '[Circular]'. The 'any' is required because 'entity' is readonly.
        // tslint:disable-next-line: no-any
        copy.entity = copy;
        // Set up a class that looks the same as the real entity, copy the schema fields in, add an
        // enumerable version of the copied internals, and use console.dir to show the full object.
        // Node displays the name set up with defineProperty below, but Chrome uses the name of the
        // class variable defined here, so we'll call that entity.
        const entity = class extends Entity {
            constructor() {
                super();
                Object.assign(this, original);
                this[SYMBOL_INTERNALS] = copy;
            }
        };
        Object.defineProperty(entity, 'name', { value: original.constructor.name });
        console.dir(new entity(), { depth: null });
    }
}
class Entity {
    toString() {
        const fields = Object.entries(this).map(([name, value]) => `${name}: ${JSON.stringify(value)}`);
        return `${this.constructor.name} { ${fields.join(', ')} }`;
    }
    // Dynamically constructs a new JS class for the entity type represented by the given schema.
    // This creates a new class which extends the Entity base class and implements the required
    // static properties, then returns a Proxy wrapping that to guard against incorrect field writes.
    static createEntityClass(schema, context) {
        const clazz = class extends Entity {
            constructor(data, userIDComponent) {
                super();
                assert(data, `can't construct entity with null data`);
                assert(!userIDComponent || userIDComponent.indexOf(':') === -1, `user IDs must not contain the ':' character`);
                // We want the SYMBOL_INTERNALS property to be non-enumerable so any copies made of this
                // entity (e.g. via Object.assign) pick up only the plain data fields from the schema, and
                // not the EntityInternals object (which should be unique to this instance).
                Object.defineProperty(this, SYMBOL_INTERNALS, {
                    value: new EntityInternals(this, clazz, schema, context, userIDComponent),
                    enumerable: false
                });
                sanitizeAndApply(this, data, schema, context);
                // We don't want a 'get' trap here because JS accesses various fields as part of routine
                // system behaviour, and making sure we special case all of them is going to be brittle.
                // For example: when returning an object from an async function, JS needs to check if the
                // object is a 'thenable' (so it knows whether to wrap it in a Promise or not), and it does
                // this by checking for the existence of a 'then' method. Not trapping 'get' is ok because
                // callers who try to read fields that aren't in the schema will just get 'undefined', which
                // is idiomatic for JS anyway.
                return new Proxy(this, {
                    set: (target, name, value) => {
                        throw new Error(`Tried to modify entity field '${name}'. Use the mutate method instead.`);
                    }
                });
            }
            static get type() {
                // TODO: should the entity's key just be its type?
                // Should it just be called type in that case?
                return new EntityType(schema);
            }
            static get key() {
                return { tag: 'entity', schema };
            }
            static get schema() {
                return schema;
            }
        };
        // Override the name property to use the name of the entity given in the schema.
        Object.defineProperty(clazz, 'name', { value: schema.name });
        return clazz;
    }
    static id(entity) {
        return getInternals(entity).getId();
    }
    static entityClass(entity) {
        return getInternals(entity).getEntityClass();
    }
    static isIdentified(entity) {
        return getInternals(entity).isIdentified();
    }
    static identify(entity, identifier) {
        getInternals(entity).identify(identifier);
    }
    static createIdentity(entity, parentId, idGenerator) {
        getInternals(entity).createIdentity(parentId, idGenerator);
    }
    static isMutable(entity) {
        return getInternals(entity).isMutable();
    }
    static makeImmutable(entity) {
        getInternals(entity).makeImmutable();
    }
    static mutate(entity, mutation) {
        getInternals(entity).mutate(mutation);
    }
    static toLiteral(entity) {
        return getInternals(entity).toLiteral();
    }
    static dataClone(entity) {
        return getInternals(entity).dataClone();
    }
    static serialize(entity) {
        return getInternals(entity).serialize();
    }
    // Because the internals object is non-enumerable, console.log(entity) in Node only shows the
    // schema-based fields; use this function to log a more complete record of the entity in tests.
    // Chrome's console.log already shows the internals object so that's usually sufficient for
    // debugging, but this function can still be useful for logging a snapshot of an entity that
    // is later modified.
    static debugLog(entity) {
        getInternals(entity).debugLog();
    }
}
function getInternals(entity) {
    const internals = entity[SYMBOL_INTERNALS];
    assert(internals !== undefined, 'SYMBOL_INTERNALS lookup on non-entity');
    return internals;
}
function sanitizeAndApply(target, data, schema, context) {
    for (const [name, value] of Object.entries(data)) {
        const sanitizedValue = sanitizeEntry(schema.fields[name], value, name, context);
        validateFieldAndTypes(name, sanitizedValue, schema);
        target[name] = sanitizedValue;
    }
}
function convertToJsType(primitiveType, schemaName) {
    switch (primitiveType.type) {
        case 'Text':
            return 'string';
        case 'URL':
            return 'string';
        case 'Number':
            return 'number';
        case 'Boolean':
            return 'boolean';
        case 'Bytes':
            return 'Uint8Array';
        default:
            throw new Error(`Unknown field type ${primitiveType.type} in schema ${schemaName}`);
    }
}
// tslint:disable-next-line: no-any
function validateFieldAndTypes(name, value, schema, fieldType) {
    fieldType = fieldType || schema.fields[name];
    if (fieldType === undefined) {
        throw new Error(`Can't set field ${name}; not in schema ${schema.name}`);
    }
    if (value === undefined || value === null) {
        return;
    }
    switch (fieldType.kind) {
        case 'schema-primitive': {
            const valueType = value.constructor.name === 'Uint8Array' ? 'Uint8Array' : typeof (value);
            if (valueType !== convertToJsType(fieldType, schema.name)) {
                throw new TypeError(`Type mismatch setting field ${name} (type ${fieldType.type}); ` +
                    `value '${value}' is type ${typeof (value)}`);
            }
            break;
        }
        case 'schema-union':
            // Value must be a primitive that matches one of the union types.
            for (const innerType of fieldType.types) {
                if (typeof (value) === convertToJsType(innerType, schema.name)) {
                    return;
                }
            }
            throw new TypeError(`Type mismatch setting field ${name} (union [${fieldType.types}]); ` +
                `value '${value}' is type ${typeof (value)}`);
        case 'schema-tuple':
            // Value must be an array whose contents match each of the tuple types.
            if (!Array.isArray(value)) {
                throw new TypeError(`Cannot set tuple ${name} with non-array value '${value}'`);
            }
            if (value.length !== fieldType.types.length) {
                throw new TypeError(`Length mismatch setting tuple ${name} ` +
                    `[${fieldType.types}] with value '${value}'`);
            }
            fieldType.types.map((innerType, i) => {
                if (value[i] !== undefined && value[i] !== null &&
                    typeof (value[i]) !== convertToJsType(innerType, schema.name)) {
                    throw new TypeError(`Type mismatch setting field ${name} (tuple [${fieldType.types}]); ` +
                        `value '${value}' has type ${typeof (value[i])} at index ${i}`);
                }
            });
            break;
        case 'schema-reference':
            if (!(value instanceof Reference)) {
                throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);
            }
            if (!TypeChecker.compareTypes({ type: value.type }, { type: new ReferenceType(fieldType.schema.model) })) {
                throw new TypeError(`Cannot set reference ${name} with value '${value}' of mismatched type`);
            }
            break;
        case 'schema-collection':
            // WTF?! value instanceof Set is returning false sometimes here because the Set in
            // this environment (a native code constructor) isn't equal to the Set that the value
            // has been constructed with (another native code constructor)...
            if (value.constructor.name !== 'Set') {
                throw new TypeError(`Cannot set collection ${name} with non-Set '${value}'`);
            }
            for (const element of value) {
                validateFieldAndTypes(name, element, schema, fieldType.schema);
            }
            break;
        default:
            throw new Error(`Unknown kind '${fieldType.kind}' for field ${name} in schema ${schema.name}`);
    }
}
function sanitizeEntry(type, value, name, context) {
    if (!type) {
        // If there isn't a field type for this, the proxy will pick up
        // that fact and report a meaningful error.
        return value;
    }
    if (type.kind === 'schema-reference' && value) {
        if (value instanceof Reference) {
            // Setting value as Reference (Particle side). This will enforce that the type provided for
            // the handle matches the type of the reference.
            return value;
        }
        else if (value.id && value.storageKey) {
            // Setting value from raw data (Channel side).
            // TODO(shans): This can't enforce type safety here as there isn't any type data available.
            // Maybe this is OK because there's type checking on the other side of the channel?
            return new Reference(value, new ReferenceType(type.schema.model), context);
        }
        else {
            throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);
        }
    }
    else if (type.kind === 'schema-collection' && value) {
        // WTF?! value instanceof Set is returning false sometimes here because the Set in
        // this environment (a native code constructor) isn't equal to the Set that the value
        // has been constructed with (another native code constructor)...
        if (value.constructor.name === 'Set') {
            return value;
        }
        else if (value.length && value instanceof Object) {
            return new Set(value.map(v => sanitizeEntry(type.schema, v, name, context)));
        }
        else {
            throw new TypeError(`Cannot set collection ${name} with non-collection '${value}'`);
        }
    }
    else {
        return value;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Schema {
    // For convenience, primitive field types can be specified as {name: 'Type'}
    // in `fields`; the constructor will convert these to the correct schema form.
    // tslint:disable-next-line: no-any
    constructor(names, fields, description) {
        this.description = {};
        this.names = names;
        this.fields = {};
        for (const [name, field] of Object.entries(fields)) {
            if (typeof (field) === 'string') {
                this.fields[name] = { kind: 'schema-primitive', type: field };
            }
            else {
                this.fields[name] = field;
            }
        }
        if (description) {
            description.description.forEach(desc => this.description[desc.name] = desc.pattern || desc.patterns[0]);
        }
    }
    toLiteral() {
        const fields = {};
        const updateField = field => {
            if (field.kind === 'schema-reference') {
                const schema = field.schema;
                return { kind: 'schema-reference', schema: { kind: schema.kind, model: schema.model.toLiteral() } };
            }
            else if (field.kind === 'schema-collection') {
                return { kind: 'schema-collection', schema: updateField(field.schema) };
            }
            else {
                return field;
            }
        };
        for (const key of Object.keys(this.fields)) {
            fields[key] = updateField(this.fields[key]);
        }
        return { names: this.names, fields, description: this.description };
    }
    static fromLiteral(data = { fields: {}, names: [], description: {} }) {
        const fields = {};
        const updateField = field => {
            if (field.kind === 'schema-reference') {
                const schema = field.schema;
                return { kind: 'schema-reference', schema: { kind: schema.kind, model: Type.fromLiteral(schema.model) } };
            }
            else if (field.kind === 'schema-collection') {
                return { kind: 'schema-collection', schema: updateField(field.schema) };
            }
            else {
                return field;
            }
        };
        for (const key of Object.keys(data.fields)) {
            fields[key] = updateField(data.fields[key]);
        }
        const result = new Schema(data.names, fields);
        result.description = data.description || {};
        return result;
    }
    // TODO: This should only be an ident used in manifest parsing.
    get name() {
        return this.names[0];
    }
    static typesEqual(fieldType1, fieldType2) {
        // TODO: structural check instead of stringification.
        return Schema._typeString(fieldType1) === Schema._typeString(fieldType2);
    }
    static _typeString(type) {
        switch (type.kind) {
            case 'schema-primitive':
                return type.type;
            case 'schema-union':
                return `(${type.types.map(t => t.type).join(' or ')})`;
            case 'schema-tuple':
                return `(${type.types.map(t => t.type).join(', ')})`;
            case 'schema-reference':
                return `Reference<${Schema._typeString(type.schema)}>`;
            case 'type-name':
            case 'schema-inline':
                return type.model.entitySchema.toInlineSchemaString();
            case 'schema-collection':
                return `[${Schema._typeString(type.schema)}]`;
            default:
                throw new Error(`Unknown type kind ${type.kind} in schema ${this.name}`);
        }
    }
    static union(schema1, schema2) {
        const names = [...new Set([...schema1.names, ...schema2.names])];
        const fields = {};
        for (const [field, type] of [...Object.entries(schema1.fields), ...Object.entries(schema2.fields)]) {
            if (fields[field]) {
                if (!Schema.typesEqual(fields[field], type)) {
                    return null;
                }
            }
            else {
                fields[field] = type;
            }
        }
        return new Schema(names, fields);
    }
    static intersect(schema1, schema2) {
        const names = [...schema1.names].filter(name => schema2.names.includes(name));
        const fields = {};
        for (const [field, type] of Object.entries(schema1.fields)) {
            const otherType = schema2.fields[field];
            if (otherType && Schema.typesEqual(type, otherType)) {
                fields[field] = type;
            }
        }
        return new Schema(names, fields);
    }
    equals(otherSchema) {
        return this === otherSchema || (this.name === otherSchema.name
            // TODO: Check equality without calling contains.
            && this.isMoreSpecificThan(otherSchema)
            && otherSchema.isMoreSpecificThan(this));
    }
    isMoreSpecificThan(otherSchema) {
        const names = new Set(this.names);
        for (const name of otherSchema.names) {
            if (!names.has(name)) {
                return false;
            }
        }
        const fields = {};
        for (const [name, type] of Object.entries(this.fields)) {
            fields[name] = type;
        }
        for (const [name, type] of Object.entries(otherSchema.fields)) {
            if (fields[name] == undefined) {
                return false;
            }
            if (!Schema.typesEqual(fields[name], type)) {
                return false;
            }
        }
        return true;
    }
    get type() {
        return new EntityType(this);
    }
    entityClass(context = null) {
        return Entity.createEntityClass(this, context);
    }
    toInlineSchemaString(options) {
        const names = this.names.join(' ') || '*';
        const fields = Object.entries(this.fields).map(([name, type]) => `${Schema._typeString(type)} ${name}`).join(', ');
        return `${names} {${fields.length > 0 && options && options.hideFields ? '...' : fields}}`;
    }
    toManifestString() {
        const results = [];
        results.push(`schema ${this.names.join(' ')}`);
        results.push(...Object.entries(this.fields).map(([name, type]) => `  ${Schema._typeString(type)} ${name}`));
        if (Object.keys(this.description).length > 0) {
            results.push(`  description \`${this.description.pattern}\``);
            for (const name of Object.keys(this.description)) {
                if (name !== 'pattern') {
                    results.push(`    ${name} \`${this.description[name]}\``);
                }
            }
        }
        return results.join('\n');
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotInfo {
    constructor(formFactor, handle) {
        this.formFactor = formFactor;
        this.handle = handle;
    }
    toLiteral() {
        return this;
    }
    static fromLiteral({ formFactor, handle }) {
        return new SlotInfo(formFactor, handle);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Equivalent to an Entity with Schema { serialization Text }
class ArcInfo {
    constructor(arcId, serialization) {
        this.id = arcId.toString();
        // TODO: remove the import-removal hack when import statements no longer appear
        // in serialized manifests, or deal with them correctly if they end up staying
        this.serialization = serialization.replace(/\bimport .*\n/g, '');
    }
    // Retrieves the serialized string from a stored instance of ArcInfo.
    static extractSerialization(data) {
        return data.serialization.replace(/\bimport .*\n/g, '');
    }
}
class ArcHandle {
    constructor(id, storageKey, type, tags) {
        this.id = id;
        this.storageKey = storageKey;
        this.type = type;
        this.tags = tags;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class TypeVariableInfo {
    constructor(name, canWriteSuperset, canReadSubset) {
        this.name = name;
        this._canWriteSuperset = canWriteSuperset;
        this._canReadSubset = canReadSubset;
        this._resolution = null;
    }
    /**
     * Merge both the read subset (upper bound) and write superset (lower bound) constraints
     * of two variables together. Use this when two separate type variables need to resolve
     * to the same value.
     */
    maybeMergeConstraints(variable) {
        if (!this.maybeMergeCanReadSubset(variable.canReadSubset)) {
            return false;
        }
        return this.maybeMergeCanWriteSuperset(variable.canWriteSuperset);
    }
    /**
     * Merge a type variable's read subset (upper bound) constraints into this variable.
     * This is used to accumulate read constraints when resolving a handle's type.
     */
    maybeMergeCanReadSubset(constraint) {
        if (constraint == null) {
            return true;
        }
        if (this.canReadSubset == null) {
            this.canReadSubset = constraint;
            return true;
        }
        if (this.canReadSubset instanceof SlotType && constraint instanceof SlotType) {
            // TODO: formFactor compatibility, etc.
            return true;
        }
        if (this.canReadSubset instanceof EntityType && constraint instanceof EntityType) {
            const mergedSchema = Schema.intersect(this.canReadSubset.entitySchema, constraint.entitySchema);
            if (!mergedSchema) {
                return false;
            }
            this.canReadSubset = new EntityType(mergedSchema);
            return true;
        }
        return false;
    }
    /**
     * merge a type variable's write superset (lower bound) constraints into this variable.
     * This is used to accumulate write constraints when resolving a handle's type.
     */
    maybeMergeCanWriteSuperset(constraint) {
        if (constraint == null) {
            return true;
        }
        if (this.canWriteSuperset == null) {
            this.canWriteSuperset = constraint;
            return true;
        }
        if (this.canWriteSuperset instanceof SlotType && constraint instanceof SlotType) {
            // TODO: formFactor compatibility, etc.
            return true;
        }
        if (this.canWriteSuperset instanceof EntityType && constraint instanceof EntityType) {
            const mergedSchema = Schema.union(this.canWriteSuperset.entitySchema, constraint.entitySchema);
            if (!mergedSchema) {
                return false;
            }
            this.canWriteSuperset = new EntityType(mergedSchema);
            return true;
        }
        return false;
    }
    isSatisfiedBy(type) {
        const constraint = this._canWriteSuperset;
        if (!constraint) {
            return true;
        }
        if (!(constraint instanceof EntityType) || !(type instanceof EntityType)) {
            throw new Error(`constraint checking not implemented for ${this} and ${type}`);
        }
        return type.getEntitySchema().isMoreSpecificThan(constraint.getEntitySchema());
    }
    get resolution() {
        if (this._resolution) {
            return this._resolution.resolvedType();
        }
        return null;
    }
    isValidResolutionCandidate(value) {
        const elementType = value.resolvedType().getContainedType();
        if (elementType instanceof TypeVariable && elementType.variable === this) {
            return { result: false, detail: 'variable cannot resolve to collection of itself' };
        }
        return { result: true };
    }
    set resolution(value) {
        assert(!this._resolution);
        const isValid = this.isValidResolutionCandidate(value);
        assert(isValid.result, isValid.detail);
        let probe = value;
        while (probe) {
            if (!(probe instanceof TypeVariable)) {
                break;
            }
            if (probe.variable === this) {
                return;
            }
            probe = probe.variable.resolution;
        }
        this._resolution = value;
        this._canWriteSuperset = null;
        this._canReadSubset = null;
    }
    get canWriteSuperset() {
        if (this._resolution) {
            assert(!this._canWriteSuperset);
            if (this._resolution instanceof TypeVariable) {
                return this._resolution.variable.canWriteSuperset;
            }
            return null;
        }
        return this._canWriteSuperset;
    }
    set canWriteSuperset(value) {
        assert(!this._resolution);
        this._canWriteSuperset = value;
    }
    get canReadSubset() {
        if (this._resolution) {
            assert(!this._canReadSubset);
            if (this._resolution instanceof TypeVariable) {
                return this._resolution.variable.canReadSubset;
            }
            return null;
        }
        return this._canReadSubset;
    }
    set canReadSubset(value) {
        assert(!this._resolution);
        this._canReadSubset = value;
    }
    get hasConstraint() {
        return this._canReadSubset !== null || this._canWriteSuperset !== null;
    }
    canEnsureResolved() {
        if (this._resolution) {
            return this._resolution.canEnsureResolved();
        }
        if (this._canWriteSuperset || this._canReadSubset) {
            return true;
        }
        return false;
    }
    maybeEnsureResolved() {
        if (this._resolution) {
            return this._resolution.maybeEnsureResolved();
        }
        if (this._canWriteSuperset) {
            this.resolution = this._canWriteSuperset;
            return true;
        }
        if (this._canReadSubset) {
            this.resolution = this._canReadSubset;
            return true;
        }
        return false;
    }
    toLiteral() {
        assert(this.resolution == null);
        return this.toLiteralIgnoringResolutions();
    }
    toLiteralIgnoringResolutions() {
        return {
            name: this.name,
            canWriteSuperset: this._canWriteSuperset && this._canWriteSuperset.toLiteral(),
            canReadSubset: this._canReadSubset && this._canReadSubset.toLiteral()
        };
    }
    static fromLiteral(data) {
        return new TypeVariableInfo(data.name, data.canWriteSuperset ? Type.fromLiteral(data.canWriteSuperset) : null, data.canReadSubset ? Type.fromLiteral(data.canReadSubset) : null);
    }
    isResolved() {
        return this._resolution && this._resolution.isResolved();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Type {
    constructor(tag) {
        this.tag = tag;
    }
    static fromLiteral(literal) {
        switch (literal.tag) {
            case 'Entity':
                return new EntityType(Schema.fromLiteral(literal.data));
            case 'TypeVariable':
                return new TypeVariable(TypeVariableInfo.fromLiteral(literal.data));
            case 'Collection':
                return new CollectionType(Type.fromLiteral(literal.data));
            case 'BigCollection':
                return new BigCollectionType(Type.fromLiteral(literal.data));
            case 'Relation':
                return new RelationType(literal.data.map(t => Type.fromLiteral(t)));
            case 'Interface':
                return new InterfaceType(InterfaceInfo.fromLiteral(literal.data));
            case 'Slot':
                return new SlotType(SlotInfo.fromLiteral(literal.data));
            case 'Reference':
                return new ReferenceType(Type.fromLiteral(literal.data));
            case 'Arc':
                return new ArcType();
            case 'Handle':
                return new HandleType();
            default:
                throw new Error(`fromLiteral: unknown type ${literal}`);
        }
    }
    static unwrapPair(type1, type2) {
        if (type1.tag === type2.tag) {
            const contained1 = type1.getContainedType();
            if (contained1 !== null) {
                return Type.unwrapPair(contained1, type2.getContainedType());
            }
        }
        return [type1, type2];
    }
    /** Tests whether two types' constraints are compatible with each other. */
    static canMergeConstraints(type1, type2) {
        return Type._canMergeCanReadSubset(type1, type2) && Type._canMergeCanWriteSuperset(type1, type2);
    }
    static _canMergeCanReadSubset(type1, type2) {
        if (type1.canReadSubset && type2.canReadSubset) {
            if (type1.canReadSubset.tag !== type2.canReadSubset.tag) {
                return false;
            }
            if (type1.canReadSubset instanceof EntityType && type2.canReadSubset instanceof EntityType) {
                return Schema.intersect(type1.canReadSubset.entitySchema, type2.canReadSubset.entitySchema) !== null;
            }
            throw new Error(`_canMergeCanReadSubset not implemented for types tagged with ${type1.canReadSubset.tag}`);
        }
        return true;
    }
    static _canMergeCanWriteSuperset(type1, type2) {
        if (type1.canWriteSuperset && type2.canWriteSuperset) {
            if (type1.canWriteSuperset.tag !== type2.canWriteSuperset.tag) {
                return false;
            }
            if (type1.canWriteSuperset instanceof EntityType && type2.canWriteSuperset instanceof EntityType) {
                return Schema.union(type1.canWriteSuperset.entitySchema, type2.canWriteSuperset.entitySchema) !== null;
            }
        }
        return true;
    }
    isSlot() {
        return this instanceof SlotType;
    }
    slandleType() {
        if (this.isSlot()) {
            return this;
        }
        if (this.isCollectionType() && this.collectionType.isSlot()) {
            return this.collectionType;
        }
        return undefined;
    }
    // If you want to type-check fully, this is an improvement over just using
    // this instanceof CollectionType,
    // because instanceof doesn't propagate generic restrictions.
    isCollectionType() {
        return this instanceof CollectionType;
    }
    // If you want to type-check fully, this is an improvement over just using
    // this instaneceof BigCollectionType,
    // because instanceof doesn't propagate generic restrictions.
    isBigCollectionType() {
        return this instanceof BigCollectionType;
    }
    isResolved() {
        // TODO: one of these should not exist.
        return !this.hasUnresolvedVariable;
    }
    mergeTypeVariablesByName(variableMap) {
        return this;
    }
    _applyExistenceTypeTest(test) {
        return test(this);
    }
    get hasVariable() {
        return this._applyExistenceTypeTest(type => type instanceof TypeVariable);
    }
    get hasUnresolvedVariable() {
        return this._applyExistenceTypeTest(type => type instanceof TypeVariable && !type.variable.isResolved());
    }
    getContainedType() {
        return null;
    }
    isTypeContainer() {
        return false;
    }
    collectionOf() {
        return new CollectionType(this);
    }
    bigCollectionOf() {
        return new BigCollectionType(this);
    }
    resolvedType() {
        return this;
    }
    canEnsureResolved() {
        return this.isResolved() || this._canEnsureResolved();
    }
    _canEnsureResolved() {
        return true;
    }
    maybeEnsureResolved() {
        return true;
    }
    get canWriteSuperset() {
        throw new Error(`canWriteSuperset not implemented for ${this}`);
    }
    get canReadSubset() {
        throw new Error(`canReadSubset not implemented for ${this}`);
    }
    isMoreSpecificThan(type) {
        return this.tag === type.tag && this._isMoreSpecificThan(type);
    }
    _isMoreSpecificThan(type) {
        throw new Error(`isMoreSpecificThan not implemented for ${this}`);
    }
    /**
     * Clone a type object.
     * When cloning multiple types, variables that were associated with the same name
     * before cloning should still be associated after cloning. To maintain this
     * property, create a Map() and pass it into all clone calls in the group.
     */
    clone(variableMap) {
        return this.resolvedType()._clone(variableMap);
    }
    _clone(variableMap) {
        return Type.fromLiteral(this.toLiteral());
    }
    /**
     * Clone a type object, maintaining resolution information.
     * This function SHOULD NOT BE USED at the type level. In order for type variable
     * information to be maintained correctly, an entire context root needs to be
     * cloned.
     */
    _cloneWithResolutions(variableMap) {
        return Type.fromLiteral(this.toLiteral());
    }
    // TODO: is this the same as _applyExistenceTypeTest
    hasProperty(property) {
        return property(this) || this._hasProperty(property);
    }
    _hasProperty(property) {
        return false;
    }
    toString(options = undefined) {
        return this.tag;
    }
    getEntitySchema() {
        return null;
    }
    toPrettyString() {
        return null;
    }
}
class EntityType extends Type {
    constructor(schema) {
        super('Entity');
        this.entitySchema = schema;
    }
    static make(names, fields, description) {
        return new EntityType(new Schema(names, fields, description));
    }
    // These type identifier methods are being left in place for non-runtime code.
    get isEntity() {
        return true;
    }
    get canWriteSuperset() {
        return this;
    }
    get canReadSubset() {
        return this;
    }
    _isMoreSpecificThan(type) {
        return this.entitySchema.isMoreSpecificThan(type.entitySchema);
    }
    toLiteral() {
        return { tag: this.tag, data: this.entitySchema.toLiteral() };
    }
    toString(options = undefined) {
        return this.entitySchema.toInlineSchemaString(options);
    }
    getEntitySchema() {
        return this.entitySchema;
    }
    _cloneWithResolutions(variableMap) {
        if (variableMap.has(this.entitySchema)) {
            return variableMap.get(this.entitySchema);
        }
        const clonedEntityType = new EntityType(this.entitySchema);
        variableMap.set(this.entitySchema, clonedEntityType);
        return clonedEntityType;
    }
    toPrettyString() {
        if (this.entitySchema.description.pattern) {
            return this.entitySchema.description.pattern;
        }
        // Spit MyTypeFOO to My Type FOO
        if (this.entitySchema.name) {
            return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2')
                .replace(/([A-Z][^A-Z])/g, ' $1')
                .replace(/[\s]+/g, ' ')
                .trim();
        }
        return JSON.stringify(this.entitySchema.toLiteral());
    }
}
class TypeVariable extends Type {
    constructor(variable) {
        super('TypeVariable');
        this.variable = variable;
    }
    static make(name, canWriteSuperset, canReadSubset) {
        return new TypeVariable(new TypeVariableInfo(name, canWriteSuperset, canReadSubset));
    }
    get isVariable() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const name = this.variable.name;
        let variable = variableMap.get(name);
        if (!variable) {
            variable = this;
            variableMap.set(name, this);
        }
        else if (variable instanceof TypeVariable) {
            if (variable.variable.hasConstraint || this.variable.hasConstraint) {
                const mergedConstraint = variable.variable.maybeMergeConstraints(this.variable);
                if (!mergedConstraint) {
                    throw new Error('could not merge type variables');
                }
            }
        }
        return variable;
    }
    resolvedType() {
        return this.variable.resolution || this;
    }
    _canEnsureResolved() {
        return this.variable.canEnsureResolved();
    }
    maybeEnsureResolved() {
        return this.variable.maybeEnsureResolved();
    }
    get canWriteSuperset() {
        return this.variable.canWriteSuperset;
    }
    get canReadSubset() {
        return this.variable.canReadSubset;
    }
    _clone(variableMap) {
        const name = this.variable.name;
        if (variableMap.has(name)) {
            return new TypeVariable(variableMap.get(name));
        }
        else {
            const newTypeVariable = TypeVariableInfo.fromLiteral(this.variable.toLiteral());
            variableMap.set(name, newTypeVariable);
            return new TypeVariable(newTypeVariable);
        }
    }
    _cloneWithResolutions(variableMap) {
        if (variableMap.has(this.variable)) {
            return new TypeVariable(variableMap.get(this.variable));
        }
        else {
            const newTypeVariable = TypeVariableInfo.fromLiteral(this.variable.toLiteralIgnoringResolutions());
            if (this.variable.resolution) {
                newTypeVariable._resolution = this.variable._resolution._cloneWithResolutions(variableMap);
            }
            if (this.variable._canReadSubset) {
                newTypeVariable.canReadSubset = this.variable.canReadSubset._cloneWithResolutions(variableMap);
            }
            if (this.variable._canWriteSuperset) {
                newTypeVariable.canWriteSuperset = this.variable.canWriteSuperset._cloneWithResolutions(variableMap);
            }
            variableMap.set(this.variable, newTypeVariable);
            return new TypeVariable(newTypeVariable);
        }
    }
    toLiteral() {
        return this.variable.resolution ? this.variable.resolution.toLiteral()
            : { tag: this.tag, data: this.variable.toLiteral() };
    }
    toString(options = undefined) {
        return `~${this.variable.name}`;
    }
    getEntitySchema() {
        return this.variable.isResolved() ? this.resolvedType().getEntitySchema() : null;
    }
    toPrettyString() {
        return this.variable.isResolved() ? this.resolvedType().toPrettyString() : `[~${this.variable.name}]`;
    }
}
class CollectionType extends Type {
    constructor(collectionType) {
        super('Collection');
        this.collectionType = collectionType;
    }
    get isCollection() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const collectionType = this.collectionType;
        const result = collectionType.mergeTypeVariablesByName(variableMap);
        return (result === collectionType) ? this : result.collectionOf();
    }
    _applyExistenceTypeTest(test) {
        return this.collectionType._applyExistenceTypeTest(test);
    }
    getContainedType() {
        return this.collectionType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const collectionType = this.collectionType;
        const resolvedCollectionType = collectionType.resolvedType();
        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.collectionOf() : this;
    }
    _canEnsureResolved() {
        return this.collectionType.canEnsureResolved();
    }
    maybeEnsureResolved() {
        return this.collectionType.maybeEnsureResolved();
    }
    get canWriteSuperset() {
        return InterfaceType.make(this.tag, [], []);
    }
    get canReadSubset() {
        return InterfaceType.make(this.tag, [], []);
    }
    _clone(variableMap) {
        const data = this.collectionType.clone(variableMap).toLiteral();
        return Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new CollectionType(this.collectionType._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.collectionType.toLiteral() };
    }
    _hasProperty(property) {
        return this.collectionType.hasProperty(property);
    }
    toString(options = undefined) {
        return `[${this.collectionType.toString(options)}]`;
    }
    getEntitySchema() {
        return this.collectionType.getEntitySchema();
    }
    toPrettyString() {
        const entitySchema = this.getEntitySchema();
        if (entitySchema && entitySchema.description.plural) {
            return entitySchema.description.plural;
        }
        return `${this.collectionType.toPrettyString()} List`;
    }
}
class BigCollectionType extends Type {
    constructor(bigCollectionType) {
        super('BigCollection');
        this.bigCollectionType = bigCollectionType;
    }
    get isBigCollection() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const collectionType = this.bigCollectionType;
        const result = collectionType.mergeTypeVariablesByName(variableMap);
        return (result === collectionType) ? this : result.bigCollectionOf();
    }
    _applyExistenceTypeTest(test) {
        return this.bigCollectionType._applyExistenceTypeTest(test);
    }
    getContainedType() {
        return this.bigCollectionType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const collectionType = this.bigCollectionType;
        const resolvedCollectionType = collectionType.resolvedType();
        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.bigCollectionOf() : this;
    }
    _canEnsureResolved() {
        return this.bigCollectionType.canEnsureResolved();
    }
    maybeEnsureResolved() {
        return this.bigCollectionType.maybeEnsureResolved();
    }
    get canWriteSuperset() {
        return InterfaceType.make(this.tag, [], []);
    }
    get canReadSubset() {
        return InterfaceType.make(this.tag, [], []);
    }
    _clone(variableMap) {
        const data = this.bigCollectionType.clone(variableMap).toLiteral();
        return Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new BigCollectionType(this.bigCollectionType._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.bigCollectionType.toLiteral() };
    }
    _hasProperty(property) {
        return this.bigCollectionType.hasProperty(property);
    }
    toString(options = undefined) {
        return `BigCollection<${this.bigCollectionType.toString(options)}>`;
    }
    getEntitySchema() {
        return this.bigCollectionType.getEntitySchema();
    }
    toPrettyString() {
        const entitySchema = this.getEntitySchema();
        if (entitySchema && entitySchema.description.plural) {
            return entitySchema.description.plural;
        }
        return `Collection of ${this.bigCollectionType.toPrettyString()}`;
    }
}
class RelationType extends Type {
    constructor(relation) {
        super('Relation');
        this.relationEntities = relation;
    }
    get isRelation() {
        return true;
    }
    toLiteral() {
        return { tag: this.tag, data: this.relationEntities.map(t => t.toLiteral()) };
    }
    toPrettyString() {
        return JSON.stringify(this.relationEntities);
    }
}
class InterfaceType extends Type {
    constructor(iface) {
        super('Interface');
        this.interfaceInfo = iface;
    }
    static make(name, handleConnections, slots) {
        return new InterfaceType(new InterfaceInfo(name, handleConnections, slots));
    }
    get isInterface() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const interfaceInfo = this.interfaceInfo.clone(new Map());
        interfaceInfo.mergeTypeVariablesByName(variableMap);
        // TODO: only build a new type when a variable is modified
        return new InterfaceType(interfaceInfo);
    }
    _applyExistenceTypeTest(test) {
        return this.interfaceInfo._applyExistenceTypeTest(test);
    }
    resolvedType() {
        return new InterfaceType(this.interfaceInfo.resolvedType());
    }
    _canEnsureResolved() {
        return this.interfaceInfo.canEnsureResolved();
    }
    maybeEnsureResolved() {
        return this.interfaceInfo.maybeEnsureResolved();
    }
    get canWriteSuperset() {
        return new InterfaceType(this.interfaceInfo.canWriteSuperset);
    }
    get canReadSubset() {
        return new InterfaceType(this.interfaceInfo.canReadSubset);
    }
    _isMoreSpecificThan(type) {
        return this.interfaceInfo.isMoreSpecificThan(type.interfaceInfo);
    }
    _clone(variableMap) {
        const data = this.interfaceInfo.clone(variableMap).toLiteral();
        return Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new InterfaceType(this.interfaceInfo._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.interfaceInfo.toLiteral() };
    }
    toString(options = undefined) {
        return this.interfaceInfo.name;
    }
    toPrettyString() {
        return this.interfaceInfo.toPrettyString();
    }
}
class SlotType extends Type {
    constructor(slot) {
        super('Slot');
        this.slot = slot;
    }
    static make(formFactor, handle) {
        return new SlotType(new SlotInfo(formFactor, handle));
    }
    getSlot() {
        return this.slot;
    }
    get canWriteSuperset() {
        return this;
    }
    get canReadSubset() {
        return this;
    }
    _isMoreSpecificThan(type) {
        // TODO: formFactor checking, etc.
        return true;
    }
    toLiteral() {
        return { tag: this.tag, data: this.slot.toLiteral() };
    }
    toString(options = undefined) {
        const fields = [];
        for (const key of Object.keys(this.slot)) {
            if (this.slot[key] !== undefined) {
                fields.push(`${key}:${this.slot[key]}`);
            }
        }
        let fieldsString = '';
        if (fields.length !== 0) {
            fieldsString = ` {${fields.join(', ')}}`;
        }
        return `Slot${fieldsString}`;
    }
    toPrettyString() {
        const fields = [];
        for (const key of Object.keys(this.slot)) {
            if (this.slot[key] !== undefined) {
                fields.push(`${key}:${this.slot[key]}`);
            }
        }
        let fieldsString = '';
        if (fields.length !== 0) {
            fieldsString = ` {${fields.join(', ')}}`;
        }
        return `Slot${fieldsString}`;
    }
}
class ReferenceType extends Type {
    constructor(reference) {
        super('Reference');
        this.referredType = reference;
    }
    get isReference() {
        return true;
    }
    getContainedType() {
        return this.referredType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const referredType = this.referredType;
        const resolvedReferredType = referredType.resolvedType();
        return (referredType !== resolvedReferredType) ? new ReferenceType(resolvedReferredType) : this;
    }
    _canEnsureResolved() {
        return this.referredType.canEnsureResolved();
    }
    maybeEnsureResolved() {
        return this.referredType.maybeEnsureResolved();
    }
    get canWriteSuperset() {
        // TODO(cypher1): Possibly cannot write to references.
        return this.referredType.canWriteSuperset;
    }
    get canReadSubset() {
        return this.referredType.canReadSubset;
    }
    _clone(variableMap) {
        const data = this.referredType.clone(variableMap).toLiteral();
        return Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new ReferenceType(this.referredType._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.referredType.toLiteral() };
    }
    toString(options = undefined) {
        return 'Reference<' + this.referredType.toString() + '>';
    }
    getEntitySchema() {
        return this.referredType.getEntitySchema();
    }
}
class ArcType extends Type {
    constructor() {
        super('Arc');
    }
    get isArc() {
        return true;
    }
    newInstance(arcId, serialization) {
        return new ArcInfo(arcId, serialization);
    }
    toLiteral() {
        return { tag: this.tag };
    }
}
class HandleType extends Type {
    constructor() {
        super('Handle');
    }
    get isHandle() {
        return true;
    }
    toLiteral() {
        return { tag: this.tag };
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class TypeChecker {
    // resolve a list of handleConnection types against a handle
    // base type. This is the core type resolution mechanism, but should only
    // be used when types can actually be associated with each other / constrained.
    //
    // By design this function is called exactly once per handle in a recipe during
    // normalization, and should provide the same final answers regardless of the
    // ordering of handles within that recipe
    //
    // NOTE: you probably don't want to call this function, if you think you
    // do, talk to shans@.
    static processTypeList(baseType, list) {
        const newBaseType = TypeVariable.make('', null, null);
        if (baseType) {
            newBaseType.variable.resolution = baseType;
        }
        baseType = newBaseType;
        const concreteTypes = [];
        // baseType might be a variable (and is definitely a variable if no baseType was available).
        // Some of the list might contain variables too.
        // First attempt to merge all the variables into the baseType
        //
        // If the baseType is a variable then this results in a single place to manipulate the constraints
        // of all the other connected variables at the same time.
        for (const item of list) {
            if (item.type.resolvedType().hasVariable) {
                baseType = TypeChecker._tryMergeTypeVariable(baseType, item.type);
                if (baseType == null) {
                    return null;
                }
            }
            else {
                concreteTypes.push(item);
            }
        }
        for (const item of concreteTypes) {
            if (!TypeChecker._tryMergeConstraints(baseType, item)) {
                return null;
            }
        }
        const getResolution = (candidate) => {
            if (!(candidate instanceof TypeVariable)) {
                return candidate;
            }
            if (candidate.canReadSubset == null || candidate.canWriteSuperset == null) {
                return candidate;
            }
            if (candidate.canReadSubset.isMoreSpecificThan(candidate.canWriteSuperset)) {
                if (candidate.canWriteSuperset.isMoreSpecificThan(candidate.canReadSubset)) {
                    candidate.variable.resolution = candidate.canReadSubset;
                }
                return candidate;
            }
            return null;
        };
        const candidate = baseType.resolvedType();
        if (candidate.isCollectionType()) {
            const resolution = getResolution(candidate.collectionType);
            return (resolution !== null) ? resolution.collectionOf() : null;
        }
        if (candidate.isBigCollectionType()) {
            const resolution = getResolution(candidate.bigCollectionType);
            return (resolution !== null) ? resolution.bigCollectionOf() : null;
        }
        return getResolution(candidate);
    }
    static _tryMergeTypeVariable(base, onto) {
        const [primitiveBase, primitiveOnto] = Type.unwrapPair(base.resolvedType(), onto.resolvedType());
        if (primitiveBase instanceof TypeVariable) {
            if (primitiveOnto instanceof TypeVariable) {
                // base, onto both variables.
                const result = primitiveBase.variable.maybeMergeConstraints(primitiveOnto.variable);
                if (result === false) {
                    return null;
                }
                primitiveOnto.variable.resolution = primitiveBase;
            }
            else {
                // base variable, onto not.
                if (!primitiveBase.variable.isValidResolutionCandidate(primitiveOnto).result) {
                    return null;
                }
                primitiveBase.variable.resolution = primitiveOnto;
            }
            return base;
        }
        else if (primitiveOnto instanceof TypeVariable) {
            // onto variable, base not.
            if (!primitiveOnto.variable.isValidResolutionCandidate(primitiveBase).result) {
                return null;
            }
            primitiveOnto.variable.resolution = primitiveBase;
            return onto;
        }
        else if (primitiveBase instanceof InterfaceType && primitiveOnto instanceof InterfaceType) {
            const result = primitiveBase.interfaceInfo.tryMergeTypeVariablesWith(primitiveOnto.interfaceInfo);
            if (result == null) {
                return null;
            }
            return new InterfaceType(result);
        }
        else if ((primitiveBase.isTypeContainer() && primitiveBase.hasVariable)
            || (primitiveOnto.isTypeContainer() && primitiveOnto.hasVariable)) {
            // Cannot merge [~a] with a type that is not a variable and not a collection.
            return null;
        }
        throw new Error('tryMergeTypeVariable shouldn\'t be called on two types without any type variables');
    }
    static _tryMergeConstraints(handleType, { type, direction }) {
        let [primitiveHandleType, primitiveConnectionType] = Type.unwrapPair(handleType.resolvedType(), type.resolvedType());
        if (primitiveHandleType instanceof TypeVariable) {
            while (primitiveConnectionType.isTypeContainer()) {
                if (primitiveHandleType.variable.resolution != null
                    || primitiveHandleType.variable.canReadSubset != null
                    || primitiveHandleType.variable.canWriteSuperset != null) {
                    // Resolved and/or constrained variables can only represent Entities, not sets.
                    return false;
                }
                // If this is an undifferentiated variable then we need to create structure to match against. That's
                // allowed because this variable could represent anything, and it needs to represent this structure
                // in order for type resolution to succeed.
                const newVar = TypeVariable.make('a', null, null);
                if (primitiveConnectionType instanceof CollectionType) {
                    primitiveHandleType.variable.resolution = new CollectionType(newVar);
                }
                else if (primitiveConnectionType instanceof BigCollectionType) {
                    primitiveHandleType.variable.resolution = new BigCollectionType(newVar);
                }
                else {
                    primitiveHandleType.variable.resolution = new ReferenceType(newVar);
                }
                const unwrap = Type.unwrapPair(primitiveHandleType.resolvedType(), primitiveConnectionType);
                [primitiveHandleType, primitiveConnectionType] = unwrap;
                if (!(primitiveHandleType instanceof TypeVariable)) {
                    // This should never happen, and the guard above is just here so we type-check.
                    throw new TypeError('unwrapping a wrapped TypeVariable somehow didn\'t become a TypeVariable');
                }
            }
            if (direction === 'out' || direction === 'inout' || direction === '`provide') {
                // the canReadSubset of the handle represents the maximal type that can be read from the
                // handle, so we need to intersect out any type that is more specific than the maximal type
                // that could be written.
                if (!primitiveHandleType.variable.maybeMergeCanReadSubset(primitiveConnectionType.canWriteSuperset)) {
                    return false;
                }
            }
            if (direction === 'in' || direction === 'inout' || direction === '`consume') {
                // the canWriteSuperset of the handle represents the maximum lower-bound type that is read from the handle,
                // so we need to union it with the type that wants to be read here.
                if (!primitiveHandleType.variable.maybeMergeCanWriteSuperset(primitiveConnectionType.canReadSubset)) {
                    return false;
                }
            }
        }
        else {
            if (primitiveConnectionType.tag !== primitiveHandleType.tag) {
                return false;
            }
            if (direction === 'out' || direction === 'inout') {
                if (!TypeChecker._writeConstraintsApply(primitiveHandleType, primitiveConnectionType)) {
                    return false;
                }
            }
            if (direction === 'in' || direction === 'inout') {
                if (!TypeChecker._readConstraintsApply(primitiveHandleType, primitiveConnectionType)) {
                    return false;
                }
            }
        }
        return true;
    }
    static _writeConstraintsApply(handleType, connectionType) {
        // this connection wants to write to this handle. If the written type is
        // more specific than the canReadSubset then it isn't violating the maximal type
        // that can be read.
        const writtenType = connectionType.canWriteSuperset;
        if (writtenType == null || handleType.canReadSubset == null) {
            return true;
        }
        if (writtenType.isMoreSpecificThan(handleType.canReadSubset)) {
            return true;
        }
        return false;
    }
    static _readConstraintsApply(handleType, connectionType) {
        // this connection wants to read from this handle. If the read type
        // is less specific than the canWriteSuperset, then it isn't violating
        // the maximum lower-bound read type.
        const readType = connectionType.canReadSubset;
        if (readType == null || handleType.canWriteSuperset == null) {
            return true;
        }
        if (handleType.canWriteSuperset.isMoreSpecificThan(readType)) {
            return true;
        }
        return false;
    }
    // Compare two types to see if they could be potentially resolved (in the absence of other
    // information). This is used as a filter when selecting compatible handles or checking
    // validity of recipes. This function returning true never implies that full type resolution
    // will succeed, but if the function returns false for a pair of types that are associated
    // then type resolution is guaranteed to fail.
    //
    // left, right: {type, direction, connection}
    static compareTypes(left, right) {
        const resolvedLeft = left.type.resolvedType();
        const resolvedRight = right.type.resolvedType();
        const [leftType, rightType] = Type.unwrapPair(resolvedLeft, resolvedRight);
        // a variable is compatible with a set only if it is unconstrained.
        if (leftType instanceof TypeVariable && rightType.isTypeContainer()) {
            return !(leftType.variable.canReadSubset || leftType.variable.canWriteSuperset);
        }
        if (rightType instanceof TypeVariable && leftType.isTypeContainer()) {
            return !(rightType.variable.canReadSubset || rightType.variable.canWriteSuperset);
        }
        if (leftType instanceof TypeVariable || rightType instanceof TypeVariable) {
            // TODO: everything should use this, eventually. Need to implement the
            // right functionality in Interfaces first, though.
            return Type.canMergeConstraints(leftType, rightType);
        }
        if ((leftType === undefined) !== (rightType === undefined)) {
            return false;
        }
        if (leftType === rightType) {
            return true;
        }
        if (leftType.tag !== rightType.tag) {
            return false;
        }
        if (leftType instanceof SlotType) {
            return true;
        }
        // TODO: we need a generic way to evaluate type compatibility
        //       interfaces + entities + etc
        if (leftType instanceof InterfaceType && rightType instanceof InterfaceType) {
            if (leftType.interfaceInfo.equals(rightType.interfaceInfo)) {
                return true;
            }
        }
        if (!(leftType instanceof EntityType) || !(rightType instanceof EntityType)) {
            return false;
        }
        const leftIsSub = leftType.entitySchema.isMoreSpecificThan(rightType.entitySchema);
        const leftIsSuper = rightType.entitySchema.isMoreSpecificThan(leftType.entitySchema);
        if (leftIsSuper && leftIsSub) {
            return true;
        }
        if (!leftIsSuper && !leftIsSub) {
            return false;
        }
        const [superclass, subclass] = leftIsSuper ? [left, right] : [right, left];
        // treat handle types as if they were 'inout' connections. Note that this
        // guarantees that the handle's type will be preserved, and that the fact
        // that the type comes from a handle rather than a connection will also
        // be preserved.
        const superDirection = superclass.direction || (superclass.connection ? superclass.connection.direction : 'inout');
        const subDirection = subclass.direction || (subclass.connection ? subclass.connection.direction : 'inout');
        if (superDirection === 'in') {
            return true;
        }
        if (subDirection === 'out') {
            return true;
        }
        return false;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/** The different types of trust checks that particles can make. */
var CheckType;
(function (CheckType) {
    CheckType["HasTag"] = "has-tag";
    CheckType["IsFromHandle"] = "is-from-handle";
    CheckType["IsFromOutput"] = "is-from-output";
    CheckType["IsFromStore"] = "is-from-store";
})(CheckType || (CheckType = {}));
class Check {
    constructor(target, expression) {
        this.target = target;
        this.expression = expression;
    }
    toManifestString() {
        let targetString;
        if (this.target instanceof HandleConnectionSpec) {
            targetString = this.target.name;
        }
        else {
            targetString = `${this.target.name} data`;
        }
        return `check ${targetString} ${this.expression.toManifestString()}`;
    }
}
/** A boolean expression inside a trust check. */
class CheckBooleanExpression {
    constructor(type, children) {
        this.type = type;
        this.children = children;
    }
    /**
     * @inheritdoc
     * @param requireParens Indicates whether to enclose the expression inside parentheses. All nested boolean expressions must have parentheses,
     *     but a top-level expression doesn't need to.
     */
    toManifestString(requireParens = false) {
        const str = this.children.map(child => child.toManifestString(/* requireParens= */ true)).join(` ${this.type} `);
        return requireParens ? `(${str})` : str;
    }
}
/** A check condition of the form 'check x is <tag>'. */
class CheckHasTag {
    constructor(tag, isNot) {
        this.tag = tag;
        this.isNot = isNot;
        this.type = CheckType.HasTag;
    }
    static fromASTNode(astNode) {
        return new CheckHasTag(astNode.tag, astNode.isNot);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}${this.tag}`;
    }
}
/** A check condition of the form 'check x is from handle <handle>'. */
class CheckIsFromHandle {
    constructor(parentHandle, isNot) {
        this.parentHandle = parentHandle;
        this.isNot = isNot;
        this.type = CheckType.IsFromHandle;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        const parentHandle = handleConnectionMap.get(astNode.parentHandle);
        if (!parentHandle) {
            throw new Error(`Unknown "check is from handle" handle name: ${astNode.parentHandle}.`);
        }
        return new CheckIsFromHandle(parentHandle, astNode.isNot);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}from handle ${this.parentHandle.name}`;
    }
}
/** A check condition of the form 'check x is from output <output>'. */
class CheckIsFromOutput {
    constructor(output, isNot) {
        this.output = output;
        this.isNot = isNot;
        this.type = CheckType.IsFromOutput;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        const output = handleConnectionMap.get(astNode.output);
        if (!output) {
            throw new Error(`Unknown "check is from output" output name: ${astNode.output}.`);
        }
        return new CheckIsFromOutput(output, astNode.isNot);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}from output ${this.output.name}`;
    }
}
/** A check condition of the form 'check x is from store <store reference>'. */
class CheckIsFromStore {
    constructor(storeRef, isNot) {
        this.storeRef = storeRef;
        this.isNot = isNot;
        this.type = CheckType.IsFromStore;
    }
    static fromASTNode(astNode) {
        return new CheckIsFromStore({
            type: astNode.storeRef.type,
            store: astNode.storeRef.store,
        }, astNode.isNot);
    }
    toManifestString() {
        let store = this.storeRef.store;
        if (this.storeRef.type === 'id') {
            // Put the ID inside single-quotes.
            store = `'${store}'`;
        }
        return `is ${this.isNot ? 'not ' : ''}from store ${store}`;
    }
}
/** Converts the given AST node into a CheckCondition object. */
function createCheckCondition(astNode, handleConnectionMap) {
    switch (astNode.checkType) {
        case CheckType.HasTag:
            return CheckHasTag.fromASTNode(astNode);
        case CheckType.IsFromHandle:
            return CheckIsFromHandle.fromASTNode(astNode, handleConnectionMap);
        case CheckType.IsFromStore:
            return CheckIsFromStore.fromASTNode(astNode);
        case CheckType.IsFromOutput:
            return CheckIsFromOutput.fromASTNode(astNode, handleConnectionMap);
        default:
            throw new Error('Unknown check type.');
    }
}
/** Converts the given AST node into a CheckExpression object. */
function createCheckExpression(astNode, handleConnectionMap) {
    if (astNode.kind === 'particle-trust-check-boolean-expression') {
        assert(astNode.children.length >= 2, 'Boolean check expressions must have at least two children.');
        return new CheckBooleanExpression(astNode.operator, astNode.children.map(child => createCheckExpression(child, handleConnectionMap)));
    }
    else {
        return createCheckCondition(astNode, handleConnectionMap);
    }
}
/** Converts the given AST node into a Check object. */
function createCheck(checkTarget, astNode, handleConnectionMap) {
    const expression = createCheckExpression(astNode.expression, handleConnectionMap);
    return new Check(checkTarget, expression);
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/** The different types of trust claims that particles can make. */
var ClaimType;
(function (ClaimType) {
    ClaimType["IsTag"] = "is-tag";
    ClaimType["DerivesFrom"] = "derives-from";
})(ClaimType || (ClaimType = {}));
/** A list of claims made by a particle on a specific handle. */
class ParticleClaim {
    constructor(handle, claims) {
        this.handle = handle;
        this.claims = claims;
    }
    toManifestString() {
        const manifestStrings = this.claims.map(claim => claim.toManifestString());
        return `claim ${this.handle.name} ${manifestStrings.join(' and ')}`;
    }
}
class ClaimIsTag {
    constructor(isNot, tag) {
        this.isNot = isNot;
        this.tag = tag;
        this.type = ClaimType.IsTag;
    }
    static fromASTNode(astNode) {
        return new ClaimIsTag(astNode.isNot, astNode.tag);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}${this.tag}`;
    }
}
class ClaimDerivesFrom {
    constructor(parentHandle) {
        this.parentHandle = parentHandle;
        this.type = ClaimType.DerivesFrom;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        // Convert handle names into HandleConnectionSpec objects.
        const parentHandle = handleConnectionMap.get(astNode.parentHandle);
        if (!parentHandle) {
            throw new Error(`Unknown "derives from" handle name: ${parentHandle}.`);
        }
        return new ClaimDerivesFrom(parentHandle);
    }
    toManifestString() {
        return `derives from ${this.parentHandle.name}`;
    }
}
function createParticleClaim(handle, astNode, handleConnectionMap) {
    const claims = astNode.expression.map(claimNode => {
        switch (claimNode.claimType) {
            case ClaimType.IsTag:
                return ClaimIsTag.fromASTNode(claimNode);
            case ClaimType.DerivesFrom:
                return ClaimDerivesFrom.fromASTNode(claimNode, handleConnectionMap);
            default:
                throw new Error('Unknown claim type.');
        }
    });
    return new ParticleClaim(handle, claims);
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function asType(t) {
    return (t instanceof Type) ? t : Type.fromLiteral(t);
}
function asTypeLiteral(t) {
    return (t instanceof Type) ? t.toLiteral() : t;
}
function isRoot({ name, tags, id, type }) {
    const rootNames = [
        'root',
        'toproot',
        'modal'
    ];
    if (type && !type.slandleType()) {
        // If this is a handle that is not a Slandle, it cannot be a root slot.
        return false;
    }
    // Checks that, if the id exists, it starts with the root id prefx.
    const prefix = 'rootslotid-';
    if (id && id.lastIndexOf(prefix, 0) === 0) {
        const rootName = id.substr(prefix.length);
        if (rootNames.includes(rootName)) {
            return true;
        }
    }
    return rootNames.includes(name) || tags.some(tag => rootNames.includes(tag));
}
class HandleConnectionSpec {
    constructor(rawData, typeVarMap) {
        this.parentConnection = null;
        this.rawData = rawData;
        this.direction = rawData.direction;
        this.name = rawData.name;
        this.type = asType(rawData.type).mergeTypeVariablesByName(typeVarMap);
        this.isOptional = rawData.isOptional;
        this.tags = rawData.tags || [];
        this.dependentConnections = [];
    }
    instantiateDependentConnections(particle, typeVarMap) {
        for (const dependentArg of this.rawData.dependentConnections) {
            const dependentConnection = particle.createConnection(dependentArg, typeVarMap);
            dependentConnection.parentConnection = this;
            this.dependentConnections.push(dependentConnection);
        }
    }
    toSlotConnectionSpec() {
        // TODO: Remove in SLANDLESv2
        const slotType = this.type.slandleType();
        if (!slotType) {
            return undefined;
        }
        const isSet = this.type.isCollectionType();
        const slotInfo = slotType.getSlot();
        return {
            name: this.name,
            isOptional: this.isOptional,
            direction: this.direction,
            tags: this.tags,
            dependentConnections: this.dependentConnections.map(conn => conn.toSlotConnectionSpec()),
            // Fakes
            isRequired: !this.isOptional,
            isSet,
            type: slotType,
            handles: [slotInfo.handle],
            formFactor: slotInfo.formFactor,
            provideSlotConnections: [],
        };
    }
    get isInput() {
        // TODO: we probably don't really want host to be here.
        // TODO: do we want to consider any here?
        return this.direction === 'in' || this.direction === 'inout' || this.direction === 'host';
    }
    get isOutput() {
        // TODO: do we want to consider any here?
        return this.direction === 'out' || this.direction === 'inout';
    }
    isCompatibleType(type) {
        return TypeChecker.compareTypes({ type }, { type: this.type, direction: this.direction });
    }
}
class ConsumeSlotConnectionSpec {
    constructor(slotModel) {
        this.name = slotModel.name;
        this.isRequired = slotModel.isRequired || false;
        this.isSet = slotModel.isSet || false;
        this.tags = slotModel.tags || [];
        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?
        this.handles = slotModel.handles || [];
        this.provideSlotConnections = [];
        if (!slotModel.provideSlotConnections) {
            return;
        }
        slotModel.provideSlotConnections.forEach(ps => {
            this.provideSlotConnections.push(new ProvideSlotConnectionSpec(ps));
        });
    }
    // Getters to 'fake' being a Handle.
    get isOptional() { return !this.isRequired; }
    get direction() { return '`consume'; }
    get type() {
        //TODO(jopra): FIXME make the null handle optional.
        const slotT = SlotType.make(this.formFactor, null);
        if (this.isSet) {
            return slotT.collectionOf();
        }
        return slotT;
    }
    get dependentConnections() { return this.provideSlotConnections; }
}
class ProvideSlotConnectionSpec extends ConsumeSlotConnectionSpec {
    constructor(slotModel) {
        super(slotModel);
        this.check = slotModel.check;
    }
}
class ParticleSpec {
    constructor(model) {
        this.model = model;
        this.name = model.name;
        this.verbs = model.verbs;
        const typeVarMap = new Map();
        this.handleConnectionMap = new Map();
        model.args.forEach(arg => this.createConnection(arg, typeVarMap));
        // initialize descriptions patterns.
        model.description = model.description || {};
        this.validateDescription(model.description);
        this.pattern = model.description['pattern'];
        this.handleConnectionMap.forEach((connectionSpec, name) => {
            connectionSpec.pattern = model.description[name];
        });
        this.implFile = model.implFile;
        this.implBlobUrl = model.implBlobUrl;
        this.modality = model.modality ? Modality.create(model.modality) : Modality.all;
        this.slotConnections = new Map();
        if (model.slotConnections) {
            model.slotConnections.forEach(s => this.slotConnections.set(s.name, new ConsumeSlotConnectionSpec(s)));
        }
        // Verify provided slots use valid handle connection names.
        this.slotConnections.forEach(slot => {
            slot.provideSlotConnections.forEach(ps => {
                ps.handles.forEach(v => assert(this.handleConnectionMap.has(v), 'Cannot provide slot for nonexistent handle constraint ' + v));
            });
        });
        this.trustClaims = this.validateTrustClaims(model.trustClaims);
        this.trustChecks = this.validateTrustChecks(model.trustChecks);
    }
    createConnection(arg, typeVarMap) {
        const connection = new HandleConnectionSpec(arg, typeVarMap);
        if (this.handleConnectionMap.get(connection.name)) {
            throw new Error(`Particle Spec ${this.name} already has a handle connection named "${connection.name}".`);
        }
        this.handleConnectionMap.set(connection.name, connection);
        connection.instantiateDependentConnections(this, typeVarMap);
        return connection;
    }
    get handleConnections() {
        return this.connections;
    }
    get connections() {
        return [...this.handleConnectionMap.values()];
    }
    get inputs() {
        return this.connections.filter(a => a.isInput);
    }
    get outputs() {
        return this.connections.filter(a => a.isOutput);
    }
    isInput(param) {
        const connection = this.handleConnectionMap.get(param);
        return connection && connection.isInput;
    }
    isOutput(param) {
        const connection = this.handleConnectionMap.get(param);
        return connection && connection.isOutput;
    }
    getConnectionByName(name) {
        return this.handleConnectionMap.get(name);
    }
    getSlotSpec(slotName) {
        return this.slotConnections.get(slotName);
    }
    getSlandleSpec(slotName) {
        const slot = this.slotConnections.get(slotName);
        if (slot)
            return slot;
        const handleConn = this.handleConnectionMap.get(slotName);
        return handleConn.toSlotConnectionSpec();
    }
    slandleConnectionNames() {
        const slandleNames = this.handleConnections.filter(conn => conn.toSlotConnectionSpec()).map(conn => conn.name);
        return [...this.slotConnections.keys(), ...slandleNames];
    }
    slotConnectionNames() {
        return [...this.slotConnections.keys()];
    }
    get primaryVerb() {
        return (this.verbs.length > 0) ? this.verbs[0] : undefined;
    }
    isCompatible(modality) {
        return this.slandleConnectionNames().length === 0 || this.modality.intersection(modality).isResolved();
    }
    setImplBlobUrl(url) {
        this.model.implBlobUrl = this.implBlobUrl = url;
    }
    toLiteral() {
        const { args, name, verbs, description, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks } = this.model;
        const connectionToLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: asTypeLiteral(type), direction, name, isOptional, dependentConnections: dependentConnections.map(connectionToLiteral) });
        const argsLiteral = args.map(a => connectionToLiteral(a));
        return { args: argsLiteral, name, verbs, description, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks };
    }
    static fromLiteral(literal) {
        let { args, name, verbs, description, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks } = literal;
        const connectionFromLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: asType(type), direction, name, isOptional, dependentConnections: dependentConnections ? dependentConnections.map(connectionFromLiteral) : [] });
        args = args.map(connectionFromLiteral);
        return new ParticleSpec({ args, name, verbs: verbs || [], description, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks });
    }
    // Note: this method shouldn't be called directly.
    clone() {
        return ParticleSpec.fromLiteral(this.toLiteral());
    }
    // Note: this method shouldn't be called directly (only as part of particle copying).
    cloneWithResolutions(variableMap) {
        const spec = this.clone();
        this.handleConnectionMap.forEach((conn, name) => {
            spec.handleConnectionMap.get(name).type = conn.type._cloneWithResolutions(variableMap);
        });
        return spec;
    }
    equals(other) {
        return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());
    }
    validateDescription(description) {
        Object.keys(description || []).forEach(d => {
            assert(['kind', 'location', 'pattern'].includes(d) || this.handleConnectionMap.has(d), `Unexpected description for ${d}`);
        });
    }
    toInterface() {
        // TODO: wat do?
        assert(!this.slotConnections.size, 'please implement slots toInterface');
        const handles = this.model.args.map(({ type, name, direction }) => ({ type: asType(type), name, direction }));
        const slots = [];
        return InterfaceType.make(this.name, handles, slots);
    }
    toString() {
        const results = [];
        let verbs = '';
        if (this.verbs.length > 0) {
            verbs = ' ' + this.verbs.map(verb => `&${verb}`).join(' ');
        }
        results.push(`particle ${this.name}${verbs} in '${this.implFile}'`.trim());
        const indent = '  ';
        const writeConnection = (connection, indent) => {
            const tags = connection.tags.map((tag) => ` #${tag}`).join('');
            results.push(`${indent}${connection.direction}${connection.isOptional ? '?' : ''} ${connection.type.toString()} ${connection.name}${tags}`);
            for (const dependent of connection.dependentConnections) {
                writeConnection(dependent, indent + '  ');
            }
        };
        for (const connection of this.handleConnections) {
            if (connection.parentConnection) {
                continue;
            }
            writeConnection(connection, indent);
        }
        this.trustClaims.forEach(claim => results.push(`  ${claim.toManifestString()}`));
        this.trustChecks.forEach(check => results.push(`  ${check.toManifestString()}`));
        this.modality.names.forEach(a => results.push(`  modality ${a}`));
        const slotToString = (s, direction, indent) => {
            const tokens = [];
            if (s.isRequired) {
                tokens.push('must');
            }
            tokens.push(direction);
            if (s.isSet) {
                tokens.push('set of');
            }
            tokens.push(s.name);
            if (s.tags.length > 0) {
                tokens.push(s.tags.map(a => `#${a}`).join(' '));
            }
            results.push(`${indent}${tokens.join(' ')}`);
            if (s.formFactor) {
                results.push(`${indent}  formFactor ${s.formFactor}`);
            }
            for (const handle of s.handles) {
                results.push(`${indent}  handle ${handle}`);
            }
            if (s.provideSlotConnections) {
                // Provided slots.
                s.provideSlotConnections.forEach(p => slotToString(p, 'provide', indent + '  '));
            }
        };
        this.slotConnections.forEach(s => slotToString(s, 'consume', '  '));
        // Description
        if (this.pattern) {
            results.push(`  description \`${this.pattern}\``);
            this.handleConnectionMap.forEach(cs => {
                if (cs.pattern) {
                    results.push(`    ${cs.name} \`${cs.pattern}\``);
                }
            });
        }
        return results.join('\n');
    }
    toManifestString() {
        return this.toString();
    }
    validateTrustClaims(statements) {
        const results = [];
        if (statements) {
            statements.forEach(statement => {
                const handle = this.handleConnectionMap.get(statement.handle);
                if (!handle) {
                    throw new Error(`Can't make a claim on unknown handle ${statement.handle}.`);
                }
                if (!handle.isOutput) {
                    throw new Error(`Can't make a claim on handle ${statement.handle} (not an output handle).`);
                }
                if (handle.claims) {
                    throw new Error(`Can't make multiple claims on the same output (${statement.handle}).`);
                }
                const particleClaim = createParticleClaim(handle, statement, this.handleConnectionMap);
                handle.claims = particleClaim.claims;
                results.push(particleClaim);
            });
        }
        return results;
    }
    validateTrustChecks(checks) {
        const results = [];
        if (checks) {
            const providedSlotNames = this.getProvidedSlotsByName();
            checks.forEach(check => {
                switch (check.target.targetType) {
                    case 'handle': {
                        const handleName = check.target.name;
                        const handle = this.handleConnectionMap.get(handleName);
                        if (!handle) {
                            throw new Error(`Can't make a check on unknown handle ${handleName}.`);
                        }
                        if (!handle.isInput) {
                            throw new Error(`Can't make a check on handle ${handleName} (not an input handle).`);
                        }
                        if (handle.check) {
                            throw new Error(`Can't make multiple checks on the same input (${handleName}).`);
                        }
                        handle.check = createCheck(handle, check, this.handleConnectionMap);
                        results.push(handle.check);
                        break;
                    }
                    case 'slot': {
                        const slotName = check.target.name;
                        const slotSpec = providedSlotNames.get(slotName);
                        if (!slotSpec) {
                            if (this.slotConnectionNames().includes(slotName)) {
                                throw new Error(`Slot ${slotName} is a consumed slot. Can only make checks on provided slots.`);
                            }
                            else {
                                throw new Error(`Can't make a check on unknown slot ${slotName}.`);
                            }
                        }
                        slotSpec.check = createCheck(slotSpec, check, this.handleConnectionMap);
                        results.push(slotSpec.check);
                        break;
                    }
                    default:
                        throw new Error('Unknown check target type.');
                }
            });
        }
        return results;
    }
    getProvidedSlotsByName() {
        const result = new Map();
        for (const consumeConnection of this.slotConnections.values()) {
            for (const provideConnection of consumeConnection.provideSlotConnections) {
                const name = provideConnection.name;
                if (result.has(name)) {
                    throw new Error(`Another slot with name '${name}' has already been provided by this particle.`);
                }
                result.set(name, provideConnection);
            }
        }
        return result;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class DescriptionFormatter {
    constructor(particleDescriptions = [], storeDescById = {}) {
        this.particleDescriptions = particleDescriptions;
        this.storeDescById = storeDescById;
        this.seenHandles = new Set();
        this.seenParticles = new Set();
        this.excludeValues = false;
    }
    getDescription(recipe) {
        if (recipe.patterns.length > 0) {
            let recipePatterns = [];
            for (const pattern of recipe.patterns) {
                recipePatterns.push(this.patternToSuggestion(pattern, { _recipe: recipe }));
            }
            recipePatterns = recipePatterns.filter(pattern => Boolean(pattern));
            if (recipePatterns.length > 0) {
                // TODO(mmandlis): Sort the descriptions.
                return this._capitalizeAndPunctuate(this._joinDescriptions(recipePatterns));
            }
        }
        // Choose particles, sort them by rank and generate suggestions.
        const particlesSet = new Set(recipe.particles);
        let selectedDescriptions = this.particleDescriptions
            .filter(desc => (particlesSet.has(desc._particle) && this._isSelectedDescription(desc)));
        // Prefer particles that render UI, if any.
        if (selectedDescriptions.find(desc => (desc._particle.spec.slotConnections.size > 0))) {
            selectedDescriptions = selectedDescriptions.filter(desc => (desc._particle.spec.slotConnections.size > 0));
        }
        selectedDescriptions = selectedDescriptions.sort(DescriptionFormatter.sort);
        if (selectedDescriptions.length > 0) {
            return this._combineSelectedDescriptions(selectedDescriptions);
        }
        return undefined;
    }
    _isSelectedDescription(desc) {
        return !!desc.pattern;
    }
    getHandleDescription(recipeHandle) {
        const handleConnection = this._selectHandleConnection(recipeHandle) || recipeHandle.connections[0];
        return this._formatDescription(handleConnection);
    }
    // TODO(mmandlis): the override of this function in subclasses also overrides the output. We'll need to unify
    // this into an output type hierarchy before we can assign a useful type to the output of this function.
    // tslint:disable-next-line: no-any
    _combineSelectedDescriptions(selectedDescriptions, options = {}) {
        const suggestions = [];
        selectedDescriptions.forEach(particle => {
            if (!this.seenParticles.has(particle._particle)) {
                suggestions.push(this.patternToSuggestion(particle.pattern, particle));
            }
        });
        const jointDescription = this._joinDescriptions(suggestions);
        if (jointDescription) {
            if (options.skipFormatting) {
                return jointDescription;
            }
            else {
                return this._capitalizeAndPunctuate(jointDescription);
            }
        }
        return undefined;
    }
    // TODO(mmandlis): the override of this function in subclasses also overrides the output. We'll need to unify
    // this into an output type hierarchy before we can assign a useful type to the output of this function.
    // tslint:disable-next-line: no-any
    _joinDescriptions(strings) {
        const nonEmptyStrings = strings.filter(str => str);
        const count = nonEmptyStrings.length;
        if (count > 0) {
            // Combine descriptions into a sentence:
            // "A."
            // "A and b."
            // "A, b, ..., and z." (Oxford comma ftw)
            const delim = ['', '', ' and ', ', and '][Math.min(3, count)];
            const lastString = nonEmptyStrings.pop();
            return `${nonEmptyStrings.join(', ')}${delim}${lastString}`;
        }
        return undefined;
    }
    _joinTokens(tokens) {
        return tokens.join('');
    }
    _capitalizeAndPunctuate(sentence) {
        assert(sentence);
        // "Capitalize, punctuate." (if the sentence doesn't end with a punctuation character).
        const last = sentence.length - 1;
        return `${sentence[0].toUpperCase()}${sentence.slice(1, last)}${sentence[last]}${sentence[last].match(/[a-z0-9()' >\]]/i) ? '.' : ''}`;
    }
    patternToSuggestion(pattern, particleDescription) {
        const tokens = this._initTokens(pattern, particleDescription);
        const tokenResults = tokens.map(token => this.tokenToString(token));
        if (tokenResults.filter(res => res == undefined).length === 0) {
            return this._joinTokens(tokenResults);
        }
        return undefined;
    }
    _initTokens(pattern, particleDescription) {
        pattern = pattern.replace(/</g, '&lt;');
        let results = [];
        while (pattern.length > 0) {
            const tokens = pattern.match(DescriptionFormatter.tokensRegex);
            let firstToken;
            let tokenIndex;
            if (tokens) {
                firstToken = tokens[0];
                tokenIndex = pattern.indexOf(firstToken);
            }
            else {
                firstToken = '';
                tokenIndex = pattern.length;
            }
            assert(tokenIndex >= 0);
            const nextToken = pattern.substring(0, tokenIndex);
            if (nextToken.length > 0) {
                results.push({ text: nextToken });
            }
            if (firstToken.length > 0) {
                results = results.concat(this._initSubTokens(firstToken, particleDescription));
            }
            pattern = pattern.substring(tokenIndex + firstToken.length);
        }
        return results;
    }
    _initSubTokens(pattern, particleDescription) {
        const valueTokens = pattern.match(DescriptionFormatter.tokensInnerRegex);
        const handleNames = valueTokens[1].split('.');
        const extra = valueTokens.length === 3 ? valueTokens[2] : undefined;
        // Fetch the particle description by name from the value token - if it wasn't passed, this is a recipe description.
        if (!particleDescription._particle) {
            const particleName = handleNames.shift();
            if (particleName[0] !== particleName[0].toUpperCase()) {
                console.warn(`Invalid particle name '${particleName}' - must start with a capital letter.`);
                return [];
            }
            const particleDescriptions = this.particleDescriptions.filter(desc => {
                return desc._particle.name === particleName
                    // The particle description is from the current recipe.
                    && particleDescription._recipe.particles.find(p => p === desc._particle);
            });
            if (particleDescriptions.length === 0) {
                console.warn(`Cannot find particles with name ${particleName}.`);
                return [];
            }
            // Note: when an arc's active recipes contains several recipes, the last recipe's description
            // is used as the arc's description. If this last recipe's description has a description pattern
            // that references a particle that is also used in one of the previous recipes,
            // there will be a duplicate particle-description.
            particleDescription = particleDescriptions[particleDescriptions.length - 1];
        }
        const particle = particleDescription._particle;
        if (handleNames.length === 0) {
            // return a particle token
            return [{
                    particleName: particle.spec.name,
                    particleDescription
                }];
        }
        const handleConn = particle.connections[handleNames[0]];
        if (handleConn) { // handle connection
            assert(handleConn.handle, 'Missing handle???');
            return [{
                    fullName: valueTokens[0],
                    handleName: handleConn.name,
                    storeId: handleConn.handle.id,
                    properties: handleNames.splice(1),
                    extra,
                    _handleConn: handleConn,
                    value: particleDescription._connections[handleConn.name].value
                }];
        }
        // slot connection
        if (handleNames.length !== 2) {
            if (handleNames.length === 1) {
                console.warn(`Unknown handle connection name '${handleNames[0]}'`);
            }
            else {
                console.warn(`Slot connections tokens must have exactly 2 names, found ${handleNames.length} in '${handleNames.join('.')}'`);
            }
            return [];
        }
        const providedSlotConn = particle.getSlotConnectionByName(handleNames[0]).providedSlots[handleNames[1]];
        assert(providedSlotConn, `Could not find handle ${handleNames.join('.')}`);
        return [{
                fullName: valueTokens[0],
                consumeSlotName: handleNames[0],
                provideSlotName: handleNames[1],
                extra,
                _providedSlotConn: providedSlotConn
            }];
    }
    tokenToString(token) {
        if (token.text) {
            return token.text;
        }
        if (token.particleName) {
            return this._particleTokenToString(token);
        }
        if (token.handleName) {
            return this._handleTokenToString(token);
        }
        else if (token.consumeSlotName && token.provideSlotName) {
            return this._slotTokenToString(token);
        }
        throw new Error('no handle or slot name');
    }
    _particleTokenToString(token) {
        return this._combineSelectedDescriptions([token.particleDescription], { skipFormatting: true });
    }
    _handleTokenToString(token) {
        switch (token.extra) {
            case '_type_':
                return token._handleConn.type.toPrettyString().toLowerCase();
            case '_values_':
                return this._formatStoreValue(token.handleName, token.value);
            case '_name_':
                return this._formatDescription(token._handleConn);
            default: {
                assert(!token.extra, `Unrecognized extra ${token.extra}`);
                // Transformation's hosted particle.
                if (token._handleConn.type instanceof InterfaceType) {
                    if (!token.value) {
                        return undefined;
                    }
                    assert(token.value.interfaceValue, `Missing interface type value for '${token._handleConn.type}'.`);
                    const particleSpec = ParticleSpec.fromLiteral(token.value.interfaceValue);
                    // TODO: call this.patternToSuggestion(...) to resolved expressions in the pattern template.
                    return particleSpec.pattern;
                }
                // singleton handle property.
                if (token.properties && token.properties.length > 0) {
                    return this._propertyTokenToString(token.handleName, token.value, token.properties);
                }
                // full handle description
                let description = this._formatDescriptionPattern(token._handleConn) ||
                    this._formatStoreDescription(token._handleConn);
                const storeValue = this._formatStoreValue(token.handleName, token.value);
                if (!description) {
                    // For singleton handle, if there is no real description (the type was used), use the plain value for description.
                    // TODO: should this look at type.getContainedType() (which includes references), or maybe just check for EntityType?
                    const storeType = token._handleConn.type;
                    if (storeValue && !this.excludeValues &&
                        !(storeType instanceof CollectionType) && !(storeType instanceof BigCollectionType)) {
                        return storeValue;
                    }
                }
                description = description || this._formatHandleType(token._handleConn);
                if (storeValue && !this.excludeValues && !this.seenHandles.has(token.storeId)) {
                    this.seenHandles.add(token.storeId);
                    return this._combineDescriptionAndValue(token, description, storeValue);
                }
                return description;
            }
        }
    }
    _combineDescriptionAndValue(token, description, storeValue) {
        if (description === storeValue) {
            return description;
        }
        return `${description} (${storeValue})`;
    }
    _slotTokenToString(token) {
        switch (token.extra) {
            case '_empty_':
                // TODO: also return false, if the consuming particles generate an empty description.
                return token._providedSlotConn.consumeConnections.length === 0;
            default:
                assert(!token.extra, `Unrecognized slot extra ${token.extra}`);
        }
        const results = token._providedSlotConn.consumeConnections.map(consumeConn => {
            const particle = consumeConn.particle;
            const particleDescription = this.particleDescriptions.find(desc => desc._particle === particle);
            this.seenParticles.add(particle);
            return this.patternToSuggestion(particle.spec.pattern, particleDescription);
        });
        return this._joinDescriptions(results);
    }
    _propertyTokenToString(handleName, value, properties) {
        if (!value) {
            return '';
        }
        assert(value.entityValue, `Cannot return property ${properties.join(',')} for non EntityType.`);
        // Use singleton value's property (eg. "09/15" for person's birthday)
        const valueVar = value.entityValue;
        if (value.entityValue) {
            let propertyValue = value.entityValue;
            for (const property of properties) {
                if (propertyValue) {
                    propertyValue = propertyValue[property];
                }
            }
            if (propertyValue) {
                return this._formatEntityProperty(handleName, properties, propertyValue);
            }
        }
    }
    _formatEntityProperty(handleName, properties, value) {
        return value;
    }
    _formatStoreValue(handleName, value) {
        if (value) {
            if (value.collectionValues) {
                return this._formatCollection(handleName, value.collectionValues);
            }
            if (value.bigCollectionValues) {
                return this._formatBigCollection(handleName, value.bigCollectionValues);
            }
            if (value.entityValue) {
                return this._formatSingleton(handleName, value);
            }
            throw new Error(`invalid store type for handle ${handleName}`);
        }
        return undefined;
    }
    _formatCollection(handleName, values) {
        if (values[0].rawData.name) {
            if (values.length > 2) {
                return `${values[0].rawData.name} plus ${values.length - 1} other items`;
            }
            return values.map(v => v.rawData.name).join(', ');
        }
        else {
            return `${values.length} items`;
        }
    }
    // TODO(mmandlis): the override of this function in subclasses also overrides the output. We'll need to unify
    // this into an output type hierarchy before we can assign a useful type to the output of this function.
    // tslint:disable-next-line: no-any
    _formatBigCollection(handleName, firstValue) {
        return `collection of items like ${firstValue.rawData.name}`;
    }
    _formatSingleton(handleName, value) {
        const entityValue = value.entityValue;
        if (value.valueDescription) {
            let valueDescription = value.valueDescription;
            let matches;
            while (matches = valueDescription.match(/\${([a-zA-Z0-9.]+)}/)) {
                valueDescription = valueDescription.replace(matches[0], entityValue[matches[1]]);
            }
            return valueDescription;
        }
        if (entityValue['name']) {
            return entityValue['name'];
        }
    }
    _formatDescription(handleConnection) {
        return this._formatDescriptionPattern(handleConnection) ||
            this._formatStoreDescription(handleConnection) ||
            this._formatHandleType(handleConnection);
    }
    _formatDescriptionPattern(handleConnection) {
        let chosenConnection = handleConnection;
        // For "out" connection, use its own description
        // For "in" connection, use description of the highest ranked out connection with description.
        if (!chosenConnection.spec.isOutput) {
            const otherConnection = this._selectHandleConnection(handleConnection.handle);
            if (otherConnection) {
                chosenConnection = otherConnection;
            }
        }
        const chosenParticleDescription = this.particleDescriptions.find(desc => desc._particle === chosenConnection.particle);
        const handleDescription = chosenParticleDescription ? chosenParticleDescription._connections[chosenConnection.name] : null;
        // Add description to result array.
        if (handleDescription && handleDescription.pattern) {
            // Add the connection spec's description pattern.
            return this.patternToSuggestion(handleDescription.pattern, chosenParticleDescription);
        }
        return undefined;
    }
    _formatStoreDescription(handleConn) {
        if (handleConn.handle) {
            if (!handleConn.handle.id) {
                return undefined;
            }
            const storeDescription = this.storeDescById[handleConn.handle.id];
            const handleType = this._formatHandleType(handleConn);
            // Use the handle description available in the arc (if it is different than type name).
            if (!!storeDescription && storeDescription !== handleType) {
                return storeDescription;
            }
        }
        return undefined;
    }
    _formatHandleType(handleConnection) {
        const type = handleConnection.handle && handleConnection.handle.type.isResolved() ? handleConnection.handle.type : handleConnection.type;
        return type.toPrettyString().toLowerCase();
    }
    _selectHandleConnection(recipeHandle) {
        const possibleConnections = recipeHandle.connections.filter(connection => {
            // Choose connections with patterns (manifest-based or dynamic).
            const connectionSpec = connection.spec;
            const particleDescription = this.particleDescriptions.find(desc => desc._particle === connection.particle);
            // TODO(sjmiles): added particleDescription null-check for
            // the moment, but we need to root cause this problem
            return !!connectionSpec.pattern ||
                (!!particleDescription && !!particleDescription._connections[connection.name].pattern);
        });
        possibleConnections.sort((c1, c2) => {
            const isOutput1 = c1.spec.isOutput;
            const isOutput2 = c2.spec.isOutput;
            if (isOutput1 !== isOutput2) {
                // Prefer output connections
                return isOutput1 ? -1 : 1;
            }
            const d1 = this.particleDescriptions.find(desc => desc._particle === c1.particle);
            const d2 = this.particleDescriptions.find(desc => desc._particle === c2.particle);
            // Sort by particle's rank in descending order.
            return d2._rank - d1._rank;
        });
        if (possibleConnections.length > 0) {
            return possibleConnections[0];
        }
    }
    static sort(p1, p2) {
        // Root slot comes first.
        const hasRoot1 = [...p1._particle.spec.slotConnections.values()].some(slotSpec => isRoot(slotSpec));
        const hasRoot2 = [...p2._particle.spec.slotConnections.values()].some(slotSpec => isRoot(slotSpec));
        if (hasRoot1 !== hasRoot2) {
            return hasRoot1 ? -1 : 1;
        }
        // Sort by rank
        if (p1._rank !== p2._rank) {
            return p2._rank - p1._rank;
        }
        // Sort by number of singleton slots.
        let p1Slots = 0;
        let p2Slots = 0;
        p1._particle.spec.slotConnections.forEach((slotSpec) => { if (!slotSpec.isSet)
            ++p1Slots; });
        p2._particle.spec.slotConnections.forEach((slotSpec) => { if (!slotSpec.isSet)
            ++p2Slots; });
        return p2Slots - p1Slots;
    }
}
DescriptionFormatter.tokensRegex = /\${[a-zA-Z0-9.]+}(?:\.[_a-zA-Z]+)?/g;
DescriptionFormatter.tokensInnerRegex = /\${([a-zA-Z0-9.]+)}(?:\.([_a-zA-Z]+))?/;

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function compareNulls(o1, o2) {
    if (o1 === o2)
        return 0;
    if (o1 === null)
        return -1;
    return 1;
}
function compareStrings(s1, s2) {
    if (s1 == null || s2 == null)
        return compareNulls(s1, s2);
    return s1.localeCompare(s2);
}
function compareNumbers(n1, n2) {
    if (n1 == null || n2 == null)
        return compareNulls(n1, n2);
    return n1 - n2;
}
function compareArrays(a1, a2, compare) {
    assert(a1 != null);
    assert(a2 != null);
    if (a1.length !== a2.length)
        return compareNumbers(a1.length, a2.length);
    for (let i = 0; i < a1.length; i++) {
        let result;
        if ((result = compare(a1[i], a2[i])) !== 0)
            return result;
    }
    return 0;
}
function compareComparables(o1, o2) {
    if (o1 == null || o2 == null)
        return compareNulls(o1, o2);
    return o1._compareTo(o2);
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var EventKind;
(function (EventKind) {
    EventKind["change"] = "Change";
})(EventKind || (EventKind = {}));
class StorageBase {
    constructor(arcId) {
        this.arcId = arcId;
        this._debug = false;
        assert(arcId !== undefined, 'Arcs with storage must have ids');
    }
    /**
     * Turn on debugginf for this storage provider.  Providers should
     * subclass this and react to changes in the debug value.
     */
    set debug(d) {
        this._debug = d;
    }
    /**
     * Provides graceful shutdown for tests.
     */
    async shutdown() { }
}
class ChangeEvent {
    constructor(args) {
        Object.assign(this, args);
    }
}
/**
 * Docs TBD
 */
class StorageProviderBase {
    constructor(type, name, id, key) {
        this.referenceMode = false;
        assert(id, 'id must be provided when constructing StorageProviders');
        assert(!type.hasUnresolvedVariable, 'Storage types must be concrete');
        this._type = type;
        this.listeners = new Map();
        this.name = name;
        this.version = 0;
        this.id = id;
        this.source = null;
        this._storageKey = key;
        this.nextLocalID = 0;
    }
    enableReferenceMode() {
        this.referenceMode = true;
    }
    get storageKey() {
        return this._storageKey;
    }
    get type() {
        return this._type;
    }
    reportExceptionInHost(exception) {
        // This class lives in the host, so it's safe to just rethrow the exception here.
        throw exception;
    }
    // TODO: add 'once' which returns a promise.
    on(kindStr, callback, target) {
        assert(target !== undefined, 'must provide a target to register a storage event handler');
        const kind = EventKind[kindStr];
        const listeners = this.listeners.get(kind) || new Map();
        listeners.set(callback, { target });
        this.listeners.set(kind, listeners);
    }
    off(kindStr, callback) {
        const kind = EventKind[kindStr];
        const listeners = this.listeners.get(kind);
        if (listeners) {
            listeners.delete(callback);
        }
    }
    // TODO: rename to _fireAsync so it's clear that callers are not re-entrant.
    /**
     * Propagate updates to change listeners.
     *
     * @param kindStr the type of event, only 'change' is supported.
     * @param details details about the change
     */
    async _fire(kindStr, details) {
        const kind = EventKind[kindStr];
        const listenerMap = this.listeners.get(kind);
        if (!listenerMap || listenerMap.size === 0) {
            return;
        }
        const callbacks = [];
        for (const [callback] of listenerMap.entries()) {
            callbacks.push(callback);
        }
        // Yield so that event firing is not re-entrant with mutation.
        await 0;
        for (const callback of callbacks) {
            callback(details);
        }
    }
    _compareTo(other) {
        let cmp;
        cmp = compareStrings(this.name, other.name);
        if (cmp !== 0)
            return cmp;
        cmp = compareNumbers(this.version, other.version);
        if (cmp !== 0)
            return cmp;
        cmp = compareStrings(this.source, other.source);
        if (cmp !== 0)
            return cmp;
        cmp = compareStrings(this.id, other.id);
        if (cmp !== 0)
            return cmp;
        return 0;
    }
    toString(handleTags) {
        const results = [];
        const handleStr = [];
        handleStr.push(`store`);
        if (this.name) {
            handleStr.push(`${this.name}`);
        }
        handleStr.push(`of ${this.type.toString()}`);
        if (this.id) {
            handleStr.push(`'${this.id}'`);
        }
        if (handleTags && handleTags.length) {
            handleStr.push(`${handleTags.join(' ')}`);
        }
        if (this.source) {
            handleStr.push(`in '${this.source}'`);
        }
        results.push(handleStr.join(' '));
        if (this.claims && this.claims.length > 0) {
            results.push(`  claim is ${this.claims.map(claim => claim.tag).join(' and is ')}`);
        }
        if (this.description) {
            results.push(`  description \`${this.description}\``);
        }
        return results.join('\n');
    }
    get apiChannelMappingId() {
        return this.id;
    }
    // TODO: make abstract?
    dispose() { }
    /**
     * Called by Particle Execution Host to synchronize it's proxy.
     */
    async modelForSynchronization() {
        return this.toLiteral();
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TODO(shans): Make sure that after refactor Storage objects have a lifecycle and can be directly used
// deflated rather than requiring this stub.
class StorageStub {
    constructor(type, id, name, storageKey, storageProviderFactory, originalId, 
    /** Trust tags claimed by this data store. */
    claims, description, version, source, referenceMode = false, model) {
        this.type = type;
        this.id = id;
        this.name = name;
        this.storageKey = storageKey;
        this.storageProviderFactory = storageProviderFactory;
        this.originalId = originalId;
        this.claims = claims;
        this.description = description;
        this.version = version;
        this.source = source;
        this.referenceMode = referenceMode;
        this.model = model;
    }
    async inflate(storageProviderFactory) {
        const factory = storageProviderFactory || this.storageProviderFactory;
        const store = this.isBackedByManifest()
            ? await factory.construct(this.id, this.type, this.storageKey)
            : await factory.connect(this.id, this.type, this.storageKey);
        assert(store != null, 'inflating missing storageKey ' + this.storageKey);
        if (this.isBackedByManifest()) {
            // Constructed store: set the reference mode according to the stub.
            store.referenceMode = this.referenceMode;
        }
        else {
            // Connected store: sync the stub's reference mode with the store.
            this.referenceMode = store.referenceMode;
        }
        store.originalId = this.originalId;
        store.name = this.name;
        store.source = this.source;
        store.description = this.description;
        if (this.isBackedByManifest()) {
            await store.fromLiteral({ version: this.version, model: this.model });
        }
        return store;
    }
    toLiteral() {
        return undefined; // Fake to match StorageProviderBase;
    }
    isBackedByManifest() {
        return (this.version !== undefined && !!this.model);
    }
    toString(handleTags) {
        const results = [];
        const handleStr = [];
        handleStr.push(`store`);
        if (this.name) {
            handleStr.push(`${this.name}`);
        }
        handleStr.push(`of ${this.type.toString()}`);
        if (this.id) {
            handleStr.push(`'${this.id}'`);
        }
        if (this.originalId) {
            handleStr.push(`!!${this.originalId}`);
        }
        if (this.version !== undefined) {
            handleStr.push(`@${this.version}`);
        }
        if (handleTags && handleTags.length) {
            handleStr.push(`${handleTags.join(' ')}`);
        }
        if (this.source) {
            handleStr.push(`in '${this.source}'`);
        }
        else if (this.storageKey) {
            handleStr.push(`at '${this.storageKey}'`);
        }
        // TODO(shans): there's a 'this.source' in StorageProviderBase which is sometimes
        // serialized here too - could it ever be part of StorageStub?
        results.push(handleStr.join(' '));
        if (this.claims.length > 0) {
            results.push(`  claim is ${this.claims.map(claim => claim.tag).join(' and is ')}`);
        }
        if (this.description) {
            results.push(`  description \`${this.description}\``);
        }
        return results.join('\n');
    }
    _compareTo(other) {
        let cmp;
        cmp = compareStrings(this.name, other.name);
        if (cmp !== 0)
            return cmp;
        cmp = compareStrings(this.id, other.id);
        if (cmp !== 0)
            return cmp;
        return 0;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Description {
    constructor(storeDescById = {}, 
    // TODO(mmandlis): replace Particle[] with serializable json objects.
    arcRecipes, particleDescriptions = []) {
        this.storeDescById = storeDescById;
        this.arcRecipes = arcRecipes;
        this.particleDescriptions = particleDescriptions;
    }
    static async XcreateForPlan(plan) {
        const particleDescriptions = await Description.initDescriptionHandles(plan.particles);
        return new Description({}, [{ patterns: plan.patterns, particles: plan.particles }], particleDescriptions);
    }
    static async createForPlan(arc, plan) {
        const allParticles = plan.particles;
        const particleDescriptions = await Description.initDescriptionHandles(allParticles, arc);
        const storeDescById = {};
        for (const { id } of plan.handles) {
            const store = arc.findStoreById(id);
            if (store && store instanceof StorageProviderBase) {
                storeDescById[id] = arc.getStoreDescription(store);
            }
        }
        // ... and pass to the private constructor.
        return new Description(storeDescById, [{ patterns: plan.patterns, particles: plan.particles }], particleDescriptions);
    }
    /**
     * Create a new Description object for the given Arc with an
     * optional Relevance object.
     */
    static async create(arc, relevance) {
        // Execute async related code here
        const allParticles = [].concat(...arc.allDescendingArcs.map(arc => arc.activeRecipe.particles));
        const particleDescriptions = await Description.initDescriptionHandles(allParticles, arc, relevance);
        const storeDescById = {};
        for (const { id } of arc.activeRecipe.handles) {
            const store = arc.findStoreById(id);
            if (store && store instanceof StorageProviderBase) {
                storeDescById[id] = arc.getStoreDescription(store);
            }
        }
        // ... and pass to the private constructor.
        return new Description(storeDescById, arc.recipeDeltas, particleDescriptions);
    }
    getArcDescription(formatterClass = DescriptionFormatter) {
        const patterns = [].concat(...this.arcRecipes.map(recipe => recipe.patterns));
        const particles = [].concat(...this.arcRecipes.map(recipe => recipe.particles));
        const desc = new (formatterClass)(this.particleDescriptions, this.storeDescById).getDescription({
            patterns,
            particles
        });
        if (desc) {
            return desc;
        }
        return undefined;
    }
    getRecipeSuggestion(formatterClass = DescriptionFormatter) {
        const formatter = new (formatterClass)(this.particleDescriptions, this.storeDescById);
        return formatter.getDescription(this.arcRecipes[this.arcRecipes.length - 1]);
    }
    getHandleDescription(recipeHandle) {
        assert(recipeHandle.connections.length > 0, 'handle has no connections?');
        const formatter = new DescriptionFormatter(this.particleDescriptions, this.storeDescById);
        formatter.excludeValues = true;
        return formatter.getHandleDescription(recipeHandle);
    }
    static getAllTokens(pattern) {
        const allTokens = [];
        const tokens = pattern.match(DescriptionFormatter.tokensRegex);
        for (let i = 0; i < tokens.length; ++i) {
            allTokens[i] = tokens[i].match(DescriptionFormatter.tokensInnerRegex)[1].split('.');
        }
        return allTokens;
    }
    static async initDescriptionHandles(allParticles, arc, relevance) {
        return await Promise.all(allParticles.map(particle => Description._createParticleDescription(particle, arc, relevance)));
    }
    static async _createParticleDescription(particle, arc, relevance) {
        let pDesc = {
            _particle: particle,
            _connections: {}
        };
        if (relevance) {
            pDesc._rank = relevance.calcParticleRelevance(particle);
        }
        const descByName = await Description._getPatternByNameFromDescriptionHandle(particle, arc);
        pDesc = { ...pDesc, ...descByName };
        pDesc.pattern = pDesc.pattern || particle.spec.pattern;
        for (const handleConn of Object.values(particle.connections)) {
            const specConn = particle.spec.handleConnectionMap.get(handleConn.name);
            const pattern = descByName[handleConn.name] || specConn.pattern;
            const store = arc ? arc.findStoreById(handleConn.handle.id) : null;
            pDesc._connections[handleConn.name] = {
                pattern,
                _handleConn: handleConn,
                value: await Description._prepareStoreValue(store)
            };
        }
        return pDesc;
    }
    static async _getPatternByNameFromDescriptionHandle(particle, arc) {
        const descriptionConn = particle.connections['descriptions'];
        if (descriptionConn && descriptionConn.handle && descriptionConn.handle.id) {
            const descHandle = arc.findStoreById(descriptionConn.handle.id);
            if (descHandle) {
                // TODO(shans): fix this mess when there's a unified Collection class or interface.
                const descByName = {};
                for (const d of await descHandle.toList()) {
                    descByName[d.rawData.key] = d.rawData.value;
                }
                return descByName;
            }
        }
        return {};
    }
    static async _prepareStoreValue(store) {
        if (!store || (store instanceof StorageStub)) {
            return undefined;
        }
        if (store.type instanceof CollectionType) {
            const collectionStore = store;
            const values = await collectionStore.toList();
            if (values && values.length > 0) {
                return { collectionValues: values };
            }
        }
        else if (store.type instanceof BigCollectionType) {
            const bigCollectionStore = store;
            const cursorId = await bigCollectionStore.stream(1);
            const { value, done } = await bigCollectionStore.cursorNext(cursorId);
            bigCollectionStore.cursorClose(cursorId);
            if (!done && value[0].rawData.name) {
                return { bigCollectionValues: value[0] };
            }
        }
        else if (store.type instanceof EntityType) {
            const singletonStore = store;
            const value = await singletonStore.get();
            if (value && value['rawData']) {
                return { entityValue: value['rawData'], valueDescription: store.type.entitySchema.description.value };
            }
        }
        else if (store.type instanceof InterfaceType) {
            const singletonStore = store;
            const interfaceValue = await singletonStore.get();
            if (interfaceValue) {
                return { interfaceValue };
            }
        }
        return undefined;
    }
}

// tslint:disable:no-any
// tslint:disable: only-arrow-functions
// tslint:disable: max-line-length
// tslint:disable: trailing-comma
// tslint:disable: interface-name
// tslint:disable: switch-default
// tslint:disable: object-literal-shorthand
class SyntaxError extends Error {
    constructor(message, expected, found, location) {
        super();
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, SyntaxError);
        }
    }
    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
        }
        function classEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
        }
        function describeExpectation(expectation) {
            switch (expectation.type) {
                case "literal":
                    return "\"" + literalEscape(expectation.text) + "\"";
                case "class":
                    const escapedParts = expectation.parts.map((part) => {
                        return Array.isArray(part)
                            ? classEscape(part[0]) + "-" + classEscape(part[1])
                            : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            const descriptions = expected1.map(describeExpectation);
            let i;
            let j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }
            switch (descriptions.length) {
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
}
function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    const peg$FAILED = {};
    const peg$startRuleFunctions = { Manifest: peg$parseManifest };
    let peg$startRuleFunction = peg$parseManifest;
    const peg$c0 = function (items) {
        const result = items.map(item => {
            const manifestItem = item[2];
            const annotations = item[0];
            manifestItem.triggers = annotations.triggerSet;
            manifestItem.annotation = annotations.simpleAnnotation;
            return manifestItem;
        });
        checkNormal(result);
        return result;
    };
    const peg$c1 = function (triggerSet, simpleAnnotation) {
        return {
            triggerSet: triggerSet.map(trigger => trigger[1]),
            simpleAnnotation: optional(simpleAnnotation, s => s[1], null),
        };
    };
    const peg$c2 = peg$otherExpectation("a trigger for a recipe");
    const peg$c3 = "@trigger";
    const peg$c4 = peg$literalExpectation("@trigger", false);
    const peg$c5 = function (pairs) {
        return pairs.map(pair => {
            return [pair[2], pair[4]];
        });
    };
    const peg$c6 = peg$otherExpectation("an annotation (e.g. @foo)");
    const peg$c7 = "@";
    const peg$c8 = peg$literalExpectation("@", false);
    const peg$c9 = function (annotation) { return annotation; };
    const peg$c10 = "resource";
    const peg$c11 = peg$literalExpectation("resource", false);
    const peg$c12 = function (name, body) {
        return {
            kind: 'resource',
            name,
            data: body,
            location: location()
        };
    };
    const peg$c13 = "start";
    const peg$c14 = peg$literalExpectation("start", false);
    const peg$c15 = function () { startIndent = indent; };
    const peg$c16 = function (lines) {
        return lines.map(line => line[0].substring(startIndent.length) + line[1]).join('');
    };
    const peg$c17 = /^[^\n]/;
    const peg$c18 = peg$classExpectation(["\n"], true, false);
    const peg$c19 = function () { return text(); };
    const peg$c20 = "store";
    const peg$c21 = peg$literalExpectation("store", false);
    const peg$c22 = "of";
    const peg$c23 = peg$literalExpectation("of", false);
    const peg$c24 = "!!";
    const peg$c25 = peg$literalExpectation("!!", false);
    const peg$c26 = function (name, type, id, originalId, version, tags, source, items) {
        items = optional(items, extractIndented, []);
        let description = null;
        let claim = null;
        for (const item of items) {
            if (item[0] === 'description') {
                if (description) {
                    error('You cannot provide more than one description.');
                }
                description = item[2];
            }
            else if (item['kind'] === 'manifest-storage-claim') {
                if (claim) {
                    error('You cannot provide more than one claim.');
                }
                claim = item;
            }
            else {
                error(`Unknown ManifestStorageItem: ${item}`);
            }
        }
        return {
            kind: 'store',
            location: location(),
            name,
            type,
            id: optional(id, id => id[1], null),
            originalId: optional(originalId, originalId => originalId[1], null),
            version: optional(version, version => version[1], null),
            tags: optional(tags, tags => tags[1], null),
            source: source.source,
            origin: source.origin,
            description,
            claim,
        };
    };
    const peg$c27 = "in";
    const peg$c28 = peg$literalExpectation("in", false);
    const peg$c29 = function (source) { return { origin: 'file', source }; };
    const peg$c30 = function (source) { return { origin: 'resource', source }; };
    const peg$c31 = "at";
    const peg$c32 = peg$literalExpectation("at", false);
    const peg$c33 = function (source) { return { origin: 'storage', source }; };
    const peg$c34 = "description";
    const peg$c35 = peg$literalExpectation("description", false);
    const peg$c36 = "claim";
    const peg$c37 = peg$literalExpectation("claim", false);
    const peg$c38 = "is";
    const peg$c39 = peg$literalExpectation("is", false);
    const peg$c40 = "and";
    const peg$c41 = peg$literalExpectation("and", false);
    const peg$c42 = function (tag, rest) {
        return {
            kind: 'manifest-storage-claim',
            location: location(),
            tags: [tag, ...rest.map(item => item[5])],
        };
    };
    const peg$c43 = "import";
    const peg$c44 = peg$literalExpectation("import", false);
    const peg$c45 = function (path) {
        return {
            kind: 'import',
            location: location(),
            path,
        };
    };
    const peg$c46 = peg$otherExpectation("an interface");
    const peg$c47 = "interface";
    const peg$c48 = peg$literalExpectation("interface", false);
    const peg$c49 = "<";
    const peg$c50 = peg$literalExpectation("<", false);
    const peg$c51 = ">";
    const peg$c52 = peg$literalExpectation(">", false);
    const peg$c53 = function (name, typeVars, items) {
        return {
            kind: 'interface',
            location: location(),
            name,
            args: optional(items, extractIndented, []).filter(item => item.kind === 'interface-argument'),
            slots: optional(items, extractIndented, []).filter(item => item.kind === 'interface-slot'),
        };
    };
    const peg$c54 = "*";
    const peg$c55 = peg$literalExpectation("*", false);
    const peg$c56 = function (direction, type, name) {
        direction = optional(direction, dir => dir[0], 'any');
        if (direction === 'host') {
            error(`Interface cannot have arguments with a 'host' direction.`);
        }
        return {
            kind: 'interface-argument',
            location: location(),
            direction,
            type: optional(type, ty => ty[0], null),
            name,
        };
    };
    const peg$c57 = "must";
    const peg$c58 = peg$literalExpectation("must", false);
    const peg$c59 = "consume";
    const peg$c60 = peg$literalExpectation("consume", false);
    const peg$c61 = "provide";
    const peg$c62 = peg$literalExpectation("provide", false);
    const peg$c63 = "set of";
    const peg$c64 = peg$literalExpectation("set of", false);
    const peg$c65 = function (isRequired, direction, isSet, name) {
        return {
            kind: 'interface-slot',
            location: location(),
            name: optional(name, isRequired => name[1], null),
            isRequired: optional(isRequired, isRequired => isRequired[0] === 'must', false),
            direction,
            isSet: !!isSet,
        };
    };
    const peg$c66 = "meta";
    const peg$c67 = peg$literalExpectation("meta", false);
    const peg$c68 = function (items) {
        items = items ? extractIndented(items) : [];
        return { kind: 'meta', items: items, location: location() };
    };
    const peg$c69 = "name";
    const peg$c70 = peg$literalExpectation("name", false);
    const peg$c71 = ":";
    const peg$c72 = peg$literalExpectation(":", false);
    const peg$c73 = function (name) {
        return { key: 'name', value: name, location: location(), kind: 'name' };
    };
    const peg$c74 = "storageKey";
    const peg$c75 = peg$literalExpectation("storageKey", false);
    const peg$c76 = function (key) {
        return { key: 'storageKey', value: key, location: location(), kind: 'storageKey' };
    };
    const peg$c77 = "particle";
    const peg$c78 = peg$literalExpectation("particle", false);
    const peg$c79 = function (name, verbs, implFile, items) {
        let args = [];
        const modality = [];
        const slotConnections = [];
        const trustClaims = [];
        const trustChecks = [];
        let description = null;
        let hasParticleHandleConnection = false;
        verbs = optional(verbs, parsedOutput => parsedOutput[1], []);
        items = optional(items, extractIndented, []);
        items.forEach(item => {
            if (item.kind === 'particle-interface') {
                if (/[A-Z]/.test(item.verb[0]) && item.verb !== name) {
                    error(`Verb ${item.verb} must start with a lower case character or be same as particle name.`);
                }
                verbs.push(item.verb);
                args = item.args; // TODO(jopra): This should merge, not overwrite;
                hasParticleHandleConnection = true;
            }
            else if (item.kind === 'particle-argument') {
                args.push(item);
            }
            else if (item.kind === 'particle-slot') {
                slotConnections.push(item);
            }
            else if (item.kind === 'description') {
                description = {
                    kind: 'description',
                    location: location() // TODO: FIXME Get the locations of the item descriptions.
                };
                item.description.forEach(d => description[d.name] = d.pattern || d.patterns[0]);
            }
            else if (item.kind === 'particle-trust-claim') {
                trustClaims.push(item);
            }
            else if (item.kind === 'particle-trust-check') {
                trustChecks.push(item);
            }
            else if (item.modality) {
                modality.push(item.modality);
            }
            else {
                error(`Particle ${name} contains an unknown element: ${item.name} / ${item.kind}`);
            }
        });
        if (modality.length === 0) {
            // Add default modality
            modality.push('dom');
        }
        return {
            kind: 'particle',
            location: location(),
            name,
            implFile: optional(implFile, implFile => implFile[3], null),
            verbs,
            args,
            modality,
            slotConnections,
            description,
            hasParticleHandleConnection,
            trustClaims,
            trustChecks,
        };
    };
    const peg$c80 = peg$otherExpectation("a particle item");
    const peg$c81 = function (handle, expression) {
        return {
            kind: 'particle-trust-claim',
            location: location(),
            handle,
            expression,
        };
    };
    const peg$c82 = function (first, rest) {
        return [first, ...rest.map(item => item[3])];
    };
    const peg$c83 = "not";
    const peg$c84 = peg$literalExpectation("not", false);
    const peg$c85 = function (not, tag) {
        return {
            kind: 'particle-trust-claim-is-tag',
            claimType: 'is-tag',
            location: location(),
            isNot: not != null,
            tag,
        };
    };
    const peg$c86 = "derives from";
    const peg$c87 = peg$literalExpectation("derives from", false);
    const peg$c88 = function (handle) {
        return {
            kind: 'particle-trust-claim-derives-from',
            claimType: 'derives-from',
            location: location(),
            parentHandle: handle,
        };
    };
    const peg$c89 = "check";
    const peg$c90 = peg$literalExpectation("check", false);
    const peg$c91 = function (target, expression) {
        return {
            kind: 'particle-trust-check',
            location: location(),
            target,
            expression,
        };
    };
    const peg$c92 = "data";
    const peg$c93 = peg$literalExpectation("data", false);
    const peg$c94 = function (name, isSlot) {
        return {
            kind: 'particle-check-target',
            location: location(),
            targetType: isSlot ? 'slot' : 'handle',
            name,
        };
    };
    const peg$c95 = "or";
    const peg$c96 = peg$literalExpectation("or", false);
    const peg$c97 = function (left, rest) {
        if (rest.length === 0) {
            return left;
        }
        const operators = new Set(rest.map(item => item[1]));
        if (operators.size > 1) {
            expected(`You cannot combine 'and' and 'or' operations in a single check expression. You must nest them inside parentheses.`);
        }
        const operator = rest[0][1];
        return {
            kind: 'particle-trust-check-boolean-expression',
            location: location(),
            operator,
            children: [left, ...rest.map(item => item[3])],
        };
    };
    const peg$c98 = function (condition) { return condition; };
    const peg$c99 = "(";
    const peg$c100 = peg$literalExpectation("(", false);
    const peg$c101 = ")";
    const peg$c102 = peg$literalExpectation(")", false);
    const peg$c103 = function (isNot, tag) {
        return {
            kind: 'particle-trust-check-has-tag',
            checkType: 'has-tag',
            location: location(),
            isNot: !!isNot,
            tag,
        };
    };
    const peg$c104 = "from";
    const peg$c105 = peg$literalExpectation("from", false);
    const peg$c106 = "handle";
    const peg$c107 = peg$literalExpectation("handle", false);
    const peg$c108 = function (isNot, parentHandle) {
        return {
            kind: 'particle-trust-check-is-from-handle',
            checkType: 'is-from-handle',
            location: location(),
            isNot: !!isNot,
            parentHandle,
        };
    };
    const peg$c109 = "output";
    const peg$c110 = peg$literalExpectation("output", false);
    const peg$c111 = function (isNot, output) {
        return {
            kind: 'particle-trust-check-is-from-output',
            checkType: 'is-from-output',
            location: location(),
            isNot: !!isNot,
            output,
        };
    };
    const peg$c112 = function (isNot, storeRef) {
        return {
            kind: 'particle-trust-check-is-from-store',
            checkType: 'is-from-store',
            location: location(),
            isNot: !!isNot,
            storeRef,
        };
    };
    const peg$c113 = function (name) { return { kind: 'store-reference', location: location(), type: 'name', store: name }; };
    const peg$c114 = function (id) { return { kind: 'store-reference', location: location(), type: 'id', store: id }; };
    const peg$c115 = function (arg, dependentConnections) {
        arg.dependentConnections = optional(dependentConnections, extractIndented, []);
        return arg;
    };
    const peg$c116 = "?";
    const peg$c117 = peg$literalExpectation("?", false);
    const peg$c118 = function (direction, isOptional, type, nametag) {
        return {
            kind: 'particle-argument',
            location: location(),
            direction,
            type: type,
            isOptional: !!isOptional,
            dependentConnections: [],
            name: nametag.name,
            tags: nametag.tags,
        };
    };
    const peg$c119 = peg$otherExpectation("a direction (e.g. inout, in, out, host, `consume, `provide, any)");
    const peg$c120 = "inout";
    const peg$c121 = peg$literalExpectation("inout", false);
    const peg$c122 = "out";
    const peg$c123 = peg$literalExpectation("out", false);
    const peg$c124 = "host";
    const peg$c125 = peg$literalExpectation("host", false);
    const peg$c126 = "`consume";
    const peg$c127 = peg$literalExpectation("`consume", false);
    const peg$c128 = "`provide";
    const peg$c129 = peg$literalExpectation("`provide", false);
    const peg$c130 = "any";
    const peg$c131 = peg$literalExpectation("any", false);
    const peg$c132 = function () {
        const dir = text();
        if (dir === null) {
            expected('a direction');
        }
        return dir;
    };
    const peg$c133 = peg$otherExpectation("a direction arrow (e.g. <-, ->, <->, =, consume, provide)");
    const peg$c134 = "<->";
    const peg$c135 = peg$literalExpectation("<->", false);
    const peg$c136 = "<-";
    const peg$c137 = peg$literalExpectation("<-", false);
    const peg$c138 = "->";
    const peg$c139 = peg$literalExpectation("->", false);
    const peg$c140 = "=";
    const peg$c141 = peg$literalExpectation("=", false);
    const peg$c142 = function () {
        const dir = text();
        if (dir === null) {
            expected('a direction arrow');
        }
        return dir;
    };
    const peg$c143 = "[";
    const peg$c144 = peg$literalExpectation("[", false);
    const peg$c145 = "]";
    const peg$c146 = peg$literalExpectation("]", false);
    const peg$c147 = function (type) {
        return {
            kind: 'collection-type',
            location: location(),
            type,
        };
    };
    const peg$c148 = "BigCollection<";
    const peg$c149 = peg$literalExpectation("BigCollection<", false);
    const peg$c150 = function (type) {
        return {
            kind: 'big-collection-type',
            location: location(),
            type,
        };
    };
    const peg$c151 = "Reference<";
    const peg$c152 = peg$literalExpectation("Reference<", false);
    const peg$c153 = function (type) {
        return {
            kind: 'reference-type',
            location: location(),
            type,
        };
    };
    const peg$c154 = peg$otherExpectation("a type variable (e.g. ~foo)");
    const peg$c155 = "~";
    const peg$c156 = peg$literalExpectation("~", false);
    const peg$c157 = "with";
    const peg$c158 = peg$literalExpectation("with", false);
    const peg$c159 = function (name, constraint) {
        return {
            kind: 'variable-type',
            location: location(),
            name,
            constraint: optional(constraint, constraint => constraint[3], null),
        };
    };
    const peg$c160 = "Slot";
    const peg$c161 = peg$literalExpectation("Slot", false);
    const peg$c162 = /^[^a-z0-9_]/i;
    const peg$c163 = peg$classExpectation([["a", "z"], ["0", "9"], "_"], true, true);
    const peg$c164 = "{";
    const peg$c165 = peg$literalExpectation("{", false);
    const peg$c166 = ",";
    const peg$c167 = peg$literalExpectation(",", false);
    const peg$c168 = "}";
    const peg$c169 = peg$literalExpectation("}", false);
    const peg$c170 = function (fields) {
        fields = optional(fields, fields => {
            const data = fields[2];
            return [data[0]].concat(data[1].map(tail => tail[2]));
        }, []);
        return {
            kind: 'slot-type',
            location: location(),
            fields
        };
    };
    const peg$c171 = function (name, value) {
        return {
            kind: 'slot-field',
            location: location(),
            name,
            value
        };
    };
    const peg$c172 = function (name) {
        return {
            kind: 'type-name',
            location: location(),
            name,
        };
    };
    const peg$c173 = function (head, tail) {
        return [head, ...tail.map(a => a[2])];
    };
    const peg$c174 = "modality";
    const peg$c175 = peg$literalExpectation("modality", false);
    const peg$c176 = function (modality) {
        return {
            kind: 'particle-modality',
            location: location(),
            modality,
        };
    };
    const peg$c177 = function (isRequired, isSet, name, tags, items) {
        let formFactor = null;
        const provideSlotConnections = [];
        items = optional(items, extractIndented, []);
        items.forEach(item => {
            if (item.kind === 'provided-slot') {
                provideSlotConnections.push(item);
            }
            else if (item.kind === 'form-factor') {
                if (formFactor) {
                    error('duplicate form factor for a slot');
                }
                formFactor = item.formFactor;
            }
            else {
                error('Unsupported particle slot item ', item);
            }
        });
        return {
            kind: 'particle-slot',
            location: location(),
            name,
            tags: optional(tags, tags => tags[1], []),
            isRequired: optional(isRequired, isRequired => isRequired[0] === 'must', false),
            isSet: !!isSet,
            formFactor,
            provideSlotConnections
        };
    };
    const peg$c178 = "formFactor";
    const peg$c179 = peg$literalExpectation("formFactor", false);
    const peg$c180 = "fullscreen";
    const peg$c181 = peg$literalExpectation("fullscreen", false);
    const peg$c182 = "big";
    const peg$c183 = peg$literalExpectation("big", false);
    const peg$c184 = "medium";
    const peg$c185 = peg$literalExpectation("medium", false);
    const peg$c186 = "small";
    const peg$c187 = peg$literalExpectation("small", false);
    const peg$c188 = function (formFactor) {
        return {
            kind: 'form-factor',
            location: location(),
            formFactor
        };
    };
    const peg$c189 = function (isRequired, isSet, name, tags, items) {
        let formFactor = null;
        const handles = [];
        items = items ? extractIndented(items) : [];
        items.forEach(item => {
            if (item.kind === 'form-factor') {
                if (formFactor) {
                    error('duplicate form factor for a slot');
                }
                formFactor = item.formFactor;
            }
            else {
                handles.push(item.handle);
            }
        });
        return {
            kind: 'provided-slot',
            location: location(),
            name,
            tags: optional(tags, tags => tags[1], []),
            isRequired: optional(isRequired, isRequired => isRequired[0] === 'must', false),
            isSet: !!isSet,
            formFactor,
            handles
        };
    };
    const peg$c190 = function (handle) {
        return {
            kind: 'particle-provided-slot-handle',
            location: location(),
            handle,
        };
    };
    const peg$c191 = function (pattern, handleDescriptions) {
        handleDescriptions = optional(handleDescriptions, extractIndented, []);
        const patterns = [];
        if (pattern) {
            patterns.push(pattern);
        }
        handleDescriptions.filter(desc => desc.name === 'pattern').forEach(p => patterns.push(p));
        handleDescriptions = handleDescriptions.filter(desc => desc.name !== 'pattern');
        return {
            kind: 'description',
            location: location(),
            description: [
                {
                    // TODO: this should be stored in a different field.
                    // TODO: FIXME
                    kind: 'default-description?',
                    location: location(),
                    name: 'pattern',
                    patterns: patterns,
                },
                ...handleDescriptions,
            ],
        };
    };
    const peg$c192 = function (name, pattern) {
        return {
            kind: 'handle-description',
            location: location(),
            name,
            pattern,
        };
    };
    const peg$c193 = "recipe";
    const peg$c194 = peg$literalExpectation("recipe", false);
    const peg$c195 = function (name, verbs, items) {
        verbs = optional(verbs, parsedOutput => parsedOutput[1], []);
        return {
            kind: 'recipe',
            location: location(),
            name: optional(name, name => name[1], null),
            verbs,
            items: optional(items, extractIndented, []),
        };
    };
    const peg$c196 = "as";
    const peg$c197 = peg$literalExpectation("as", false);
    const peg$c198 = /^[a-zA-Z0-9]/;
    const peg$c199 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
    const peg$c200 = function () { expected(`lower identifier`); };
    const peg$c201 = function (name) {
        return name;
    };
    const peg$c202 = function (ref, name, connections) {
        const handleConnections = [];
        const slotConnections = [];
        if (connections) {
            connections = extractIndented(connections);
            for (const conn of connections) {
                if (conn.kind === 'handle-connection') {
                    handleConnections.push(conn);
                }
                else {
                    slotConnections.push(conn);
                }
            }
        }
        return {
            kind: 'particle',
            location: location(),
            name: optional(name, name => name[1], null),
            ref,
            connections: handleConnections,
            slotConnections: slotConnections,
        };
    };
    const peg$c203 = function (param, dir, target, dependentConnections) {
        return {
            kind: 'handle-connection',
            location: location(),
            param,
            dir,
            target: optional(target, target => target[1], null),
            dependentConnections: optional(dependentConnections, extractIndented, []),
        };
    };
    const peg$c204 = function (param, tags) {
        param = optional(param, param => param, null);
        let name = null;
        let particle = null;
        if (param) {
            if (param[0].toUpperCase() === param[0]) {
                particle = param;
            }
            else {
                name = param;
            }
        }
        return {
            kind: 'handle-connection-components',
            location: location(),
            name,
            particle,
            tags: optional(tags, tags => tags, []),
        };
    };
    const peg$c205 = function (direction, ref, name, dependentSlotConnections) {
        return {
            kind: 'slot-connection',
            location: location(),
            direction,
            param: ref.param,
            tags: ref.tags,
            name: optional(name, name => name[1], null),
            dependentSlotConnections: optional(dependentSlotConnections, extractIndented, []),
        };
    };
    const peg$c206 = function (param, tags) {
        return {
            kind: 'slot-connection-ref',
            location: location(),
            param,
            tags: tags || [],
        };
    };
    const peg$c207 = function (from, direction, to) {
        return {
            kind: 'connection',
            location: location(),
            direction,
            from,
            to,
        };
    };
    const peg$c208 = "search";
    const peg$c209 = peg$literalExpectation("search", false);
    const peg$c210 = "tokens";
    const peg$c211 = peg$literalExpectation("tokens", false);
    const peg$c212 = function (phrase, tokens) {
        return {
            kind: 'search',
            location: location(),
            phrase,
            tokens: optional(tokens, tokens => tokens[1][2].map(t => t[1]), null)
        };
    };
    const peg$c213 = function (verbs, components) {
        const { param, tags } = optional(components, components => components, { param: null, tags: [] });
        return {
            kind: 'connection-target',
            location: location(),
            targetType: 'verb',
            verbs,
            param,
            tags
        };
    };
    const peg$c214 = function (tags) {
        return {
            kind: 'connection-target',
            location: location(),
            targetType: 'tag',
            tags
        };
    };
    const peg$c215 = function (name, components) {
        const { param, tags } = optional(components, components => components, { param: null, tags: [] });
        return {
            kind: 'connection-target',
            targetType: 'localName',
            location: location(),
            name,
            param,
            tags
        };
    };
    const peg$c216 = function (particle, components) {
        const { param, tags } = optional(components, components => components, { param: null, tags: [] });
        return {
            kind: 'connection-target',
            targetType: 'particle',
            location: location(),
            particle,
            param,
            tags
        };
    };
    const peg$c217 = ".";
    const peg$c218 = peg$literalExpectation(".", false);
    const peg$c219 = function (param, tags) {
        return {
            param: optional(param, param => param, null),
            tags: optional(tags, tags => tags[1], []),
        };
    };
    const peg$c220 = "use";
    const peg$c221 = peg$literalExpectation("use", false);
    const peg$c222 = "map";
    const peg$c223 = peg$literalExpectation("map", false);
    const peg$c224 = "create";
    const peg$c225 = peg$literalExpectation("create", false);
    const peg$c226 = "copy";
    const peg$c227 = peg$literalExpectation("copy", false);
    const peg$c228 = "`slot";
    const peg$c229 = peg$literalExpectation("`slot", false);
    const peg$c230 = function (type, ref, name) {
        return {
            kind: 'handle',
            location: location(),
            name: optional(name, name => name[1], null),
            ref: optional(ref, ref => ref[1], emptyRef()),
            fate: type
        };
    };
    const peg$c231 = "require";
    const peg$c232 = peg$literalExpectation("require", false);
    const peg$c233 = function (items) {
        return {
            kind: 'require',
            location: location(),
            items: extractIndented(items),
        };
    };
    const peg$c234 = function (name, ref) {
        return {
            kind: 'requireHandle',
            location: location(),
            name: optional(name, name => name[1], null),
            ref: optional(ref, ref => ref[1], emptyRef()),
        };
    };
    const peg$c235 = "#";
    const peg$c236 = peg$literalExpectation("#", false);
    const peg$c237 = function (tag) { return tag; };
    const peg$c238 = function (head, tail) { return [head, ...(tail && tail[1] || [])]; };
    const peg$c239 = peg$otherExpectation("a verb (e.g. &Verb)");
    const peg$c240 = "&";
    const peg$c241 = peg$literalExpectation("&", false);
    const peg$c242 = function (verb) { return verb; };
    const peg$c243 = function (tags) { return tags; };
    const peg$c244 = function (name, tags) {
        return {
            location: location(),
            name: name,
            tags: tags = optional(tags, list => list[1], [])
        };
    };
    const peg$c245 = function (name) {
        return {
            location: location(),
            name: name,
            tags: []
        };
    };
    const peg$c246 = function (tags) {
        return {
            location: location(),
            name: tags[0],
            tags: tags
        };
    };
    const peg$c247 = function (name) {
        return {
            kind: 'particle-ref',
            location: location(),
            name,
            verbs: [],
            tags: []
        };
    };
    const peg$c248 = function (verb) {
        return {
            kind: 'particle-ref',
            location: location(),
            verbs: [verb],
            tags: []
        };
    };
    const peg$c249 = function (id, tags) {
        return {
            kind: 'handle-ref',
            location: location(),
            id,
            tags: tags || [],
        };
    };
    const peg$c250 = function (name, tags) {
        return {
            kind: 'handle-ref',
            location: location(),
            name,
            tags: tags || [],
        };
    };
    const peg$c251 = function (tags) {
        return {
            kind: 'handle-ref',
            location: location(),
            tags,
        };
    };
    const peg$c252 = "slot";
    const peg$c253 = peg$literalExpectation("slot", false);
    const peg$c254 = function (ref, name) {
        return {
            kind: 'slot',
            location: location(),
            ref: optional(ref, ref => ref[1], emptyRef()),
            name: optional(name, name => name[1], '')
        };
    };
    const peg$c255 = function (names, fields) {
        return {
            kind: 'schema-inline',
            location: location(),
            names: optional(names, names => names.map(name => name[0]).filter(name => name !== '*'), []),
            fields: optional(fields, fields => [fields[0], ...fields[1].map(tail => tail[2])], []),
        };
    };
    const peg$c256 = function (type, name) {
        return {
            kind: 'schema-inline-field',
            location: location(),
            name,
            type: optional(type, type => type[0], null),
        };
    };
    const peg$c257 = "schema";
    const peg$c258 = peg$literalExpectation("schema", false);
    const peg$c259 = function (names, parents) {
        return {
            names: names.map(name => name[1]).filter(name => name !== '*'),
            parents: optional(parents, parents => parents, []),
        };
    };
    const peg$c260 = "alias";
    const peg$c261 = peg$literalExpectation("alias", false);
    const peg$c262 = function (spec, alias, items) {
        return {
            kind: 'schema',
            location: location(),
            items: optional(items, extractIndented, []),
            alias,
            ...spec
        };
    };
    const peg$c263 = function (spec, items) {
        return {
            kind: 'schema',
            location: location(),
            items: optional(items, extractIndented, []),
            ...spec
        };
    };
    const peg$c264 = "extends";
    const peg$c265 = peg$literalExpectation("extends", false);
    const peg$c266 = function (first, rest) {
        return [first, ...(rest.map(item => item[3]))];
    };
    const peg$c267 = function (type, name) {
        return {
            kind: 'schema-field',
            location: location(),
            type,
            name,
        };
    };
    const peg$c268 = function (schema) {
        return {
            kind: 'schema-collection',
            location: location(),
            schema
        };
    };
    const peg$c269 = function (schema) {
        return {
            kind: 'schema-reference',
            location: location(),
            schema
        };
    };
    const peg$c270 = "Text";
    const peg$c271 = peg$literalExpectation("Text", false);
    const peg$c272 = "URL";
    const peg$c273 = peg$literalExpectation("URL", false);
    const peg$c274 = "Number";
    const peg$c275 = peg$literalExpectation("Number", false);
    const peg$c276 = "Boolean";
    const peg$c277 = peg$literalExpectation("Boolean", false);
    const peg$c278 = "Bytes";
    const peg$c279 = peg$literalExpectation("Bytes", false);
    const peg$c280 = function (type) {
        return {
            kind: 'schema-primitive',
            location: location(),
            type
        };
    };
    const peg$c281 = function (first, rest) {
        const types = [first];
        for (const type of rest) {
            types.push(type[3]);
        }
        return { kind: 'schema-union', location: location(), types };
    };
    const peg$c282 = function (first, rest) {
        const types = [first];
        for (const type of rest) {
            types.push(type[3]);
        }
        return { kind: 'schema-tuple', location: location(), types };
    };
    const peg$c283 = peg$otherExpectation("a version number (e.g. @012)");
    const peg$c284 = /^[0-9]/;
    const peg$c285 = peg$classExpectation([["0", "9"]], false, false);
    const peg$c286 = function (version) {
        return Number(version.join(''));
    };
    const peg$c287 = peg$otherExpectation("indentation");
    const peg$c288 = " ";
    const peg$c289 = peg$literalExpectation(" ", false);
    const peg$c290 = function (i) {
        i = i.join('');
        if (i.length > indent.length) {
            indents.push(indent);
            indent = i;
            return true;
        }
        return false;
    };
    const peg$c291 = peg$otherExpectation("same indentation");
    const peg$c292 = function (i) {
        i = i.join('');
        if (i.length === indent.length) {
            return true;
        }
        else if (i.length < indent.length) {
            indent = indents.pop();
            return false;
        }
        return false;
    };
    const peg$c293 = peg$otherExpectation("same or more indentation");
    const peg$c294 = function (i) {
        i = i.join('');
        if (i.length >= indent.length) {
            return true;
        }
        else if (i.length < indent.length) {
            indent = indents.pop();
            return false;
        }
        return undefined;
    };
    const peg$c295 = /^[^a-zA-Z0-9_]/;
    const peg$c296 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], true, false);
    const peg$c297 = peg$anyExpectation();
    const peg$c298 = function (keyword) {
        expected(`identifier`);
    };
    const peg$c299 = peg$otherExpectation("a `backquoted string`");
    const peg$c300 = "`";
    const peg$c301 = peg$literalExpectation("`", false);
    const peg$c302 = /^[^`]/;
    const peg$c303 = peg$classExpectation(["`"], true, false);
    const peg$c304 = function (pattern) { return pattern.join(''); };
    const peg$c305 = peg$otherExpectation("an identifier (e.g. 'id')");
    const peg$c306 = "'";
    const peg$c307 = peg$literalExpectation("'", false);
    const peg$c308 = /^[^'\n]/;
    const peg$c309 = peg$classExpectation(["'", "\n"], true, false);
    const peg$c310 = function (id) { expected('\' at the end of an identifier'); };
    const peg$c311 = function (id) { return id.join(''); };
    const peg$c312 = peg$otherExpectation("an uppercase identifier (e.g. Foo)");
    const peg$c313 = /^[A-Z]/;
    const peg$c314 = peg$classExpectation([["A", "Z"]], false, false);
    const peg$c315 = /^[a-z0-9_]/i;
    const peg$c316 = peg$classExpectation([["a", "z"], ["0", "9"], "_"], false, true);
    const peg$c317 = peg$otherExpectation("a lowercase identifier (e.g. foo)");
    const peg$c318 = /^[a-z]/;
    const peg$c319 = peg$classExpectation([["a", "z"]], false, false);
    const peg$c320 = peg$otherExpectation("a field name (e.g. foo9)");
    const peg$c321 = peg$otherExpectation("a name conforming to the rules of an android app name, per https://developer.android.com/guide/topics/manifest/manifest-element.html#package");
    const peg$c322 = peg$otherExpectation("a name starting with a letter and containing letters, digits and underscores");
    const peg$c323 = /^[a-zA-Z]/;
    const peg$c324 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
    const peg$c325 = /^[a-zA-Z0-9_]/;
    const peg$c326 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false);
    const peg$c327 = function () { return text(); };
    const peg$c328 = peg$otherExpectation("one or more whitespace characters");
    const peg$c329 = peg$otherExpectation("a group of new lines (and optionally comments)");
    const peg$c330 = /^[ ]/;
    const peg$c331 = peg$classExpectation([" "], false, false);
    const peg$c332 = "//";
    const peg$c333 = peg$literalExpectation("//", false);
    const peg$c334 = peg$otherExpectation("a new line");
    const peg$c335 = "\r";
    const peg$c336 = peg$literalExpectation("\r", false);
    const peg$c337 = "\n";
    const peg$c338 = peg$literalExpectation("\n", false);
    let peg$currPos = 0;
    let peg$savedPos = 0;
    const peg$posDetailsCache = [{ line: 1, column: 1 }];
    let peg$maxFailPos = 0;
    let peg$maxFailExpected = [];
    let peg$silentFails = 0;
    let peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return { type: "literal", text: text1, ignoreCase: ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }
    function peg$anyExpectation() {
        return { type: "any" };
    }
    function peg$endExpectation() {
        return { type: "end" };
    }
    function peg$otherExpectation(description) {
        return { type: "other", description: description };
    }
    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;
        if (details) {
            return details;
        }
        else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
                p--;
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                }
                else {
                    details.column++;
                }
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);
        return {
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new SyntaxError(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$parseManifest() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseeolWhiteSpace();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseIndent();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseAnnotation();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parseSameIndent();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseManifestItem();
                        if (s7 !== peg$FAILED) {
                            s5 = [s5, s6, s7];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseAnnotation();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseSameIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseManifestItem();
                            if (s7 !== peg$FAILED) {
                                s5 = [s5, s6, s7];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c0(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestItem() {
        let s0;
        s0 = peg$parseRecipe();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticle();
            if (s0 === peg$FAILED) {
                s0 = peg$parseImport();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseSchema();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseSchemaAlias();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseManifestStorage();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseInterface();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseMeta();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseResource();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseAnnotation() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseSameIndent();
        if (s3 !== peg$FAILED) {
            s4 = peg$parseTrigger();
            if (s4 !== peg$FAILED) {
                s5 = peg$parseeolWhiteSpace();
                if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parseSameIndent();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseTrigger();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseeolWhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s3 = [s3, s4, s5];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseSameIndent();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseSimpleAnnotation();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseeolWhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s3 = [s3, s4, s5];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTrigger() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c3) {
            s1 = peg$c3;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c4);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseIndent();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parseeolWhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsesimpleName();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parsewhiteSpace();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsedottedName();
                                    if (s10 !== peg$FAILED) {
                                        s6 = [s6, s7, s8, s9, s10];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$currPos;
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseSameIndent();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parsesimpleName();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parsewhiteSpace();
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$parsedottedName();
                                            if (s10 !== peg$FAILED) {
                                                s6 = [s6, s7, s8, s9, s10];
                                                s5 = s6;
                                            }
                                            else {
                                                peg$currPos = s5;
                                                s5 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s5;
                                            s5 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                    }
                    else {
                        s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c5(s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c2);
            }
        }
        return s0;
    }
    function peg$parseSimpleAnnotation() {
        let s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
            s1 = peg$c7;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c8);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c9(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c6);
            }
        }
        return s0;
    }
    function peg$parseResource() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c10) {
            s1 = peg$c10;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c11);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseIndent();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseSameIndent();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseResourceStart();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseResourceBody();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseeolWhiteSpace();
                                        if (s9 === peg$FAILED) {
                                            s9 = null;
                                        }
                                        if (s9 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c12(s3, s8);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseResourceStart() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c13) {
            s1 = peg$c13;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c14);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeol();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c15();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseResourceBody() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseSameOrMoreIndent();
        if (s3 !== peg$FAILED) {
            s4 = peg$parseResourceLine();
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parseSameOrMoreIndent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseResourceLine();
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c16(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseResourceLine() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c17.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c18);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c17.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c18);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeol();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorage() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c20) {
            s1 = peg$c20;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c21);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c22) {
                            s5 = peg$c22;
                            peg$currPos += 2;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c23);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsewhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseManifestStorageType();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$currPos;
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseid();
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$currPos;
                                        if (input.substr(peg$currPos, 2) === peg$c24) {
                                            s10 = peg$c24;
                                            peg$currPos += 2;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c25);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s11 = peg$parseid();
                                            if (s11 !== peg$FAILED) {
                                                s10 = [s10, s11];
                                                s9 = s10;
                                            }
                                            else {
                                                peg$currPos = s9;
                                                s9 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                        if (s9 === peg$FAILED) {
                                            s9 = null;
                                        }
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$currPos;
                                            s11 = peg$parsewhiteSpace();
                                            if (s11 !== peg$FAILED) {
                                                s12 = peg$parseVersion();
                                                if (s12 !== peg$FAILED) {
                                                    s11 = [s11, s12];
                                                    s10 = s11;
                                                }
                                                else {
                                                    peg$currPos = s10;
                                                    s10 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                            if (s10 === peg$FAILED) {
                                                s10 = null;
                                            }
                                            if (s10 !== peg$FAILED) {
                                                s11 = peg$currPos;
                                                s12 = peg$parsewhiteSpace();
                                                if (s12 !== peg$FAILED) {
                                                    s13 = peg$parseTagList();
                                                    if (s13 !== peg$FAILED) {
                                                        s12 = [s12, s13];
                                                        s11 = s12;
                                                    }
                                                    else {
                                                        peg$currPos = s11;
                                                        s11 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                                if (s11 === peg$FAILED) {
                                                    s11 = null;
                                                }
                                                if (s11 !== peg$FAILED) {
                                                    s12 = peg$parsewhiteSpace();
                                                    if (s12 !== peg$FAILED) {
                                                        s13 = peg$parseManifestStorageSource();
                                                        if (s13 !== peg$FAILED) {
                                                            s14 = peg$parseeolWhiteSpace();
                                                            if (s14 !== peg$FAILED) {
                                                                s15 = peg$currPos;
                                                                s16 = peg$parseIndent();
                                                                if (s16 !== peg$FAILED) {
                                                                    s17 = [];
                                                                    s18 = peg$currPos;
                                                                    s19 = peg$parseSameIndent();
                                                                    if (s19 !== peg$FAILED) {
                                                                        s20 = peg$parseManifestStorageItem();
                                                                        if (s20 !== peg$FAILED) {
                                                                            s19 = [s19, s20];
                                                                            s18 = s19;
                                                                        }
                                                                        else {
                                                                            peg$currPos = s18;
                                                                            s18 = peg$FAILED;
                                                                        }
                                                                    }
                                                                    else {
                                                                        peg$currPos = s18;
                                                                        s18 = peg$FAILED;
                                                                    }
                                                                    if (s18 !== peg$FAILED) {
                                                                        while (s18 !== peg$FAILED) {
                                                                            s17.push(s18);
                                                                            s18 = peg$currPos;
                                                                            s19 = peg$parseSameIndent();
                                                                            if (s19 !== peg$FAILED) {
                                                                                s20 = peg$parseManifestStorageItem();
                                                                                if (s20 !== peg$FAILED) {
                                                                                    s19 = [s19, s20];
                                                                                    s18 = s19;
                                                                                }
                                                                                else {
                                                                                    peg$currPos = s18;
                                                                                    s18 = peg$FAILED;
                                                                                }
                                                                            }
                                                                            else {
                                                                                peg$currPos = s18;
                                                                                s18 = peg$FAILED;
                                                                            }
                                                                        }
                                                                    }
                                                                    else {
                                                                        s17 = peg$FAILED;
                                                                    }
                                                                    if (s17 !== peg$FAILED) {
                                                                        s16 = [s16, s17];
                                                                        s15 = s16;
                                                                    }
                                                                    else {
                                                                        peg$currPos = s15;
                                                                        s15 = peg$FAILED;
                                                                    }
                                                                }
                                                                else {
                                                                    peg$currPos = s15;
                                                                    s15 = peg$FAILED;
                                                                }
                                                                if (s15 === peg$FAILED) {
                                                                    s15 = null;
                                                                }
                                                                if (s15 !== peg$FAILED) {
                                                                    peg$savedPos = s0;
                                                                    s1 = peg$c26(s3, s7, s8, s9, s10, s11, s13, s15);
                                                                    s0 = s1;
                                                                }
                                                                else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            }
                                                            else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageType() {
        let s0;
        s0 = peg$parseSchemaInline();
        if (s0 === peg$FAILED) {
            s0 = peg$parseCollectionType();
            if (s0 === peg$FAILED) {
                s0 = peg$parseBigCollectionType();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseTypeName();
                }
            }
        }
        return s0;
    }
    function peg$parseManifestStorageSource() {
        let s0;
        s0 = peg$parseManifestStorageFileSource();
        if (s0 === peg$FAILED) {
            s0 = peg$parseManifestStorageResourceSource();
            if (s0 === peg$FAILED) {
                s0 = peg$parseManifestStorageStorageSource();
            }
        }
        return s0;
    }
    function peg$parseManifestStorageFileSource() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c27) {
            s1 = peg$c27;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c28);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c29(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageResourceSource() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c27) {
            s1 = peg$c27;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c28);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c30(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageStorageSource() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c31) {
            s1 = peg$c31;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c32);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c33(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageItem() {
        let s0;
        s0 = peg$parseManifestStorageDescription();
        if (s0 === peg$FAILED) {
            s0 = peg$parseManifestStorageClaim();
        }
        return s0;
    }
    function peg$parseManifestStorageDescription() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 11) === peg$c34) {
            s1 = peg$c34;
            peg$currPos += 11;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c35);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s1 = [s1, s2, s3, s4];
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageClaim() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c36) {
            s1 = peg$c36;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c37);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c38) {
                    s3 = peg$c38;
                    peg$currPos += 2;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c39);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parselowerIdent();
                        if (s5 !== peg$FAILED) {
                            s6 = [];
                            s7 = peg$currPos;
                            s8 = peg$parsewhiteSpace();
                            if (s8 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 3) === peg$c40) {
                                    s9 = peg$c40;
                                    peg$currPos += 3;
                                }
                                else {
                                    s9 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c41);
                                    }
                                }
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsewhiteSpace();
                                    if (s10 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c38) {
                                            s11 = peg$c38;
                                            peg$currPos += 2;
                                        }
                                        else {
                                            s11 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c39);
                                            }
                                        }
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parsewhiteSpace();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parselowerIdent();
                                                if (s13 !== peg$FAILED) {
                                                    s8 = [s8, s9, s10, s11, s12, s13];
                                                    s7 = s8;
                                                }
                                                else {
                                                    peg$currPos = s7;
                                                    s7 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s7;
                                                s7 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                            while (s7 !== peg$FAILED) {
                                s6.push(s7);
                                s7 = peg$currPos;
                                s8 = peg$parsewhiteSpace();
                                if (s8 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c40) {
                                        s9 = peg$c40;
                                        peg$currPos += 3;
                                    }
                                    else {
                                        s9 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c41);
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parsewhiteSpace();
                                        if (s10 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c38) {
                                                s11 = peg$c38;
                                                peg$currPos += 2;
                                            }
                                            else {
                                                s11 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c39);
                                                }
                                            }
                                            if (s11 !== peg$FAILED) {
                                                s12 = peg$parsewhiteSpace();
                                                if (s12 !== peg$FAILED) {
                                                    s13 = peg$parselowerIdent();
                                                    if (s13 !== peg$FAILED) {
                                                        s8 = [s8, s9, s10, s11, s12, s13];
                                                        s7 = s8;
                                                    }
                                                    else {
                                                        peg$currPos = s7;
                                                        s7 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s7;
                                                    s7 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s7;
                                                s7 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c42(s5, s6);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseImport() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c43) {
            s1 = peg$c43;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c44);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c45(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseInterface() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c47) {
            s1 = peg$c47;
            peg$currPos += 9;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c48);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 === peg$FAILED) {
                        s5 = null;
                    }
                    if (s5 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s6 = peg$c49;
                            peg$currPos++;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c50);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsewhiteSpace();
                            if (s7 === peg$FAILED) {
                                s7 = null;
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parseTypeVariableList();
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 === peg$FAILED) {
                                        s9 = null;
                                    }
                                    if (s9 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 62) {
                                            s10 = peg$c51;
                                            peg$currPos++;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c52);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s5 = [s5, s6, s7, s8, s9, s10];
                                            s4 = s5;
                                        }
                                        else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parseIndent();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parseSameIndent();
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseInterfaceItem();
                                    if (s11 !== peg$FAILED) {
                                        s10 = [s10, s11];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseSameIndent();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseInterfaceItem();
                                        if (s11 !== peg$FAILED) {
                                            s10 = [s10, s11];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c53(s3, s4, s6);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        return s0;
    }
    function peg$parseInterfaceItem() {
        let s0;
        s0 = peg$parseInterfaceSlot();
        if (s0 === peg$FAILED) {
            s0 = peg$parseInterfaceArgument();
        }
        return s0;
    }
    function peg$parseInterfaceArgument() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDirection();
        if (s2 !== peg$FAILED) {
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseParticleHandleConnectionType();
            if (s3 !== peg$FAILED) {
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 42) {
                        s3 = peg$c54;
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c55);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c56(s1, s2, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseInterfaceSlot() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c57) {
            s2 = peg$c57;
            peg$currPos += 4;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c58);
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c59) {
                s2 = peg$c59;
                peg$currPos += 7;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c60);
                }
            }
            if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c61) {
                    s2 = peg$c61;
                    peg$currPos += 7;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c62);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c63) {
                        s5 = peg$c63;
                        peg$currPos += 6;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c64);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parselowerIdent();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c65(s1, s2, s3, s4);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMeta() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c66) {
            s1 = peg$c66;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c67);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseMetaItem();
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseMetaItem();
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c68(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaItem() {
        let s0;
        s0 = peg$parseMetaStorageKey();
        if (s0 === peg$FAILED) {
            s0 = peg$parseMetaName();
        }
        return s0;
    }
    function peg$parseMetaName() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c69) {
            s1 = peg$c69;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c70);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c71;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c72);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseid();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c73(s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaStorageKey() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c74) {
            s1 = peg$c74;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c75);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c71;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c72);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseid();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c76(s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c78);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseVerbList();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c27) {
                                s7 = peg$c27;
                                peg$currPos += 2;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c28);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsewhiteSpace();
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parseid();
                                    if (s9 !== peg$FAILED) {
                                        s6 = [s6, s7, s8, s9];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$currPos;
                                s8 = peg$parseIndent();
                                if (s8 !== peg$FAILED) {
                                    s9 = [];
                                    s10 = peg$currPos;
                                    s11 = peg$parseSameIndent();
                                    if (s11 !== peg$FAILED) {
                                        s12 = peg$parseParticleItem();
                                        if (s12 !== peg$FAILED) {
                                            s11 = [s11, s12];
                                            s10 = s11;
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s10;
                                        s10 = peg$FAILED;
                                    }
                                    while (s10 !== peg$FAILED) {
                                        s9.push(s10);
                                        s10 = peg$currPos;
                                        s11 = peg$parseSameIndent();
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parseParticleItem();
                                            if (s12 !== peg$FAILED) {
                                                s11 = [s11, s12];
                                                s10 = s11;
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s8 = [s8, s9];
                                        s7 = s8;
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseeolWhiteSpace();
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c79(s3, s4, s5, s7);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleItem() {
        let s0;
        peg$silentFails++;
        s0 = peg$parseParticleModality();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticleSlotConnection();
            if (s0 === peg$FAILED) {
                s0 = peg$parseDescription();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseParticleHandleConnection();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseParticleClaimStatement();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseParticleCheckStatement();
                        }
                    }
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
                peg$fail(peg$c80);
            }
        }
        return s0;
    }
    function peg$parseParticleClaimStatement() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c36) {
            s1 = peg$c36;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c37);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseParticleClaimExpression();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c81(s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleClaimExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseParticleClaim();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c40) {
                    s5 = peg$c40;
                    peg$currPos += 3;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c41);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseParticleClaim();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c40) {
                        s5 = peg$c40;
                        peg$currPos += 3;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c41);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseParticleClaim();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c82(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleClaim() {
        let s0;
        s0 = peg$parseParticleClaimIsTag();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticleClaimDerivesFrom();
        }
        return s0;
    }
    function peg$parseParticleClaimIsTag() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c38) {
            s1 = peg$c38;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c39);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c83) {
                    s4 = peg$c83;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c84);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parselowerIdent();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c85(s3, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleClaimDerivesFrom() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 12) === peg$c86) {
            s1 = peg$c86;
            peg$currPos += 12;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c87);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c88(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckStatement() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c90);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseParticleCheckTarget();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseParticleCheckExpressionBody();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c91(s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckTarget() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c92) {
                    s4 = peg$c92;
                    peg$currPos += 4;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c93);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c94(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckExpressionBody() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseParticleCheckExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c95) {
                    s5 = peg$c95;
                    peg$currPos += 2;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c96);
                    }
                }
                if (s5 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c40) {
                        s5 = peg$c40;
                        peg$currPos += 3;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c41);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseParticleCheckExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c95) {
                        s5 = peg$c95;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c96);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 3) === peg$c40) {
                            s5 = peg$c40;
                            peg$currPos += 3;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c41);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseParticleCheckExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c97(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckExpression() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseParticleCheckCondition();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c98(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c99;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c100);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsewhiteSpace();
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseParticleCheckExpressionBody();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parsewhiteSpace();
                        if (s4 === peg$FAILED) {
                            s4 = null;
                        }
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s5 = peg$c101;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c102);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c98(s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseParticleCheckCondition() {
        let s0;
        s0 = peg$parseParticleCheckIsFromHandle();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticleCheckIsFromStore();
            if (s0 === peg$FAILED) {
                s0 = peg$parseParticleCheckIsFromOutput();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseParticleCheckHasTag();
                }
            }
        }
        return s0;
    }
    function peg$parseParticleCheckHasTag() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c38) {
            s1 = peg$c38;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c39);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c83) {
                    s4 = peg$c83;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c84);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parselowerIdent();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c103(s2, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckIsFromHandle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c38) {
            s1 = peg$c38;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c39);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c83) {
                    s4 = peg$c83;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c84);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c104) {
                        s4 = peg$c104;
                        peg$currPos += 4;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c105);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c106) {
                                s6 = peg$c106;
                                peg$currPos += 6;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c107);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsewhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parselowerIdent();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c108(s2, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckIsFromOutput() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c38) {
            s1 = peg$c38;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c39);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c83) {
                    s4 = peg$c83;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c84);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c104) {
                        s4 = peg$c104;
                        peg$currPos += 4;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c105);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c109) {
                                s6 = peg$c109;
                                peg$currPos += 6;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c110);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsewhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parselowerIdent();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c111(s2, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleCheckIsFromStore() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c38) {
            s1 = peg$c38;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c39);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c83) {
                    s4 = peg$c83;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c84);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c104) {
                        s4 = peg$c104;
                        peg$currPos += 4;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c105);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c20) {
                                s6 = peg$c20;
                                peg$currPos += 5;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c21);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsewhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseStoreReference();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c112(s2, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseStoreReference() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c113(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseid();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c114(s1);
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parseParticleHandleConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseParticleHandleConnectionBody();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseParticleHandleConnection();
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseParticleHandleConnection();
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c115(s1, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleHandleConnectionBody() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseDirection();
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 63) {
                s2 = peg$c116;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c117);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseParticleHandleConnectionType();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseNameAndTagList();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c118(s1, s2, s4, s6);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseDirection() {
        let s0, s1;
        peg$silentFails++;
        if (input.substr(peg$currPos, 5) === peg$c120) {
            s0 = peg$c120;
            peg$currPos += 5;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c121);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c27) {
                s0 = peg$c27;
                peg$currPos += 2;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c28);
                }
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c122) {
                    s0 = peg$c122;
                    peg$currPos += 3;
                }
                else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c123);
                    }
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c124) {
                        s0 = peg$c124;
                        peg$currPos += 4;
                    }
                    else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c125);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c126) {
                            s0 = peg$c126;
                            peg$currPos += 8;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c127);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c128) {
                                s0 = peg$c128;
                                peg$currPos += 8;
                            }
                            else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c129);
                                }
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 3) === peg$c130) {
                                    s1 = peg$c130;
                                    peg$currPos += 3;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c131);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c132();
                                }
                                s0 = s1;
                            }
                        }
                    }
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c119);
            }
        }
        return s0;
    }
    function peg$parseDirectionArrow() {
        let s0, s1;
        peg$silentFails++;
        if (input.substr(peg$currPos, 3) === peg$c134) {
            s0 = peg$c134;
            peg$currPos += 3;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c135);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c136) {
                s0 = peg$c136;
                peg$currPos += 2;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c137);
                }
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c138) {
                    s0 = peg$c138;
                    peg$currPos += 2;
                }
                else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c139);
                    }
                }
                if (s0 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 61) {
                        s0 = peg$c140;
                        peg$currPos++;
                    }
                    else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c141);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 7) === peg$c59) {
                            s0 = peg$c59;
                            peg$currPos += 7;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c60);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 7) === peg$c61) {
                                s1 = peg$c61;
                                peg$currPos += 7;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c62);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c142();
                            }
                            s0 = s1;
                        }
                    }
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c133);
            }
        }
        return s0;
    }
    function peg$parseParticleHandleConnectionType() {
        let s0;
        s0 = peg$parseTypeVariable();
        if (s0 === peg$FAILED) {
            s0 = peg$parseCollectionType();
            if (s0 === peg$FAILED) {
                s0 = peg$parseBigCollectionType();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseReferenceType();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseSlotType();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseSchemaInline();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseTypeName();
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseCollectionType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c143;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c144);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c145;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c146);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c147(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseBigCollectionType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 14) === peg$c148) {
            s1 = peg$c148;
            peg$currPos += 14;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c149);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                    s3 = peg$c51;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c52);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c150(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseReferenceType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c151) {
            s1 = peg$c151;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c152);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                    s3 = peg$c51;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c52);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c153(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTypeVariable() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c155;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c156);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c157) {
                        s5 = peg$c157;
                        peg$currPos += 4;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c158);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseParticleHandleConnectionType();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c159(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c154);
            }
        }
        return s0;
    }
    function peg$parseSlotType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c160) {
            s1 = peg$c160;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c161);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c162.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c163);
                }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
                peg$currPos = s2;
                s2 = undefined;
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s5 = peg$c164;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c165);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$currPos;
                        s7 = peg$parseSlotField();
                        if (s7 !== peg$FAILED) {
                            s8 = [];
                            s9 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s10 = peg$c166;
                                peg$currPos++;
                            }
                            else {
                                s10 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c167);
                                }
                            }
                            if (s10 !== peg$FAILED) {
                                s11 = peg$parsewhiteSpace();
                                if (s11 !== peg$FAILED) {
                                    s12 = peg$parseSlotField();
                                    if (s12 !== peg$FAILED) {
                                        s10 = [s10, s11, s12];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                            }
                            while (s9 !== peg$FAILED) {
                                s8.push(s9);
                                s9 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s10 = peg$c166;
                                    peg$currPos++;
                                }
                                else {
                                    s10 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c167);
                                    }
                                }
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parsewhiteSpace();
                                    if (s11 !== peg$FAILED) {
                                        s12 = peg$parseSlotField();
                                        if (s12 !== peg$FAILED) {
                                            s10 = [s10, s11, s12];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                            }
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                                s7 = peg$c168;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c169);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c170(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSlotField() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c71;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c72);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parselowerIdent();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c171(s1, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTypeName() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c172(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseTypeVariableList() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseTypeVariable();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c166;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c167);
                }
            }
            if (s4 !== peg$FAILED) {
                s5 = peg$parsewhiteSpace();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parseTypeVariable();
                    if (s6 !== peg$FAILED) {
                        s4 = [s4, s5, s6];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c166;
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c167);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseTypeVariable();
                        if (s6 !== peg$FAILED) {
                            s4 = [s4, s5, s6];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c173(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleModality() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c174) {
            s1 = peg$c174;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c175);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsefieldName();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c176(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleSlotConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c57) {
            s2 = peg$c57;
            peg$currPos += 4;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c58);
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c59) {
                s2 = peg$c59;
                peg$currPos += 7;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c60);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c63) {
                        s5 = peg$c63;
                        peg$currPos += 6;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c64);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parselowerIdent();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parsewhiteSpace();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parseTagList();
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$currPos;
                                    s9 = peg$parseIndent();
                                    if (s9 !== peg$FAILED) {
                                        s10 = [];
                                        s11 = peg$currPos;
                                        s12 = peg$parseSameIndent();
                                        if (s12 !== peg$FAILED) {
                                            s13 = peg$parseParticleSlotConnectionItem();
                                            if (s13 !== peg$FAILED) {
                                                s12 = [s12, s13];
                                                s11 = s12;
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s11;
                                            s11 = peg$FAILED;
                                        }
                                        while (s11 !== peg$FAILED) {
                                            s10.push(s11);
                                            s11 = peg$currPos;
                                            s12 = peg$parseSameIndent();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parseParticleSlotConnectionItem();
                                                if (s13 !== peg$FAILED) {
                                                    s12 = [s12, s13];
                                                    s11 = s12;
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c177(s1, s4, s5, s6, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleSlotConnectionItem() {
        let s0;
        s0 = peg$parseSlotFormFactor();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticleProvidedSlot();
        }
        return s0;
    }
    function peg$parseSlotFormFactor() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c178) {
            s1 = peg$c178;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c179);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c180) {
                    s3 = peg$c180;
                    peg$currPos += 10;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c181);
                    }
                }
                if (s3 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c182) {
                        s3 = peg$c182;
                        peg$currPos += 3;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c183);
                        }
                    }
                    if (s3 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c184) {
                            s3 = peg$c184;
                            peg$currPos += 6;
                        }
                        else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c185);
                            }
                        }
                        if (s3 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c186) {
                                s3 = peg$c186;
                                peg$currPos += 5;
                            }
                            else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c187);
                                }
                            }
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c188(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleProvidedSlot() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c57) {
            s2 = peg$c57;
            peg$currPos += 4;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c58);
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c61) {
                s2 = peg$c61;
                peg$currPos += 7;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c62);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c63) {
                        s5 = peg$c63;
                        peg$currPos += 6;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c64);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parselowerIdent();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parsewhiteSpace();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parseTagList();
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$currPos;
                                    s9 = peg$parseIndent();
                                    if (s9 !== peg$FAILED) {
                                        s10 = [];
                                        s11 = peg$currPos;
                                        s12 = peg$parseSameIndent();
                                        if (s12 !== peg$FAILED) {
                                            s13 = peg$parseParticleProvidedSlotItem();
                                            if (s13 !== peg$FAILED) {
                                                s12 = [s12, s13];
                                                s11 = s12;
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s11;
                                            s11 = peg$FAILED;
                                        }
                                        while (s11 !== peg$FAILED) {
                                            s10.push(s11);
                                            s11 = peg$currPos;
                                            s12 = peg$parseSameIndent();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parseParticleProvidedSlotItem();
                                                if (s13 !== peg$FAILED) {
                                                    s12 = [s12, s13];
                                                    s11 = s12;
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c189(s1, s4, s5, s6, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleProvidedSlotItem() {
        let s0;
        s0 = peg$parseSlotFormFactor();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticleProvidedSlotHandle();
        }
        return s0;
    }
    function peg$parseParticleProvidedSlotHandle() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c106) {
            s1 = peg$c106;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c107);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c190(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseDescription() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 11) === peg$c34) {
            s1 = peg$c34;
            peg$currPos += 11;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c35);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            s9 = peg$parseSameIndent();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parseParticleHandleDescription();
                                if (s10 !== peg$FAILED) {
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            if (s8 !== peg$FAILED) {
                                while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$currPos;
                                    s9 = peg$parseSameIndent();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseParticleHandleDescription();
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                            }
                            else {
                                s7 = peg$FAILED;
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c191(s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleHandleDescription() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c192(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipe() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c193) {
            s1 = peg$c193;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c194);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseupperIdent();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseVerbList();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            s9 = peg$parseSameIndent();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parseRecipeItem();
                                if (s10 !== peg$FAILED) {
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$currPos;
                                s9 = peg$parseSameIndent();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parseRecipeItem();
                                    if (s10 !== peg$FAILED) {
                                        s9 = [s9, s10];
                                        s8 = s9;
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c195(s2, s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeItem() {
        let s0;
        s0 = peg$parseRecipeParticle();
        if (s0 === peg$FAILED) {
            s0 = peg$parseRecipeHandle();
            if (s0 === peg$FAILED) {
                s0 = peg$parseRequireHandleSection();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseRecipeRequire();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseRecipeSlot();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseRecipeSearch();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseRecipeConnection();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseDescription();
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseLocalName() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c196) {
            s1 = peg$c196;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c197);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = [];
                    if (peg$c198.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c199);
                        }
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        if (peg$c198.test(input.charAt(peg$currPos))) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c199);
                            }
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c200();
                    }
                    s3 = s4;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c201(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTopLevelAlias() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c196) {
            s1 = peg$c196;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c197);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c201(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeParticle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parseParticleRef();
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
                s1 = peg$c54;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c55);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseLocalName();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseeolWhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parseIndent();
                    if (s5 !== peg$FAILED) {
                        s6 = [];
                        s7 = peg$currPos;
                        s8 = peg$parseSameIndent();
                        if (s8 !== peg$FAILED) {
                            s9 = peg$parseRecipeParticleItem();
                            if (s9 !== peg$FAILED) {
                                s8 = [s8, s9];
                                s7 = s8;
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                        }
                        while (s7 !== peg$FAILED) {
                            s6.push(s7);
                            s7 = peg$currPos;
                            s8 = peg$parseSameIndent();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseRecipeParticleItem();
                                if (s9 !== peg$FAILED) {
                                    s8 = [s8, s9];
                                    s7 = s8;
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c202(s1, s2, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeParticleItem() {
        let s0;
        s0 = peg$parseRecipeParticleSlotConnection();
        if (s0 === peg$FAILED) {
            s0 = peg$parseRecipeParticleConnection();
        }
        return s0;
    }
    function peg$parseRecipeParticleConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
                s1 = peg$c54;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c55);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseDirectionArrow();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseParticleConnectionTargetComponents();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parseIndent();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parseSameIndent();
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseRecipeParticleConnection();
                                    if (s11 !== peg$FAILED) {
                                        s10 = [s10, s11];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseSameIndent();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseRecipeParticleConnection();
                                        if (s11 !== peg$FAILED) {
                                            s10 = [s10, s11];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c203(s1, s3, s4, s6);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleConnectionTargetComponents() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 === peg$FAILED) {
            s1 = peg$parselowerIdent();
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseTagList();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c204(s1, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeParticleSlotConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parseSlotDirection();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseRecipeSlotConnectionRef();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseLocalName();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parseIndent();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parseSameIndent();
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseRecipeParticleSlotConnection();
                                    if (s11 !== peg$FAILED) {
                                        s10 = [s10, s11];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseSameIndent();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseRecipeParticleSlotConnection();
                                        if (s11 !== peg$FAILED) {
                                            s10 = [s10, s11];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c205(s1, s3, s4, s6);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeSlotConnectionRef() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseSpaceTagList();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c206(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSlotDirection() {
        let s0;
        if (input.substr(peg$currPos, 7) === peg$c61) {
            s0 = peg$c61;
            peg$currPos += 7;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c62);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c59) {
                s0 = peg$c59;
                peg$currPos += 7;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c60);
                }
            }
        }
        return s0;
    }
    function peg$parseRecipeConnection() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseConnectionTarget();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseDirectionArrow();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseConnectionTarget();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c207(s1, s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeSearch() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c208) {
            s1 = peg$c208;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c209);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$currPos;
                            s8 = peg$parseSameIndent();
                            if (s8 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c210) {
                                    s9 = peg$c210;
                                    peg$currPos += 6;
                                }
                                else {
                                    s9 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c211);
                                    }
                                }
                                if (s9 !== peg$FAILED) {
                                    s10 = [];
                                    s11 = peg$currPos;
                                    s12 = peg$parsewhiteSpace();
                                    if (s12 !== peg$FAILED) {
                                        s13 = peg$parsebackquotedString();
                                        if (s13 !== peg$FAILED) {
                                            s12 = [s12, s13];
                                            s11 = s12;
                                        }
                                        else {
                                            peg$currPos = s11;
                                            s11 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s11;
                                        s11 = peg$FAILED;
                                    }
                                    if (s11 !== peg$FAILED) {
                                        while (s11 !== peg$FAILED) {
                                            s10.push(s11);
                                            s11 = peg$currPos;
                                            s12 = peg$parsewhiteSpace();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parsebackquotedString();
                                                if (s13 !== peg$FAILED) {
                                                    s12 = [s12, s13];
                                                    s11 = s12;
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                    }
                                    else {
                                        s10 = peg$FAILED;
                                    }
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseeolWhiteSpace();
                                        if (s11 !== peg$FAILED) {
                                            s8 = [s8, s9, s10, s11];
                                            s7 = s8;
                                        }
                                        else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c212(s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseConnectionTarget() {
        let s0;
        s0 = peg$parseVerbConnectionTarget();
        if (s0 === peg$FAILED) {
            s0 = peg$parseTagConnectionTarget();
            if (s0 === peg$FAILED) {
                s0 = peg$parseParticleConnectionTarget();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseNameConnectionTarget();
                }
            }
        }
        return s0;
    }
    function peg$parseVerbConnectionTarget() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseVerbList();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseConnectionTargetHandleComponents();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c213(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTagConnectionTarget() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseTagList();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c214(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseNameConnectionTarget() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseConnectionTargetHandleComponents();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c215(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleConnectionTarget() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseConnectionTargetHandleComponents();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c216(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseConnectionTargetHandleComponents() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c217;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c218);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseTagList();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c219(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeHandleFate() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 63) {
            s0 = peg$c116;
            peg$currPos++;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c117);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c220) {
                s0 = peg$c220;
                peg$currPos += 3;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c221);
                }
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c222) {
                    s0 = peg$c222;
                    peg$currPos += 3;
                }
                else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c223);
                    }
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c224) {
                        s0 = peg$c224;
                        peg$currPos += 6;
                    }
                    else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c225);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c226) {
                            s0 = peg$c226;
                            peg$currPos += 4;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c227);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c228) {
                                s0 = peg$c228;
                                peg$currPos += 5;
                            }
                            else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c229);
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseRecipeHandle() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseRecipeHandleFate();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseHandleRef();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseLocalName();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c230(s1, s2, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeRequire() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c231) {
            s1 = peg$c231;
            peg$currPos += 7;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c232);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseRecipeParticle();
                        if (s8 === peg$FAILED) {
                            s8 = peg$parseRequireHandleSection();
                            if (s8 === peg$FAILED) {
                                s8 = peg$parseRecipeSlot();
                            }
                        }
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseRecipeParticle();
                            if (s8 === peg$FAILED) {
                                s8 = peg$parseRequireHandleSection();
                                if (s8 === peg$FAILED) {
                                    s8 = peg$parseRecipeSlot();
                                }
                            }
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c233(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRequireHandleSection() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c106) {
            s1 = peg$c106;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c107);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseLocalName();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseHandleRef();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c234(s2, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTag() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c235;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c236);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsesimpleName();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c237(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTagList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseTag();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseTagList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c238(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseVerb() {
        let s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c240;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c241);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsesimpleName();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c242(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c239);
            }
        }
        return s0;
    }
    function peg$parseVerbList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseVerb();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseVerbList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c238(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSpaceTagList() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsewhiteSpace();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseTagList();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c243(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNameAndTagList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseTagList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c244(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsewhiteSpace();
            if (s1 !== peg$FAILED) {
                s2 = peg$parselowerIdent();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c245(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsewhiteSpace();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseTagList();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c246(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        return s0;
    }
    function peg$parseParticleRef() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c247(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseVerb();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c248(s1);
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parseHandleRef() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseid();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseSpaceTagList();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c249(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseupperIdent();
            if (s1 !== peg$FAILED) {
                s2 = peg$parseSpaceTagList();
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c250(s1, s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseTagList();
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c251(s1);
                }
                s0 = s1;
            }
        }
        return s0;
    }
    function peg$parseRecipeSlot() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c252) {
            s1 = peg$c252;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c253);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseHandleRef();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseLocalName();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c254(s2, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaInline() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseupperIdent();
        if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
                s3 = peg$c54;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c55);
                }
            }
        }
        if (s3 !== peg$FAILED) {
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parseupperIdent();
                if (s3 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 42) {
                        s3 = peg$c54;
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c55);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
                s2 = peg$c164;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c165);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseSchemaInlineField();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s7 = peg$c166;
                        peg$currPos++;
                    }
                    else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c167);
                        }
                    }
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parsewhiteSpace();
                        if (s8 !== peg$FAILED) {
                            s9 = peg$parseSchemaInlineField();
                            if (s9 !== peg$FAILED) {
                                s7 = [s7, s8, s9];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c166;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c167);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsewhiteSpace();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseSchemaInlineField();
                                if (s9 !== peg$FAILED) {
                                    s7 = [s7, s8, s9];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                        s4 = peg$c168;
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c169);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c255(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaInlineField() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseSchemaType();
        if (s2 !== peg$FAILED) {
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsefieldName();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c256(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaSpec() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c257) {
            s1 = peg$c257;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c258);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                    s5 = peg$c54;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c55);
                    }
                }
                if (s5 === peg$FAILED) {
                    s5 = peg$parseupperIdent();
                }
                if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 42) {
                            s5 = peg$c54;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c55);
                            }
                        }
                        if (s5 === peg$FAILED) {
                            s5 = peg$parseupperIdent();
                        }
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaExtends();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c259(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaAlias() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c260) {
            s1 = peg$c260;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c261);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaSpec();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseTopLevelAlias();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$currPos;
                                s8 = peg$parseIndent();
                                if (s8 !== peg$FAILED) {
                                    s9 = [];
                                    s10 = peg$currPos;
                                    s11 = peg$parseSameIndent();
                                    if (s11 !== peg$FAILED) {
                                        s12 = peg$parseSchemaItem();
                                        if (s12 !== peg$FAILED) {
                                            s11 = [s11, s12];
                                            s10 = s11;
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s10;
                                        s10 = peg$FAILED;
                                    }
                                    while (s10 !== peg$FAILED) {
                                        s9.push(s10);
                                        s10 = peg$currPos;
                                        s11 = peg$parseSameIndent();
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parseSchemaItem();
                                            if (s12 !== peg$FAILED) {
                                                s11 = [s11, s12];
                                                s10 = s11;
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s8 = [s8, s9];
                                        s7 = s8;
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c262(s3, s5, s7);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchema() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseSchemaSpec();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseSchemaItem();
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseSchemaItem();
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c263(s1, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaExtends() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsewhiteSpace();
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c264) {
                s2 = peg$c264;
                peg$currPos += 7;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c265);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseupperIdent();
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$currPos;
                        s7 = peg$parsewhiteSpace();
                        if (s7 === peg$FAILED) {
                            s7 = null;
                        }
                        if (s7 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s8 = peg$c166;
                                peg$currPos++;
                            }
                            else {
                                s8 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c167);
                                }
                            }
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parsewhiteSpace();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parseupperIdent();
                                    if (s10 !== peg$FAILED) {
                                        s7 = [s7, s8, s9, s10];
                                        s6 = s7;
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                        while (s6 !== peg$FAILED) {
                            s5.push(s6);
                            s6 = peg$currPos;
                            s7 = peg$parsewhiteSpace();
                            if (s7 === peg$FAILED) {
                                s7 = null;
                            }
                            if (s7 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s8 = peg$c166;
                                    peg$currPos++;
                                }
                                else {
                                    s8 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c167);
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseupperIdent();
                                        if (s10 !== peg$FAILED) {
                                            s7 = [s7, s8, s9, s10];
                                            s6 = s7;
                                        }
                                        else {
                                            peg$currPos = s6;
                                            s6 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c266(s4, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaItem() {
        let s0;
        s0 = peg$parseSchemaField();
        if (s0 === peg$FAILED) {
            s0 = peg$parseDescription();
        }
        return s0;
    }
    function peg$parseSchemaField() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseSchemaType();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsefieldName();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c267(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaType() {
        let s0;
        s0 = peg$parseSchemaReferenceType();
        if (s0 === peg$FAILED) {
            s0 = peg$parseSchemaCollectionType();
            if (s0 === peg$FAILED) {
                s0 = peg$parseSchemaPrimitiveType();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseSchemaUnionType();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseSchemaTupleType();
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseSchemaCollectionType() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c143;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c144);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewhiteSpace();
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsewhiteSpace();
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaReferenceType();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parsewhiteSpace();
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$parsewhiteSpace();
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                            s5 = peg$c145;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c146);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c268(s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaReferenceType() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c151) {
            s1 = peg$c151;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c152);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewhiteSpace();
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsewhiteSpace();
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaInline();
                if (s3 === peg$FAILED) {
                    s3 = peg$parseTypeName();
                }
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parsewhiteSpace();
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$parsewhiteSpace();
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 62) {
                            s5 = peg$c51;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c52);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c269(s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaPrimitiveType() {
        let s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c270) {
            s1 = peg$c270;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c271);
            }
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c272) {
                s1 = peg$c272;
                peg$currPos += 3;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c273);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c274) {
                    s1 = peg$c274;
                    peg$currPos += 6;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c275);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c276) {
                        s1 = peg$c276;
                        peg$currPos += 7;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c277);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c278) {
                            s1 = peg$c278;
                            peg$currPos += 5;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c279);
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c280(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseSchemaUnionType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c99;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c100);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaPrimitiveType();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parsewhiteSpace();
                    if (s6 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c95) {
                            s7 = peg$c95;
                            peg$currPos += 2;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c96);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsewhiteSpace();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseSchemaPrimitiveType();
                                if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$currPos;
                            s6 = peg$parsewhiteSpace();
                            if (s6 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c95) {
                                    s7 = peg$c95;
                                    peg$currPos += 2;
                                }
                                else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c96);
                                    }
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parsewhiteSpace();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseSchemaPrimitiveType();
                                        if (s9 !== peg$FAILED) {
                                            s6 = [s6, s7, s8, s9];
                                            s5 = s6;
                                        }
                                        else {
                                            peg$currPos = s5;
                                            s5 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                    }
                    else {
                        s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s6 = peg$c101;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c102);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c281(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaTupleType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c99;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c100);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaPrimitiveType();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parsewhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c166;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c167);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsewhiteSpace();
                            if (s8 === peg$FAILED) {
                                s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseSchemaPrimitiveType();
                                if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$currPos;
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s7 = peg$c166;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c167);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsewhiteSpace();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parseSchemaPrimitiveType();
                                    if (s9 !== peg$FAILED) {
                                        s6 = [s6, s7, s8, s9];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s6 = peg$c101;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c102);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c282(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseVersion() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
            s1 = peg$c7;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c8);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c284.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c285);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c284.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c285);
                        }
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c286(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c283);
            }
        }
        return s0;
    }
    function peg$parseIndent() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        peg$silentFails++;
        s1 = peg$currPos;
        s2 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c288;
            peg$currPos++;
        }
        else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c289);
            }
        }
        if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s3 = peg$c288;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c289);
                    }
                }
            }
        }
        else {
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c290(s2);
            if (s3) {
                s3 = undefined;
            }
            else {
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        peg$silentFails--;
        if (s1 !== peg$FAILED) {
            peg$currPos = s0;
            s0 = undefined;
        }
        else {
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c287);
            }
        }
        return s0;
    }
    function peg$parseSameIndent() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s4 = peg$c288;
            peg$currPos++;
        }
        else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c289);
            }
        }
        while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.charCodeAt(peg$currPos) === 32) {
                s4 = peg$c288;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c289);
                }
            }
        }
        if (s3 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s4 = peg$c292(s3);
            if (s4) {
                s4 = undefined;
            }
            else {
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = undefined;
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (input.charCodeAt(peg$currPos) === 32) {
                s3 = peg$c288;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c289);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s3 = peg$c288;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c289);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c291);
            }
        }
        return s0;
    }
    function peg$parseSameOrMoreIndent() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s4 = peg$c288;
            peg$currPos++;
        }
        else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c289);
            }
        }
        while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.charCodeAt(peg$currPos) === 32) {
                s4 = peg$c288;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c289);
                }
            }
        }
        if (s3 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s4 = peg$c294(s3);
            if (s4) {
                s4 = undefined;
            }
            else {
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = undefined;
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (input.charCodeAt(peg$currPos) === 32) {
                s3 = peg$c288;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c289);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s3 = peg$c288;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c289);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c293);
            }
        }
        return s0;
    }
    function peg$parseReservedWord() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseDirectionArrow();
        if (s1 === peg$FAILED) {
            s1 = peg$parseDirection();
            if (s1 === peg$FAILED) {
                s1 = peg$parseRecipeHandleFate();
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c77) {
                        s1 = peg$c77;
                        peg$currPos += 8;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c78);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c193) {
                            s1 = peg$c193;
                            peg$currPos += 6;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c194);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c43) {
                                s1 = peg$c43;
                                peg$currPos += 6;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c44);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 9) === peg$c47) {
                                    s1 = peg$c47;
                                    peg$currPos += 9;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c48);
                                    }
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 6) === peg$c257) {
                                        s1 = peg$c257;
                                        peg$currPos += 6;
                                    }
                                    else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c258);
                                        }
                                    }
                                    if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 7) === peg$c231) {
                                            s1 = peg$c231;
                                            peg$currPos += 7;
                                        }
                                        else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c232);
                                            }
                                        }
                                        if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c106) {
                                                s1 = peg$c106;
                                                peg$currPos += 6;
                                            }
                                            else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c107);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            if (peg$c295.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c296);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c297);
                    }
                }
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                    s2 = undefined;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c298();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsebackquotedString() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 96) {
            s1 = peg$c300;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c301);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c302.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c303);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c302.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c303);
                        }
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 96) {
                    s3 = peg$c300;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c301);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c304(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c299);
            }
        }
        return s0;
    }
    function peg$parseid() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c306;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c307);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c308.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c309);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c308.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c309);
                        }
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                    s3 = peg$c306;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c307);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.length > peg$currPos) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c297);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c310();
                    }
                    s3 = s4;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c311(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c305);
            }
        }
        return s0;
    }
    function peg$parseupperIdent() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c313.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c314);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c315.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c316);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c315.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c316);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c312);
            }
        }
        return s0;
    }
    function peg$parselowerIdent() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseReservedWord();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
            s1 = undefined;
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (peg$c318.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c319);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = [];
                if (peg$c315.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c316);
                    }
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$c315.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c316);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c19();
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c317);
            }
        }
        return s0;
    }
    function peg$parsefieldName() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c318.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c319);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c315.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c316);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c315.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c316);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c320);
            }
        }
        return s0;
    }
    function peg$parsedottedName() {
        let s0, s1, s2, s3, s4, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesimpleName();
        if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c217;
                peg$currPos++;
            }
            else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c218);
                }
            }
            if (s5 !== peg$FAILED) {
                s6 = peg$parsesimpleName();
                if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                    s5 = peg$c217;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c218);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsesimpleName();
                    if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            }
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c321);
            }
        }
        return s0;
    }
    function peg$parsesimpleName() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c323.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c324);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c325.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c326);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c325.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c326);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c327();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c322);
            }
        }
        return s0;
    }
    function peg$parsewhiteSpace() {
        let s0, s1;
        peg$silentFails++;
        s0 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c288;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c289);
            }
        }
        if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
                s0.push(s1);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s1 = peg$c288;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c289);
                    }
                }
            }
        }
        else {
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c328);
            }
        }
        return s0;
    }
    function peg$parseeolWhiteSpace() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c330.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c331);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c330.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c331);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c297);
                }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
                s2 = undefined;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c330.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c331);
                }
            }
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c330.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c331);
                    }
                }
            }
            if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c332) {
                    s2 = peg$c332;
                    peg$currPos += 2;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c333);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (peg$c17.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c18);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c17.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c18);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseeolWhiteSpace();
                        if (s4 !== peg$FAILED) {
                            s1 = [s1, s2, s3, s4];
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                if (peg$c330.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c331);
                    }
                }
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (peg$c330.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c331);
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseeol();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseeolWhiteSpace();
                        if (s3 === peg$FAILED) {
                            s3 = null;
                        }
                        if (s3 !== peg$FAILED) {
                            s1 = [s1, s2, s3];
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c329);
            }
        }
        return s0;
    }
    function peg$parseeol() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c335;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c336);
            }
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c337;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c338);
                }
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 13) {
                    s3 = peg$c335;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c336);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c334);
            }
        }
        return s0;
    }
    let indent = '';
    let startIndent = '';
    const indents = [];
    const emptyRef = () => ({ kind: 'handle-ref', id: null, name: null, tags: [], location: location() });
    function extractIndented(items) {
        return items[1].map(item => item[1]);
    }
    function optional(result, extract, defaultValue) {
        if (result !== null) {
            const value = extract(result);
            if (value !== null) {
                return value;
            }
        }
        return defaultValue === null ? null : defaultValue;
    }
    function checkNormal(result) {
        if (['string', 'number', 'boolean'].includes(typeof result) || result === null) {
            return;
        }
        if (result === undefined) {
            error(`result was undefined`);
        }
        if (Array.isArray(result)) {
            for (const item of result) {
                checkNormal(item);
            }
            return;
        }
        if (result.model) {
            error(`unexpected 'model' in ${JSON.stringify(result)}`);
        }
        if (!result.location) {
            error(`no 'location' in ${JSON.stringify(result)}`);
        }
        if (!result.kind) {
            error(`no 'kind' in ${JSON.stringify(result)}`);
        }
        for (const key of Object.keys(result)) {
            if (['location', 'kind'].includes(key)) {
                continue;
            }
            checkNormal(result[key]);
        }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
    }
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
const parse = peg$parse;

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
async function digest(str) {
    const sha = crypto$1.createHash('sha1');
    sha.update(str);
    return Promise.resolve().then(() => sha.digest('hex'));
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ManifestMeta {
    constructor() {
        this.storageKey = null;
        this.name = null;
    }
    apply(items) {
        items.forEach(item => { this[item.key] = item.value; });
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class EndPoint {
}
class ParticleEndPoint extends EndPoint {
    constructor(particle, connection) {
        super();
        this.particle = particle;
        this.connection = connection;
    }
    _clone(cloneMap) {
        return new ParticleEndPoint(this.particle, this.connection);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.particle.name, other.particle.name)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.connection, other.connection)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap) {
        if (!this.connection) {
            return `${this.particle.name}`;
        }
        return `${this.particle.name}.${this.connection}`;
    }
}
class InstanceEndPoint extends EndPoint {
    constructor(instance, connection) {
        super();
        assert(instance);
        //this.recipe = instance.recipe;
        this.instance = instance;
        this.connection = connection;
    }
    _clone(cloneMap) {
        return new InstanceEndPoint(cloneMap.get(this.instance), this.connection);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareComparables(this.instance, other.instance)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.connection, other.connection)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap) {
        if (!this.connection) {
            return `${nameMap.get(this.instance)}`;
        }
        return `${nameMap.get(this.instance)}.${this.connection}`;
    }
}
class HandleEndPoint extends EndPoint {
    constructor(handle) {
        super();
        this.handle = handle;
    }
    _clone(cloneMap = undefined) {
        return new HandleEndPoint(this.handle);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.handle.localName, other.handle.localName)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap = undefined) {
        return `${this.handle.localName}`;
    }
}
class TagEndPoint extends EndPoint {
    constructor(tags) {
        super();
        this.tags = tags;
    }
    _clone(cloneMap = undefined) {
        return new TagEndPoint(this.tags);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareArrays(this.tags, other.tags, compareStrings)) !== 0)
            return cmp;
        return 0;
    }
    // TODO: nameMap is not used. Remove it?
    toString(nameMap = undefined) {
        return this.tags.map(a => `#${a}`).join(' ');
    }
}
//type EndPoint = ParticleEndPoint | InstanceEndPoint | HandleEndPoint | TagEndPoint;
class ConnectionConstraint {
    constructor(fromConnection, toConnection, direction, type) {
        assert(direction);
        assert(type);
        this.from = fromConnection;
        this.to = toConnection;
        this.direction = direction;
        this.type = type;
        Object.freeze(this);
    }
    _copyInto(recipe, cloneMap) {
        if (this.type === 'constraint') {
            if (this.from instanceof InstanceEndPoint || this.to instanceof InstanceEndPoint) {
                assert(false, `Can't have connection constraints of type constraint with InstanceEndPoints`);
            }
            else {
                return recipe.newConnectionConstraint(this.from._clone(), this.to._clone(), this.direction);
            }
        }
        return recipe.newObligation(this.from._clone(cloneMap), this.to._clone(cloneMap), this.direction);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = this.from._compareTo(other.from)) !== 0)
            return cmp;
        if ((cmp = this.to._compareTo(other.to)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.direction, other.direction)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap, options) {
        let unresolved = '';
        if (options && options.showUnresolved === true && this.type === 'obligation') {
            unresolved = ' // unresolved obligation';
        }
        return `${this.from.toString(nameMap)} ${this.direction} ${this.to.toString(nameMap)}${unresolved}`;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function directionToArrow(direction) {
    // Use switch for totality checking.
    switch (direction) {
        case 'out':
            return '->';
        case 'in':
            return '<-';
        case 'inout':
            return '<->';
        case '`consume':
            return 'consume';
        case '`provide':
            return 'provide';
        case 'host':
            return '='; // TODO(cypher1): Check this
        case 'any':
            return '=';
        default:
            throw new Error(`Bad direction ${direction}`);
    }
}
function arrowToDirection(arrow) {
    // Use switch for totality checking.
    switch (arrow) {
        case '->':
            return 'out';
        case '<-':
            return 'in';
        case '<->':
            return 'inout';
        case 'consume':
            return '`consume';
        case 'provide':
            return '`provide';
        case '=':
            return 'any';
        default:
            // Catch nulls and unsafe values from javascript.
            throw new Error(`Bad arrow ${arrow}`);
    }
}
function reverseArrow(arrow) {
    switch (arrow) {
        case '->':
            return '<-';
        case '<-':
            return '->';
        case '<->':
            return '<->';
        case 'consume':
            return 'provide';
        case 'provide':
            return 'consume';
        case '=':
            return '=';
        default:
            // Catch nulls and unsafe values from javascript.
            throw new Error(`Bad arrow ${arrow}`);
    }
}
function connectionMatchesHandleDirection(connectionDirection, handleDirection) {
    return acceptedDirections(connectionDirection).includes(handleDirection);
}
function acceptedDirections(direction) {
    // @param direction: the direction of a handleconnection.
    // @return acceptedDirections: the list of directions a handle can have that
    // are allowed with this handle connection.
    //
    switch (direction) {
        case 'any':
            return ['any', 'in', 'out', 'inout', 'host', '`consume', '`provide'];
        case 'in':
            return ['any', 'in', 'inout', 'host', '`consume'];
        case 'out':
            return ['any', 'out', 'inout', '`provide'];
        case 'inout':
            return ['any', 'inout'];
        case 'host':
            return ['any', 'host'];
        case '`consume':
            return ['any', '`consume'];
        case '`provide':
            return ['any', '`provide'];
        default:
            // Catch nulls and unsafe values from javascript.
            throw new Error(`Bad direction ${direction}`);
    }
}
class Shape {
    constructor(recipe, particles, handles, hcs) {
        this.recipe = recipe;
        this.particles = particles;
        this.handles = handles;
        this.reverse = new Map();
        for (const p of Object.keys(particles)) {
            this.reverse.set(particles[p], p);
        }
        for (const h of handles.keys()) {
            this.reverse.set(handles.get(h), h);
        }
        for (const hc of Object.keys(hcs)) {
            this.reverse.set(hcs[hc], hc);
        }
    }
}
class RecipeUtil {
    static makeShape(particles, handles, map, recipe) {
        recipe = recipe || new Recipe();
        const pMap = {};
        const hMap = new Map();
        const hcMap = {};
        particles.forEach(particle => pMap[particle] = recipe.newParticle(particle));
        handles.forEach(handle => hMap.set(handle, recipe.newHandle()));
        Object.keys(map).forEach(key => {
            Object.keys(map[key]).forEach(name => {
                const handle = map[key][name];
                const tags = handle.tags || [];
                if (handle.localName) {
                    hMap.get(handle.handle).localName = handle.localName;
                }
                const connection = pMap[key].addConnectionName(name);
                // NOTE: for now, 'any' on the connection and '=' on the shape means 'accept anything'.
                connection.direction = arrowToDirection(handle.direction || '=');
                hMap.get(handle.handle).tags = tags;
                connection.connectToHandle(hMap.get(handle.handle));
                hcMap[key + ':' + name] = pMap[key].connections[name];
            });
        });
        return new Shape(recipe, pMap, hMap, hcMap);
    }
    static recipeToShape(recipe) {
        const particles = {};
        let id = 0;
        recipe.particles.forEach(particle => particles[particle.name] = particle);
        const handles = new Map();
        recipe.handles.forEach(handle => handles.set('h' + id++, handle));
        const hcs = {};
        recipe.handleConnections.forEach(hc => hcs[hc.particle.name + ':' + hc.name] = hc);
        return new Shape(recipe, particles, handles, hcs);
    }
    static _buildNewHCMatches(recipe, shapeHC, match, outputList) {
        const { forward, reverse, score } = match;
        let matchFound = false;
        for (const recipeParticle of recipe.particles) {
            if (!recipeParticle.spec) {
                continue;
            }
            for (const recipeConnSpec of recipeParticle.spec.handleConnections) {
                // TODO are there situations where multiple handleConnections should
                // be allowed to point to the same one in the recipe?
                if (reverse.has(recipeConnSpec)) {
                    continue;
                }
                // TODO support unnamed shape particles.
                if (recipeParticle.name !== shapeHC.particle.name) {
                    continue;
                }
                if (shapeHC.name && shapeHC.name !== recipeConnSpec.name) {
                    continue;
                }
                if (!connectionMatchesHandleDirection(shapeHC.direction, recipeConnSpec.direction)) {
                    continue;
                }
                const recipeHC = recipeParticle.connections[recipeConnSpec.name];
                if (shapeHC.handle && recipeHC && recipeHC.handle && shapeHC.handle.localName &&
                    shapeHC.handle.localName !== recipeHC.handle.localName) {
                    continue;
                }
                // recipeHC is a candidate for shapeHC. shapeHC references a
                // particle, so recipeHC must reference the matching particle,
                // or a particle that isn't yet mapped from shape.
                if (reverse.has(recipeParticle)) {
                    if (reverse.get(recipeParticle) !== shapeHC.particle) {
                        continue;
                    }
                }
                else if (forward.has(shapeHC.particle)) {
                    // we've already mapped the particle referenced by shapeHC
                    // and it doesn't match recipeHC's particle as recipeHC's
                    // particle isn't mapped
                    continue;
                }
                // shapeHC doesn't necessarily reference a handle, but if it does
                // then recipeHC needs to reference the matching handle, or one
                // that isn't yet mapped, or no handle yet.
                if (shapeHC.handle && recipeHC && recipeHC.handle) {
                    if (reverse.has(recipeHC.handle)) {
                        if (reverse.get(recipeHC.handle) !== shapeHC.handle) {
                            continue;
                        }
                    }
                    else if (forward.has(shapeHC.handle) && forward.get(shapeHC.handle) !== null) {
                        continue;
                    }
                    // Check whether shapeHC and recipeHC reference the same handle.
                    if (shapeHC.handle.fate !== 'create' || (recipeHC.handle.fate !== 'create' && recipeHC.handle.originalFate !== 'create')) {
                        if (Boolean(shapeHC.handle.immediateValue) !== Boolean(recipeHC.handle.immediateValue)) {
                            continue; // One is an immediate value handle and the other is not.
                        }
                        if (recipeHC.handle.immediateValue) {
                            if (!recipeHC.handle.immediateValue.equals(shapeHC.handle.immediateValue)) {
                                continue; // Immediate values are different.
                            }
                        }
                        else {
                            // Note: the id of a handle with 'copy' fate changes during recipe instantiation, hence comparing to original id too.
                            // Skip the check if handles have 'create' fate (their ids are arbitrary).
                            if (shapeHC.handle.id !== recipeHC.handle.id && shapeHC.handle.id !== recipeHC.handle.originalId) {
                                continue; // This is a different handle.
                            }
                        }
                    }
                }
                // clone forward and reverse mappings and establish new components.
                const newMatch = { forward: new Map(forward), reverse: new Map(reverse), score };
                assert(!newMatch.reverse.has(recipeParticle) || newMatch.reverse.get(recipeParticle) === shapeHC.particle);
                assert(!newMatch.forward.has(shapeHC.particle) || newMatch.forward.get(shapeHC.particle) === recipeParticle);
                newMatch.forward.set(shapeHC.particle, recipeParticle);
                newMatch.reverse.set(recipeParticle, shapeHC.particle);
                if (shapeHC.handle) {
                    if (!recipeHC || !recipeHC.handle) {
                        if (!newMatch.forward.has(shapeHC.handle)) {
                            newMatch.forward.set(shapeHC.handle, null);
                            newMatch.score -= 2;
                        }
                    }
                    else {
                        newMatch.forward.set(shapeHC.handle, recipeHC.handle);
                        newMatch.reverse.set(recipeHC.handle, shapeHC.handle);
                    }
                }
                newMatch.forward.set(shapeHC, recipeConnSpec);
                newMatch.reverse.set(recipeConnSpec, shapeHC);
                outputList.push(newMatch);
                matchFound = true;
            }
        }
        if (matchFound === false) {
            // Non-null particle in the `forward` map means that some of the particle
            // handle connections were successful matches, but some couldn't be matched.
            // It means that this match in invalid.
            if (match.forward.get(shapeHC.particle)) {
                return;
            }
            // The current handle connection from the shape doesn't match anything
            // in the recipe. Find (or create) a particle for it.
            const newMatches = [];
            RecipeUtil._buildNewParticleMatches(recipe, shapeHC.particle, match, newMatches);
            newMatches.forEach(newMatch => {
                // the shape references a handle, might also need to create a recipe
                // handle for it (if there isn't already one from a previous match).
                if (shapeHC.handle && !newMatch.forward.has(shapeHC.handle)) {
                    newMatch.forward.set(shapeHC.handle, null);
                    newMatch.score -= 2;
                }
                newMatch.forward.set(shapeHC, null);
                newMatch.score -= 1;
                outputList.push(newMatch);
            });
        }
    }
    static _buildNewParticleMatches(recipe, shapeParticle, match, newMatches) {
        const { forward, reverse, score } = match;
        let matchFound = false;
        for (const recipeParticle of recipe.particles) {
            if (reverse.has(recipeParticle)) {
                continue;
            }
            if (recipeParticle.name !== shapeParticle.name) {
                continue;
            }
            let handleNamesMatch = true;
            for (const connectionName of Object.keys(recipeParticle.connections)) {
                const recipeConnection = recipeParticle.connections[connectionName];
                if (!recipeConnection.handle) {
                    continue;
                }
                const shapeConnection = shapeParticle.connections[connectionName];
                if (shapeConnection && shapeConnection.handle && shapeConnection.handle.localName && shapeConnection.handle.localName !== recipeConnection.handle.localName) {
                    handleNamesMatch = false;
                    break;
                }
            }
            if (!handleNamesMatch) {
                continue;
            }
            const newMatch = { forward: new Map(forward), reverse: new Map(reverse), score };
            assert(!newMatch.forward.has(shapeParticle) || newMatch.forward.get(shapeParticle) === recipeParticle);
            assert(!newMatch.reverse.has(recipeParticle) || newMatch.reverse.get(recipeParticle) === shapeParticle);
            newMatch.forward.set(shapeParticle, recipeParticle);
            newMatch.reverse.set(recipeParticle, shapeParticle);
            newMatches.push(newMatch);
            matchFound = true;
        }
        if (matchFound === false) {
            const newMatch = { forward: new Map(), reverse: new Map(), score: 0 };
            forward.forEach((value, key) => {
                assert(!newMatch.forward.has(key) || newMatch.forward.get(key) === value);
                newMatch.forward.set(key, value);
            });
            reverse.forEach((value, key) => {
                assert(!newMatch.reverse.has(key) || newMatch.reverse.get(key) === value);
                newMatch.reverse.set(key, value);
            });
            if (!newMatch.forward.has(shapeParticle)) {
                newMatch.forward.set(shapeParticle, null);
                newMatch.score = match.score - 1;
            }
            newMatches.push(newMatch);
        }
    }
    static _assignHandlesToEmptyPosition(shape, match, emptyHandles, nullHandles) {
        if (emptyHandles.length === 1) {
            const matches = [];
            const { forward, reverse, score } = match;
            for (const nullHandle of nullHandles) {
                let tagsMatch = true;
                for (const tag of nullHandle.tags) {
                    if (!emptyHandles[0].tags.includes(tag)) {
                        tagsMatch = false;
                        break;
                    }
                }
                if (!tagsMatch) {
                    continue;
                }
                const newMatch = { forward: new Map(forward), reverse: new Map(reverse), score: score + 1 };
                newMatch.forward.set(nullHandle, emptyHandles[0]);
                newMatch.reverse.set(emptyHandles[0], nullHandle);
                matches.push(newMatch);
            }
            return matches;
        }
        const thisHandle = emptyHandles.pop();
        const matches = RecipeUtil._assignHandlesToEmptyPosition(shape, match, emptyHandles, nullHandles);
        let newMatches = [];
        for (const match of matches) {
            const nullHandles = [...shape.handles.values()].filter(handle => match.forward.get(handle) === null);
            if (nullHandles.length > 0) {
                newMatches = newMatches.concat(RecipeUtil._assignHandlesToEmptyPosition(shape, match, [thisHandle], nullHandles));
            }
            else {
                newMatches = newMatches.concat(match);
            }
        }
        return newMatches;
    }
    static find(recipe, shape) {
        // Particles and Handles are initially stored by a forward map from
        // shape component to recipe component.
        // Handle connections, particles and handles are also stored by a reverse map
        // from recipe component to shape component.
        // Start with a single, empty match
        let matches = [{ forward: new Map(), reverse: new Map(), score: 0 }];
        for (const shapeHC of shape.recipe.handleConnections) {
            const newMatches = [];
            for (const match of matches) {
                // collect matching handle connections into a new matches list
                RecipeUtil._buildNewHCMatches(recipe, shapeHC, match, newMatches);
            }
            matches = newMatches;
        }
        for (const shapeParticle of shape.recipe.particles) {
            if (Object.keys(shapeParticle.connections).length > 0) {
                continue;
            }
            if (shapeParticle.unnamedConnections.length > 0) {
                continue;
            }
            const newMatches = [];
            for (const match of matches) {
                RecipeUtil._buildNewParticleMatches(recipe, shapeParticle, match, newMatches);
            }
            matches = newMatches;
        }
        const emptyHandles = recipe.handles.filter(handle => handle.connections.length === 0);
        if (emptyHandles.length > 0) {
            let newMatches = [];
            for (const match of matches) {
                const nullHandles = [...shape.handles.values()].filter(handle => match.forward.get(handle) === null);
                if (nullHandles.length > 0) {
                    newMatches = newMatches.concat(RecipeUtil._assignHandlesToEmptyPosition(shape, match, emptyHandles, nullHandles));
                }
                else {
                    newMatches = newMatches.concat(match);
                }
            }
            matches = newMatches;
        }
        return matches.map((match) => {
            const result = {};
            match.forward.forEach((value, key) => result[shape.reverse.get(key)] = value);
            return { match: result, score: match.score };
        });
    }
    static constructImmediateValueHandle(connection, particleSpec, id) {
        assert(connection.type instanceof InterfaceType);
        if (!(connection.type instanceof InterfaceType) ||
            !connection.type.interfaceInfo.restrictType(particleSpec)) {
            // Type of the connection does not match the ParticleSpec.
            return null;
        }
        // The connection type may have type variables:
        // E.g. if connection shape requires `in ~a *`
        //      and particle has `in Entity input`
        //      then type system has to ensure ~a is at least Entity.
        // The type of a handle hosting the particle literal has to be
        // concrete, so we concretize connection type with maybeEnsureResolved().
        const handleType = connection.type.clone(new Map());
        handleType.maybeEnsureResolved();
        const handle = connection.recipe.newHandle();
        handle.id = id.toString();
        handle.mappedType = handleType;
        handle.fate = 'copy';
        handle.immediateValue = particleSpec;
        return handle;
    }
    static directionCounts(handle) {
        const counts = { 'in': 0, 'out': 0, 'inout': 0, 'host': 0, '`consume': 0, '`provide': 0, 'any': 0 };
        for (const connection of handle.connections) {
            counts[connection.direction]++;
        }
        counts.in += counts.inout;
        counts.out += counts.inout;
        return counts;
    }
    // Returns true if `otherRecipe` matches the shape of recipe.
    static matchesRecipe(recipe, otherRecipe) {
        const shape = RecipeUtil.recipeToShape(otherRecipe);
        const result = RecipeUtil.find(recipe, shape);
        return result.some(r => r.score === 0);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class HandleConnection {
    constructor(name, particle) {
        this._tags = [];
        this.resolvedType = undefined;
        this._direction = 'any';
        this._handle = undefined;
        assert(particle);
        assert(particle.recipe);
        this._recipe = particle.recipe;
        this._name = name;
        this._particle = particle;
    }
    _clone(particle, cloneMap) {
        if (cloneMap.has(this)) {
            return cloneMap.get(this);
        }
        const handleConnection = new HandleConnection(this._name, particle);
        handleConnection._tags = [...this._tags];
        // Note: _resolvedType will be cloned later by the particle that references this connection.
        // Doing it there allows the particle to maintain variable associations across the particle
        // scope.
        handleConnection.resolvedType = this.resolvedType;
        handleConnection._direction = this._direction;
        if (this._handle != undefined) {
            handleConnection._handle = cloneMap.get(this._handle);
            assert(handleConnection._handle !== undefined);
            handleConnection._handle.connections.push(handleConnection);
        }
        cloneMap.set(this, handleConnection);
        return handleConnection;
    }
    // Note: don't call this method directly, only called from particle cloning.
    cloneTypeWithResolutions(variableMap) {
        if (this.resolvedType) {
            this.resolvedType = this.resolvedType._cloneWithResolutions(variableMap);
        }
    }
    _normalize() {
        this._tags.sort();
        // TODO: type?
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareComparables(this._particle, other._particle)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._name, other._name)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        if ((cmp = compareComparables(this._handle, other._handle)) !== 0)
            return cmp;
        // TODO: add type comparison
        // if ((cmp = compareStrings(this._type, other._type)) != 0) return cmp;
        if ((cmp = compareStrings(this._direction, other._direction)) !== 0)
            return cmp;
        return 0;
    }
    get recipe() { return this._recipe; }
    get name() { return this._name; } // Parameter name?
    getQualifiedName() { return `${this.particle.name}::${this.name}`; }
    get tags() { return this._tags; }
    get type() {
        if (this.resolvedType) {
            return this.resolvedType;
        }
        const spec = this.spec;
        // TODO: We need a global way to generate variables so that everything can
        // have proper type bounds.
        return spec ? spec.type : undefined;
    }
    get direction() {
        // TODO: Should take the most strict of the direction and the spec direction.
        if (this._direction !== 'any') {
            return this._direction;
        }
        const spec = this.spec;
        return spec ? spec.direction : 'any';
    }
    get isInput() {
        return this.direction === 'in' || this.direction === 'inout';
    }
    get isOutput() {
        return this.direction === 'out' || this.direction === 'inout';
    }
    get handle() { return this._handle; } // Handle?
    get particle() { return this._particle; } // never null
    set tags(tags) { this._tags = tags; }
    set type(type) {
        this.resolvedType = type;
        this._resetHandleType();
    }
    set direction(direction) {
        if (direction === null) {
            throw new Error(`Invalid direction '${direction}' for handle connection '${this.getQualifiedName()}'`);
        }
        this._direction = direction;
        this._resetHandleType();
    }
    get spec() {
        if (this.particle.spec == null) {
            return null;
        }
        return this.particle.spec.handleConnectionMap.get(this.name);
    }
    toSlotConnection() {
        // TODO: Remove in SLANDLESv2
        if (!this.handle || this.handle.fate !== '`slot') {
            return undefined;
        }
        const slandle = new SlotConnection(this.name, this.particle);
        slandle.tags = this.tags;
        slandle.targetSlot = this.handle && this.handle.toSlot();
        return slandle;
    }
    get isOptional() {
        if (this.spec == null) {
            return false;
        }
        return this.spec.isOptional;
    }
    _isValid(options) {
        // Note: The following casts are necessary to catch invalid values that typescript does not manage to check).
        if (this.direction === null || this.direction === undefined) {
            if (options && options.errors) {
                options.errors.set(this, `Invalid direction '${this.direction}' for handle connection '${this.getQualifiedName()}'`);
            }
            return false;
        }
        if (this.particle.spec && this.name) {
            const connectionSpec = this.spec;
            if (!connectionSpec) {
                if (options && options.errors) {
                    options.errors.set(this, `Connection ${this.name} is not defined by ${this.particle.name}.`);
                }
                return false;
            }
            if (!acceptedDirections(this.direction).includes(connectionSpec.direction)) {
                if (options && options.errors) {
                    options.errors.set(this, `Direction '${this.direction}' for handle connection '${this.getQualifiedName()}' doesn't match particle spec's direction '${connectionSpec.direction}'`);
                }
                return false;
            }
            if (this.resolvedType) {
                if (!connectionSpec.isCompatibleType(this.resolvedType)) {
                    if (options && options.errors) {
                        options.errors.set(this, `Type '${this.resolvedType.toString()} for handle connection '${this.getQualifiedName()}' doesn't match particle spec's type '${connectionSpec.type.toString()}'`);
                    }
                    return false;
                }
            }
            else {
                this.resolvedType = connectionSpec.type;
            }
        }
        return true;
    }
    isResolved(options) {
        assert(Object.isFrozen(this));
        let parent;
        if (this.spec && this.spec.parentConnection) {
            parent = this.particle.connections[this.spec.parentConnection.name];
            if (!parent) {
                if (options) {
                    options.details = `parent connection '${this.spec.parentConnection.name}' missing`;
                }
                return false;
            }
            if (!parent.handle) {
                if (options) {
                    options.details = `parent connection '${this.spec.parentConnection.name}' missing handle`;
                }
                return false;
            }
        }
        if (!this.handle) {
            if (this.isOptional) {
                // We're optional we don't need to resolve.
                return true;
            }
            // We're not optional we do need to resolve.
            if (options) {
                options.details = 'missing handle';
            }
            return false;
        }
        if (!this.direction) {
            if (options) {
                options.details = 'missing direction';
            }
            return false;
        }
        // TODO: This should use this._type, or possibly not consider type at all.
        if (!this.type) {
            if (options) {
                options.details = 'missing type';
            }
            return false;
        }
        return true;
    }
    _resetHandleType() {
        if (this._handle) {
            this._handle._type = undefined;
        }
    }
    connectToHandle(handle) {
        assert(handle.recipe === this.recipe);
        this._handle = handle;
        this._resetHandleType();
        this._handle.connections.push(this);
    }
    disconnectHandle() {
        const idx = this._handle.connections.indexOf(this);
        assert(idx >= 0);
        this._handle.connections.splice(idx, 1);
        this._handle = undefined;
    }
    toString(nameMap, options) {
        const result = [];
        result.push(this.name || '*');
        result.push(directionToArrow(this.direction));
        if (this.handle) {
            if (this.handle.immediateValue) {
                result.push(this.handle.immediateValue.name);
            }
            else {
                result.push(`${(nameMap && nameMap.get(this.handle)) || this.handle.localName}`);
            }
        }
        result.push(...this.tags.map(a => `#${a}`));
        if (options && options.showUnresolved) {
            if (!this.isResolved(options)) {
                result.push(`// unresolved handle-connection: ${options.details}`);
            }
        }
        return result.join(' ');
    }
    // TODO: the logic is wrong :)
    findSpecsForUnnamedHandles() {
        return this.particle.spec.handleConnections.filter(specConn => {
            // filter specs with matching types that don't have handles bound to the corresponding handle connection.
            return !specConn.isOptional &&
                TypeChecker.compareTypes({ type: this.handle.type }, { type: specConn.type }) &&
                !this.particle.getConnectionByName(specConn.name);
        });
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Particle {
    constructor(recipe, name) {
        this._id = undefined;
        this._localName = undefined;
        this.spec = undefined;
        this._verbs = [];
        this._tags = [];
        this._connections = {};
        // TODO: replace with constraint connections on the recipe
        this._unnamedConnections = [];
        // map of consumed Slot connections by slot name.
        this._consumedSlotConnections = {};
        assert(recipe);
        this._recipe = recipe;
        this._name = name;
    }
    _copyInto(recipe, cloneMap, variableMap) {
        const particle = recipe.newParticle(this._name);
        particle._id = this._id;
        particle._verbs = [...this._verbs];
        particle._tags = [...this._tags];
        particle.spec = this.spec ? this.spec.cloneWithResolutions(variableMap) : undefined;
        Object.keys(this._connections).forEach(key => {
            particle._connections[key] = this._connections[key]._clone(particle, cloneMap);
        });
        particle._unnamedConnections = this._unnamedConnections.map(connection => connection._clone(particle, cloneMap));
        particle._cloneConnectionRawTypes(variableMap);
        for (const key of this.getSlotConnectionNames()) {
            const slotConn = this.getSlotConnectionByName(key);
            particle._consumedSlotConnections[key] = slotConn._clone(particle, cloneMap);
            // if recipe is a requireSection, then slot may already exist in recipe.
            if (cloneMap.has(slotConn.targetSlot)) {
                assert(recipe instanceof RequireSection);
                const targetSlot = cloneMap.get(slotConn.targetSlot);
                particle.getSlotConnectionByName(key).connectToSlot(targetSlot);
                if (particle.recipe.slots.indexOf(targetSlot) === -1) {
                    particle.recipe.slots.push(targetSlot);
                }
            }
            for (const [name, slot] of Object.entries(slotConn.providedSlots)) {
                if (cloneMap.has(slot)) {
                    assert(recipe instanceof RequireSection);
                    const clonedSlot = cloneMap.get(slot);
                    clonedSlot.sourceConnection = particle.getSlotConnectionByName(key);
                    particle.getSlotConnectionByName(key).providedSlots[name] = clonedSlot;
                    if (particle.recipe.slots.indexOf(clonedSlot) === -1) {
                        particle.recipe.slots.push(clonedSlot);
                    }
                }
            }
        }
        return particle;
    }
    _cloneConnectionRawTypes(variableMap) {
        for (const connection of Object.values(this._connections)) {
            connection.cloneTypeWithResolutions(variableMap);
        }
        for (const connection of this._unnamedConnections) {
            connection.cloneTypeWithResolutions(variableMap);
        }
    }
    _startNormalize() {
        this._localName = null;
        this._verbs.sort();
        this._tags.sort();
        const normalizedConnections = {};
        for (const key of (Object.keys(this._connections).sort())) {
            normalizedConnections[key] = this._connections[key];
        }
        this._connections = normalizedConnections;
        const normalizedSlotConnections = {};
        for (const key of this.getSlotConnectionNames().sort()) {
            normalizedSlotConnections[key] = this.getSlotConnectionByName(key);
        }
        this._consumedSlotConnections = normalizedSlotConnections;
    }
    _finishNormalize() {
        this._unnamedConnections.sort(compareComparables);
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this._id ? this._id.toString() : '', other._id ? other._id.toString() : '')) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._name, other._name)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._localName, other._localName)) !== 0)
            return cmp;
        // TODO: spec?
        if ((cmp = compareArrays(this._verbs, other._verbs, compareStrings)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        // TODO: slots
        return 0;
    }
    /**
     * Param particle matches this particle if the names are the same and the slot and handle requirements this particle
     * is a subset of the slot and handle requirements of the param particle.
     * @param particle
     */
    matches(particle) {
        if (this.name && particle.name && this.name !== particle.name)
            return false;
        for (const name of this.getSlotConnectionNames()) {
            const slotConn = this.getSlotConnectionByName(name);
            if (particle.getSlotConnectionByName(name) == undefined
                || particle.getSlotConnectionByName(name).targetSlot == undefined)
                return false;
            if (slotConn.targetSlot && slotConn.targetSlot.id && slotConn.targetSlot.id !== particle.getSlotConnectionByName(name).targetSlot.id)
                return false;
            for (const pname of Object.keys(slotConn.providedSlots)) {
                const slot = slotConn.providedSlots[pname];
                const pslot = particle.getSlotConnectionByName(name).providedSlots[pname];
                if (pslot == undefined || (slot.id && pslot.id && slot.id !== pslot.id))
                    return false;
            }
        }
        return true;
    }
    _isValid(options) {
        if (!this.spec) {
            return true;
        }
        if (!this.name && !this.primaryVerb) {
            // Must have either name of a verb
            if (options && options.errors) {
                options.errors.set(this, `Particle has no name and no verb`);
            }
            return false;
        }
        // TODO: What
        return true;
    }
    isResolved(options = undefined) {
        assert(Object.isFrozen(this));
        if (!this.spec) {
            if (options && options.showUnresolved) {
                options.details = 'missing spec';
            }
            return false;
        }
        const slandleConnections = Object.values(this.connections).filter(connection => connection.type.isSlot()
            || (connection.type.isCollectionType() && connection.type.getContainedType().isSlot()));
        if (slandleConnections.length === 0 && this.spec.slotConnections.size > 0) {
            const fulfilledSlotConnections = this.getSlotConnections().filter(connection => connection.targetSlot !== undefined);
            if (fulfilledSlotConnections.length === 0) {
                if (options && options.showUnresolved) {
                    options.details = `unfulfilled slot connections ${JSON.stringify([...this.spec.slotConnections])}`;
                }
                return false;
            }
        }
        if (!this.spec) {
            if (options && options.showUnresolved) {
                options.details = 'missing spec';
            }
            return false;
        }
        const unresolvedRequiredConnections = this.getUnboundConnections().filter(connSpec => {
            // A non-optional connection dependent on an optional and unresolved is ok.
            let parent = connSpec.parentConnection;
            while (parent !== null) {
                if (!this.connections[parent.name]) {
                    return false;
                }
                parent = parent.parentConnection;
            }
            return true;
        });
        if (unresolvedRequiredConnections.length > 0) {
            if (options && options.showUnresolved) {
                options.details = `unresolved connections: ${unresolvedRequiredConnections.map(c => c.name).join(', ')}`;
            }
            return false;
        }
        if (this.unnamedConnections.length !== 0) {
            if (options && options.showUnresolved) {
                options.details = `${this.unnamedConnections.length} unnamed connections`;
            }
            return false;
        }
        return true;
    }
    get recipe() { return this._recipe; }
    get localName() { return this._localName; }
    set localName(name) { this._localName = name; }
    get id() { return this._id; } // Not resolved until we have an ID.
    set id(id) { assert(!this._id, 'Particle ID can only be set once.'); this._id = id; }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    get connections() { return this._connections; } // {parameter -> HandleConnection}
    get unnamedConnections() { return this._unnamedConnections; } // HandleConnection*
    get primaryVerb() { return (this._verbs.length > 0) ? this._verbs[0] : undefined; }
    set verbs(verbs) { this._verbs = verbs; }
    set tags(tags) { this._tags = tags; }
    addUnnamedConnection() {
        const connection = new HandleConnection(undefined, this);
        this._unnamedConnections.push(connection);
        return connection;
    }
    addConnectionName(name) {
        assert(name, `Cannot create connection with no name`);
        assert(this._connections[name] == undefined);
        this._connections[name] = new HandleConnection(name, this);
        return this._connections[name];
    }
    allConnections() {
        return Object.values(this._connections).concat(this._unnamedConnections);
    }
    ensureConnectionName(name) {
        return this._connections[name] || this.addConnectionName(name);
    }
    getSlotConnectionNames() {
        return Object.keys(this._consumedSlotConnections);
    }
    getSlandleConnectionByName(name) {
        if (name in this._connections) {
            const slandle = this._connections[name].toSlotConnection();
            return slandle;
        }
        return this._consumedSlotConnections[name];
    }
    getSlandleConnectionBySpec(spec) {
        return this.getSlandleConnections().find(slotConn => slotConn.getSlotSpec() === spec);
    }
    getSlotConnectionByName(name) {
        return this._consumedSlotConnections[name];
    }
    getSlotConnectionBySpec(spec) {
        return this.getSlotConnections().find(slotConn => slotConn.getSlotSpec() === spec);
    }
    getSlandleConnections() {
        // TODO(jopra): Revisit when slots are removed.
        return [...Object.values(this._consumedSlotConnections), ...this.allConnections().map(conn => conn.toSlotConnection()).filter(conn => conn)];
    }
    getSlotConnections() {
        // TODO(jopra): Revisit when slots are removed.
        return Object.values(this._consumedSlotConnections);
    }
    getSlotSpecByName(name) {
        if (!this.spec)
            return undefined;
        const slot = this.spec.slotConnections.get(name);
        if (slot)
            return slot;
        // TODO(jopra): Provided slots should always be listed in the particle spec.
        for (const slot of this.spec.slotConnections.values()) {
            for (const provided of slot.provideSlotConnections) {
                if (provided.name === name)
                    return provided;
            }
        }
        return undefined;
    }
    getProvidedSlotByName(consumeName, name) {
        const conn = this.getSlotConnectionByName(consumeName);
        return conn && conn.providedSlots[name];
    }
    getSlotSpecs() {
        if (this.spec)
            return this.spec.slotConnections;
        return new Map();
    }
    getConnectionByName(name) {
        return this._connections[name];
    }
    nameConnection(connection, name) {
        assert(!this._connections[name], `Connection "${name}" already has a handle`);
        const idx = this._unnamedConnections.indexOf(connection);
        assert(idx >= 0, `Cannot name '${name}' nonexistent unnamed connection.`);
        // TODO: FIX: The following is accessing a readonly field illegally.
        // tslint:disable-next-line: no-any
        connection._name = name;
        const connectionSpec = this.spec.getConnectionByName(name);
        connection.type = connectionSpec.type;
        if (connection.direction !== connectionSpec.direction) {
            assert(connection.direction === 'inout', `Unnamed connection cannot adjust direction ${connection.direction} to ${name}'s direction ${connectionSpec.direction}`);
            connection.direction = connectionSpec.direction;
        }
        this._connections[name] = connection;
        this._unnamedConnections.splice(idx, 1);
    }
    getUnboundConnections(type) {
        return this.spec.handleConnections.filter(connSpec => !connSpec.isOptional &&
            !this.getConnectionByName(connSpec.name) &&
            (!type || TypeChecker.compareTypes({ type }, { type: connSpec.type })));
    }
    addSlotConnection(name) {
        assert(!this.getSlotConnectionByName(name), 'slot connection already exists');
        const slandle = this.spec && this.spec.connections.find(conn => conn.name === name);
        const isSlandle = slandle && slandle.type.isSlot();
        const isSetSlandle = slandle && slandle.type.isCollectionType() && slandle.type.getContainedType().isSlot();
        assert(!this.spec || this.spec.slotConnections.has(name) || isSlandle || isSetSlandle, `slot connection '${name}' is not in particle spec`);
        const slotConn = this.addSlotConnectionAsCopy(name);
        const slotSpec = this.getSlotSpecByName(name);
        if (slotSpec) {
            slotSpec.provideSlotConnections.forEach(providedSlot => {
                const slot = this.recipe.newSlot(providedSlot.name);
                slot.sourceConnection = slotConn;
                slotConn.providedSlots[providedSlot.name] = slot;
                // TODO: hook the handles up
            });
        }
        return slotConn;
    }
    addSlotConnectionAsCopy(name) {
        // Called when a recipe and all of it's contents are being cloned.
        // Each slot connection in the existing recipe has to be created for the clone,
        // This method must not create slots for provided slot connections otherwise there
        // will be duplicate slots.
        const slotConn = new SlotConnection(name, this);
        this._consumedSlotConnections[name] = slotConn;
        return slotConn;
    }
    removeSlotConnection(slotConnection) {
        this._consumedSlotConnections[slotConnection.name] = null;
        slotConnection.disconnectFromSlot();
    }
    remove() {
        this.recipe.removeParticle(this);
    }
    isJavaParticle() {
        return this.spec && (this.spec.implFile || '').endsWith('java');
    }
    toString(options = {}, nameMap) {
        let result = [];
        // TODO: we need at least name or verb(s)
        if (this.name) {
            result.push(this.name);
            result.push(`as ${(nameMap && nameMap.get(this)) || this.localName}`);
            if (this.primaryVerb && this.primaryVerb !== this.name) {
                result.push(`// verb=${this.primaryVerb}`);
            }
        }
        else { // verb must exist, if there is no name.
            result.push(`&${this.primaryVerb}`);
        }
        if (options.showUnresolved) {
            if (!this.isResolved(options)) {
                result.push(`// unresolved particle: ${options.details}`);
            }
        }
        result = [result.join(' ')];
        for (const connection of this.unnamedConnections) {
            result.push(connection.toString(nameMap, options).replace(/^|(\n)/g, '$1  '));
        }
        for (const connection of Object.values(this.connections)) {
            result.push(connection.toString(nameMap, options).replace(/^|(\n)/g, '$1  '));
        }
        for (const slotConnection of this.getSlotConnections()) {
            result.push(slotConnection.toString(nameMap, options).replace(/^|(\n)/g, '$1  '));
        }
        return result.join('\n');
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Search {
    constructor(phrase, unresolvedTokens) {
        assert(phrase);
        this._phrase = phrase;
        const tokens = this.phrase.toLowerCase().split(/[^a-z0-9]/g);
        // If unresolvedTokens not passed, consider all tokens unresolved.
        this._unresolvedTokens = [];
        (unresolvedTokens || tokens).forEach(token => this._unresolvedTokens.push(token));
        // compute the resolved tokens
        this._resolvedTokens = tokens.slice();
        for (const token of this.unresolvedTokens) {
            const index = this._resolvedTokens.indexOf(token);
            if (index >= 0) {
                this._resolvedTokens.splice(index, 1);
            }
        }
        assert(tokens.length === this.unresolvedTokens.length + this.resolvedTokens.length);
    }
    _append(phrase, unresolvedTokens, resolvedTokens) {
        // concat phrase
        if (this._phrase.length > 0) {
            this._phrase = this.phrase.concat(' ');
        }
        this._phrase = this._phrase.concat(phrase);
        resolvedTokens.forEach(t => this._resolvedTokens.push(t));
        unresolvedTokens.forEach(t => this._unresolvedTokens.push(t));
    }
    get phrase() { return this._phrase; }
    get unresolvedTokens() { return this._unresolvedTokens; }
    get resolvedTokens() { return this._resolvedTokens; }
    resolveToken(token) {
        const index = this.unresolvedTokens.indexOf(token.toLowerCase());
        assert(index >= 0, `Cannot resolved nonexistent token ${token}`);
        this._unresolvedTokens.splice(index, 1);
        this._resolvedTokens.push(token.toLowerCase());
    }
    isValid() {
        return this._unresolvedTokens.length > 0 || this._resolvedTokens.length > 0;
    }
    isResolved() {
        assert(Object.isFrozen(this));
        // Recipe is considered resolved, if at least one of the search tokens was resolved.
        // TODO: Unresolved tokens don't prevent the recipe from being resolved. For now...
        return this._resolvedTokens.length > 0;
    }
    _normalize() {
        this._unresolvedTokens.sort();
        this._resolvedTokens.sort();
        Object.freeze(this);
    }
    _copyInto(recipe) {
        if (recipe.search) {
            recipe.search._append(this.phrase, this.unresolvedTokens, this.resolvedTokens);
        }
        else {
            recipe.search = new Search(this.phrase, this.unresolvedTokens);
            assert(recipe.search.resolvedTokens.length === this.resolvedTokens.length, `${recipe.search.resolvedTokens} is not same as ${this.resolvedTokens}`);
        }
        assert(this.resolvedTokens.every(rt => recipe.search.resolvedTokens.indexOf(rt) >= 0) &&
            this.unresolvedTokens.every(rt => recipe.search.unresolvedTokens.indexOf(rt) >= 0));
        return recipe.search;
    }
    toString(options) {
        const result = [];
        result.push(`search \`${this.phrase}\``);
        const tokenStr = [];
        tokenStr.push('  tokens');
        if (this.unresolvedTokens.length > 0) {
            tokenStr.push(this.unresolvedTokens.map(t => `\`${t}\``).join(' '));
        }
        if (this.resolvedTokens.length > 0) {
            tokenStr.push(`// ${this.resolvedTokens.map(t => `\`${t}\``).join(' ')}`);
        }
        if (options && options.showUnresolved) {
            if (this.unresolvedTokens.length > 0) {
                tokenStr.push('// unresolved search tokens');
            }
        }
        result.push(tokenStr.join(' '));
        return result.join('\n');
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Recipe {
    constructor(name) {
        this._requires = [];
        this._particles = [];
        this._handles = [];
        this._slots = [];
        this._localName = undefined;
        this.annotation = undefined;
        this.triggers = [];
        // TODO: Recipes should be collections of records that are tagged
        // with a type. Strategies should register the record types they
        // can handle. ConnectionConstraints should be a different record
        // type to particles/handles.
        this._connectionConstraints = [];
        // Obligations are like connection constraints in that they describe
        // required connections between particles/verbs. However, where
        // connection constraints can be acted upon in order to create these
        // connections, obligations can't be. Instead, they describe requirements
        // that must be discharged before a recipe can be considered to be
        // resolved.
        this._obligations = [];
        this._verbs = [];
        // TODO: Change to array, if needed for search strings of merged recipes.
        this._search = null;
        this._patterns = [];
        this._name = name;
    }
    newConnectionConstraint(from, to, direction) {
        const result = new ConnectionConstraint(from, to, direction, 'constraint');
        this._connectionConstraints.push(result);
        return result;
    }
    newObligation(from, to, direction) {
        const result = new ConnectionConstraint(from, to, direction, 'obligation');
        this._obligations.push(result);
        return result;
    }
    removeObligation(obligation) {
        const idx = this._obligations.indexOf(obligation);
        assert(idx > -1);
        this._obligations.splice(idx, 1);
    }
    removeConstraint(constraint) {
        const idx = this._connectionConstraints.indexOf(constraint);
        assert(idx >= 0);
        this._connectionConstraints.splice(idx, 1);
    }
    clearConnectionConstraints() {
        this._connectionConstraints.length = 0; // truncate
    }
    newRequireSection() {
        const require = new RequireSection(this);
        this._requires.push(require);
        return require;
    }
    newParticle(name) {
        const particle = new Particle(this, name);
        this._particles.push(particle);
        return particle;
    }
    removeParticle(particle) {
        const idx = this._particles.indexOf(particle);
        assert(idx > -1);
        this._particles.splice(idx, 1);
        particle.getSlotConnections().forEach(conn => conn.remove());
    }
    newHandle() {
        const handle = new Handle(this);
        this._handles.push(handle);
        return handle;
    }
    removeHandle(handle) {
        assert(handle.connections.length === 0);
        const idx = this._handles.indexOf(handle);
        assert(idx > -1);
        this._handles.splice(idx, 1);
    }
    newSlot(name) {
        const slot = new Slot(this, name);
        this._slots.push(slot);
        return slot;
    }
    addSlot(slot) {
        if (this.slots.indexOf(slot) === -1) {
            this.slots.push(slot);
        }
    }
    removeSlot(slot) {
        assert(slot.consumeConnections.length === 0);
        let idx = this._slots.indexOf(slot);
        assert(idx > -1);
        this._slots.splice(idx, 1);
        for (const requires of this.requires) {
            idx = requires.slots.indexOf(slot);
            if (idx !== -1) {
                requires.slots.splice(idx, 1);
            }
        }
    }
    isResolved(options) {
        assert(Object.isFrozen(this), 'Recipe must be normalized to be resolved.');
        const checkThat = (check, label) => {
            if (!check && options && options.errors) {
                options.errors.set(this.name, label);
            }
            return check;
        };
        return checkThat(this._obligations.length === 0, 'unresolved obligations')
            && checkThat(this._connectionConstraints.length === 0, 'unresolved constraints')
            && checkThat(this.requires.every(require => require.isEmpty()), 'unresolved require')
            && checkThat((this._search === null || this._search.isResolved()), 'unresolved search')
            && checkThat(this._handles.every(handle => handle.isResolved()), 'unresolved handles')
            && checkThat(this._particles.every(particle => particle.isResolved(options)), 'unresolved particles')
            && checkThat(this.modality.isResolved(), 'unresolved modality')
            && checkThat(this.allRequiredSlotsPresent(options), 'unresolved required slot')
            && checkThat(this._slots.every(slot => slot.isResolved()), 'unresolved slots')
            && checkThat(this.handleConnections.every(connection => connection.isResolved(options)), 'unresolved handle connections')
            && checkThat(this.slotConnections.every(slotConnection => slotConnection.isResolved(options)), 'unresolved slot connections');
        // TODO: check recipe level resolution requirements, eg there is no slot loops.
    }
    isCompatible(modality) {
        return this.particles.every(p => !p.spec || p.spec.isCompatible(modality));
    }
    get modality() {
        return Modality.intersection(this.particles.filter(p => Boolean(p.spec && p.spec.slandleConnectionNames().length > 0)).map(p => p.spec.modality));
    }
    allRequiredSlotsPresent(options = undefined) {
        // All required slots and at least one consume slot for each particle must be present in order for the 
        // recipe to be considered resolved.
        for (const particle of this.particles) {
            if (particle.spec.slotConnections.size === 0) {
                continue;
            }
            let atLeastOneSlotConnection = false;
            let usesSlandles = false;
            for (const handleSpec of Object.values(particle.spec.connections)) {
                if (handleSpec.type.isSlot() ||
                    (handleSpec.type.isCollectionType() && handleSpec.type.collectionType.isSlot())) {
                    usesSlandles = true;
                }
            }
            for (const [name, slotSpec] of particle.spec.slotConnections) {
                if (slotSpec.isRequired && !particle.getSlotConnectionByName(name)) {
                    if (options && options.errors) {
                        options.errors.set(name, `required slot ${name} has no matching connection`);
                    }
                    return false;
                }
                // required provided slots are only required when the corresponding consume slot connection is present
                if (particle.getSlotConnectionByName(name)) {
                    atLeastOneSlotConnection = true;
                    for (const providedSlotSpec of slotSpec.provideSlotConnections) {
                        if (providedSlotSpec.isRequired && !particle.getProvidedSlotByName(name, providedSlotSpec.name)) {
                            if (options && options.errors) {
                                options.errors.set(name, `required provided slot ${providedSlotSpec.name} has no matching connection`);
                            }
                            return false;
                        }
                    }
                }
            }
            // TODO: Remove check for slots in SLANDLESv2
            if (!usesSlandles && !atLeastOneSlotConnection) {
                if (options && options.errors) {
                    options.errors.set(`?`, `no slot connections`);
                }
                return false;
            }
        }
        return true;
    }
    _findDuplicate(items, options) {
        const seenHandles = new Set();
        const duplicateHandle = items.find(handle => {
            if (handle.id) {
                if (seenHandles.has(handle.id)) {
                    return handle;
                }
                seenHandles.add(handle.id);
            }
        });
        if (duplicateHandle && options && options.errors) {
            options.errors.set(duplicateHandle, `Has Duplicate ${duplicateHandle instanceof Handle ? 'Handle' : 'Slot'} '${duplicateHandle.id}'`);
        }
        return duplicateHandle;
    }
    _isValid(options = undefined) {
        const checkAllValid = (list) => list.every(item => item._isValid(options));
        return !this._findDuplicate(this._handles, options)
            && !this._findDuplicate(this._slots, options)
            && checkAllValid(this._handles)
            && checkAllValid(this._particles)
            && checkAllValid(this._slots)
            && checkAllValid(this.handleConnections)
            && checkAllValid(this.slotConnections)
            && (!this.search || this.search.isValid());
    }
    get requires() { return this._requires; }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    get localName() { return this._localName; }
    set localName(name) { this._localName = name; }
    get particles() { return this._particles; }
    set particles(particles) { this._particles = particles; }
    get handles() { return this._handles; }
    set handles(handles) { this._handles = handles; }
    get slots() { return this._slots; }
    set slots(slots) { this._slots = slots; }
    get connectionConstraints() { return this._connectionConstraints; }
    get obligations() { return this._obligations; }
    get verbs() { return this._verbs; }
    set verbs(verbs) { this._verbs = verbs; }
    get search() { return this._search; }
    set search(search) {
        this._search = search;
    }
    setSearchPhrase(phrase) {
        assert(!this._search, 'Cannot override search phrase');
        if (phrase) {
            this._search = new Search(phrase);
        }
    }
    get slotConnections() {
        // TODO: Is this the correct api?
        const slotConnections = [];
        this._particles.forEach(particle => {
            slotConnections.push(...particle.getSlotConnections());
        });
        return slotConnections;
    }
    get handleConnections() {
        const handleConnections = [];
        this._particles.forEach(particle => {
            handleConnections.push(...Object.values(particle.connections));
            handleConnections.push(...particle._unnamedConnections);
        });
        return handleConnections;
    }
    isEmpty() {
        return this.particles.length === 0 &&
            this.handles.length === 0 &&
            this.slots.length === 0 &&
            this._connectionConstraints.length === 0;
    }
    findHandle(id) {
        for (const handle of this.handles) {
            if (handle.id === id) {
                return handle;
            }
        }
        return null;
    }
    findSlot(id) {
        for (const slot of this.slots) {
            if (slot.id === id) {
                return slot;
            }
        }
        return null;
    }
    get patterns() {
        return this._patterns;
    }
    set patterns(patterns) {
        this._patterns = patterns;
    }
    set description(description) {
        const pattern = description.find(desc => desc.name === 'pattern');
        if (pattern) {
            pattern.patterns.forEach(pattern => this._patterns.push(pattern));
        }
        description.forEach(desc => {
            if (desc.name !== 'pattern') {
                const handle = this.handles.find(handle => handle.localName === desc.name);
                assert(handle, `Cannot set description pattern for nonexistent handle ${desc.name}.`);
                handle.pattern = desc.pattern;
            }
        });
    }
    async digest() {
        return digest(this.toString());
    }
    normalize(options) {
        if (Object.isFrozen(this)) {
            if (options && options.errors) {
                options.errors.set(this, 'already normalized');
            }
            return false;
        }
        if (!this._isValid()) {
            this._findDuplicate(this._handles, options);
            this._findDuplicate(this._slots, options);
            const checkForInvalid = (list) => list.forEach(item => !item._isValid(options));
            checkForInvalid(this._handles);
            checkForInvalid(this._particles);
            checkForInvalid(this._slots);
            checkForInvalid(this.handleConnections);
            checkForInvalid(this.slotConnections);
            return false;
        }
        // Get handles and particles ready to sort connections.
        for (const particle of this._particles) {
            particle._startNormalize();
        }
        for (const handle of this._handles) {
            handle._startNormalize();
        }
        for (const slot of this._slots) {
            slot._startNormalize();
        }
        // Sort and normalize handle connections.
        const connections = this.handleConnections;
        for (const connection of connections) {
            connection._normalize();
        }
        connections.sort(compareComparables);
        // Sort and normalize slot connections.
        const slotConnections = this.slotConnections;
        for (const slotConnection of slotConnections) {
            slotConnection._normalize();
        }
        slotConnections.sort(compareComparables);
        if (this.search) {
            this.search._normalize();
        }
        for (const require of this.requires) {
            require.normalize();
        }
        // Finish normalizing particles and handles with sorted connections.
        for (const particle of this._particles) {
            particle._finishNormalize();
        }
        for (const handle of this._handles) {
            handle._finishNormalize();
        }
        for (const slot of this._slots) {
            slot._finishNormalize();
        }
        const seenHandles = new Set();
        const seenParticles = new Set();
        const seenSlots = new Set();
        const particles = [];
        const handles = [];
        const slots = [];
        // Reorder connections so that interfaces come last.
        // TODO: update handle-connection comparison method instead?
        let ordered = connections.filter(c => !c.type || !(c.type instanceof InterfaceType));
        ordered = ordered.concat(connections.filter(c => !!c.type && !!(c.type instanceof InterfaceType)));
        for (const connection of ordered) {
            if (!seenParticles.has(connection.particle)) {
                particles.push(connection.particle);
                seenParticles.add(connection.particle);
            }
            if (connection.handle && !seenHandles.has(connection.handle)) {
                handles.push(connection.handle);
                seenHandles.add(connection.handle);
            }
        }
        for (const slotConnection of slotConnections) {
            if (slotConnection.targetSlot && !seenSlots.has(slotConnection.targetSlot)) {
                slots.push(slotConnection.targetSlot);
                seenSlots.add(slotConnection.targetSlot);
            }
            Object.values(slotConnection.providedSlots).forEach(ps => {
                if (!seenSlots.has(ps)) {
                    slots.push(ps);
                    seenSlots.add(ps);
                }
            });
        }
        const orphanedHandles = this._handles.filter(handle => !seenHandles.has(handle));
        orphanedHandles.sort(compareComparables);
        handles.push(...orphanedHandles);
        const orphanedParticles = this._particles.filter(particle => !seenParticles.has(particle));
        orphanedParticles.sort(compareComparables);
        particles.push(...orphanedParticles);
        const orphanedSlots = this._slots.filter(slot => !seenSlots.has(slot));
        orphanedSlots.sort(compareComparables);
        slots.push(...orphanedSlots);
        // Put particles and handles in their final ordering.
        this._particles = particles;
        this._handles = handles;
        this._slots = slots;
        this._connectionConstraints.sort(compareComparables);
        this._verbs.sort();
        this._patterns.sort();
        Object.freeze(this._particles);
        Object.freeze(this._handles);
        Object.freeze(this._slots);
        Object.freeze(this._connectionConstraints);
        Object.freeze(this);
        return true;
    }
    clone(map = undefined) {
        // for now, just copy everything
        const recipe = new Recipe(this.name);
        if (map == undefined) {
            map = new Map();
        }
        this._copyInto(recipe, map);
        // TODO: figure out a better approach than stashing the cloneMap permanently
        // on the recipe
        recipe._cloneMap = map;
        return recipe;
    }
    // tslint:disable-next-line: no-any
    mergeInto(recipe) {
        const cloneMap = new Map();
        const numHandles = recipe._handles.length;
        const numParticles = recipe._particles.length;
        const numSlots = recipe._slots.length;
        this._copyInto(recipe, cloneMap);
        return {
            handles: recipe._handles.slice(numHandles),
            particles: recipe._particles.slice(numParticles),
            slots: recipe._slots.slice(numSlots),
            cloneMap
        };
    }
    _copyInto(recipe, cloneMap) {
        const variableMap = new Map();
        const cloneTheThing = (ob) => {
            const clonedObject = ob._copyInto(recipe, cloneMap, variableMap);
            cloneMap.set(ob, clonedObject);
        };
        recipe._name = this.name;
        recipe._verbs = recipe._verbs.concat(...this._verbs);
        this._handles.forEach(cloneTheThing);
        this._particles.forEach(cloneTheThing);
        this._slots.forEach(cloneTheThing);
        this._connectionConstraints.forEach(cloneTheThing);
        this._obligations.forEach(cloneTheThing);
        recipe.verbs = recipe.verbs.slice();
        if (this.search) {
            this.search._copyInto(recipe);
        }
        for (const require of this.requires) {
            const newRequires = recipe.newRequireSection();
            require._copyInto(newRequires, cloneMap);
            newRequires._cloneMap = cloneMap;
        }
        recipe.patterns = recipe.patterns.concat(this.patterns);
    }
    // tslint:disable-next-line: no-any
    updateToClone(dict) {
        const result = {};
        Object.keys(dict).forEach(key => result[key] = this._cloneMap.get(dict[key]));
        return result;
    }
    _makeLocalNameMap() {
        const names = new Set([...this.particles,
            ...this.handles,
            ...this.slots].map((item) => item.localName));
        let i;
        const nameMap = new Map();
        const mapName = (item, prefix) => {
            let localName = item.localName;
            if (!localName) {
                do {
                    localName = `${prefix}${i++}`;
                } while (names.has(localName));
            }
            nameMap.set(item, localName);
        };
        i = 0;
        this.particles.forEach(particle => mapName(particle, 'particle'));
        i = 0;
        this.handles.forEach(handle => mapName(handle, 'handle'));
        i = 0;
        this.slots.forEach(slot => mapName(slot, 'slot'));
        return nameMap;
    }
    // TODO: Add a normalize() which strips local names and puts and nested
    //       lists into a normal ordering.
    //
    // use { showUnresolved: true } in options to see why a recipe can't resolve.
    toString(options) {
        const nameMap = this._makeLocalNameMap();
        const result = [];
        const verbs = this.verbs.length > 0 ? ` ${this.verbs.map(verb => `&${verb}`).join(' ')}` : '';
        result.push(`recipe${this.name ? ` ${this.name}` : ''}${verbs}`);
        if (options && options.showUnresolved) {
            if (this.search) {
                result.push(this.search.toString(options).replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const constraint of this._connectionConstraints) {
            let constraintStr = constraint.toString().replace(/^|(\n)/g, '$1  ');
            if (options && options.showUnresolved) {
                constraintStr = constraintStr.concat(' // unresolved connection-constraint');
            }
            result.push(constraintStr);
        }
        result.push(...this.handles
            .map(h => h.toString(options, nameMap))
            .filter(strValue => strValue)
            .map(strValue => strValue.replace(/^|(\n)/g, '$1  ')));
        for (const slot of this.slots) {
            const slotString = slot.toString(options, nameMap);
            if (slotString) {
                result.push(slotString.replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const require of this.requires) {
            if (!require.isEmpty())
                result.push(require.toString(options, nameMap).replace(/^|(\n)/g, '$1  '));
        }
        for (const particle of this.particles) {
            result.push(particle.toString(options, nameMap).replace(/^|(\n)/g, '$1  '));
        }
        if (this.patterns.length > 0 || this.handles.find(h => h.pattern !== undefined)) {
            result.push(`  description \`${this.patterns[0]}\``);
            for (let i = 1; i < this.patterns.length; ++i) {
                result.push(`    pattern \`${this.patterns[i]}\``);
            }
            this.handles.forEach(h => {
                if (h.pattern) {
                    result.push(`    ${h.localName} \`${h.pattern}\``);
                }
            });
        }
        if (this._obligations.length > 0) {
            result.push('  obligations');
            for (const obligation of this._obligations) {
                const obligationStr = obligation.toString(nameMap).replace(/^|(\n)/g, '$1    ');
                result.push(obligationStr);
            }
        }
        return result.join('\n');
    }
    getFreeHandles() {
        return this.handles.filter(handle => handle.connections.length === 0);
    }
    get allSpecifiedConnections() {
        return [].concat(...this.particles.filter(p => p.spec && p.spec.connections).map(particle => particle.spec.connections.map(connSpec => ({ particle, connSpec }))));
    }
    getFreeConnections(type) {
        // TODO(jopra): Check that this works for required connections that are
        // dependent on optional connections.
        return this.allSpecifiedConnections.filter(({ particle, connSpec }) => !connSpec.isOptional &&
            connSpec.name !== 'descriptions' &&
            connSpec.direction !== 'host' &&
            !particle.connections[connSpec.name] &&
            (!type || TypeChecker.compareTypes({ type }, { type: connSpec.type })));
    }
    findHandleByID(id) {
        return this.handles.find(handle => handle.id === id);
    }
    getUnnamedUntypedConnections() {
        return this.handleConnections.find(hc => !hc.type || !hc.name || hc.isOptional);
    }
    getParticlesByImplFile(files) {
        return this.particles.filter(particle => particle.spec && files.has(particle.spec.implFile));
    }
    // overridded by RequireSection
    findSlotByID(id) {
        let slot = this.slots.find(s => s.id === id);
        if (slot === undefined) {
            for (const require of this.requires) {
                slot = require.slots.find(s => s.id === id);
                if (slot !== undefined)
                    break;
            }
        }
        return slot;
    }
}
class RequireSection extends Recipe {
    constructor(parent, name) {
        super(name);
        this.parent = parent;
    }
    findSlotByID(id) {
        let slot = this.slots.find(s => s.id === id);
        if (slot === undefined) {
            slot = this.parent.slots.find(s => s.id === id);
        }
        return slot;
    }
    toString(options = {}, nameMap) {
        if (nameMap == undefined) {
            nameMap = this._makeLocalNameMap();
        }
        const result = [];
        result.push(`require`);
        if (options.showUnresolved) {
            if (this.search) {
                result.push(this.search.toString(options).replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const constraint of this.connectionConstraints) {
            let constraintStr = constraint.toString().replace(/^|(\n)/g, '$1  ');
            if (options.showUnresolved) {
                constraintStr = constraintStr.concat(' // unresolved connection-constraint');
            }
            result.push(constraintStr);
        }
        result.push(...this.handles
            .map(h => h.toString(options, nameMap))
            .filter(strValue => strValue)
            .map(strValue => strValue.replace(/^|(\n)/g, '$1  ')));
        for (const slot of this.slots) {
            const slotString = slot.toString(options, nameMap);
            if (slotString) {
                result.push(slotString.replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const particle of this.particles) {
            result.push(particle.toString(options, nameMap).replace(/^|(\n)/g, '$1  '));
        }
        if (this.patterns.length > 0 || this.handles.find(h => h.pattern !== undefined)) {
            result.push(`  description \`${this.patterns[0]}\``);
            for (let i = 1; i < this.patterns.length; ++i) {
                result.push(`    pattern \`${this.patterns[i]}\``);
            }
            this.handles.forEach(h => {
                if (h.pattern) {
                    result.push(`    ${h.localName} \`${h.pattern}\``);
                }
            });
        }
        if (this.obligations.length > 0) {
            result.push('  obligations');
            for (const obligation of this.obligations) {
                const obligationStr = obligation.toString(nameMap).replace(/^|(\n)/g, '$1    ');
                result.push(obligationStr);
            }
        }
        return result.join('\n');
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotConnection {
    constructor(name, particle) {
        this._targetSlot = undefined;
        this._providedSlots = {};
        this._tags = [];
        assert(particle);
        assert(particle.recipe);
        assert(name);
        this._recipe = particle.recipe;
        this._particle = particle;
        this._name = name;
    }
    remove() {
        this._particle.removeSlotConnection(this);
    }
    get recipe() { return this._recipe; }
    get particle() { return this._particle; }
    get name() { return this._name; }
    getQualifiedName() { return `${this.particle.name}::${this.name}`; }
    get targetSlot() { return this._targetSlot; }
    set targetSlot(targetSlot) { this._targetSlot = targetSlot; }
    get providedSlots() { return this._providedSlots; }
    get tags() { return this._tags; }
    set tags(tags) { this._tags = tags; }
    getSlotSpec() {
        return this.particle.spec && this.particle.spec.getSlandleSpec(this.name);
    }
    connectToSlot(targetSlot) {
        assert(targetSlot);
        assert(!this.targetSlot);
        assert(this.recipe instanceof RequireSection || this.recipe === targetSlot.recipe, 'Cannot connect to slot from different recipe');
        this._targetSlot = targetSlot;
        targetSlot.consumeConnections.push(this);
    }
    disconnectFromSlot() {
        if (this._targetSlot) {
            this._targetSlot.removeConsumeConnection(this);
            this._targetSlot = undefined;
        }
    }
    _clone(particle, cloneMap) {
        if (cloneMap.has(this)) {
            return cloneMap.get(this);
        }
        const slotConnection = particle.addSlotConnectionAsCopy(this.name);
        slotConnection.tags = this.tags;
        cloneMap.set(this, slotConnection);
        return slotConnection;
    }
    _normalize() {
        const normalizedSlots = {};
        for (const key of (Object.keys(this._providedSlots).sort())) {
            normalizedSlots[key] = this._providedSlots[key];
        }
        this._providedSlots = normalizedSlots;
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.name, other.name)) !== 0)
            return cmp;
        if ((cmp = compareComparables(this._targetSlot, other._targetSlot)) !== 0)
            return cmp;
        if ((cmp = compareComparables(this._particle, other._particle)) !== 0)
            return cmp;
        return 0;
    }
    _isValid(options) {
        if (this._targetSlot && this._targetSlot.sourceConnection &&
            this._targetSlot !== this._targetSlot.sourceConnection.providedSlots[this._targetSlot.name]) {
            if (options && options.errors) {
                options.errors.set(this, `Invalid target slot '${this._targetSlot.name}' for slot connection '${this.name}' of particle ${this.particle.name}`);
            }
            return false;
        }
        // TODO: add more checks.
        return true;
    }
    isResolved(options) {
        const error = (label) => {
            if (options && options.errors) {
                options.errors.set(this.name, label);
            }
            if (options && options.details) {
                options.details = label; // TODO(jopra): use .errors instead.
            }
        };
        assert(Object.isFrozen(this), `slot connection ${this.name} must be frozen before it is resolved`);
        if (!this.name) {
            error('missing name');
            return false;
        }
        if (!this.particle) {
            error('missing particle');
            return false;
        }
        const slotSpec = this.getSlotSpec();
        if (slotSpec === undefined || slotSpec.isRequired) {
            if (!this.targetSlot) {
                // The required connection has no target slot
                error(`missing target-slot`);
                return false;
            }
            if (!this.targetSlot.id && !(this.targetSlot.sourceConnection && this.targetSlot.sourceConnection.isConnected())) {
                // The required connection's target slot is not resolved (has no ID or source connection).
                error(`unresolved target-slot`);
                return false;
            }
        }
        if (!this.targetSlot) {
            return true;
        }
        if (slotSpec === undefined)
            return true;
        return this.getSlotSpec().provideSlotConnections.every(providedSlot => {
            if (providedSlot && providedSlot.isRequired && this.providedSlots[providedSlot.name].consumeConnections.length === 0) {
                error('missing consuming slot');
                return false;
            }
            return true;
        });
    }
    isConnectedToInternalSlot() {
        return this.targetSlot && (!!this.targetSlot.sourceConnection);
    }
    isConnectedToRemoteSlot() {
        return this.targetSlot && (!!this.targetSlot.id);
    }
    isConnected() {
        return this.isConnectedToInternalSlot() || this.isConnectedToRemoteSlot();
    }
    toString(nameMap, options) {
        const consumeRes = [];
        consumeRes.push('consume');
        consumeRes.push(`${this.name}`);
        if (this.targetSlot) {
            consumeRes.push(`as ${(nameMap && nameMap.get(this.targetSlot)) ||
                this.targetSlot.localName}`);
        }
        if (options && options.showUnresolved) {
            if (!this.isResolved(options)) {
                consumeRes.push(`// unresolved slot-connection: ${options.details}`);
            }
        }
        const result = [];
        result.push(consumeRes.join(' '));
        Object.keys(this.providedSlots).forEach(psName => {
            const providedSlot = this.providedSlots[psName];
            const provideRes = [];
            provideRes.push('  provide');
            // Only assert that there's a spec for this provided slot if there's a spec for
            // the consumed slot .. otherwise this is just a constraint.
            if (this.getSlotSpec()) {
                const providedSlotSpec = this.particle.getSlotSpecByName(psName);
                assert(providedSlotSpec, `Cannot find providedSlotSpec for ${psName}`);
            }
            provideRes.push(`${psName} as ${(nameMap && nameMap.get(providedSlot)) || providedSlot}`);
            result.push(provideRes.join(' '));
        });
        return result.join('\n');
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Slot {
    constructor(recipe, name) {
        this._id = undefined;
        this._localName = undefined;
        this._tags = [];
        this._sourceConnection = undefined;
        this._formFactor = undefined;
        this._consumeConnections = [];
        assert(recipe);
        this._recipe = recipe;
        this._name = name;
    }
    get recipe() { return this._recipe; }
    get id() { return this._id; }
    set id(id) { this._id = id; }
    get localName() { return this._localName; }
    set localName(localName) { this._localName = localName; }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    get tags() { return this._tags; }
    set tags(tags) { this._tags = tags; }
    get formFactor() { return this._formFactor; }
    set formFactor(formFactor) { this._formFactor = formFactor; }
    get sourceConnection() { return this._sourceConnection; }
    set sourceConnection(sourceConnection) { this._sourceConnection = sourceConnection; }
    get consumeConnections() { return this._consumeConnections; }
    get spec() {
        // TODO: should this return something that indicates this isn't available yet instead of
        // the constructed {isSet: false, tags: []}?
        return (this.sourceConnection && this.sourceConnection.getSlotSpec()) ? this.sourceConnection.particle.getSlotSpecByName(this.name) : { isSet: false, tags: [] };
    }
    get handles() {
        // TODO(jopra): This lazy initialization is surprising. Consider removing.
        const handles = [];
        if (this.sourceConnection && this.sourceConnection.getSlotSpec()) {
            for (const handleName of this.sourceConnection.particle.getSlotSpecByName(this.name).handles) {
                const handleConn = this.sourceConnection.particle.connections[handleName];
                if (handleConn || handleConn.handle) {
                    handles.push(handleConn.handle);
                }
            }
        }
        return handles;
    }
    _copyInto(recipe, cloneMap) {
        let slot = undefined;
        if (cloneMap.has(this)) {
            return cloneMap.get(this);
        }
        if (!this.sourceConnection && this.id) {
            slot = recipe.findSlot(this.id);
        }
        if (slot == undefined) {
            slot = recipe.newSlot(this.name);
            slot._id = this.id;
            slot._formFactor = this.formFactor;
            slot._localName = this._localName;
            slot._tags = [...this._tags];
            // the connections are re-established when Particles clone their attached SlotConnection objects.
            slot._sourceConnection = cloneMap.get(this._sourceConnection);
            if (slot.sourceConnection) {
                slot.sourceConnection.providedSlots[slot.name] = slot;
            }
        }
        this._consumeConnections.forEach(connection => {
            const clonedConnection = cloneMap.get(connection);
            if (clonedConnection && clonedConnection instanceof SlotConnection && clonedConnection.targetSlot == undefined) {
                clonedConnection.connectToSlot(slot);
            }
        });
        return slot;
    }
    _startNormalize() {
        this.localName = null;
        this._tags.sort();
    }
    _finishNormalize() {
        // TODO(mmandlis): This was assert(Object.isFroze(this._source)) - but there is no _source.
        // Changing to _sourceConnection makes the assert fail.
        // assert(Object.isFrozen(this._sourceConnection));
        this._consumeConnections.forEach(cc => assert(Object.isFrozen(cc)));
        this._consumeConnections.sort(compareComparables);
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.id, other.id)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.localName, other.localName)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.formFactor, other.formFactor)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        return 0;
    }
    findHandleByID(id) {
        return this.handles.find(handle => handle.id === id);
    }
    removeConsumeConnection(slotConnection) {
        const idx = this._consumeConnections.indexOf(slotConnection);
        assert(idx > -1);
        this._consumeConnections.splice(idx, 1);
        if (this._consumeConnections.length === 0) {
            this.remove();
        }
    }
    remove() {
        this._recipe.removeSlot(this);
    }
    isResolved(options) {
        assert(Object.isFrozen(this));
        if (options && options.showUnresolved) {
            options.details = [];
            if (!this._sourceConnection) {
                options.details.push('missing source-connection');
            }
            if (!this.id) {
                options.details.push('missing id');
            }
        }
        return Boolean(this._sourceConnection || this.id);
    }
    _isValid(options) {
        // TODO: implement
        return true;
    }
    toString(options = {}, nameMap) {
        const result = [];
        result.push('slot');
        if (this.id) {
            result.push(`'${this.id}'`);
        }
        if (this.tags.length > 0) {
            result.push(this.tags.map(tag => `#${tag}`).join(' '));
        }
        result.push(`as ${(nameMap && nameMap.get(this)) || this.localName}`);
        const includeUnresolved = options.showUnresolved && !this.isResolved(options);
        if (includeUnresolved) {
            result.push(`// unresolved slot: ${options.details}`);
        }
        if (this.id || includeUnresolved) {
            return result.join(' ');
        }
        return '';
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Handle {
    constructor(recipe) {
        this._id = null;
        this._localName = undefined;
        this._tags = [];
        this._type = undefined;
        this._fate = null;
        // TODO: replace originalFate and originalId with more generic mechanism for tracking
        // how and from what the recipe was generated.
        this._originalFate = null;
        this._originalId = null;
        this._connections = [];
        this._mappedType = undefined;
        this._storageKey = undefined;
        this._pattern = undefined;
        // Value assigned in the immediate mode, E.g. hostedParticle = ShowProduct
        // Currently only supports ParticleSpec.
        this._immediateValue = undefined;
        this.claims = undefined;
        assert(recipe);
        this._recipe = recipe;
    }
    toSlot() {
        if (!this.type) {
            return undefined;
        }
        if (this.fate !== '`slot') {
            return undefined;
        }
        const slandle = new Slot(this.recipe, this.localName);
        slandle.tags = this.tags;
        slandle.id = this.id;
        const slotType = this.type.slandleType();
        if (slotType) {
            const slotInfo = slotType.getSlot();
            if (slotInfo) {
                slandle.formFactor = slotInfo.formFactor;
                if (slotInfo.handle) {
                    // TODO(jopra): cannot assign slandle handles as the slots do not
                    // actually track their handles but use a source particle connection
                    // mapping.
                    const particle = undefined;
                    slandle.sourceConnection = new SlotConnection(slotInfo.handle, particle);
                }
            }
        }
        return slandle;
    }
    _copyInto(recipe, cloneMap, variableMap) {
        let handle = undefined;
        if (this._id !== null && ['map', 'use', 'copy'].includes(this.fate)) {
            handle = recipe.findHandle(this._id);
        }
        if (handle == undefined) {
            handle = recipe.newHandle();
            handle._id = this._id;
            handle._tags = [...this._tags];
            handle._type = this._type ? this._type._cloneWithResolutions(variableMap) : undefined;
            handle._fate = this._fate;
            handle._originalFate = this._originalFate;
            handle._originalId = this._originalId;
            handle._mappedType = this._mappedType;
            handle._storageKey = this._storageKey;
            handle._immediateValue = this._immediateValue;
            // the connections are re-established when Particles clone their
            // attached HandleConnection objects.
            handle._connections = [];
            handle._pattern = this._pattern;
        }
        return handle;
    }
    // Merges `this` recipe handle into `handle`
    mergeInto(handle) {
        assert(this.recipe === handle.recipe, 'Cannot merge handles from different recipes.');
        while (this.connections.length > 0) {
            const [connection] = this.connections;
            connection.disconnectHandle();
            connection.connectToHandle(handle);
        }
        handle._immediateValue = this._immediateValue;
        handle.tags = handle.tags.concat(this.tags);
        handle.recipe.removeHandle(this);
        handle.fate = this._mergedFate([this.fate, handle.fate]);
    }
    _mergedFate(fates) {
        assert(fates.length > 0, `Cannot merge empty fates list`);
        // Merging handles only used in coalesce-recipe strategy, which is only done for use/create/? fates.
        assert(!fates.includes('map') && !fates.includes('copy'), `Merging map/copy not supported yet`);
        // If all fates were `use` keep their fate, otherwise set to `create`.
        return fates.every(fate => fate === 'use') ? 'use' : 'create';
    }
    _startNormalize() {
        this._localName = null;
        this._tags.sort();
        const isSlotType = (type) => {
            const hasTypeWithoutFate = type && this._fate === '?';
            const supersetIsSlandle = type.canWriteSuperset && type.canWriteSuperset.slandleType();
            const subersetIsSlandle = type.canReadSubset && type.canReadSubset.slandleType();
            return hasTypeWithoutFate && (supersetIsSlandle || subersetIsSlandle);
        };
        const resolvedType = this.type.resolvedType();
        const collectionType = resolvedType && resolvedType.isCollectionType() && resolvedType.collectionType;
        if (isSlotType(resolvedType) || isSlotType(collectionType)) {
            this._fate = '`slot';
        }
    }
    _finishNormalize() {
        for (const connection of this._connections) {
            assert(Object.isFrozen(connection), `Handle connection '${connection.name}' is not frozen.`);
        }
        this._connections.sort(compareComparables);
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this._id, other._id)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._localName, other._localName)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        // TODO: type?
        if ((cmp = compareStrings(this.fate, other.fate)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._immediateValue && this._immediateValue.toString() || '', other._immediateValue && other._immediateValue.toString() || '')) !== 0)
            return cmp;
        return 0;
    }
    // a resolved Handle has either an id or create=true
    get fate() { return this._fate || '?'; }
    set fate(fate) {
        if (this._originalFate == null) {
            this._originalFate = this._fate;
        }
        this._fate = fate;
    }
    get originalFate() { return this._originalFate || '?'; }
    get originalId() { return this._originalId; }
    get recipe() { return this._recipe; }
    get tags() { return this._tags; } // only tags owned by the handle
    set tags(tags) { this._tags = tags; }
    get type() { return this._type; } // nullable
    get id() { return this._id; }
    set id(id) {
        if (!this._originalId) {
            this._originalId = this._id;
        }
        this._id = id;
    }
    mapToStorage(storage) {
        if (!storage) {
            throw new Error(`Cannot map to undefined storage`);
        }
        this._id = storage.id;
        this._originalId = storage.originalId;
        this._type = undefined;
        this._mappedType = storage.type;
        this._storageKey = storage.storageKey;
        this.claims = storage.claims;
    }
    get localName() { return this._localName; }
    set localName(name) { this._localName = name; }
    get connections() { return this._connections; } // HandleConnection*
    get storageKey() { return this._storageKey; }
    set storageKey(key) { this._storageKey = key; }
    get pattern() { return this._pattern; }
    set pattern(pattern) { this._pattern = pattern; }
    get mappedType() { return this._mappedType; }
    set mappedType(mappedType) { this._mappedType = mappedType; }
    get immediateValue() { return this._immediateValue; }
    set immediateValue(value) { this._immediateValue = value; }
    static effectiveType(handleType, connections) {
        const variableMap = new Map();
        // It's OK to use _cloneWithResolutions here as for the purpose of this test, the handle set + handleType
        // contain the full set of type variable information that needs to be maintained across the clone.
        const typeSet = connections.filter(connection => connection.type != null).map(connection => ({ type: connection.type._cloneWithResolutions(variableMap), direction: connection.direction }));
        return TypeChecker.processTypeList(handleType ? handleType._cloneWithResolutions(variableMap) : null, typeSet);
    }
    static resolveEffectiveType(handleType, connections) {
        const typeSet = connections.filter(connection => connection.type != null).map(connection => ({ type: connection.type, direction: connection.direction }));
        return TypeChecker.processTypeList(handleType, typeSet);
    }
    _isValid(options) {
        const tags = new Set();
        for (const connection of this._connections) {
            // A remote handle cannot be connected to an output param.
            if (this.fate === 'map' && ['out', 'inout'].includes(connection.direction)) {
                if (options && options.errors) {
                    options.errors.set(this, `Invalid fate '${this.fate}' for handle '${this}'; it is used for '${connection.direction}' ${connection.getQualifiedName()} connection`);
                }
                return false;
            }
            connection.tags.forEach(tag => tags.add(tag));
        }
        if (!this.mappedType && this.fate === '`slot') {
            this._mappedType = TypeVariable.make(this.id, null, null);
        }
        const type = Handle.resolveEffectiveType(this._mappedType, this._connections);
        if (!type) {
            if (options && options.errors) {
                // TODO: pass options to TypeChecker.processTypeList for better error.
                options.errors.set(this, `Type validations failed for handle '${this}' with type ${this._mappedType} and fate ${this.fate}`);
            }
            return false;
        }
        this._type = type;
        this._tags.forEach(tag => tags.add(tag));
        this._tags = [...tags];
        return true;
    }
    isResolved(options) {
        assert(Object.isFrozen(this));
        let resolved = true;
        if (this.type) {
            let mustBeResolved = true;
            if (this.fate === 'create' || this.fate === '`slot') {
                mustBeResolved = false;
            }
            if (!this.type.canEnsureResolved()) {
                if (options) {
                    options.details.push('unresolved type (cannot ensure resolved)');
                }
                resolved = false;
            }
            if (mustBeResolved && !this.type.isResolved()) {
                if (options) {
                    options.details.push('unresolved type');
                }
                resolved = false;
            }
        }
        else {
            if (options) {
                options.details.push('missing type');
            }
            resolved = false;
        }
        switch (this.fate) {
            case '?': {
                if (options) {
                    options.details.push('missing fate');
                }
                resolved = false;
                break;
            }
            case 'copy':
            case 'map':
            case 'use': {
                if (options && this.id === null) {
                    options.details.push('missing id');
                }
                resolved = resolved && (this.id !== null);
                break;
            }
            case '`slot':
            case 'create':
                break;
            default: {
                if (options) {
                    options.details.push(`invalid fate ${this.fate}`);
                }
                throw new Error(`Unexpected fate: ${this.fate}`);
            }
        }
        return resolved;
    }
    toString(options = {}, nameMap) {
        if (this._immediateValue) {
            // Immediate Value handles are only rendered inline with particle connections.
            // E.g. hostedParticle = ShowProduct
            return undefined;
        }
        // TODO: type? maybe output in a comment
        const result = [];
        result.push(this.fate);
        if (this.id) {
            result.push(`'${this.id}'`);
        }
        result.push(...this.tags.map(a => `#${a}`));
        const name = (nameMap && nameMap.get(this)) || this.localName;
        if (name) {
            result.push(`as ${name}`);
        }
        if (this.type) {
            result.push('//');
            if (this.type.isResolved()) {
                result.push(this.type.resolvedType().toString({ hideFields: options.hideFields == undefined ? true : options.hideFields }));
            }
            else {
                // TODO: include the unresolved constraints in toString (ie in the hash).
                result.push(this.type.toString());
                if (options.showUnresolved && this.type.canEnsureResolved()) {
                    const type = Type.fromLiteral(this.type.toLiteral());
                    type.maybeEnsureResolved();
                    result.push('//');
                    result.push(type.resolvedType().toString({ hideFields: options.hideFields == undefined ? true : options.hideFields }));
                }
            }
        }
        if (options.showUnresolved) {
            const unresolvedOptions = { details: [] };
            if (!this.isResolved(unresolvedOptions)) {
                result.push(` // unresolved handle: ${unresolvedOptions.details.join(', ')}`);
            }
        }
        return result.join(' ');
    }
    findConnectionByDirection(dir) {
        return this._connections.find(conn => conn.direction === dir);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class KeyBase {
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class VolatileKey extends KeyBase {
    constructor(key) {
        super();
        let parts = key.split('://');
        this.protocol = parts[0];
        assert(this.protocol === 'volatile', `can't construct volatile key for protocol ${this.protocol} (input key ${key})`);
        parts = parts[1] ? parts.slice(1).join('://').split('^^') : [];
        this.arcId = parts[0];
        this.location = parts[1];
        assert(this.toString() === key, `Expected ${key}, but got ${this.toString()} volatile key base.`);
    }
    base() { return 'volatile'; }
    get arcId() { return this._arcId; }
    set arcId(arcId) { this._arcId = arcId; }
    childKeyForHandle(id) {
        return new VolatileKey('volatile');
    }
    childKeyForArcInfo() {
        return new VolatileKey(`${this.protocol}://${this.arcId}^^arc-info`);
    }
    childKeyForSuggestions(userId, arcId) {
        return new VolatileKey(`${this.protocol}://${this.arcId}^^${userId}/suggestions/${arcId}`);
    }
    childKeyForSearch(userId) {
        return new VolatileKey(`${this.protocol}://${this.arcId}^^${userId}/search`);
    }
    toString() {
        if (this.location !== undefined && this.arcId !== undefined) {
            return `${this.protocol}://${this.arcId}^^${this.location}`;
        }
        if (this.arcId !== undefined) {
            return `${this.protocol}://${this.arcId}`;
        }
        return `${this.protocol}`;
    }
}
const storageCache = () => Runtime.getRuntime().getCacheService().getOrCreateCache('volatileStorageCache');
class VolatileStorage extends StorageBase {
    constructor(arcId) {
        super(arcId);
        this._memoryMap = {};
        this._typeMap = {};
        this.localIDBase = 0;
        this.typePromiseMap = {};
        // TODO(shans): re-add this assert once we have a runtime object to put it on.
        // assert(__storageCache[this._arc.id] == undefined, `${this._arc.id} already exists in local storage cache`);
        storageCache().set(this.arcId.toString(), this);
    }
    async construct(id, type, keyFragment) {
        const provider = await this._construct(id, type, keyFragment);
        if (type instanceof ReferenceType || type instanceof BigCollectionType) {
            return provider;
        }
        if (type.isTypeContainer() && type.getContainedType() instanceof ReferenceType) {
            return provider;
        }
        provider.enableReferenceMode();
        return provider;
    }
    async _construct(id, type, keyFragment) {
        const key = this.constructKey(keyFragment);
        // TODO(shanestephens): should pass in factory, not 'this' here.
        const provider = VolatileStorageProvider.newProvider(type, this, undefined, id, key);
        if (this._memoryMap[key] !== undefined) {
            return null;
        }
        this._memoryMap[key] = provider;
        return provider;
    }
    constructKey(keyFragment) {
        const key = new VolatileKey(keyFragment);
        if (key.arcId === undefined) {
            key.arcId = this.arcId.toString();
        }
        if (key.location === undefined) {
            key.location = 'volatile-' + this.localIDBase++;
        }
        return key.toString();
    }
    async connect(id, type, key) {
        const imKey = new VolatileKey(key);
        if (imKey.arcId !== this.arcId.toString()) {
            if (storageCache().get(imKey.arcId) == undefined) {
                return null;
            }
            return storageCache().get(imKey.arcId).connect(id, type, key);
        }
        if (this._memoryMap[key] === undefined) {
            return null;
        }
        // TODO assert types match?
        return this._memoryMap[key];
    }
    baseStorageKey(type) {
        const key = new VolatileKey('volatile');
        key.arcId = this.arcId.toString();
        key.location = 'volatile-' + type.toString();
        return key.toString();
    }
    async baseStorageFor(type, key) {
        if (this._typeMap[key]) {
            return this._typeMap[key];
        }
        if (this.typePromiseMap[key]) {
            return this.typePromiseMap[key];
        }
        const storagePromise = this._construct(type.toString(), type.collectionOf(), key);
        this.typePromiseMap[key] = storagePromise;
        const storage = await storagePromise;
        assert(storage, `could not construct baseStorage for key ${key}`);
        this._typeMap[key] = storage;
        return storage;
    }
    parseStringAsKey(s) {
        const key = new VolatileKey(s);
        if (key.arcId === undefined) {
            key.arcId = this.arcId.toString();
        }
        return key;
    }
}
class VolatileStorageProvider extends StorageProviderBase {
    constructor() {
        super(...arguments);
        this.backingStore = null;
        this.pendingBackingStore = null;
    }
    static newProvider(type, storageEngine, name, id, key) {
        if (type instanceof CollectionType) {
            return new VolatileCollection(type, storageEngine, name, id, key);
        }
        if (type instanceof BigCollectionType) {
            return new VolatileBigCollection(type, storageEngine, name, id, key);
        }
        return new VolatileSingleton(type, storageEngine, name, id, key);
    }
    // A consequence of awaiting this function is that this.backingStore
    // is guaranteed to exist once the await completes. This is because
    // if backingStore doesn't yet exist, the assignment in the then()
    // is guaranteed to execute before anything awaiting this function.
    async ensureBackingStore() {
        if (this.backingStore) {
            return this.backingStore;
        }
        if (!this.pendingBackingStore) {
            const key = this.storageEngine.baseStorageKey(this.backingType());
            this.pendingBackingStore = this.storageEngine.baseStorageFor(this.backingType(), key);
            await this.pendingBackingStore.then(backingStore => this.backingStore = backingStore);
        }
        return this.pendingBackingStore;
    }
    fromLiteral({ version, model }) { }
}
class VolatileCollection extends VolatileStorageProvider {
    constructor(type, storageEngine, name, id, key) {
        super(type, name, id, key);
        this._model = new CrdtCollectionModel();
        this.storageEngine = storageEngine;
        assert(this.version !== null);
    }
    backingType() {
        return this.type.getContainedType();
    }
    async clone() {
        const handle = new VolatileCollection(this.type, this.storageEngine, this.name, this.id, null);
        await handle.cloneFrom(this);
        return handle;
    }
    async cloneFrom(handle) {
        this.referenceMode = handle.referenceMode;
        const literal = await handle.toLiteral();
        if (this.referenceMode && literal.model.length > 0) {
            await Promise.all([this.ensureBackingStore(), handle.ensureBackingStore()]);
            literal.model = literal.model.map(({ id, value }) => ({ id, value: { id: value.id, storageKey: this.backingStore.storageKey } }));
            const underlying = await handle.backingStore.getMultiple(literal.model.map(({ id }) => id));
            await this.backingStore.storeMultiple(underlying, [this.storageKey]);
        }
        this.fromLiteral(literal);
    }
    async modelForSynchronization() {
        const model = await this._toList();
        return { version: this.version, model };
    }
    // Returns {version, model: [{id, value, keys: []}]}
    async toLiteral() {
        return { version: this.version, model: this._model.toLiteral() };
    }
    fromLiteral({ version, model }) {
        this.version = version;
        this._model = new CrdtCollectionModel(model);
    }
    async _toList() {
        if (this.referenceMode) {
            const items = (await this.toLiteral()).model;
            if (items.length === 0) {
                return [];
            }
            const refSet = new Set();
            items.forEach(item => refSet.add(item.value.storageKey));
            assert(refSet.size === 1, `multiple storageKeys in reference set of collection not yet supported.`);
            const ref = refSet.values().next().value;
            await this.ensureBackingStore();
            const ids = items.map(item => item.value.id);
            const results = await this.backingStore.getMultiple(ids);
            const output = [];
            for (let i = 0; i < results.length; i++) {
                output.push({ id: ids[i], value: results[i], keys: items[i].keys });
            }
            return output;
        }
        const literal = await this.toLiteral();
        return literal.model;
    }
    async toList() {
        return (await this._toList()).map(item => item.value);
    }
    async getMultiple(ids) {
        assert(!this.referenceMode, 'getMultiple not implemented for referenceMode stores');
        return ids.map(id => this._model.getValue(id));
    }
    async storeMultiple(values, keys, originatorId = null) {
        assert(!this.referenceMode, 'storeMultiple not implemented for referenceMode stores');
        values.map(value => this._model.add(value.id, value, keys));
        this.version++;
    }
    async get(id) {
        if (this.referenceMode) {
            const ref = this._model.getValue(id);
            if (ref == null) {
                return null;
            }
            await this.ensureBackingStore();
            return await this.backingStore.get(ref.id);
        }
        return this._model.getValue(id);
    }
    traceInfo() {
        return { items: this._model.size };
    }
    async store(value, keys, originatorId = null) {
        assert(keys != null && keys.length > 0, 'keys required');
        const item = { value, keys, effective: undefined };
        if (this.referenceMode) {
            const referredType = this.type.getContainedType();
            const storageKey = this.backingStore ? this.backingStore.storageKey : this.storageEngine.baseStorageKey(referredType);
            // It's important to store locally first, as the upstream consumers
            // are set up to assume all writes are processed (at least locally) synchronously.
            item.effective = this._model.add(value.id, { id: value.id, storageKey }, keys);
            await this.ensureBackingStore();
            await this.backingStore.store(value, keys);
        }
        else {
            item.effective = this._model.add(value.id, value, keys);
        }
        this.version++;
        await this._fire('change', new ChangeEvent({ add: [item], version: this.version, originatorId }));
    }
    async removeMultiple(items, originatorId = null) {
        if (items.length === 0) {
            items = this._model.toList().map(item => ({ id: item.id, keys: [] }));
        }
        items.forEach(item => {
            if (item.keys.length === 0) {
                item.keys = this._model.getKeys(item.id);
            }
            item.value = this._model.getValue(item.id);
            if (item.value !== null) {
                item.effective = this._model.remove(item.id, item.keys);
            }
        });
        this.version++;
        await this._fire('change', new ChangeEvent({ remove: items, version: this.version, originatorId }));
    }
    async remove(id, keys = [], originatorId = null) {
        if (keys.length === 0) {
            keys = this._model.getKeys(id);
        }
        const value = this._model.getValue(id);
        if (value !== null) {
            const effective = this._model.remove(id, keys);
            this.version++;
            await this._fire('change', new ChangeEvent({ remove: [{ value, keys, effective }], version: this.version, originatorId }));
        }
    }
    clearItemsForTesting() {
        this._model = new CrdtCollectionModel();
    }
}
class VolatileSingleton extends VolatileStorageProvider {
    constructor(type, storageEngine, name, id, key) {
        super(type, name, id, key);
        this.localKeyId = 0;
        this.storageEngine = storageEngine;
        this._stored = null;
        this.backingStore = null;
    }
    backingType() {
        return this.type;
    }
    async clone() {
        const singleton = new VolatileSingleton(this.type, this.storageEngine, this.name, this.id, null);
        await singleton.cloneFrom(this);
        return singleton;
    }
    async cloneFrom(handle) {
        this.referenceMode = handle.referenceMode;
        // TODO(shans): if the handle has local modifications then cloning can fail because
        // underlying backingStore data isn't yet available to be read. However, checking the
        // localModified flag and calling persistChanges is really not the correct way to
        // mitigate this problem - instead, the model provided by await handle.toLiteral() should
        // remove local modifications that haven't been persisted.
        if (handle.referenceMode && handle.localModified) {
            await handle._persistChanges();
        }
        const literal = await handle.toLiteral();
        if (this.referenceMode && literal.model.length > 0) {
            await Promise.all([this.ensureBackingStore(), handle.ensureBackingStore()]);
            literal.model = literal.model.map(({ id, value }) => ({ id, value: { id: value.id, storageKey: this.backingStore.storageKey } }));
            const underlying = await handle.backingStore.getMultiple(literal.model.map(({ id }) => id));
            await this.backingStore.storeMultiple(underlying, [this.storageKey]);
        }
        await this.fromLiteral(literal);
    }
    async modelForSynchronization() {
        if (this.referenceMode && this._stored !== null) {
            const value = this._stored;
            await this.ensureBackingStore();
            const result = await this.backingStore.get(value.id);
            return {
                version: this.version,
                model: [{ id: value.id, value: result }]
            };
        }
        return super.modelForSynchronization();
    }
    async toLiteral() {
        const value = this._stored;
        // TODO: what should keys be set to?
        const model = (value != null) ? [{ id: value.id, value, keys: [] }] : [];
        return { version: this.version, model };
    }
    fromLiteral({ version, model }) {
        const value = model.length === 0 ? null : model[0].value;
        if (this.referenceMode && value && value.rawData) {
            assert(false, `shouldn't have rawData ${JSON.stringify(value.rawData)} here`);
        }
        assert(value !== undefined);
        this._stored = value;
        this.version = version;
    }
    traceInfo() {
        return { stored: this._stored !== null };
    }
    async get() {
        if (this.referenceMode && this._stored) {
            const value = this._stored;
            await this.ensureBackingStore();
            return await this.backingStore.get(value.id);
        }
        return this._stored;
    }
    async set(value, originatorId = null, barrier = null) {
        assert(value !== undefined);
        if (this.referenceMode && value) {
            // Even if this value is identical to the previously written one,
            // we can't suppress an event here because we don't actually have
            // the previous value for comparison (that's down in the backing store).
            // TODO(shans): should we fetch and compare in the case of the ids matching?
            const referredType = this.type;
            const storageKey = this.backingStore ? this.backingStore.storageKey : this.storageEngine.baseStorageKey(referredType);
            // It's important to store locally first, as the upstream consumers
            // are set up to assume all writes are processed (at least locally) synchronously.
            this._stored = { id: value.id, storageKey };
            await this.ensureBackingStore();
            // TODO(shans): mutating the storageKey here to provide unique keys is
            // a hack that can be removed once entity mutation is distinct from collection
            // updates. Once entity mutation exists, it shouldn't ever be possible to write
            // different values with the same id.
            await this.backingStore.store(value, [this.storageKey + this.localKeyId++]);
        }
        else {
            // If there's a barrier set, then the originating storage-proxy is expecting
            // a result so we cannot suppress the event here.
            if (JSON.stringify(this._stored) === JSON.stringify(value) &&
                barrier == null) {
                return;
            }
            this._stored = value;
        }
        this.version++;
        const data = this.referenceMode ? value : this._stored;
        await this._fire('change', new ChangeEvent({ data, version: this.version, originatorId, barrier }));
    }
    async clear(originatorId = null, barrier = null) {
        await this.set(null, originatorId, barrier);
    }
}
// Volatile version of the BigCollection API; primarily for testing.
class VolatileCursor {
    constructor(version, data, pageSize, forward) {
        this.version = version;
        this.pageSize = pageSize;
        const copy = [...data];
        copy.sort((a, b) => a.index - b.index);
        this.data = copy.map(v => v.value);
        if (!forward) {
            this.data.reverse();
        }
    }
    async next() {
        if (this.data.length === 0) {
            return { done: true };
        }
        return { value: this.data.splice(0, this.pageSize), done: false };
    }
    close() {
        this.data = [];
    }
}
class VolatileBigCollection extends VolatileStorageProvider {
    constructor(type, storageEngine, name, id, key) {
        super(type, name, id, key);
        this.items = new Map();
        this.cursors = new Map();
        this.cursorIndex = 0;
    }
    enableReferenceMode() {
        assert(false, 'referenceMode is not supported for BigCollection');
    }
    backingType() {
        return this.type.getContainedType();
    }
    async get(id) {
        const data = this.items.get(id);
        return (data !== undefined) ? data.value : null;
    }
    async store(value, keys, originatorId) {
        assert(keys != null && keys.length > 0, 'keys required');
        this.version++;
        if (!this.items.has(value.id)) {
            this.items.set(value.id, { index: null, value: null, keys: {} });
        }
        const data = this.items.get(value.id);
        data.index = this.version;
        data.value = value;
        keys.forEach(k => data.keys[k] = this.version);
    }
    async remove(id, keys, originatorId) {
        this.version++;
        this.items.delete(id);
    }
    async stream(pageSize, forward = true) {
        assert(!isNaN(pageSize) && pageSize > 0);
        this.cursorIndex++;
        const cursor = new VolatileCursor(this.version, this.items.values(), pageSize, forward);
        this.cursors.set(this.cursorIndex, cursor);
        return this.cursorIndex;
    }
    async cursorNext(cursorId) {
        const cursor = this.cursors.get(cursorId);
        if (!cursor) {
            return { done: true };
        }
        const data = await cursor.next();
        if (data.done) {
            this.cursors.delete(cursorId);
        }
        return data;
    }
    async cursorClose(cursorId) {
        const cursor = this.cursors.get(cursorId);
        if (cursor) {
            this.cursors.delete(cursorId);
            cursor.close();
        }
    }
    cursorVersion(cursorId) {
        const cursor = this.cursors.get(cursorId);
        return cursor ? cursor.version : null;
    }
    async cloneFrom(handle) {
        // TODO: clone from non-volatile versions
        if (handle.items) {
            this.fromLiteral(handle.toLiteral());
        }
    }
    // Returns {version, model: [{id, index, value, keys: []}]}
    async toLiteral() {
        const model = [];
        for (const [id, { index, value, keys }] of this.items.entries()) {
            model.push({ id, index, value, keys: Object.keys(keys) });
        }
        return { version: this.version, model };
    }
    fromLiteral({ version, model }) {
        this.version = version;
        this.items.clear();
        for (const { id, index, value, keys } of model) {
            const adjustedKeys = {};
            for (const k of keys) {
                adjustedKeys[k] = index;
            }
            this.items.set(id, { index, value, keys: adjustedKeys });
        }
    }
    clearItemsForTesting() {
        this.items.clear();
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Returns the set delta between two lists based on custom object comparison.
 * `keyFn` takes type T and returns the value by which items should be compared.
 */
function setDiffCustom(from, to, keyFn) {
    const result = { add: [], remove: [] };
    const items = new Map();
    const fromSet = new Map();
    const toSet = new Map();
    for (const item of from) {
        const key = keyFn(item);
        items.set(key, item);
        fromSet.set(key, item);
    }
    for (const item of to) {
        const key = keyFn(item);
        items.set(key, item);
        toSet.set(key, item);
    }
    for (const [key, item] of items) {
        if (fromSet.has(key)) {
            if (toSet.has(key)) {
                continue;
            }
            result.remove.push(item);
            continue;
        }
        assert(toSet.has(key));
        result.add.push(item);
    }
    return result;
}
/**
 * A hack to ignore a floating promise and bypass the linter. Promises should very rarely be left floating, and when such behaviour is intended,
 * it should be clearly marked as such. See https://tsetse.info/must-use-promises.html for details.
 *
 * TODO: Remove all usages of this function and then delete it.
 */
function floatingPromiseToAudit(promise) { }

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var Scope;
(function (Scope) {
    Scope[Scope["arc"] = 1] = "arc"; // target must be a storage key for an ArcInfo Singleton
})(Scope || (Scope = {}));
var Category;
(function (Category) {
    Category[Category["handles"] = 1] = "handles"; // synthetic data will be a collection of ArcHandles
})(Category || (Category = {}));
// Format is 'synthetic://<scope>/<category>/<target>'
class SyntheticKey extends KeyBase {
    constructor(key, storageFactory) {
        super();
        const match = key.match(/^synthetic:\/\/([^/]+)\/([^/]+)\/(.+)$/);
        if (match === null || match.length !== 4) {
            throw new Error(`invalid synthetic key: ${key}`);
        }
        this.scope = Scope[match[1]];
        this.category = Category[match[2]];
        if (this.scope === Scope.arc) {
            this.targetType = new ArcType();
            const key = storageFactory.parseStringAsKey(match[3]).childKeyForArcInfo();
            this.targetKey = key.toString();
        }
        else {
            throw new Error(`invalid scope '${match[1]}' for synthetic key: ${key}`);
        }
        if (this.category === Category.handles) {
            this.syntheticType = new HandleType();
        }
        else {
            throw new Error(`invalid category '${match[2]}' for synthetic key: ${key}`);
        }
    }
    get protocol() {
        return 'synthetic';
    }
    base() {
        assert(false, 'base not supported for synthetic keys');
        return null;
    }
    get arcId() {
        assert(false, 'arcId not supported for synthetic keys');
        return null;
    }
    childKeyForHandle(id) {
        assert(false, 'childKeyForHandle not supported for synthetic keys');
        return null;
    }
    childKeyForArcInfo() {
        assert(false, 'childKeyForArcInfo not supported for synthetic keys');
        return null;
    }
    childKeyForSuggestions(userId, arcId) {
        assert(false, 'childKeyForSuggestions not supported for synthetic keys');
        return null;
    }
    childKeyForSearch(userId) {
        assert(false, 'childKeyForSearch not supported for synthetic keys');
        return null;
    }
    toString() {
        return `${this.protocol}://${Scope[this.scope]}/${Category[this.category]}/${this.targetKey}`;
    }
}
class SyntheticStorage extends StorageBase {
    constructor(arcId, storageFactory) {
        super(arcId);
        this.storageFactory = storageFactory;
    }
    async construct(id, type, keyFragment) {
        throw new Error('cannot construct SyntheticStorage providers; use connect');
    }
    async connect(id, type, key) {
        assert(type === null, 'SyntheticStorage does not accept a type parameter');
        const synthKey = new SyntheticKey(key, this.storageFactory);
        const targetStore = await this.storageFactory.connect(id, synthKey.targetType, synthKey.targetKey);
        if (targetStore === null) {
            return null;
        }
        return new SyntheticCollection(synthKey.syntheticType, id, key, targetStore, this.storageFactory);
    }
    async baseStorageFor(type, key) {
        throw new Error('baseStorageFor not implemented for SyntheticStorage');
    }
    baseStorageKey(type, key) {
        throw new Error('baseStorageKey not implemented for SyntheticStorage');
    }
    parseStringAsKey(s) {
        return new SyntheticKey(s, this.storageFactory);
    }
}
// Currently hard-wired to parse serialized data in an ArcInfo Singleton to provide a list of ArcHandles.
class SyntheticCollection extends StorageProviderBase {
    constructor(type, id, key, targetStore, storageFactory) {
        super(type, undefined, id, key);
        this.model = [];
        this.backingStore = undefined;
        this.targetStore = targetStore;
        this.storageFactory = storageFactory;
        this.initialized = (async () => {
            const data = await targetStore.get();
            await this.process(data, false);
            targetStore.on('change', details => this.process(details.data, true), this);
        })();
    }
    async process(data, fireEvent) {
        let handles;
        try {
            if (data) {
                const manifest = await Manifest.parse(ArcInfo.extractSerialization(data), {});
                handles = manifest.activeRecipe && manifest.activeRecipe.handles;
            }
        }
        catch (e) {
            console.warn(`Error parsing manifest at ${this.storageKey}:\n${e.message}`);
        }
        const oldModel = this.model;
        this.model = [];
        for (const handle of handles || []) {
            if (this.storageFactory.isPersistent(handle.storageKey)) {
                this.model.push(new ArcHandle(handle.id, handle.storageKey, handle.mappedType, handle.tags));
            }
        }
        if (fireEvent) {
            const diff = setDiffCustom(oldModel, this.model, JSON.stringify);
            const add = diff.add.map(arcHandle => ({ value: arcHandle }));
            const remove = diff.remove.map(arcHandle => ({ value: arcHandle }));
            await this._fire('change', new ChangeEvent({ add, remove }));
        }
    }
    async toList() {
        await this.initialized;
        return this.model;
    }
    async toLiteral() {
        throw new Error('unimplemented');
    }
    async cloneFrom() {
        throw new Error('cloneFrom should never be called on SyntheticCollection!');
    }
    async ensureBackingStore() {
        throw new Error('ensureBackingStore should never be called on SyntheticCollection!');
    }
    // tslint:disable-next-line: no-any
    async getMultiple(ids) {
        throw new Error('unimplemented');
    }
    async storeMultiple(values, keys, originatorId) {
        throw new Error('unimplemented');
    }
    async removeMultiple(items, originatorId) {
        throw new Error('unimplemented');
    }
    async get(id) {
        throw new Error('unimplemented');
    }
    remove(id, keys, originatorId) {
        throw new Error('unimplemented');
    }
    store(value, keys, originatorId) {
        throw new Error('unimplemented');
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A simmple Mutex to gate access to critical async code
 * sections that should not execute concurrently.
 *
 * Sample usage:
 *
 * ```
 *   class SampleClass {
 *     private readonly mutex = new Mutex();
 *
 *     async instantiate() {
 *       const release = await mutex.acquire();
 *       try {
 *         // Protected section with async execution.
 *       } finally {
 *         release();
 *       }
 *     }
 *   }
 */
class Mutex {
    constructor() {
        this.next = Promise.resolve();
        this.depth = 0; // tracks the number of blocked executions on this lock.
    }
    /**
     * @return true if the mutex is already acquired.
     */
    get locked() {
        return this.depth !== 0;
    }
    /**
     * Call acquire and await it to lock the critical section for the Mutex.
     *
     * @return A Releaser which resolves to a function which releases the Mutex.
     */
    async acquire() {
        let release;
        const current = this.next.then(() => {
            // external code is awaiting the result of acquire
            this.depth++;
            return () => {
                // external code is calling the releaser
                release();
                this.depth--;
            };
        });
        this.next = new Promise(resolve => {
            release = resolve;
        });
        return current;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TODO(sjmiles): StorageProviderFactory.register can be used
// to install additional providers, as long as it's invoked
// before any StorageProviderFactory objects are constructed.
const providers = {
    volatile: { storage: VolatileStorage, isPersistent: false },
    synthetic: { storage: SyntheticStorage, isPersistent: false }
};
class StorageProviderFactory {
    constructor(arcId) {
        this.arcId = arcId;
        this.mutexMap = new Map();
        this._storageInstances = {};
        Object.keys(providers).forEach(name => {
            const { storage, isPersistent } = providers[name];
            this._storageInstances[name] = { storage: new storage(arcId, this), isPersistent };
        });
    }
    static register(name, instance) {
        providers[name] = instance;
    }
    getInstance(key) {
        const instance = this._storageInstances[key.split(':')[0]];
        if (!instance) {
            throw new Error(`unknown storage protocol: ${key}`);
        }
        return instance;
    }
    _storageForKey(key) {
        if (!key) {
            throw new Error('key is required');
        }
        return this.getInstance(key).storage;
    }
    isPersistent(key) {
        return key && this.getInstance(key).isPersistent;
    }
    async construct(id, type, keyFragment) {
        // TODO(shans): don't use reference mode once adapters are implemented
        return await this._storageForKey(keyFragment).construct(id, type, keyFragment);
    }
    async connect(id, type, key) {
        // TODO(shans): don't use reference mode once adapters are implemented
        return await this._storageForKey(key).connect(id, type, key);
    }
    async _acquireMutexForKey(key) {
        if (!this.mutexMap.has(key)) {
            this.mutexMap.set(key, new Mutex());
        }
        return this.mutexMap.get(key).acquire();
    }
    async connectOrConstruct(id, type, key) {
        const storage = this._storageForKey(key);
        const release = await this._acquireMutexForKey(key);
        try {
            let result = await storage.connect(id, type, key);
            if (result == null) {
                result = await storage.construct(id, type, key);
            }
            return result;
        }
        finally {
            release();
        }
    }
    async baseStorageFor(type, keyString) {
        return await this._storageForKey(keyString).baseStorageFor(type, keyString);
    }
    baseStorageKey(type, keyString) {
        return this._storageForKey(keyString).baseStorageKey(type, keyString);
    }
    parseStringAsKey(s) {
        return this._storageForKey(s).parseStringAsKey(s);
    }
    newKey(id, associatedKeyFragment) {
    }
    // For testing
    async shutdown() {
        for (const s of Object.values(this._storageInstances)) {
            await s.storage.shutdown();
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ManifestError extends Error {
    constructor(location, message) {
        super(message);
        this.location = location;
    }
}
/**
 * Calls `this.visit()` for each node in a manfest AST, parents before children.
 */
class ManifestVisitor {
    traverse(ast) {
        if (['string', 'number', 'boolean'].includes(typeof ast) || ast === null) {
            return;
        }
        if (ast instanceof Array) {
            for (const item of ast) {
                this.traverse(item);
            }
            return;
        }
        assert(ast.location, 'expected manifest node to have `location`');
        assert(ast.kind, 'expected manifest node to have `kind`');
        let childrenVisited = false;
        const visitChildren = () => {
            if (childrenVisited) {
                return;
            }
            childrenVisited = true;
            for (const key of Object.keys(ast)) {
                if (['location', 'kind', 'model'].includes(key)) {
                    continue;
                }
                this.traverse(ast[key]);
            }
        };
        this.visit(ast, visitChildren);
        visitChildren();
    }
    // Parents are visited before children, but an implementation can force
    // children to be visted by calling `visitChildren()`.
    visit(node, visitChildren) {
    }
}
const globalWarningKeys = new Set();
class Manifest {
    constructor({ id }) {
        this._recipes = [];
        this._imports = [];
        // TODO: These should be lists, possibly with a separate flattened map.
        this._particles = {};
        this._schemas = {};
        this._stores = [];
        this._interfaces = [];
        this.storeTags = new Map();
        this._fileName = null;
        // TODO(csilvestrini): Inject an IdGenerator instance instead of creating a new one.
        this._idGenerator = IdGenerator.newSession();
        this._storageProviderFactory = undefined;
        this._meta = new ManifestMeta();
        this._resources = {};
        this.storeManifestUrls = new Map();
        this.errors = [];
        // TODO: Cleanup usage of strings as Ids.
        assert(id instanceof Id || typeof id === 'string');
        if (id instanceof Id) {
            this._id = id;
        }
        else {
            // We use the first component of an ID as a session ID, for manifests parsed
            // from the file, this is the 'manifest' phrase.
            // TODO: Figure out if this is ok, and stop using internal Id APIs.
            const components = id.split(':');
            this._id = Id._newIdInternal(components[0], components.slice(1));
        }
    }
    get id() {
        if (this._meta.name) {
            return Id.fromString(this._meta.name);
        }
        return this._id;
    }
    get storageProviderFactory() {
        if (this._storageProviderFactory == undefined) {
            this._storageProviderFactory = new StorageProviderFactory(this.id);
        }
        return this._storageProviderFactory;
    }
    get recipes() {
        return this._recipes;
    }
    get allRecipes() {
        return [...new Set(this._findAll(manifest => manifest._recipes))];
    }
    get activeRecipe() {
        return this._recipes.find(recipe => recipe.annotation === 'active');
    }
    get particles() {
        return Object.values(this._particles);
    }
    get allParticles() {
        return [...new Set(this._findAll(manifest => Object.values(manifest._particles)))];
    }
    get imports() {
        return this._imports;
    }
    get schemas() {
        return this._schemas;
    }
    get allSchemas() {
        return [...new Set(this._findAll(manifest => Object.values(manifest._schemas)))];
    }
    get fileName() {
        return this._fileName;
    }
    get stores() {
        return this._stores;
    }
    get allStores() {
        return [...this._findAll(manifest => manifest._stores)];
    }
    get interfaces() {
        return this._interfaces;
    }
    get meta() {
        return this._meta;
    }
    get resources() {
        return this._resources;
    }
    applyMeta(section) {
        if (this._storageProviderFactory !== undefined) {
            assert(section.name === this._meta.name || section.name == undefined, `can't change manifest ID after storage is constructed`);
        }
        this._meta.apply(section);
    }
    // TODO: newParticle, Schema, etc.
    // TODO: simplify() / isValid().
    async createStore(type, name, id, tags, claims, storageKey) {
        return this.newStorageStub(type, name, id, storageKey, tags, null, claims);
    }
    _addStore(store, tags) {
        this._stores.push(store);
        this.storeTags.set(store, tags ? tags : []);
        return store;
    }
    newStorageStub(type, name, id, storageKey, tags, originalId, claims, description, version, source, referenceMode, model) {
        if (source) {
            this.storeManifestUrls.set(id, this.fileName);
        }
        return this._addStore(new StorageStub(type, id, name, storageKey, this.storageProviderFactory, originalId, claims, description, version, source, referenceMode, model), tags);
    }
    _find(manifestFinder) {
        let result = manifestFinder(this);
        if (!result) {
            for (const importedManifest of this._imports) {
                result = importedManifest._find(manifestFinder);
                if (result) {
                    break;
                }
            }
        }
        return result;
    }
    *_findAll(manifestFinder) {
        yield* manifestFinder(this);
        for (const importedManifest of this._imports) {
            yield* importedManifest._findAll(manifestFinder);
        }
    }
    findSchemaByName(name) {
        return this._find(manifest => manifest._schemas[name]);
    }
    findTypeByName(name) {
        const schema = this.findSchemaByName(name);
        if (schema) {
            return new EntityType(schema);
        }
        const iface = this.findInterfaceByName(name);
        if (iface) {
            return new InterfaceType(iface);
        }
        return undefined;
    }
    findParticleByName(name) {
        return this._find(manifest => manifest._particles[name]);
    }
    findParticlesByVerb(verb) {
        return [...this._findAll(manifest => Object.values(manifest._particles).filter(particle => particle.primaryVerb === verb))];
    }
    findStoreByName(name) {
        return this._find(manifest => manifest._stores.find(store => store.name === name));
    }
    findStoreById(id) {
        return this._find(manifest => manifest._stores.find(store => store.id === id));
    }
    findStoreTags(store) {
        return new Set(this._find(manifest => manifest.storeTags.get(store)));
    }
    findManifestUrlForHandleId(id) {
        return this._find(manifest => manifest.storeManifestUrls.get(id));
    }
    findStoresByType(type, options = { tags: [], subtype: false }) {
        const tags = options.tags || [];
        const subtype = options.subtype || false;
        function typePredicate(store) {
            const resolvedType = type.resolvedType();
            if (!resolvedType.isResolved()) {
                return (type instanceof CollectionType) === (store.type instanceof CollectionType) &&
                    (type instanceof BigCollectionType) === (store.type instanceof BigCollectionType);
            }
            if (subtype) {
                const [left, right] = Type.unwrapPair(store.type, resolvedType);
                if (left instanceof EntityType && right instanceof EntityType) {
                    return left.entitySchema.isMoreSpecificThan(right.entitySchema);
                }
                return false;
            }
            return TypeChecker.compareTypes({ type: store.type }, { type });
        }
        function tagPredicate(manifest, store) {
            return tags.filter(tag => !manifest.storeTags.get(store).includes(tag)).length === 0;
        }
        const stores = [...this._findAll(manifest => manifest._stores.filter(store => typePredicate(store) && tagPredicate(manifest, store)))];
        // Quick check that a new handle can fulfill the type contract.
        // Rewrite of this method tracked by https://github.com/PolymerLabs/arcs/issues/1636.
        return stores.filter(s => !!Handle.effectiveType(type, [{ type: s.type, direction: (s.type instanceof InterfaceType) ? 'host' : 'inout' }]));
    }
    findInterfaceByName(name) {
        return this._find(manifest => manifest._interfaces.find(iface => iface.name === name));
    }
    findRecipesByVerb(verb) {
        return [...this._findAll(manifest => manifest._recipes.filter(recipe => recipe.verbs.includes(verb)))];
    }
    generateID() {
        return this._idGenerator.newChildId(this.id);
    }
    static async load(fileName, loader, options = {}) {
        let { registry } = options;
        registry = registry || {};
        if (registry && registry[fileName]) {
            return await registry[fileName];
        }
        registry[fileName] = (async () => {
            const content = await loader.loadResource(fileName);
            // TODO: When does this happen? The loader should probably throw an exception here.
            assert(content !== undefined, `${fileName} unable to be loaded by Manifest parser`);
            return await Manifest.parse(content, {
                fileName,
                loader,
                registry,
            });
        })();
        return await registry[fileName];
    }
    static getErrors(manifest) {
        return manifest.errors;
    }
    static async parse(content, options = {}) {
        // TODO(sjmiles): allow `context` for including an existing manifest in the import list
        let { fileName, loader, registry, context, throwImportErrors } = options;
        registry = registry || {};
        const id = `manifest:${fileName}:`;
        function dumpErrors(manifest) {
            for (const error of manifest.errors) {
                // TODO: make a decision as to whether we should be logging these here, or if it should
                //       be a responsibility of the caller.
                // TODO: figure out how to have node print the correct message and stack trace
                if (error.key) {
                    if (globalWarningKeys.has(error.key)) {
                        continue;
                    }
                    globalWarningKeys.add(error.key);
                }
                console.warn(processError(error).message);
            }
        }
        // tslint:disable-next-line: no-any
        function processError(e, parseError) {
            if (!((e instanceof ManifestError) || e.location)) {
                return e;
            }
            return processManifestError(e, parseError);
        }
        function processManifestError(e, parseError) {
            const lines = content.split('\n');
            const line = lines[e.location.start.line - 1];
            // TODO(sjmiles): see https://github.com/PolymerLabs/arcs/issues/2570
            let message = e.message || '';
            if (line) {
                let span = 1;
                if (e.location.end.line === e.location.start.line) {
                    span = e.location.end.column - e.location.start.column;
                }
                else {
                    span = line.length - e.location.start.column;
                }
                span = Math.max(1, span);
                let highlight = '';
                for (let i = 0; i < e.location.start.column - 1; i++) {
                    highlight += ' ';
                }
                for (let i = 0; i < span; i++) {
                    highlight += '^';
                }
                let preamble;
                if (parseError) {
                    preamble = 'Parse error in';
                }
                else {
                    preamble = 'Post-parse processing error caused by';
                }
                message = `${preamble} '${fileName}' line ${e.location.start.line}.
${e.message}
  ${line}
  ${highlight}`;
            }
            const err = new ManifestError(e.location, message);
            if (!parseError) {
                err.stack = e.stack;
            }
            return err;
        } // end processManifestError
        let items = [];
        try {
            items = parse(content);
        }
        catch (e) {
            throw processError(e, true);
        }
        const manifest = new Manifest({ id });
        manifest._fileName = fileName;
        // TODO(sjmiles): optionally include pre-existing context
        if (context) {
            manifest._imports.push(context);
        }
        try {
            // Loading of imported manifests is triggered in parallel to avoid a serial loading
            // of resources over the network.
            await Promise.all(items.map(async (item) => {
                if (item.kind === 'import') {
                    if (!loader) {
                        throw new Error('loader required to parse import statements');
                    }
                    // item is an AstNode.Import
                    const path = loader.path(manifest.fileName);
                    const target = loader.join(path, item.path);
                    try {
                        manifest._imports.push(await Manifest.load(target, loader, { registry }));
                    }
                    catch (e) {
                        manifest.errors.push(e);
                        manifest.errors.push(new ManifestError(item.location, `Error importing '${target}'`));
                    }
                }
            }));
            const processItems = async (kind, f) => {
                for (const item of items) {
                    if (item.kind === kind) {
                        Manifest._augmentAstWithTypes(manifest, item);
                        await f(item); // TODO(cypher1): Use Promise.all here.
                    }
                }
            };
            // processing meta sections should come first as this contains identifying
            // information that might need to be used in other sections. For example,
            // the meta.name, if present, becomes the manifest id which is relevant
            // when constructing manifest stores.
            await processItems('meta', meta => manifest.applyMeta(meta.items));
            // similarly, resources may be referenced from other parts of the manifest.
            await processItems('resource', item => this._processResource(manifest, item));
            await processItems('schema', item => this._processSchema(manifest, item));
            await processItems('interface', item => this._processInterface(manifest, item));
            await processItems('particle', item => this._processParticle(manifest, item, loader));
            await processItems('store', item => this._processStore(manifest, item, loader));
            await processItems('recipe', item => this._processRecipe(manifest, item));
        }
        catch (e) {
            dumpErrors(manifest);
            throw processError(e, false);
        }
        dumpErrors(manifest);
        if (options.throwImportErrors && manifest.errors.length > 0) {
            throw manifest.errors[0];
        }
        return manifest;
    }
    static _augmentAstWithTypes(manifest, items) {
        const visitor = new class extends ManifestVisitor {
            constructor() {
                super();
            }
            visit(node, visitChildren) {
                // TODO(dstockwell): set up a scope and merge type variables here, so that
                //     errors relating to failed merges can reference the manifest source.
                visitChildren();
                switch (node.kind) {
                    case 'schema-inline': {
                        const schemas = [];
                        const aliases = [];
                        const names = [];
                        for (const name of node.names) {
                            const resolved = manifest.resolveTypeName(name);
                            if (resolved && resolved.schema && resolved.schema.isAlias) {
                                aliases.push(resolved.schema);
                            }
                            else {
                                names.push(name);
                            }
                            if (resolved && resolved.schema) {
                                schemas.push(resolved.schema);
                            }
                        }
                        // tslint:disable-next-line: no-any
                        const fields = {};
                        for (let { name, type } of node.fields) {
                            for (const schema of schemas) {
                                if (!type) {
                                    // If we don't have a type, try to infer one from the schema.
                                    type = schema.fields[name];
                                }
                                else {
                                    // Validate that the specified or inferred type matches the schema.
                                    const externalType = schema.fields[name];
                                    if (externalType && !Schema.typesEqual(externalType, type)) {
                                        throw new ManifestError(node.location, `Type of '${name}' does not match schema (${type} vs ${externalType})`);
                                    }
                                }
                            }
                            if (!type) {
                                throw new ManifestError(node.location, `Could not infer type of '${name}' field`);
                            }
                            fields[name] = type;
                        }
                        let schema = new Schema(names, fields);
                        for (const alias of aliases) {
                            schema = Schema.union(alias, schema);
                            if (!schema) {
                                throw new ManifestError(node.location, `Could not merge schema aliases`);
                            }
                        }
                        node.model = new EntityType(schema);
                        return;
                    }
                    case 'variable-type': {
                        const constraint = node.constraint && node.constraint.model;
                        node.model = TypeVariable.make(node.name, constraint, null);
                        return;
                    }
                    case 'slot-type': {
                        const fields = {};
                        for (const fieldIndex of Object.keys(node.fields)) {
                            const field = node.fields[fieldIndex];
                            fields[field.name] = field.value;
                        }
                        node.model = SlotType.make(fields['formFactor'], fields['handle']);
                        return;
                    }
                    case 'type-name': {
                        const resolved = manifest.resolveTypeName(node.name);
                        if (!resolved) {
                            throw new ManifestError(node.location, `Could not resolve type reference to type name '${node.name}'`);
                        }
                        if (resolved.schema) {
                            node.model = new EntityType(resolved.schema);
                        }
                        else if (resolved.iface) {
                            node.model = new InterfaceType(resolved.iface);
                        }
                        else {
                            throw new ManifestError(node.location, 'Expected {iface} or {schema}');
                        }
                        return;
                    }
                    case 'collection-type':
                        node.model = new CollectionType(node.type.model);
                        return;
                    case 'big-collection-type':
                        node.model = new BigCollectionType(node.type.model);
                        return;
                    case 'reference-type':
                        node.model = new ReferenceType(node.type.model);
                        return;
                    default:
                        return;
                }
            }
        }();
        visitor.traverse(items);
    }
    static _processSchema(manifest, schemaItem) {
        let description;
        const fields = {};
        let names = [...schemaItem.names];
        for (const item of schemaItem.items) {
            switch (item.kind) {
                case 'schema-field': {
                    const field = item;
                    if (fields[field.name]) {
                        throw new ManifestError(field.location, `Duplicate definition of field '${field.name}'`);
                    }
                    fields[field.name] = field.type;
                    break;
                }
                case 'description': {
                    if (description) {
                        throw new ManifestError(item.location, `Duplicate schema description`);
                    }
                    description = item;
                    break;
                }
                default:
                    throw new ManifestError(item.location, `unknown parser artifact ${item.kind} while processing schema`);
            }
        }
        for (const parent of schemaItem.parents) {
            const result = manifest.findSchemaByName(parent);
            if (!result) {
                throw new ManifestError(schemaItem.location, `Could not find parent schema '${parent}'`);
            }
            for (const [name, type] of Object.entries(result.fields)) {
                if (fields[name] && !Schema.typesEqual(fields[name], type)) {
                    throw new ManifestError(schemaItem.location, `'${parent}' defines incompatible type for field '${name}'`);
                }
            }
            Object.assign(fields, result.fields);
            names.push(...result.names);
        }
        names = [names[0], ...names.filter(name => name !== names[0])];
        const name = schemaItem.alias || names[0];
        if (!name) {
            throw new ManifestError(schemaItem.location, `Schema defined without name or alias`);
        }
        const schema = new Schema(names, fields, description);
        if (schemaItem.alias) {
            schema.isAlias = true;
        }
        manifest._schemas[name] = schema;
    }
    static _processResource(manifest, schemaItem) {
        manifest._resources[schemaItem.name] = schemaItem.data;
    }
    static _processParticle(manifest, particleItem, loader) {
        // TODO: we should be producing a new particleSpec, not mutating
        //       particleItem directly.
        // TODO: we should require both of these and update failing tests...
        assert(particleItem.implFile == null || particleItem.args !== null, 'no valid body defined for this particle');
        if (!particleItem.args) {
            particleItem.args = [];
        }
        if (particleItem.hasParticleArgument) {
            const warning = new ManifestError(particleItem.location, `Particle uses deprecated argument body`);
            warning.key = 'hasParticleArgument';
            manifest['_warnings'].push(warning);
        }
        // TODO: loader should not be optional.
        if (particleItem.implFile && loader) {
            particleItem.implFile = loader.join(manifest.fileName, particleItem.implFile);
        }
        const processArgTypes = args => {
            for (const arg of args) {
                arg.type = arg.type.model;
                processArgTypes(arg.dependentConnections);
            }
        };
        processArgTypes(particleItem.args);
        manifest._particles[particleItem.name] = new ParticleSpec(particleItem);
    }
    // TODO: Move this to a generic pass over the AST and merge with resolveTypeName.
    static _processInterface(manifest, interfaceItem) {
        const handles = [];
        for (const arg of interfaceItem.args) {
            const handle = { name: undefined, type: undefined, direction: arg.direction };
            if (arg.name !== '*') {
                handle.name = arg.name;
            }
            if (arg.type) {
                handle.type = arg.type.model;
            }
            handles.push(handle);
        }
        const slots = [];
        for (const slotItem of interfaceItem.slots) {
            slots.push({
                direction: slotItem.direction,
                name: slotItem.name,
                isRequired: slotItem.isRequired,
                isSet: slotItem.isSet
            });
        }
        // TODO: move interface to recipe/ and add interface builder?
        const ifaceInfo = new InterfaceInfo(interfaceItem.name, handles, slots);
        manifest._interfaces.push(ifaceInfo);
    }
    static _processRecipe(manifest, recipeItem) {
        const recipe = manifest._newRecipe(recipeItem.name);
        if (recipeItem.annotation) {
            recipe.annotation = recipeItem.annotation;
        }
        if (recipeItem.triggers) {
            recipe.triggers = recipeItem.triggers;
        }
        if (recipeItem.verbs) {
            recipe.verbs = recipeItem.verbs;
        }
        this._buildRecipe(manifest, recipe, recipeItem.items);
    }
    static _buildRecipe(manifest, recipe, recipeItems) {
        const items = {
            require: recipeItems.filter(item => item.kind === 'require'),
            handles: recipeItems.filter(item => item.kind === 'handle'),
            byHandle: new Map(),
            // requireHandles are handles constructed by the 'handle' keyword. This is intended to replace handles.
            requireHandles: recipeItems.filter(item => item.kind === 'requireHandle'),
            particles: recipeItems.filter(item => item.kind === 'particle'),
            byParticle: new Map(),
            slots: recipeItems.filter(item => item.kind === 'slot'),
            bySlot: new Map(),
            // tslint:disable-next-line: no-any
            byName: new Map(),
            connections: recipeItems.filter(item => item.kind === 'connection'),
            search: recipeItems.find(item => item.kind === 'search'),
            description: recipeItems.find(item => item.kind === 'description')
        };
        // A recipe should either source handles by the 'handle' keyword (requireHandle item) or use fates (handle item).
        // A recipe should not use both methods.
        assert(!(items.handles.length > 0 && items.requireHandles.length > 0), `Inconsistent handle definitions`);
        const itemHandles = (items.handles.length > 0 ? items.handles : items.requireHandles);
        for (const item of itemHandles) {
            const handle = recipe.newHandle();
            const ref = item.ref;
            if (ref.id) {
                handle.id = ref.id;
                const targetStore = manifest.findStoreById(handle.id);
                if (targetStore) {
                    handle.mapToStorage(targetStore);
                }
            }
            else if (ref.name) {
                const targetStore = manifest.findStoreByName(ref.name);
                // TODO: Error handling.
                assert(targetStore, `Could not find handle ${ref.name}`);
                handle.mapToStorage(targetStore);
            }
            handle.tags = ref.tags;
            if (item.name) {
                assert(!items.byName.has(item.name), `duplicate handle name: ${item.name}`);
                handle.localName = item.name;
                items.byName.set(item.name, { item, handle });
            }
            handle.fate = item.fate ? item.fate : null;
            items.byHandle.set(handle, item);
        }
        const prepareEndpoint = (connection, info) => {
            switch (info.targetType) {
                case 'particle': {
                    const particle = manifest.findParticleByName(info.particle);
                    if (!particle) {
                        throw new ManifestError(connection.location, `could not find particle '${info.particle}'`);
                    }
                    if (info.param !== null && !particle.handleConnectionMap.has(info.param)) {
                        throw new ManifestError(connection.location, `param '${info.param}' is not defined by '${info.particle}'`);
                    }
                    return new ParticleEndPoint(particle, info.param);
                }
                case 'localName': {
                    if (!items.byName.has(info.name)) {
                        throw new ManifestError(connection.location, `local name '${info.name}' does not exist in recipe`);
                    }
                    if (info.param == null && info.tags.length === 0 &&
                        items.byName.get(info.name).handle) {
                        return new HandleEndPoint(items.byName.get(info.name).handle);
                    }
                    throw new ManifestError(connection.location, `references to particles by local name not yet supported`);
                }
                case 'tag': {
                    return new TagEndPoint(info.tags);
                }
                default:
                    throw new ManifestError(connection.location, `endpoint ${info.targetType} not supported`);
            }
        };
        for (const connection of items.connections) {
            const from = prepareEndpoint(connection, connection.from);
            const to = prepareEndpoint(connection, connection.to);
            recipe.newConnectionConstraint(from, to, connection.direction);
        }
        if (items.search) {
            recipe.search = new Search(items.search.phrase, items.search.tokens);
        }
        for (const item of items.slots) {
            // TODO(mmandlis): newSlot requires a name. What should the name be here?
            const slot = recipe.newSlot(undefined);
            if (item.ref.id) {
                slot.id = item.ref.id;
            }
            if (item.ref.tags) {
                slot.tags = item.ref.tags;
            }
            if (item.name) {
                assert(!items.byName.has(item.name), `Duplicate slot local name ${item.name}`);
                slot.localName = item.name;
                items.byName.set(item.name, slot);
            }
            items.bySlot.set(slot, item);
        }
        // TODO: disambiguate.
        for (const item of items.particles) {
            const particle = recipe.newParticle(item.ref.name);
            particle.verbs = item.ref.verbs;
            if (!(recipe instanceof RequireSection)) {
                if (item.ref.name) {
                    const spec = manifest.findParticleByName(item.ref.name);
                    if (!spec) {
                        throw new ManifestError(item.location, `could not find particle ${item.ref.name}`);
                    }
                    particle.spec = spec.clone();
                }
            }
            if (item.name) {
                // TODO: errors.
                assert(!items.byName.has(item.name));
                particle.localName = item.name;
                items.byName.set(item.name, { item, particle });
            }
            items.byParticle.set(particle, item);
            for (const slotConnectionItem of item.slotConnections) {
                if (slotConnectionItem.direction === 'provide') {
                    throw new ManifestError(item.location, `invalid slot connection: provide slot must be dependent`);
                }
                let slotConn = particle.getSlotConnectionByName(slotConnectionItem.param);
                if (!slotConn) {
                    // particles that reference verbs should store slot connection information as constraints to be used
                    // during verb matching. However, if there's a spec then the slots need to be validated against it
                    // instead.
                    if (particle.spec !== undefined) {
                        // Validate consumed and provided slots names are according to spec.
                        if (!particle.spec.slotConnections.has(slotConnectionItem.param)) {
                            throw new ManifestError(slotConnectionItem.location, `Consumed slot '${slotConnectionItem.param}' is not defined by '${particle.name}'`);
                        }
                        slotConnectionItem.dependentSlotConnections.forEach(ps => {
                            if (!particle.getSlotSpecByName(ps.param)) {
                                throw new ManifestError(ps.location, `Provided slot '${ps.param}' is not defined by '${particle.name}'`);
                            }
                        });
                    }
                    slotConn = particle.addSlotConnection(slotConnectionItem.param);
                }
                slotConn.tags = slotConnectionItem.tags || [];
                slotConnectionItem.dependentSlotConnections.forEach(ps => {
                    if (ps.direction === 'consume') {
                        throw new ManifestError(item.location, `invalid slot connection: consume slot must not be dependent`);
                    }
                    if (ps.dependentSlotConnections.length !== 0) {
                        throw new ManifestError(item.location, `invalid slot connection: provide slot must not have dependencies`);
                    }
                    if (recipe instanceof RequireSection) {
                        // replace provided slot if it already exist in recipe.
                        const existingSlot = recipe.parent.slots.find(rslot => rslot.localName === ps.name);
                        if (existingSlot !== undefined) {
                            slotConn.providedSlots[ps.param] = existingSlot;
                            existingSlot.sourceConnection = slotConn;
                            existingSlot.name = ps.param;
                        }
                    }
                    let providedSlot = slotConn.providedSlots[ps.param];
                    if (providedSlot) {
                        if (ps.name) {
                            if (items.byName.has(ps.name)) {
                                // The slot was added to the recipe twice - once as part of the
                                // slots in the manifest, then as part of particle spec.
                                // Unifying both slots, updating name and source slot connection.
                                const theSlot = items.byName.get(ps.name);
                                assert(theSlot !== providedSlot);
                                assert(!theSlot.name && providedSlot);
                                assert(!theSlot.sourceConnection && providedSlot.sourceConnection);
                                providedSlot.id = theSlot.id;
                                providedSlot.tags = theSlot.tags;
                                items.byName.set(ps.name, providedSlot);
                                recipe.removeSlot(theSlot);
                            }
                            else {
                                items.byName.set(ps.name, providedSlot);
                            }
                        }
                        items.bySlot.set(providedSlot, ps);
                    }
                    else {
                        providedSlot = items.byName.get(ps.name);
                    }
                    if (!providedSlot) {
                        providedSlot = recipe.newSlot(ps.param);
                        providedSlot.localName = ps.name;
                        providedSlot.sourceConnection = slotConn;
                        if (ps.name) {
                            assert(!items.byName.has(ps.name));
                            items.byName.set(ps.name, providedSlot);
                        }
                        items.bySlot.set(providedSlot, ps);
                    }
                    if (!slotConn.providedSlots[ps.param]) {
                        slotConn.providedSlots[ps.param] = providedSlot;
                    }
                    providedSlot.localName = ps.name;
                });
            }
        }
        for (const [particle, item] of items.byParticle) {
            for (const connectionItem of item.connections) {
                let connection;
                if (connectionItem.param === '*') {
                    connection = particle.addUnnamedConnection();
                }
                else {
                    connection = particle.connections[connectionItem.param];
                    if (!connection) {
                        connection = particle.addConnectionName(connectionItem.param);
                    }
                    // TODO: else, merge tags? merge directions?
                }
                connection.tags = connectionItem.target ? connectionItem.target.tags : [];
                const direction = arrowToDirection(connectionItem.dir);
                if (!connectionMatchesHandleDirection(direction, connection.direction)) {
                    throw new ManifestError(connectionItem.location, `'${connectionItem.dir}' (${direction}) not compatible with '${connection.direction}' param of '${particle.name}'`);
                }
                else if (connection.direction === 'any') {
                    if (connectionItem.param !== '*' && particle.spec !== undefined) {
                        throw new ManifestError(connectionItem.location, `param '${connectionItem.param}' is not defined by '${particle.name}'`);
                    }
                    connection.direction = direction;
                }
                let targetHandle;
                let targetParticle;
                if (connectionItem.target && connectionItem.target.name) {
                    let entry = items.byName.get(connectionItem.target.name);
                    if (!entry) {
                        const handle = recipe.newHandle();
                        handle.tags = [];
                        handle.localName = connectionItem.target.name;
                        handle.fate = 'create';
                        // TODO: item does not exist on handle.
                        handle['item'] = { kind: 'handle' };
                        entry = { item: handle['item'], handle };
                        items.byName.set(handle.localName, entry);
                        items.byHandle.set(handle, handle['item']);
                    }
                    else if (!entry.item) {
                        throw new ManifestError(connectionItem.location, `did not expect '${entry}' expected handle or particle`);
                    }
                    if (entry.item.kind === 'handle' || entry.item.kind === 'requireHandle') {
                        targetHandle = entry.handle;
                    }
                    else if (entry.item.kind === 'particle') {
                        targetParticle = entry.particle;
                    }
                    else {
                        throw new ManifestError(connectionItem.location, `did not expect ${entry.item.kind}`);
                    }
                }
                // Handle implicit handle connections in the form `param = SomeParticle`
                if (connectionItem.target && connectionItem.target.particle) {
                    const hostedParticle = manifest.findParticleByName(connectionItem.target.particle);
                    if (!hostedParticle) {
                        throw new ManifestError(connectionItem.target.location, `Could not find hosted particle '${connectionItem.target.particle}'`);
                    }
                    targetHandle = RecipeUtil.constructImmediateValueHandle(connection, hostedParticle, manifest.generateID());
                    if (!targetHandle) {
                        throw new ManifestError(connectionItem.target.location, `Hosted particle '${hostedParticle.name}' does not match interface '${connection.name}'`);
                    }
                }
                if (targetParticle) {
                    let targetConnection;
                    // TODO(lindner): replaced param with name since param is not defined, but name/particle are...
                    if (connectionItem.target.name) {
                        targetConnection = targetParticle.connections[connectionItem.target.name];
                        if (!targetConnection) {
                            targetConnection = targetParticle.addConnectionName(connectionItem.target.name);
                            // TODO: direction?
                        }
                    }
                    else {
                        targetConnection = targetParticle.addUnnamedConnection();
                        // TODO: direction?
                    }
                    targetHandle = targetConnection.handle;
                    if (!targetHandle) {
                        // TODO: tags?
                        targetHandle = recipe.newHandle();
                        targetConnection.connectToHandle(targetHandle);
                    }
                }
                if (targetHandle) {
                    connection.connectToHandle(targetHandle);
                }
            }
            for (const slotConnectionItem of item.slotConnections) {
                let targetSlot = items.byName.get(slotConnectionItem.name);
                if (targetSlot) {
                    assert(items.bySlot.has(targetSlot));
                    if (!targetSlot.name) {
                        targetSlot.name = slotConnectionItem.param;
                    }
                    assert(targetSlot === items.byName.get(slotConnectionItem.name), `Target slot ${targetSlot.name} doesn't match slot connection ${slotConnectionItem.param}`);
                }
                else if (slotConnectionItem.name) {
                    // if this is a require section, check if slot exists in recipe.
                    if (recipe instanceof RequireSection) {
                        targetSlot = recipe.parent.slots.find(slot => slot.localName === slotConnectionItem.name);
                        if (targetSlot !== undefined) {
                            items.bySlot.set(targetSlot, slotConnectionItem);
                            if (slotConnectionItem.name) {
                                items.byName.set(slotConnectionItem.name, targetSlot);
                            }
                        }
                    }
                    if (targetSlot == undefined) {
                        targetSlot = recipe.newSlot(slotConnectionItem.param);
                        targetSlot.localName = slotConnectionItem.name;
                        items.byName.set(slotConnectionItem.name, targetSlot);
                        items.bySlot.set(targetSlot, slotConnectionItem);
                    }
                }
                if (targetSlot) {
                    particle.getSlotConnectionByName(slotConnectionItem.param).connectToSlot(targetSlot);
                }
            }
        }
        if (items.description && items.description.description) {
            recipe.description = items.description.description;
        }
        if (items.require) {
            for (const item of items.require) {
                const requireSection = recipe.newRequireSection();
                this._buildRecipe(manifest, requireSection, item.items);
            }
        }
    }
    resolveTypeName(name) {
        const schema = this.findSchemaByName(name);
        if (schema) {
            return { schema };
        }
        const iface = this.findInterfaceByName(name);
        if (iface) {
            return { iface };
        }
        return null;
    }
    static async _processStore(manifest, item, loader) {
        const name = item.name;
        let id = item.id;
        const originalId = item.originalId;
        const type = item.type['model']; // Model added in _augmentAstWithTypes.
        if (id == null) {
            id = `${manifest._id}store${manifest._stores.length}`;
        }
        let tags = item.tags;
        if (tags == null) {
            tags = [];
        }
        const claims = [];
        if (item.claim) {
            item.claim.tags.forEach(tag => claims.push(new ClaimIsTag(/* isNot= */ false, tag)));
        }
        // Instead of creating links to remote firebase during manifest parsing,
        // we generate storage stubs that contain the relevant information.
        if (item.origin === 'storage') {
            return manifest.newStorageStub(type, name, id, item.source, tags, originalId, claims, item.description, item.version);
        }
        let json;
        let source;
        if (item.origin === 'file') {
            if (!loader) {
                throw new ManifestError(item.location, 'No loader available for file');
            }
            item.source = loader.join(manifest.fileName, item.source);
            // TODO: json5?
            json = await loader.loadResource(item.source);
        }
        else if (item.origin === 'resource') {
            source = item.source;
            json = manifest.resources[source];
            if (json == undefined) {
                throw new ManifestError(item.location, `Resource '${source}' referenced by store '${id}' is not defined in this manifest`);
            }
        }
        let entities;
        try {
            entities = JSON.parse(json);
        }
        catch (e) {
            throw new ManifestError(item.location, `Error parsing JSON from '${source}' (${e.message})'`);
        }
        // TODO: clean this up
        let unitType = null;
        let referenceMode = true;
        if (type instanceof CollectionType) {
            unitType = type.collectionType;
        }
        else if (type instanceof BigCollectionType) {
            unitType = type.bigCollectionType;
        }
        else {
            if (entities.length === 0) {
                referenceMode = false;
            }
            else {
                entities = entities.slice(entities.length - 1);
                unitType = type;
            }
        }
        if (unitType && unitType instanceof EntityType) {
            let hasSerializedId = false;
            entities = entities.map(entity => {
                if (entity == null) {
                    // FIXME: perhaps this happens when we have an empty singleton?
                    // we should just generate an empty list in that case.
                    return null;
                }
                hasSerializedId = hasSerializedId || entity.$id;
                const id = entity.$id || manifest.generateID().toString();
                delete entity.$id;
                return { id, rawData: entity };
            });
            // TODO(wkorman): Efficiency improvement opportunities: (1) We could build
            // array of entities in above map rather than mapping again below, (2) we
            // could hash the object tree data directly rather than stringifying.
            if (!item.id && !hasSerializedId) {
                const entityHash = await digest(JSON.stringify(entities.map(entity => entity.rawData)));
                id = `${id}:${entityHash}`;
            }
        }
        // While the referenceMode hack exists, we need to look at the entities being stored to
        // determine whether this store should be in referenceMode or not.
        // TODO(shans): Eventually the actual type will need to be part of the determination too.
        // TODO(shans): Need to take into account the possibility of multiple storage key mappings
        // at some point.
        if (entities.length > 0 && entities[0].rawData && entities[0].rawData.storageKey) {
            let storageKey = entities[0].rawData.storageKey;
            storageKey = manifest.findStoreByName(storageKey).storageKey;
            entities = entities.map(({ id, rawData }) => ({ id, storageKey }));
        }
        else if (entities.length > 0) {
            referenceMode = false;
        }
        // For this store to be able to be treated as a CRDT, each item needs a key.
        // Using id as key seems safe, nothing else should do this.
        let model;
        if (type instanceof CollectionType) {
            model = entities.map(value => ({ id: value.id, value, keys: new Set([value.id]) }));
        }
        else if (type instanceof BigCollectionType) {
            model = entities.map(value => {
                const index = value.rawData.$index;
                delete value.rawData.$index;
                return { id: value.id, index, value, keys: new Set([value.id]) };
            });
        }
        else {
            model = entities.map(value => ({ id: value.id, value }));
        }
        const version = item.version || 0;
        const storageKey = manifest.storageProviderFactory._storageForKey('volatile').constructKey('volatile');
        return manifest.newStorageStub(type, name, id, storageKey, tags, originalId, claims, item.description, version, item.source, referenceMode, model);
    }
    _newRecipe(name) {
        const recipe = new Recipe(name);
        this._recipes.push(recipe);
        return recipe;
    }
    toString(options = {}) {
        // TODO: sort?
        const results = [];
        this._imports.forEach(i => {
            if (options.recursive) {
                results.push(`// import '${i.fileName}'`);
                const importStr = i.toString(options);
                results.push(`${i.toString(options)}`);
            }
            else {
                results.push(`import '${i.fileName}'`);
            }
        });
        Object.values(this._schemas).forEach(s => {
            results.push(s.toManifestString());
        });
        Object.values(this._particles).forEach(p => {
            results.push(p.toString());
        });
        this._recipes.forEach(r => {
            results.push(r.toString(options));
        });
        const stores = [...this.stores].sort(compareComparables);
        stores.forEach(store => {
            results.push(store.toString(this.storeTags.get(store).map(a => `#${a}`)));
        });
        return results.join('\n');
    }
    get idGeneratorForTesting() {
        return this._idGenerator;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class MessagePort {
    constructor(channel, id, other) {
        this._channel = channel;
        this._id = id;
        this._other = other;
        this._onmessage = undefined;
    }
    // TODO appears to be {messageType, messageBody}
    async postMessage(message) {
        await this._channel._post(this._other, message);
    }
    set onmessage(f) {
        this._onmessage = f;
    }
    close() {
        this.postMessage = async () => { };
    }
}
class MessageEvent {
    constructor(message) {
        this.data = message;
    }
}
class MessageChannel {
    constructor() {
        this.port1 = new MessagePort(this, 0, 1);
        this.port2 = new MessagePort(this, 1, 0);
        this._ports = [this.port1, this.port2];
    }
    async _post(id, message) {
        message = JSON.parse(JSON.stringify(message));
        if (this._ports[id]._onmessage) {
            try {
                // Yield so that we deliver the message asynchronously.
                await 0;
                await this._ports[id]._onmessage(new MessageEvent(message));
            }
            catch (e) {
                console.error('Exception in particle code\n', e);
            }
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MappingType;
(function (MappingType) {
    MappingType[MappingType["Mapped"] = 0] = "Mapped";
    MappingType[MappingType["LocalMapped"] = 1] = "LocalMapped";
    MappingType[MappingType["RemoteMapped"] = 2] = "RemoteMapped";
    MappingType[MappingType["Direct"] = 3] = "Direct";
    MappingType[MappingType["ObjectMap"] = 4] = "ObjectMap";
    MappingType[MappingType["List"] = 5] = "List";
    MappingType[MappingType["ByLiteral"] = 6] = "ByLiteral";
})(MappingType || (MappingType = {}));
const targets = new Map();
function setPropertyKey(target, propertyKey) {
    let map = targets.get(target);
    if (map == undefined) {
        map = new Map();
        targets.set(target, map);
    }
    let list = map.get(propertyKey);
    if (list == undefined) {
        list = [];
        map.set(propertyKey, list);
    }
    return list;
}
function getPropertyKey(target, propertyKey, parameterIndex) {
    const map = targets.get(target);
    if (map) {
        const list = map.get(propertyKey);
        if (list) {
            const result = list[parameterIndex];
            if (result) {
                return result;
            }
        }
    }
    throw new Error(`the target ${target}, propertyKey ${propertyKey} and parameterIndex ${parameterIndex} provided did not exist`);
}
function set(target, propertyKey, parameterIndex, info) {
    const list = setPropertyKey(target, propertyKey);
    list[parameterIndex] = info;
}
function Direct(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct });
}
function Mapped(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Mapped });
}
function ByLiteral(constructor) {
    return (target, propertyKey, parameterIndex) => {
        const info = { type: MappingType.ByLiteral, converter: constructor };
        set(target.constructor, propertyKey, parameterIndex, info);
    };
}
function ObjectMap(key, value) {
    return (target, propertyKey, parameterIndex) => {
        const info = { type: MappingType.ObjectMap, key: { type: key }, value: { type: value } };
        set(target.constructor, propertyKey, parameterIndex, info);
    };
}
function List(value) {
    return (target, propertyKey, parameterIndex) => {
        const info = { type: MappingType.List, value: { type: value } };
        set(target.constructor, propertyKey, parameterIndex, info);
    };
}
function LocalMapped(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.LocalMapped });
}
function RemoteMapped(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.RemoteMapped });
}
function NoArgs(target, propertyKey) {
    setPropertyKey(target.constructor, propertyKey);
}
function RedundantInitializer(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, redundant: true });
}
function OverridingInitializer(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, overriding: true });
}
function Initializer(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true });
}
function Identifier(target, propertyKey, parameterIndex) {
    getPropertyKey(target.constructor, propertyKey, parameterIndex).identifier = true;
}
function RemoteIgnore(target, propertyKey, parameterIndex) {
    getPropertyKey(target.constructor, propertyKey, parameterIndex).ignore = true;
}
class ThingMapper {
    constructor(prefix) {
        this._prefix = prefix;
        this._nextIdentifier = 0;
        this._idMap = new Map();
        this._reverseIdMap = new Map();
    }
    _newIdentifier() {
        return this._prefix + (this._nextIdentifier++);
    }
    createMappingForThing(thing, requestedId = undefined) {
        assert(!this._reverseIdMap.has(thing));
        let id;
        if (requestedId) {
            id = requestedId;
        }
        else if (thing.apiChannelMappingId) {
            id = thing.apiChannelMappingId;
        }
        else {
            id = this._newIdentifier();
        }
        assert(!this._idMap.has(id), `${requestedId ? 'requestedId' : (thing.apiChannelMappingId ? 'apiChannelMappingId' : 'newIdentifier()')} ${id} already in use`);
        // TODO: Awaiting this promise causes tests to fail...
        floatingPromiseToAudit(this.establishThingMapping(id, thing));
        return id;
    }
    recreateMappingForThing(things) {
        const ids = [];
        things.forEach(thing => {
            assert(this._reverseIdMap.has(thing));
            const id = this._reverseIdMap.get(thing);
            floatingPromiseToAudit(this.establishThingMapping(id, thing));
            ids.push(id);
        });
        return ids;
    }
    maybeCreateMappingForThing(thing) {
        if (this.hasMappingForThing(thing)) {
            return this.identifierForThing(thing);
        }
        return this.createMappingForThing(thing);
    }
    async establishThingMapping(id, thing) {
        let continuation;
        if (!Array.isArray(id)) {
            if (Array.isArray(thing)) {
                [thing, continuation] = thing;
            }
            this._idMap.set(id, thing);
        }
        if (thing instanceof Promise) {
            assert(continuation == null);
            await this.establishThingMapping(id, await thing);
        }
        else if (Array.isArray(id)) {
            assert(id.length === thing.length);
            for (let i = 0; i < id.length; i++) {
                await this.establishThingMapping(id[i], thing[i]);
            }
        }
        else {
            this._reverseIdMap.set(thing, id);
            if (continuation) {
                await continuation();
            }
        }
    }
    hasMappingForThing(thing) {
        return this._reverseIdMap.has(thing);
    }
    identifierForThing(thing) {
        assert(this._reverseIdMap.has(thing), `Missing thing [${thing}]`);
        return this._reverseIdMap.get(thing);
    }
    thingForIdentifier(id) {
        assert(this._idMap.has(id), `Missing id: ${id}`);
        return this._idMap.get(id);
    }
}
class APIPort {
    constructor(messagePort, prefix) {
        this._port = messagePort;
        this._mapper = new ThingMapper(prefix);
        this._port.onmessage = async (e) => this._processMessage(e);
        this.inspector = null;
        this.attachStack = false;
        this.messageCount = 0;
        this._testingHook();
    }
    // Overridden by unit tests.
    _testingHook() {
    }
    close() {
        this._port.close();
    }
    async _processMessage(e) {
        assert(this['before' + e.data.messageType] !== undefined);
        const count = this.messageCount++;
        if (this.inspector) {
            this.inspector.pecMessage('on' + e.data.messageType, e.data.messageBody, count, e.data.stack);
        }
        this['before' + e.data.messageType](e.data.messageBody);
    }
    async send(name, args) {
        const call = { messageType: name, messageBody: args, stack: this.attachStack ? new Error().stack : undefined };
        const count = this.messageCount++;
        if (this.inspector) {
            this.inspector.pecMessage(name, args, count, new Error().stack || '');
        }
        await this._port.postMessage(call);
    }
    supportsJavaParticle() {
        // TODO: improve heuristics.
        return Object.getPrototypeOf(this._port.constructor).name === 'MessagePort';
    }
}
// The horror. From https://davidwalsh.name/javascript-arguments
function getArgs(func) {
    // First match everything inside the function argument parens.
    const args = func.toString().match(/.*?\(([^)]*)\)/)[1];
    // Split the arguments string into an array comma delimited.
    return args.split(',').map((arg) => {
        // Ensure no inline comments are parsed and trim the whitespace.
        return arg.replace(/\/\*.*\*\//, '').trim();
        // Ensure no undefined values are added.
    }).filter((arg) => arg);
}
// value is covariant with info, and errors will be found
// at start of runtime.
// tslint:disable-next-line: no-any
function convert(info, value, mapper) {
    if (info === undefined) {
        return;
    }
    switch (info.type) {
        case MappingType.Mapped:
            return mapper.identifierForThing(value);
        case MappingType.LocalMapped:
            return mapper.maybeCreateMappingForThing(value);
        case MappingType.RemoteMapped:
            // This is on the local side, so we don't do anything here.
            return value;
        case MappingType.Direct:
            return value;
        case MappingType.ObjectMap: {
            const r = {};
            value.forEach((childvalue, key) => r[convert(info.key, key, mapper)] = convert(info.value, childvalue, mapper));
            return r;
        }
        case MappingType.List:
            return value.map(v => convert(info.value, v, mapper));
        case MappingType.ByLiteral:
            return value.toLiteral();
        default:
            throw new Error(`Can't yet send MappingType ${info.type}`);
    }
}
// value is covariant with info, and errors will be found
// at start of runtime.
// tslint:disable-next-line: no-any
function unconvert(info, value, mapper) {
    if (info === undefined) {
        return;
    }
    switch (info.type) {
        case MappingType.Mapped:
            return mapper.thingForIdentifier(value);
        case MappingType.LocalMapped:
            // This is on the remote side, so we don't do anything here.
            return value;
        case MappingType.RemoteMapped:
            return mapper.thingForIdentifier(value);
        case MappingType.Direct:
            return value;
        case MappingType.ObjectMap: {
            const r = new Map();
            for (const key of Object.keys(value)) {
                r.set(unconvert(info.key, key, mapper), unconvert(info.value, value[key], mapper));
            }
            return r;
        }
        case MappingType.List:
            return value.map(v => unconvert(info.value, v, mapper));
        case MappingType.ByLiteral:
            if (!info.converter) {
                throw new Error(`Expected ${info.type} to have a converter but it doesn't`);
            }
            return info.converter.fromLiteral(value);
        default:
            throw new Error(`Can't yet recieve MappingType ${info.type}`);
    }
}
function AutoConstruct(target) {
    return (constructor) => {
        const doConstruct = (me, other) => {
            const functions = targets.get(me) || new Map();
            for (const f of functions.keys()) {
                const argNames = getArgs(me.prototype[f]);
                const descriptor = functions.get(f) || [];
                // If this descriptor is for an initializer, record that fact and we'll process it after
                // the rest of the arguments.
                const initializer = descriptor.findIndex(d => d.initializer || false);
                // If this descriptor records that this argument is the identifier, record it
                // as the requestedId for mapping below.
                const requestedId = descriptor.findIndex(d => d.identifier || false);
                /** @this APIPort */
                const impl = async function (...args) {
                    const messageBody = {};
                    for (let i = 0; i < descriptor.length; i++) {
                        if (i === initializer) {
                            continue;
                        }
                        // Process this argument.
                        messageBody[argNames[i]] = convert(descriptor[i], args[i], this._mapper);
                    }
                    // Process the initializer if present.
                    if (initializer !== -1) {
                        if (descriptor[initializer].redundant) {
                            assert(requestedId === -1);
                            messageBody['identifier'] = this._mapper.maybeCreateMappingForThing(args[initializer]);
                        }
                        else if (descriptor[initializer].overriding) {
                            messageBody['identifier'] = this._mapper.recreateMappingForThing(args[initializer]);
                        }
                        else {
                            messageBody['identifier'] = this._mapper.createMappingForThing(args[initializer], args[requestedId]);
                        }
                    }
                    await this.send(f, messageBody);
                };
                /** @this APIPort */
                const before = async function before(messageBody) {
                    const args = [];
                    const promises = [];
                    for (let i = 0; i < descriptor.length; i++) {
                        // If there's a requestedId then the receiving end won't expect to
                        // see the identifier as well.
                        if (i === initializer && (requestedId !== -1 || descriptor[i].ignore)) {
                            continue;
                        }
                        const argName = i === initializer ? 'identifier' : argNames[i];
                        const result = unconvert(descriptor[i], messageBody[argName], this._mapper);
                        if (result instanceof Promise) {
                            promises.push({ promise: result, position: args.length });
                            args.push(() => unconvert(descriptor[i], messageBody[argName], this._mapper));
                        }
                        else {
                            args.push(result);
                        }
                    }
                    if (promises.length > 0) {
                        await Promise.all(promises.map(async (a) => a.promise));
                        promises.forEach(a => {
                            args[a.position] = args[a.position]();
                        });
                    }
                    const result = this['on' + f](...args);
                    // If this message is an initializer, need to establish a mapping
                    // with the result of processing the message.
                    if (initializer > -1) {
                        assert(messageBody['identifier']);
                        await this._mapper.establishThingMapping(messageBody['identifier'], result);
                    }
                };
                Object.defineProperty(me.prototype, f, {
                    get() {
                        return impl;
                    }
                });
                Object.defineProperty(other.prototype, 'before' + f, {
                    get() {
                        return before;
                    }
                });
            }
        };
        doConstruct(constructor, target);
        doConstruct(target, constructor);
    };
}
class PECOuterPort extends APIPort {
    constructor(messagePort, arc) {
        super(messagePort, 'o');
        this.inspector = arc.inspector;
        if (this.inspector) {
            this.inspector.onceActive.then(() => this.DevToolsConnected(), e => console.error(e));
        }
    }
    Stop() { }
    DefineHandle(store, type, name) { }
    InstantiateParticle(particle, id, spec, stores) { }
    ReinstantiateParticle(id, spec, stores) { }
    ReloadParticles(particles, ids) { }
    UIEvent(particle, slotName, event) { }
    SimpleCallback(callback, data) { }
    AwaitIdle(version) { }
    StartRender(particle, slotName, providedSlots, contentTypes) { }
    StopRender(particle, slotName) { }
    GetBackingStoreCallback(store, callback, type, name, id, storageKey) { }
    ConstructArcCallback(callback, arc) { }
    CreateHandleCallback(handle, callback, type, name, id) { }
    MapHandleCallback(newHandle, callback, id) { }
    CreateSlotCallback(slot, callback, hostedSlotId) { }
    InnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) { }
    // We need an API call to tell the context side that DevTools has been connected, so it can start sending
    // stack traces attached to the API calls made from that side.
    DevToolsConnected() { }
}
__decorate([
    NoArgs
], PECOuterPort.prototype, "Stop", null);
__decorate([
    __param(0, RedundantInitializer), __param(1, ByLiteral(Type)), __param(2, Direct)
], PECOuterPort.prototype, "DefineHandle", null);
__decorate([
    __param(0, Initializer), __param(1, Identifier), __param(1, Direct), __param(2, ByLiteral(ParticleSpec)), __param(3, ObjectMap(MappingType.Direct, MappingType.Mapped))
], PECOuterPort.prototype, "InstantiateParticle", null);
__decorate([
    __param(0, Identifier), __param(0, Direct), __param(1, ByLiteral(ParticleSpec)), __param(2, ObjectMap(MappingType.Direct, MappingType.Mapped))
], PECOuterPort.prototype, "ReinstantiateParticle", null);
__decorate([
    __param(0, OverridingInitializer), __param(1, List(MappingType.Direct))
], PECOuterPort.prototype, "ReloadParticles", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, Direct)
], PECOuterPort.prototype, "UIEvent", null);
__decorate([
    __param(0, RemoteMapped), __param(1, Direct)
], PECOuterPort.prototype, "SimpleCallback", null);
__decorate([
    __param(0, Direct)
], PECOuterPort.prototype, "AwaitIdle", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, ObjectMap(MappingType.Direct, MappingType.Direct)), __param(3, List(MappingType.Direct))
], PECOuterPort.prototype, "StartRender", null);
__decorate([
    __param(0, Mapped), __param(1, Direct)
], PECOuterPort.prototype, "StopRender", null);
__decorate([
    __param(0, Initializer), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct), __param(4, Identifier), __param(4, Direct), __param(5, Direct)
], PECOuterPort.prototype, "GetBackingStoreCallback", null);
__decorate([
    __param(0, RemoteMapped), __param(1, LocalMapped)
], PECOuterPort.prototype, "ConstructArcCallback", null);
__decorate([
    __param(0, Initializer), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct), __param(4, Identifier), __param(4, Direct)
], PECOuterPort.prototype, "CreateHandleCallback", null);
__decorate([
    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)
], PECOuterPort.prototype, "MapHandleCallback", null);
__decorate([
    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)
], PECOuterPort.prototype, "CreateSlotCallback", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, Direct), __param(3, Direct)
], PECOuterPort.prototype, "InnerArcRender", null);
__decorate([
    NoArgs
], PECOuterPort.prototype, "DevToolsConnected", null);
let PECInnerPort = class PECInnerPort extends APIPort {
    constructor(messagePort) {
        super(messagePort, 'i');
    }
    Render(particle, slotName, content) { }
    // TODO(sjmiles): alternate render path for slotObserver (UiBroker)
    Output(particle, content) { }
    InitializeProxy(handle, callback) { }
    SynchronizeProxy(handle, callback) { }
    HandleGet(handle, callback) { }
    HandleToList(handle, callback) { }
    HandleSet(handle, data, particleId, barrier) { }
    HandleClear(handle, particleId, barrier) { }
    HandleStore(handle, callback, data, particleId) { }
    HandleRemove(handle, callback, data, particleId) { }
    HandleRemoveMultiple(handle, callback, data, particleId) { }
    HandleStream(handle, callback, pageSize, forward) { }
    StreamCursorNext(handle, callback, cursorId) { }
    StreamCursorClose(handle, cursorId) { }
    Idle(version, relevance) { }
    GetBackingStore(callback, storageKey, type) { }
    ConstructInnerArc(callback, particle) { }
    ArcCreateHandle(callback, arc, type, name) { }
    ArcMapHandle(callback, arc, handle) { }
    // TODO(sjmiles): experimental `services` impl
    ServiceRequest(particle, content, callback) { }
    ArcCreateSlot(callback, arc, transformationParticle, transformationSlotName, handleId) { }
    ArcLoadRecipe(arc, recipe, callback) { }
    ReportExceptionInHost(exception) { }
    // To show stack traces for calls made inside the context, we need to capture the trace at the call point and
    // send it along with the message. We only want to do this after a DevTools connection has been detected, which
    // we can't directly detect inside a worker context, so the PECOuterPort will send an API message instead.
    onDevToolsConnected() {
        this.attachStack = true;
    }
};
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, Direct)
], PECInnerPort.prototype, "Render", null);
__decorate([
    __param(0, Mapped), __param(1, Direct)
], PECInnerPort.prototype, "Output", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped)
], PECInnerPort.prototype, "InitializeProxy", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped)
], PECInnerPort.prototype, "SynchronizeProxy", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped)
], PECInnerPort.prototype, "HandleGet", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped)
], PECInnerPort.prototype, "HandleToList", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, Direct), __param(3, Direct)
], PECInnerPort.prototype, "HandleSet", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, Direct)
], PECInnerPort.prototype, "HandleClear", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)
], PECInnerPort.prototype, "HandleStore", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)
], PECInnerPort.prototype, "HandleRemove", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)
], PECInnerPort.prototype, "HandleRemoveMultiple", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct), __param(3, Direct)
], PECInnerPort.prototype, "HandleStream", null);
__decorate([
    __param(0, Mapped), __param(1, LocalMapped), __param(2, Direct)
], PECInnerPort.prototype, "StreamCursorNext", null);
__decorate([
    __param(0, Mapped), __param(1, Direct)
], PECInnerPort.prototype, "StreamCursorClose", null);
__decorate([
    __param(0, Direct), __param(1, ObjectMap(MappingType.Mapped, MappingType.Direct))
], PECInnerPort.prototype, "Idle", null);
__decorate([
    __param(0, LocalMapped), __param(1, Direct), __param(2, ByLiteral(Type))
], PECInnerPort.prototype, "GetBackingStore", null);
__decorate([
    __param(0, LocalMapped), __param(1, Mapped)
], PECInnerPort.prototype, "ConstructInnerArc", null);
__decorate([
    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, ByLiteral(Type)), __param(3, Direct)
], PECInnerPort.prototype, "ArcCreateHandle", null);
__decorate([
    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped)
], PECInnerPort.prototype, "ArcMapHandle", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, LocalMapped)
], PECInnerPort.prototype, "ServiceRequest", null);
__decorate([
    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped), __param(3, Direct), __param(4, Direct)
], PECInnerPort.prototype, "ArcCreateSlot", null);
__decorate([
    __param(0, RemoteMapped), __param(1, Direct), __param(2, LocalMapped)
], PECInnerPort.prototype, "ArcLoadRecipe", null);
__decorate([
    __param(0, ByLiteral(PropagatedException))
], PECInnerPort.prototype, "ReportExceptionInHost", null);
PECInnerPort = __decorate([
    AutoConstruct(PECOuterPort)
], PECInnerPort);

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A representation of a consumed slot. Retrieved from a particle using
 * particle.getSlot(name)
 */
class SlotProxy {
    constructor(apiPort, particle, slotName, providedSlots) {
        // eslint-disable-next-line func-call-spacing
        this.handlers = new Map();
        this.requestedContentTypes = new Set();
        this._isRendered = false;
        this.apiPort = apiPort;
        this.slotName = slotName;
        this.particle = particle;
        this.providedSlots = providedSlots;
    }
    get isRendered() {
        return this._isRendered;
    }
    /**
     * renders content to the slot.
     */
    render(content) {
        this.apiPort.Render(this.particle, this.slotName, content);
        Object.keys(content).forEach(key => { this.requestedContentTypes.delete(key); });
        // Slot is considered rendered, if a non-empty content was sent and all requested content types were fullfilled.
        this._isRendered = this.requestedContentTypes.size === 0 && (Object.keys(content).length > 0);
    }
    /**
     * registers a callback to be invoked when 'name' event happens.
     */
    registerEventHandler(name, f) {
        if (!this.handlers.has(name)) {
            this.handlers.set(name, []);
        }
        this.handlers.get(name).push(f);
    }
    clearEventHandlers(name) {
        this.handlers.set(name, []);
    }
    fireEvent(event) {
        for (const handler of this.handlers.get(event.handler) || []) {
            handler(event);
        }
    }
    /**
     * Called by PEC to remove all rendering capabilities to this slotProxy from the current
     * particle and give them to the given particle.
     */
    rewire(particle) {
        this.particle.removeSlotProxy(this.slotName);
        this.particle = particle;
        this._isRendered = false;
        this.particle.addSlotProxy(this);
        this.particle.renderSlot(this.slotName, ['model', 'template', 'templateName']);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A basic particle. For particles that provide UI, you may like to
 * instead use DOMParticle.
 */
class Particle$1 {
    constructor() {
        this.relevances = [];
        this._idle = Promise.resolve();
        this._busy = 0;
        this.slotProxiesByName = new Map();
        // Typescript only sees this.constructor as a Function type.
        // TODO(shans): move spec off the constructor
        this.spec = this.constructor['spec'];
        if (this.spec.inputs.length === 0) {
            this.extraData = true;
        }
    }
    /**
     * This sets the capabilities for this particle.  This can only
     * be called once.
     */
    setCapabilities(capabilities) {
        if (this.capabilities) {
            // Capabilities already set, throw an error.
            throw new Error('capabilities should only be set once');
        }
        this.capabilities = capabilities || {};
    }
    async invokeSafely(fun, err) {
        try {
            this.startBusy();
            await fun(this);
        }
        catch (e) {
            err(e);
        }
        finally {
            this.doneBusy();
        }
    }
    async callSetHandles(handles, onException) {
        this.handles = handles;
        await this.invokeSafely(async (p) => p.setHandles(handles), onException);
    }
    /**
     * This method is invoked with a handle for each store this particle
     * is registered to interact with, once those handles are ready for
     * interaction. Override the method to register for events from
     * the handles.
     *
     * @param handles a map from handle names to store handles.
     */
    async setHandles(handles) {
    }
    async callOnHandleSync(handle, model, onException) {
        await this.invokeSafely(async (p) => p.onHandleSync(handle, model), onException);
    }
    /**
     * Called for handles that are configured with both keepSynced and notifySync, when they are
     * updated with the full model of their data. This will occur once after setHandles() and any time
     * thereafter if the handle is resynchronized.
     *
     * @param handle The Handle instance that was updated.
     * @param model For Singleton-backed Handles, the Entity data or null if the Singleton is not set.
     *        For Collection-backed Handles, the Array of Entities, which may be empty.
     */
    async onHandleSync(handle, model) {
    }
    // tslint:disable-next-line: no-any
    async callOnHandleUpdate(handle, update, onException) {
        await this.invokeSafely(async (p) => p.onHandleUpdate(handle, update), onException);
    }
    /**
     * Called for handles that are configued with notifyUpdate, when change events are received from
     * the backing store. For handles also configured with keepSynced these events will be correctly
     * ordered, with some potential skips if a desync occurs. For handles not configured with
     * keepSynced, all change events will be passed through as they are received.
     *
     * @param handle The Handle instance that was updated.
     * @param update An object containing one of the following fields:
     *  - data: The full Entity for a Singleton-backed Handle.
     *  - oldData: The previous value of a Singleton before it was updated.
     *  - added: An Array of Entities added to a Collection-backed Handle.
     *  - removed: An Array of Entities removed from a Collection-backed Handle.
     *  - originator: whether the update originated from this particle.
     */
    // tslint:disable-next-line: no-any
    async onHandleUpdate(handle, update) {
    }
    async callOnHandleDesync(handle, onException) {
        await this.invokeSafely(async (p) => p.onHandleDesync(handle), onException);
    }
    /**
     * Called for handles that are configured with both keepSynced and notifyDesync, when they are
     * detected as being out-of-date against the backing store. For Singletons, the event that triggers
     * this will also resync the data and thus this call may usually be ignored. For Collections, the
     * underlying proxy will automatically request a full copy of the stored data to resynchronize.
     * onHandleSync will be invoked when that is received.
     *
     * @param handle The Handle instance that was desynchronized.
     */
    async onHandleDesync(handle) {
    }
    async constructInnerArc() {
        if (!this.capabilities.constructInnerArc) {
            throw new Error('This particle is not allowed to construct inner arcs');
        }
        return this.capabilities.constructInnerArc(this);
    }
    get busy() {
        return this._busy > 0;
    }
    get idle() {
        return this._idle;
    }
    set relevance(r) {
        this.relevances.push(r);
    }
    startBusy() {
        if (this._busy === 0) {
            this._idle = new Promise(resolve => this._idleResolver = () => resolve());
        }
        this._busy++;
    }
    doneBusy() {
        this._busy--;
        if (this._busy === 0) {
            this._idleResolver();
        }
    }
    inputs() {
        return this.spec.inputs;
    }
    outputs() {
        return this.spec.outputs;
    }
    hasSlotProxy(name) {
        return this.slotProxiesByName.has(name);
    }
    addSlotProxy(slotlet) {
        this.slotProxiesByName.set(slotlet.slotName, slotlet);
    }
    removeSlotProxy(name) {
        this.slotProxiesByName.delete(name);
    }
    /**
     * Request (outerPEC) service invocations.
     */
    // TODO(sjmiles): experimental services impl
    async service(request) {
        if (!this.capabilities.serviceRequest) {
            console.warn(`${this.spec.name} has no service support.`);
            return null;
        }
        return new Promise(resolve => {
            this.capabilities.serviceRequest(this, request, response => resolve(response));
        });
    }
    /**
     * Returns the slot with provided name.
     */
    getSlot(name) {
        return this.slotProxiesByName.get(name);
    }
    getSlotNames() {
        return [...this.slotProxiesByName.keys()];
    }
    static buildManifest(strings, ...bits) {
        const output = [];
        for (let i = 0; i < bits.length; i++) {
            const str = strings[i];
            const indent = / *$/.exec(str)[0];
            let bitStr;
            if (typeof bits[i] === 'string') {
                bitStr = bits[i];
            }
            else {
                bitStr = bits[i].toManifestString();
            }
            bitStr = bitStr.replace(/(\n)/g, '$1' + indent);
            output.push(str);
            output.push(bitStr);
        }
        if (strings.length > bits.length) {
            output.push(strings[strings.length - 1]);
        }
        return output.join('');
    }
    async setParticleDescription(pattern) {
        return this.setDescriptionPattern('pattern', pattern);
    }
    async setDescriptionPattern(connectionName, pattern) {
        const descriptions = this.handles.get('descriptions');
        if (descriptions) {
            const entityClass = descriptions.entityClass;
            if (descriptions instanceof Collection || descriptions instanceof BigCollection) {
                await descriptions.store(new entityClass({ key: connectionName, value: pattern }, this.spec.name + '-' + connectionName));
            }
            return true;
        }
        throw new Error('A particle needs a description handle to set a decription pattern');
    }
    // Entity functions.
    idFor(entity) {
        return Entity.id(entity);
    }
    dataClone(entity) {
        return Entity.dataClone(entity);
    }
    mutate(entity, mutation) {
        Entity.mutate(entity, mutation);
    }
    // TODO(sjmiles): alternate render path for UiBroker
    output(content) {
        const { output } = this.capabilities;
        if (output) {
            output(this, content);
        }
    }
    // abstract
    renderSlot(slotName, contentTypes) { }
    renderHostedSlot(slotName, hostedSlotId, content) { }
    fireEvent(slotName, event) { }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Encodes/decodes the wire format for transferring entities over the wasm boundary.
// Note that entities must have an id before serializing for use in a wasm particle.
//
//  <singleton> = <id-length>:<id>|<name>:<value>|<name>:<value>| ... |
//  <value> depends on the field type:
//    Text       <name>:T<length>:<text>
//    URL        <name>:U<length>:<text>
//    Number     <name>:N<number>:
//    Boolean    <name>:B<zero-or-one>
//
//  <collection> = <num-entities>:<length>:<encoded><length>:<encoded> ...
//
// Examples:
//   Singleton:   4:id05|txt:T3:abc|lnk:U10:http://def|num:N37:|flg:B1|
//   Collection:  3:29:4:id12|txt:T4:qwer|num:N9.2:|18:6:id2670|num:N-7:|15:5:id501|flg:B0|
//
// The encoder classes also support a "Dictionary" format of key:value string pairs:
//   <size>:<key-len>:<key><value-len>:<value><key-len>:<key><value-len>:<value>...
class EntityPackager {
    constructor(schema) {
        this.encoder = new StringEncoder();
        this.decoder = new StringDecoder();
        assert(schema.names.length > 0, 'At least one schema name is required for entity packaging');
        this.schema = schema;
    }
    encodeSingleton(entity) {
        return this.encoder.encodeSingleton(this.schema, entity);
    }
    encodeCollection(entities) {
        return this.encoder.encodeCollection(this.schema, entities);
    }
    decodeSingleton(str) {
        const { id, data } = this.decoder.decodeSingleton(str);
        const entity = new (this.schema.entityClass())(data);
        if (id !== '') {
            Entity.identify(entity, id);
        }
        return entity;
    }
}
class StringEncoder {
    encodeSingleton(schema, entity) {
        const id = Entity.id(entity);
        let encoded = id.length + ':' + id + '|';
        for (const [name, value] of Object.entries(entity)) {
            encoded += this.encodeField(schema.fields[name], name, value);
        }
        return encoded;
    }
    encodeCollection(schema, entities) {
        let encoded = entities.length + ':';
        for (const entity of entities) {
            const str = this.encodeSingleton(schema, entity);
            encoded += str.length + ':' + str;
        }
        return encoded;
    }
    static encodeDictionary(dict) {
        const entries = Object.entries(dict);
        let encoded = entries.length + ':';
        for (const [key, value] of entries) {
            encoded += key.length + ':' + key + value.length + ':' + value;
        }
        return encoded;
    }
    encodeField(field, name, value) {
        switch (field.kind) {
            case 'schema-primitive':
                return name + ':' + field.type.substr(0, 1) + this.encodeValue(field.type, value) + '|';
            case 'schema-collection':
            case 'schema-union':
            case 'schema-tuple':
            case 'schema-reference':
                throw new Error(`'${field.kind}' not yet supported for entity packaging`);
            default:
                throw new Error(`Unknown field kind '${field.kind}' in schema`);
        }
    }
    encodeValue(type, value) {
        switch (type) {
            case 'Text':
            case 'URL':
                return value.length + ':' + value;
            case 'Number':
                return value + ':';
            case 'Boolean':
                return (value ? '1' : '0');
            case 'Bytes':
            case 'Object':
                throw new Error(`'${type}' not yet supported for entity packaging`);
            default:
                throw new Error(`Unknown primitive value type '${type}' in schema`);
        }
    }
}
class StringDecoder {
    decodeSingleton(str) {
        this.str = str;
        const len = Number(this.upTo(':'));
        const id = this.chomp(len);
        this.validate('|');
        const data = {};
        while (this.str.length > 0) {
            const name = this.upTo(':');
            const typeChar = this.chomp(1);
            data[name] = this.decodeValue(typeChar);
            this.validate('|');
        }
        return { id, data };
    }
    decodeDictionary(str) {
        this.str = str;
        const dict = {};
        let num = Number(this.upTo(':'));
        while (num--) {
            const klen = Number(this.upTo(':'));
            const key = this.chomp(klen);
            const vlen = Number(this.upTo(':'));
            dict[key] = this.chomp(vlen);
        }
        return dict;
    }
    upTo(char) {
        const i = this.str.indexOf(char);
        if (i < 0) {
            throw new Error(`Packaged entity decoding fail: expected '${char}' separator in '${this.str}'`);
        }
        const token = this.str.slice(0, i);
        this.str = this.str.slice(i + 1);
        return token;
    }
    chomp(len) {
        if (len > this.str.length) {
            throw new Error(`Packaged entity decoding fail: expected '${len}' chars to remain in '${this.str}'`);
        }
        const token = this.str.slice(0, len);
        this.str = this.str.slice(len);
        return token;
    }
    validate(token) {
        if (this.chomp(token.length) !== token) {
            throw new Error(`Packaged entity decoding fail: expected '${token}' at start of '${this.str}'`);
        }
    }
    decodeValue(typeChar) {
        switch (typeChar) {
            case 'T':
            case 'U': {
                const len = Number(this.upTo(':'));
                return this.chomp(len);
            }
            case 'N':
                return Number(this.upTo(':'));
            case 'B':
                return Boolean(this.chomp(1) === '1');
            default:
                throw new Error(`Packaged entity decoding fail: unknown or unsupported primitive value type '${typeChar}'`);
        }
    }
}
class EmscriptenWasmDriver {
    constructor(customSection) {
        // Records file and line for console logging in C++. This is set by the console/error macros in
        // arcs.h and used immediately in the following printf call (implemented by sysWritev() below).
        this.logInfo = null;
        // Wasm modules built by emscripten require some external memory configuration by the caller,
        // which is usually built into the glue code generated alongside the module. We're not using
        // the glue code, but if we set the EMIT_EMSCRIPTEN_METADATA flag when building, emscripten
        // will provide a custom section in the module itself with the required values.
        const METADATA_SIZE = 11;
        const METADATA_MAJOR = 0;
        const METADATA_MINOR = 2;
        const ABI_MAJOR = 0;
        const ABI_MINOR = 4;
        // The logic for reading metadata values here was copied from the emscripten source.
        const buffer = new Uint8Array(customSection);
        const metadata = [];
        let offset = 0;
        while (offset < buffer.byteLength) {
            let result = 0;
            let shift = 0;
            while (1) {
                const byte = buffer[offset++];
                result |= (byte & 0x7f) << shift;
                if (!(byte & 0x80)) {
                    break;
                }
                shift += 7;
            }
            metadata.push(result);
        }
        // The specifics of the section are not published anywhere official (yet). The values here
        // correspond to emscripten version 1.38.42:
        //   https://github.com/emscripten-core/emscripten/blob/1.38.42/tools/shared.py#L3051
        if (metadata.length < 4) {
            throw new Error(`emscripten metadata section should have at least 4 values; ` +
                `got ${metadata.length}`);
        }
        if (metadata[0] !== METADATA_MAJOR || metadata[1] !== METADATA_MINOR) {
            throw new Error(`emscripten metadata version should be ${METADATA_MAJOR}.${METADATA_MINOR}; ` +
                `got ${metadata[0]}.${metadata[1]}`);
        }
        if (metadata[2] !== ABI_MAJOR || metadata[3] !== ABI_MINOR) {
            throw new Error(`emscripten ABI version should be ${ABI_MAJOR}.${ABI_MINOR}; ` +
                `got ${metadata[2]}.${metadata[3]}`);
        }
        if (metadata.length !== METADATA_SIZE) {
            throw new Error(`emscripten metadata section should have ${METADATA_SIZE} values; ` +
                `got ${metadata.length}`);
        }
        // metadata[4] is 'Settings.WASM_BACKEND'; whether the binary is from wasm backend or fastcomp.
        // metadata[10] is 'tempdoublePtr'; appears to be related to pthreads and is not used here.
        this.cfg = {
            memSize: metadata[5],
            tableSize: metadata[6],
            globalBase: metadata[7],
            dynamicBase: metadata[8],
            dynamictopPtr: metadata[9],
        };
    }
    configureEnvironment(module, container, env) {
        container.memory = new WebAssembly.Memory({ initial: this.cfg.memSize, maximum: this.cfg.memSize });
        container.heapU8 = new Uint8Array(container.memory.buffer);
        container.heap32 = new Int32Array(container.memory.buffer);
        // We need to poke the address of the heap base into the memory buffer prior to instantiating.
        container.heap32[this.cfg.dynamictopPtr >> 2] = this.cfg.dynamicBase;
        Object.assign(env, {
            // Memory setup
            memory: container.memory,
            __memory_base: this.cfg.globalBase,
            table: new WebAssembly.Table({ initial: this.cfg.tableSize, maximum: this.cfg.tableSize, element: 'anyfunc' }),
            __table_base: 0,
            DYNAMICTOP_PTR: this.cfg.dynamictopPtr,
            // Heap management
            _emscripten_get_heap_size: () => container.heapU8.length,
            _emscripten_resize_heap: (size) => false,
            _emscripten_memcpy_big: (dst, src, num) => container.heapU8.set(container.heapU8.subarray(src, src + num), dst),
            // Error handling
            _systemError: (msg) => { throw new Error(container.read(msg)); },
            abortOnCannotGrowMemory: (size) => { throw new Error(`abortOnCannotGrowMemory(${size})`); },
            // Logging
            _setLogInfo: (file, line) => this.logInfo = [container.read(file), line],
            ___syscall146: (which, varargs) => this.sysWritev(container, which, varargs),
        });
    }
    initializeInstance(container, instance) {
        // Emscripten doesn't need main() invoked
    }
    // C++ printf support cribbed from emscripten glue js - currently only supports ASCII
    sysWritev(container, which, varargs) {
        const get = () => {
            varargs += 4;
            return container.heap32[(((varargs) - (4)) >> 2)];
        };
        const output = (get() === 1) ? console.log : console.error;
        const iov = get();
        const iovcnt = get();
        // TODO: does this need to be persistent across calls? (i.e. due to write buffering)
        let str = this.logInfo ? `[${this.logInfo[0]}:${this.logInfo[1]}] ` : '';
        let ret = 0;
        for (let i = 0; i < iovcnt; i++) {
            const ptr = container.heap32[(((iov) + (i * 8)) >> 2)];
            const len = container.heap32[(((iov) + (i * 8 + 4)) >> 2)];
            for (let j = 0; j < len; j++) {
                const curr = container.heapU8[ptr + j];
                if (curr === 0 || curr === 10) { // NUL or \n
                    output(str);
                    str = '';
                }
                else {
                    str += String.fromCharCode(curr);
                }
            }
            ret += len;
        }
        this.logInfo = null;
        return ret;
    }
}
class KotlinWasmDriver {
    configureEnvironment(module, container, env) {
        Object.assign(env, {
            // These two are used by launcher.cpp
            Konan_js_arg_size: (index) => 1,
            Konan_js_fetch_arg: (index, ptr) => 'dummyArg',
            // These two are imported, but never used
            Konan_js_allocateArena: (array) => { },
            Konan_js_freeArena: (arenaIndex) => { },
            // These two are used by logging functions
            write: (ptr) => console.log(container.read(ptr)),
            flush: () => { },
            // Apparently used by Kotlin Memory management
            Konan_notify_memory_grow: () => this.updateMemoryViews(container),
            // Kotlin's own glue for abort and exit
            Konan_abort: (pointer) => { throw new Error('Konan_abort(' + container.read(pointer) + ')'); },
            Konan_exit: (status) => { },
            // Needed by some code that tries to get the current time in it's runtime
            Konan_date_now: (pointer) => {
                const now = Date.now();
                const high = Math.floor(now / 0xffffffff);
                const low = Math.floor(now % 0xffffffff);
                container.heap32[pointer] = low;
                container.heap32[pointer + 1] = high;
            },
        });
    }
    // Kotlin manages its own heap construction, as well as tables.
    initializeInstance(container, instance) {
        this.updateMemoryViews(container);
        // Kotlin main() must be invoked before everything else.
        instance.exports.Konan_js_main(1, 0);
    }
    updateMemoryViews(container) {
        container.memory = container.exports.memory;
        container.heapU8 = new Uint8Array(container.memory.buffer);
        container.heap32 = new Int32Array(container.memory.buffer);
    }
}
// Holds an instance of a running wasm module, which may contain multiple particles.
class WasmContainer {
    constructor(loader, apiPort) {
        this.particleMap = new Map();
        this.loader = loader;
        this.apiPort = apiPort;
    }
    async initialize(buffer) {
        // TODO: vet the imports/exports on 'module'
        // TODO: use compileStreaming? requires passing the fetch() Response, not its ArrayBuffer
        const module = await WebAssembly.compile(buffer);
        const driver = this.driverForModule(module);
        // Shared ENV between Emscripten and Kotlin
        const env = {
            abort: () => { throw new Error('Abort!'); },
            // Inner particle API
            // TODO: guard against null/empty args from the wasm side
            _singletonSet: (p, handle, entity) => this.getParticle(p).singletonSet(handle, entity),
            _singletonClear: (p, handle) => this.getParticle(p).singletonClear(handle),
            _collectionStore: (p, handle, entity) => this.getParticle(p).collectionStore(handle, entity),
            _collectionRemove: (p, handle, entity) => this.getParticle(p).collectionRemove(handle, entity),
            _collectionClear: (p, handle) => this.getParticle(p).collectionClear(handle),
            _render: (p, slotName, template, model) => this.getParticle(p).renderImpl(slotName, template, model),
            _serviceRequest: (p, call, args, tag) => this.getParticle(p).serviceRequest(call, args, tag),
            _resolveUrl: (url) => this.resolve(url),
        };
        driver.configureEnvironment(module, this, env);
        const global = { 'NaN': NaN, 'Infinity': Infinity };
        this.wasm = await WebAssembly.instantiate(module, { env, global });
        this.exports = this.wasm.exports;
        driver.initializeInstance(this, this.wasm);
    }
    driverForModule(module) {
        const customSections = WebAssembly.Module.customSections(module, 'emscripten_metadata');
        if (customSections.length === 1) {
            return new EmscriptenWasmDriver(customSections[0]);
        }
        return new KotlinWasmDriver();
    }
    getParticle(innerParticle) {
        return this.particleMap.get(innerParticle);
    }
    register(particle, innerParticle) {
        this.particleMap.set(innerParticle, particle);
    }
    // Allocates memory in the wasm container; the calling particle is responsible for freeing.
    resolve(urlPtr) {
        return this.store(this.loader.resolve(this.read(urlPtr)));
    }
    // Allocates memory in the wasm container.
    store(str) {
        const p = this.exports._malloc(str.length + 1);
        for (let i = 0; i < str.length; i++) {
            this.heapU8[p + i] = str.charCodeAt(i);
        }
        this.heapU8[p + str.length] = 0;
        return p;
    }
    // Convenience function for freeing one or more wasm memory allocations. Null pointers are ignored.
    free(...ptrs) {
        ptrs.forEach(p => p && this.exports._free(p));
    }
    // Currently only supports ASCII. TODO: unicode
    read(idx) {
        let str = '';
        while (idx < this.heapU8.length && this.heapU8[idx] !== 0) {
            str += String.fromCharCode(this.heapU8[idx++]);
        }
        return str;
    }
}
// Creates and interfaces to a particle inside a WasmContainer's module.
class WasmParticle extends Particle$1 {
    constructor(id, container) {
        super();
        this.handleMap = new Map();
        this.revHandleMap = new Map();
        this.converters = new Map();
        this.id = id;
        this.container = container;
        this.exports = container.exports;
        const fn = `_new${this.spec.name}`;
        if (!(fn in this.exports)) {
            throw new Error(`wasm module does not export instantiator function '${fn}' for particle '${this.spec.name}'`);
        }
        this.innerParticle = this.exports[fn]();
        this.container.register(this, this.innerParticle);
    }
    // TODO: for now we set up Handle objects with onDefineHandle and map them into the
    // wasm container through this call, which creates corresponding Handle objects in there.
    // That means entity transfer goes from the StorageProxy, deserializes at the outer Handle
    // which then notifies this class (calling onHandle*), and we then serialize into the wasm
    // transfer format. Obviously this can be improved.
    async setHandles(handles) {
        for (const [name, handle] of handles) {
            const p = this.container.store(name);
            const wasmHandle = this.exports._connectHandle(this.innerParticle, p, handle.canRead, handle.canWrite);
            this.container.free(p);
            if (wasmHandle === 0) {
                throw new Error(`Wasm particle failed to connect handle '${name}'`);
            }
            this.handleMap.set(handle, wasmHandle);
            this.revHandleMap.set(wasmHandle, handle);
            this.converters.set(handle, new EntityPackager(handle.entityClass.schema));
        }
        this.exports._init(this.innerParticle);
    }
    async onHandleSync(handle, model) {
        const wasmHandle = this.handleMap.get(handle);
        if (!model) {
            this.exports._syncHandle(this.innerParticle, wasmHandle, 0);
            return;
        }
        const converter = this.converters.get(handle);
        if (!converter) {
            throw new Error('cannot find handle ' + handle.name);
        }
        let encoded;
        if (handle instanceof Singleton) {
            encoded = converter.encodeSingleton(model);
        }
        else {
            encoded = converter.encodeCollection(model);
        }
        const p = this.container.store(encoded);
        this.exports._syncHandle(this.innerParticle, wasmHandle, p);
        this.container.free(p);
    }
    // tslint:disable-next-line: no-any
    async onHandleUpdate(handle, update) {
        if (update.originator) {
            return;
        }
        const wasmHandle = this.handleMap.get(handle);
        const converter = this.converters.get(handle);
        if (!converter) {
            throw new Error('cannot find handle ' + handle.name);
        }
        let p1 = 0;
        let p2 = 0;
        if (handle instanceof Singleton) {
            if (update.data) {
                p1 = this.container.store(converter.encodeSingleton(update.data));
            }
        }
        else {
            p1 = this.container.store(converter.encodeCollection(update.added || []));
            p2 = this.container.store(converter.encodeCollection(update.removed || []));
        }
        this.exports._updateHandle(this.innerParticle, wasmHandle, p1, p2);
        this.container.free(p1, p2);
    }
    // Ignored for wasm particles.
    async onHandleDesync(handle) { }
    // Store API.
    //
    // Each of these calls an async storage method, but we don't want to await them because returning
    // a Promise to wasm doesn't work, and control (surprisingly) returns to the calling wasm function
    // at the first await point anyway. However, our CRDTs make it safe to fire-and-forget the storage
    // updates, and the wasm handles already have the updated version of the stored data, so it's safe
    // to leave the promises floating.
    // If the given entity doesn't have an id, this will create one for it and return the new id
    // in allocated memory that the wasm particle must free. If the entity already has an id this
    // returns 0 (nulltpr).
    singletonSet(wasmHandle, entityPtr) {
        const singleton = this.getHandle(wasmHandle);
        const entity = this.decodeEntity(singleton, entityPtr);
        const p = this.ensureIdentified(entity, singleton);
        void singleton.set(entity);
        return p;
    }
    singletonClear(wasmHandle) {
        const singleton = this.getHandle(wasmHandle);
        void singleton.clear();
    }
    // If the given entity doesn't have an id, this will create one for it and return the new id
    // in allocated memory that the wasm particle must free. If the entity already has an id this
    // returns 0 (nulltpr).
    collectionStore(wasmHandle, entityPtr) {
        const collection = this.getHandle(wasmHandle);
        const entity = this.decodeEntity(collection, entityPtr);
        const p = this.ensureIdentified(entity, collection);
        void collection.store(entity);
        return p;
    }
    collectionRemove(wasmHandle, entityPtr) {
        const collection = this.getHandle(wasmHandle);
        void collection.remove(this.decodeEntity(collection, entityPtr));
    }
    collectionClear(wasmHandle) {
        const collection = this.getHandle(wasmHandle);
        void collection.clear();
    }
    getHandle(wasmHandle) {
        const handle = this.revHandleMap.get(wasmHandle);
        if (!handle) {
            const err = new Error(`wasm particle '${this.spec.name}' attempted to write to unconnected handle`);
            const userException = new UserException(err, 'WasmParticle::getHandle', this.id, this.spec.name);
            this.container.apiPort.ReportExceptionInHost(userException);
            throw err;
        }
        return handle;
    }
    decodeEntity(handle, entityPtr) {
        const converter = this.converters.get(handle);
        return converter.decodeSingleton(this.container.read(entityPtr));
    }
    ensureIdentified(entity, handle) {
        let p = 0;
        if (!Entity.isIdentified(entity)) {
            handle.createIdentityFor(entity);
            p = this.container.store(Entity.id(entity));
        }
        return p;
    }
    // Called by the shell to initiate rendering; the particle will call env._render in response.
    renderSlot(slotName, contentTypes) {
        const p = this.container.store(slotName);
        const sendTemplate = contentTypes.includes('template');
        const sendModel = contentTypes.includes('model');
        this.exports._renderSlot(this.innerParticle, p, sendTemplate, sendModel);
        this.container.free(p);
    }
    // TODO
    renderHostedSlot(slotName, hostedSlotId, content) {
        throw new Error('renderHostedSlot not implemented for wasm particles');
    }
    // Actually renders the slot. May be invoked due to an external request via renderSlot(),
    // or directly from the wasm particle itself (e.g. in response to a data update).
    // template is a string provided by the particle. model is an encoded Dictionary.
    renderImpl(slotNamePtr, templatePtr, modelPtr) {
        const slot = this.slotProxiesByName.get(this.container.read(slotNamePtr));
        if (slot) {
            const content = { templateName: 'default' };
            if (templatePtr) {
                content.template = this.container.read(templatePtr);
                slot.requestedContentTypes.add('template');
            }
            if (modelPtr) {
                content.model = new StringDecoder().decodeDictionary(this.container.read(modelPtr));
                slot.requestedContentTypes.add('model');
            }
            slot.render(content);
        }
    }
    // Wasm particles can request service calls with a Dictionary of arguments and an optional string
    // tag to disambiguate different requests to the same service call.
    async serviceRequest(callPtr, argsPtr, tagPtr) {
        const call = this.container.read(callPtr);
        const args = new StringDecoder().decodeDictionary(this.container.read(argsPtr));
        const tag = this.container.read(tagPtr);
        // tslint:disable-next-line: no-any
        const response = await this.service({ call, ...args });
        // Convert the arbitrary response object to key:value string pairs.
        const dict = {};
        if (typeof response === 'object') {
            for (const entry of Object.entries(response)) {
                // tslint:disable-next-line: no-any
                const [key, value] = entry;
                dict[key] = (typeof value === 'object') ? JSON.stringify(value) : (value + '');
            }
        }
        else {
            // Convert a plain value response to {value: 'string'}
            dict['value'] = response + '';
        }
        // We can't re-use the string pointers passed in as args to this method, because the await
        // point above means the call to internal::serviceRequest inside the wasm module will already
        // have completed, and the memory for those args will have been freed.
        const cp = this.container.store(call);
        const rp = this.container.store(StringEncoder.encodeDictionary(dict));
        const tp = this.container.store(tag);
        this.exports._serviceResponse(this.innerParticle, cp, rp, tp);
        this.container.free(cp, rp, tp);
    }
    fireEvent(slotName, event) {
        const sp = this.container.store(slotName);
        const hp = this.container.store(event.handler);
        this.exports._fireEvent(this.innerParticle, sp, hp);
        this.container.free(sp, hp);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ParticleExecutionContext {
    constructor(port, pecId, idGenerator, loader) {
        this.particles = new Map();
        this.pendingLoads = [];
        this.scheduler = new StorageProxyScheduler();
        this.keyedProxies = {};
        this.wasmContainers = {};
        const pec = this;
        this.apiPort = new class extends PECInnerPort {
            onDefineHandle(identifier, type, name) {
                return StorageProxy.newProxy(identifier, type, this, pec, pec.scheduler, name);
            }
            onGetBackingStoreCallback(callback, type, name, id, storageKey) {
                const proxy = StorageProxy.newProxy(id, type, this, pec, pec.scheduler, name);
                proxy.storageKey = storageKey;
                return [proxy, () => callback(proxy, storageKey)];
            }
            onCreateHandleCallback(callback, type, name, id) {
                const proxy = StorageProxy.newProxy(id, type, this, pec, pec.scheduler, name);
                return [proxy, () => callback(proxy)];
            }
            onMapHandleCallback(callback, id) {
                return [id, () => callback(id)];
            }
            onCreateSlotCallback(callback, hostedSlotId) {
                return [hostedSlotId, () => callback(hostedSlotId)];
            }
            onInnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) {
                transformationParticle.renderHostedSlot(transformationSlotName, hostedSlotId, content);
            }
            onStop() {
                if (global['close']) {
                    global['close']();
                }
            }
            async onInstantiateParticle(id, spec, proxies) {
                return pec.instantiateParticle(id, spec, proxies);
            }
            async onReinstantiateParticle(id, spec, proxies) {
                assert(false, `Not implemented`);
            }
            async onReloadParticles(ids) {
                return pec.reloadParticles(ids);
            }
            onSimpleCallback(callback, data) {
                callback(data);
            }
            onConstructArcCallback(callback, arc) {
                callback(arc);
            }
            onAwaitIdle(version) {
                pec.idle.then(a => {
                    // TODO: dom-particles update is async, this is a workaround to allow dom-particles to
                    // update relevance, after handles are updated. Needs better idle signal.
                    setTimeout(() => this.Idle(version, pec.relevance), 0);
                });
            }
            onUIEvent(particle, slotName, event) {
                particle.fireEvent(slotName, event);
            }
            onStartRender(particle, slotName, providedSlots, contentTypes) {
                particle.addSlotProxy(new SlotProxy(this, particle, slotName, providedSlots));
                particle.renderSlot(slotName, contentTypes);
            }
            onStopRender(particle, slotName) {
                assert(particle.hasSlotProxy(slotName), `Stop render called for particle ${particle.spec.name} slot ${slotName} without start render being called.`);
                particle.removeSlotProxy(slotName);
            }
        }(port);
        this.pecId = pecId;
        this.idGenerator = idGenerator;
        this.loader = loader;
        loader.setParticleExecutionContext(this);
        /*
         * This code ensures that the relevant types are known
         * in the scope object, because otherwise we can't do
         * particleSpec resolution, which is currently a necessary
         * part of particle construction.
         *
         * Possibly we should eventually consider having particle
         * specifications separated from particle classes - and
         * only keeping type information on the arc side.
         */
    }
    generateID() {
        return this.idGenerator.newChildId(this.pecId).toString();
    }
    innerArcHandle(arcId, particleId) {
        const pec = this;
        return {
            async createHandle(type, name, hostParticle) {
                return new Promise((resolve, reject) => pec.apiPort.ArcCreateHandle(proxy => {
                    const handle = handleFor(proxy, pec.idGenerator, name, particleId);
                    resolve(handle);
                    if (hostParticle) {
                        proxy.register(hostParticle, handle);
                    }
                }, arcId, type, name));
            },
            async mapHandle(handle) {
                return new Promise((resolve, reject) => pec.apiPort.ArcMapHandle(id => {
                    resolve(id);
                }, arcId, handle)); // recipe handle vs not?
            },
            async createSlot(transformationParticle, transformationSlotName, handleId) {
                // handleId: the ID of a handle (returned by `createHandle` above) this slot is rendering; null - if not applicable.
                // TODO: support multiple handle IDs.
                return new Promise((resolve, reject) => pec.apiPort.ArcCreateSlot(hostedSlotId => resolve(hostedSlotId), arcId, transformationParticle, transformationSlotName, handleId));
            },
            async loadRecipe(recipe) {
                // TODO: do we want to return a promise on completion?
                return new Promise((resolve, reject) => pec.apiPort.ArcLoadRecipe(arcId, recipe, response => {
                    if (response.error) {
                        reject(response.error);
                    }
                    else {
                        resolve(response);
                    }
                }));
            }
        };
    }
    getStorageProxy(storageKey, type) {
        if (!this.keyedProxies[storageKey]) {
            this.keyedProxies[storageKey] = new Promise((resolve, reject) => {
                this.apiPort.GetBackingStore((proxy, storageKey) => {
                    this.keyedProxies[storageKey] = proxy;
                    resolve(proxy);
                }, storageKey, type);
            });
        }
        return this.keyedProxies[storageKey];
    }
    capabilities(hasInnerArcs) {
        const cap = {
            // TODO(sjmiles): experimental `services` impl
            serviceRequest: (particle, args, callback) => {
                this.apiPort.ServiceRequest(particle, args, callback);
            },
            // TODO(sjmiles): alternate render path via slotObserver (UiBroker)
            output: (particle, content) => {
                this.apiPort.Output(particle, content);
            }
        };
        if (hasInnerArcs) {
            // TODO: Particle doesn't have an id field; not sure if it needs one or innerArcHandle shouldn't have that arg.
            cap.constructInnerArc = async (particle) => {
                return new Promise((resolve, reject) => this.apiPort.ConstructInnerArc(arcId => resolve(this.innerArcHandle(arcId, undefined)), particle));
            };
        }
        return cap;
    }
    // tslint:disable-next-line: no-any
    async instantiateParticle(id, spec, proxies) {
        let resolve;
        const p = new Promise(res => resolve = res);
        this.pendingLoads.push(p);
        const particle = await this.createParticleFromSpec(id, spec);
        const handleMap = new Map();
        const registerList = [];
        proxies.forEach((proxy, name) => {
            this.createHandle(particle, spec, id, name, proxy, handleMap, registerList);
        });
        return [particle, async () => {
                await this.assignHandle(particle, spec, id, handleMap, registerList, p);
                resolve();
            }];
    }
    async reloadParticles(ids) {
        // Delete old particles' caches
        ids.forEach(id => {
            const oldParticle = this.particles.get(id);
            if (oldParticle.spec.implBlobUrl)
                delete oldParticle.spec.implBlobUrl;
            if (oldParticle.spec.implFile.endsWith('.wasm') && this.wasmContainers[oldParticle.spec.implFile]) {
                // For WASM particles the container will be re-instantiated along with all of the particles
                this.wasmContainers[oldParticle.spec.implFile] = undefined;
            }
        });
        const result = [];
        // Go through the given array of particles one by one
        for (const id of ids) {
            let resolve;
            const p = new Promise(res => resolve = res);
            this.pendingLoads.push(p);
            // Get the old particle
            const oldParticle = this.particles.get(id);
            // Create a new particle and replace the old one
            const particle = await this.createParticleFromSpec(id, oldParticle.spec);
            const handleMap = new Map();
            const registerList = [];
            // Create new handles and disable the handles of the old particles
            oldParticle.handles.forEach((oldHandle) => {
                this.createHandle(particle, oldParticle.spec, id, oldHandle.name, oldHandle.storage, handleMap, registerList);
                oldHandle.disable(oldParticle);
            });
            result.push([particle, async () => {
                    // Set the new handles to the new particle
                    await this.assignHandle(particle, oldParticle.spec, id, handleMap, registerList, p);
                    resolve();
                    // Transfer the slot proxies from the old particle to the new one
                    for (const name of oldParticle.getSlotNames()) {
                        oldParticle.getSlot(name).rewire(particle);
                    }
                }]);
        }
        return result;
    }
    createHandle(particle, spec, id, name, proxy, handleMap, registerList) {
        const connSpec = spec.handleConnectionMap.get(name);
        const handle = handleFor(proxy, this.idGenerator, name, id, connSpec.isInput, connSpec.isOutput);
        handleMap.set(name, handle);
        // Defer registration of handles with proxies until after particles have a chance to
        // configure them in setHandles.
        registerList.push({ proxy, particle, handle });
    }
    async assignHandle(particle, spec, id, handleMap, registerList, p) {
        await particle.callSetHandles(handleMap, err => {
            const exc = new UserException(err, 'setHandles', id, spec.name);
            this.apiPort.ReportExceptionInHost(exc);
        });
        registerList.forEach(({ proxy, particle, handle }) => {
            if (proxy instanceof StorageProxy)
                proxy.register(particle, handle);
        });
        const idx = this.pendingLoads.indexOf(p);
        this.pendingLoads.splice(idx, 1);
    }
    async createParticleFromSpec(id, spec) {
        let particle;
        if (spec.implFile && spec.implFile.endsWith('.wasm')) {
            particle = await this.loadWasmParticle(id, spec);
            particle.setCapabilities(this.capabilities(false));
        }
        else {
            const clazz = await this.loader.loadParticleClass(spec);
            if (!clazz) {
                return Promise.reject(new Error(`Unknown error loading particle ${id} ${spec.name}`));
            }
            particle = new clazz();
            particle.setCapabilities(this.capabilities(true));
        }
        this.particles.set(id, particle);
        return particle;
    }
    async loadWasmParticle(id, spec) {
        assert(spec.name.length > 0);
        let container = this.wasmContainers[spec.implFile];
        if (!container) {
            const buffer = await this.loader.loadWasmBinary(spec);
            if (!buffer || buffer.byteLength === 0) {
                throw new Error(`Failed to load wasm binary '${spec.implFile}'`);
            }
            container = new WasmContainer(this.loader, this.apiPort);
            await container.initialize(buffer);
            this.wasmContainers[spec.implFile] = container;
        }
        // Particle constructor expects spec to be attached to the class object (and attaches it to
        // the particle instance at that time).
        WasmParticle.spec = spec;
        const particle = new WasmParticle(id, container);
        WasmParticle.spec = null;
        return particle;
    }
    get relevance() {
        const rMap = new Map();
        this.particles.forEach(p => {
            if (p.relevances.length === 0) {
                return;
            }
            rMap.set(p, p.relevances);
            p.relevances.length = 0; // truncate
        });
        return rMap;
    }
    get busy() {
        if (this.pendingLoads.length > 0 || this.scheduler.busy) {
            return true;
        }
        if ([...this.particles.values()].filter(particle => particle.busy).length > 0) {
            return true;
        }
        return false;
    }
    get idle() {
        if (!this.busy) {
            return Promise.resolve();
        }
        const busyParticlePromises = [...this.particles.values()].filter(async (particle) => particle.busy).map(async (particle) => particle.idle);
        return Promise.all([this.scheduler.idle, ...this.pendingLoads, ...busyParticlePromises]).then(() => this.idle);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TODO: Make this generic so that it can also be used in-browser, or add a
// separate in-process browser pec-factory.
function FakePecFactory(loader) {
    return (pecId, idGenerator) => {
        const channel = new MessageChannel();
        // Each PEC should get its own loader.
        const pec = new ParticleExecutionContext(channel.port1, pecId, idGenerator, loader.clone());
        return channel.port2;
    };
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Walkers traverse an object, calling methods based on the
 * features encountered on that object. For example, a RecipeWalker
 * takes a list of recipes and calls methods when:
 *  - a new recipe is encountered
 *  - a handle is found inside a recipe
 *  - a particle is found inside a recipe
 *  - etc..
 *
 * Each of these methods can return a list of updates:
 *   [(recipe, encountered_thing) => new_recipe]
 *
 * The walker then does something with the updates depending on the
 * tactic selected.
 *
 * If the tactic is "Permuted", then an output will be generated
 * for every combination of 1 element drawn from each update list.
 * For example, if 3 methods return [a,b], [c,d,e], and [f] respectively
 * then "Permuted" will cause 6 outputs to be generated: [acf, adf, aef, bcf, bdf, bef]
 *
 * If the tactic is "Independent", an output will be generated for each
 * update, regardless of the list the update is in. For example,
 * if 3 methods return [a,b], [c,d,e], and [f] respectively,
 * then "Independent" will cause 6 outputs to be generated: [a,b,c,d,e,f]
 */
var WalkerTactic;
(function (WalkerTactic) {
    WalkerTactic["Permuted"] = "permuted";
    WalkerTactic["Independent"] = "independent";
})(WalkerTactic || (WalkerTactic = {}));
/**
 * An Action generates the list of Descendants by walking the object with a
 * Walker.
 */
class Action {
    constructor(arc, args) {
        this._arc = arc;
        this._args = args;
    }
    get arc() {
        return this._arc;
    }
    getResults({ generated }) {
        return generated;
    }
    async generateFrom(generated) {
        return this.generate({
            generated,
            population: [],
            terminal: [],
            generation: 0,
        });
    }
}
class Walker {
    constructor(tactic) {
        this.descendants = [];
        assert(tactic);
        this.tactic = tactic;
    }
    onAction(action) {
        this.currentAction = action;
    }
    onResult(result) {
        this.currentResult = result;
        this.updateList = [];
    }
    onResultDone() {
        this.runUpdateList(this.currentResult.result, this.updateList);
        this.currentResult = undefined;
        this.updateList = undefined;
    }
    onActionDone() {
        this.currentAction = undefined;
    }
    static walk(results, walker, action) {
        walker.onAction(action);
        results.forEach(result => {
            walker.onResult(result);
            walker.onResultDone();
        });
        walker.onActionDone();
        return walker.descendants;
    }
    visit(visitor, ...context) {
        const continuation = visitor(this.currentResult.result, ...context);
        if (!this.isEmptyResult(continuation)) {
            this.updateList.push({
                continuation: continuation,
                context
            });
        }
    }
    runUpdateList(start, updateList) {
        const updated = [];
        if (updateList.length) {
            switch (this.tactic) {
                case WalkerTactic.Permuted: {
                    let permutations = [[]];
                    updateList.forEach(({ continuation, context }) => {
                        const newResults = [];
                        if (typeof continuation === 'function') {
                            continuation = [continuation];
                        }
                        continuation.forEach(f => {
                            permutations.forEach(p => {
                                const newP = p.slice();
                                newP.push({ continuation: f, context });
                                newResults.push(newP);
                            });
                        });
                        permutations = newResults;
                    });
                    for (const permutation of permutations) {
                        const cloneMap = new Map();
                        const newResult = start.clone(cloneMap);
                        let score = 0;
                        const newPermutation = permutation.filter(p => p.continuation !== null);
                        if (newPermutation.length === 0) {
                            continue;
                        }
                        newPermutation.forEach(({ continuation, context }) => {
                            // TODO: Should this only take the last?
                            score = continuation(newResult, ...context.map(c => cloneMap.get(c) || c));
                        });
                        updated.push({ result: newResult, score });
                    }
                    break;
                }
                case WalkerTactic.Independent:
                    updateList.forEach(({ continuation, context }) => {
                        if (typeof continuation === 'function') {
                            continuation = [continuation];
                        }
                        continuation.forEach(continuation => {
                            const cloneMap = new Map();
                            const newResult = start.clone(cloneMap);
                            let score = 0;
                            if (continuation == null) {
                                score = 0;
                            }
                            else {
                                score = continuation(newResult, ...context.map(c => cloneMap.get(c) || c));
                            }
                            updated.push({ result: newResult, score });
                        });
                    });
                    break;
                default:
                    throw new Error(`${this.tactic} not supported`);
            }
        }
        // commit phase - output results.
        for (const newResult of updated) {
            this.createDescendant(newResult.result, newResult.score);
        }
    }
    createWalkerDescendant(item, score, hash, valid) {
        assert(this.currentResult, 'no current result');
        assert(this.currentAction, 'no current action');
        if (this.currentResult.score) {
            score += this.currentResult.score;
        }
        this.descendants.push({
            result: item,
            score,
            derivation: [{ parent: this.currentResult, strategy: this.currentAction }],
            hash,
            valid,
        });
    }
    isEmptyResult(result) {
        if (!result) {
            return true;
        }
        if (result.constructor === Array && result.length <= 0) {
            return true;
        }
        assert(typeof result === 'function' || result.length);
        return false;
    }
}
// tslint:disable-next-line: variable-name
Walker.Permuted = WalkerTactic.Permuted;
// tslint:disable-next-line: variable-name
Walker.Independent = WalkerTactic.Independent;

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class RecipeWalker extends Walker {
    onResult(result) {
        super.onResult(result);
        const recipe = result.result;
        if (this.onRecipe) {
            this.visit(this.onRecipe.bind(this));
        }
        if (this.onParticle) {
            for (const particle of recipe.particles) {
                this.visit(this.onParticle.bind(this), particle);
            }
        }
        if (this.onPotentialHandleConnection) {
            for (const particle of recipe.particles) {
                if (particle.spec) {
                    for (const connectionSpec of particle.spec.handleConnectionMap.values()) {
                        if (particle.connections[connectionSpec.name]) {
                            continue;
                        }
                        this.visit(this.onPotentialHandleConnection.bind(this), particle, connectionSpec);
                    }
                }
            }
        }
        if (this.onHandleConnection) {
            for (const handleConnection of recipe.handleConnections) {
                this.visit(this.onHandleConnection.bind(this), handleConnection);
            }
        }
        if (this.onHandle) {
            for (const handle of recipe.handles) {
                this.visit(this.onHandle.bind(this), handle);
            }
        }
        if (this.onPotentialSlotConnection) {
            for (const particle of recipe.particles) {
                for (const [name, slotSpec] of particle.getSlotSpecs()) {
                    if (particle.getSlotConnectionByName(name))
                        continue;
                    this.visit(this.onPotentialSlotConnection.bind(this), particle, slotSpec);
                }
            }
        }
        if (this.onSlotConnection) {
            for (const slotConnection of recipe.slotConnections) {
                this.visit(this.onSlotConnection.bind(this), slotConnection);
            }
        }
        if (this.onSlot) {
            for (const slot of recipe.slots) {
                this.visit(this.onSlot.bind(this), slot);
            }
        }
        if (this.onObligation) {
            for (const obligation of recipe.obligations) {
                this.visit(this.onObligation.bind(this), obligation);
            }
        }
        if (this.onRequiredParticle) {
            for (const require of recipe.requires) {
                for (const particle of require.particles) {
                    this.visit(this.onRequiredParticle.bind(this), particle);
                }
            }
        }
    }
    createDescendant(recipe, score) {
        const valid = recipe.normalize();
        const hash = valid ? recipe.digest() : null;
        super.createWalkerDescendant(recipe, score, hash, valid);
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotUtils {
    // Helper methods.
    static getClonedSlot(recipe, selectedSlot) {
        let clonedSlot = recipe.updateToClone({ selectedSlot }).selectedSlot;
        if (clonedSlot) {
            return clonedSlot;
        }
        if (selectedSlot.id) {
            clonedSlot = recipe.findSlotByID(selectedSlot.id);
        }
        if (clonedSlot === undefined) {
            if (recipe instanceof RequireSection) {
                clonedSlot = recipe.parent.newSlot(selectedSlot.name);
            }
            else {
                clonedSlot = recipe.newSlot(selectedSlot.name);
            }
            clonedSlot.id = selectedSlot.id;
            return clonedSlot;
        }
        return clonedSlot;
    }
    // Connect the given slot connection to the selectedSlot, create the slot, if needed.
    static connectSlotConnection(slotConnection, selectedSlot) {
        const recipe = slotConnection.recipe;
        if (!slotConnection.targetSlot) {
            const clonedSlot = SlotUtils.getClonedSlot(recipe, selectedSlot);
            slotConnection.connectToSlot(clonedSlot);
        }
        if (!slotConnection.targetSlot) {
            throw new Error('missing targetSlot');
        }
        assert(!selectedSlot.id || !slotConnection.targetSlot.id || (selectedSlot.id === slotConnection.targetSlot.id), `Cannot override slot id '${slotConnection.targetSlot.id}' with '${selectedSlot.id}'`);
        slotConnection.targetSlot.id = selectedSlot.id || slotConnection.targetSlot.id;
        // TODO: need to concat to existing tags and dedup?
        slotConnection.targetSlot.tags = [...selectedSlot.tags];
    }
    // Returns all possible slot candidates, sorted by "quality"
    static findAllSlotCandidates(particle, slotSpec, arc) {
        const slotConn = particle.getSlandleConnectionByName(slotSpec.name);
        return {
            // Note: during manfiest parsing, target slot is only set in slot connection, if the slot exists in the recipe.
            // If this slot is internal to the recipe, it has the sourceConnection set to the providing connection
            // (and hence the consuming connection is considered connected already). Otherwise, this may only be a remote slot.
            local: !slotConn || !slotConn.targetSlot ? SlotUtils._findSlotCandidates(particle, slotSpec, particle.recipe.slots) : [],
            remote: SlotUtils._findSlotCandidates(particle, slotSpec, arc.pec.slotComposer.getAvailableContexts())
        };
    }
    // Returns the given slot candidates, sorted by "quality".
    static _findSlotCandidates(particle, slotSpec, slots) {
        const possibleSlots = slots.filter(s => this.slotMatches(particle, slotSpec, s));
        possibleSlots.sort((slot1, slot2) => {
            // TODO: implement.
            return slot1.name < slot2.name;
        });
        return possibleSlots;
    }
    // Returns true, if the given slot is a viable candidate for the slotConnection.
    static slotMatches(particle, slotSpec, slot) {
        if (!SlotUtils.specMatch(slotSpec, slot.spec)) {
            return false;
        }
        const potentialSlotConn = particle.getSlandleConnectionBySpec(slotSpec);
        if (!SlotUtils.tagsOrNameMatch(slotSpec, slot.spec, potentialSlotConn, slot)) {
            return false;
        }
        // Match handles of the provided slot with the slot-connection particle's handles.
        if (!SlotUtils.handlesMatch(particle, slot)) {
            return false;
        }
        return true;
    }
    static specMatch(slotSpec, providedSlotSpec) {
        return slotSpec && // if there's no slotSpec, this is just a slot constraint on a verb
            providedSlotSpec &&
            slotSpec.isSet === providedSlotSpec.isSet;
    }
    // Returns true, if the providing slot handle restrictions are satisfied by the consuming slot connection.
    // TODO: should we move some of this logic to the recipe? Or type matching?
    static handlesMatch(particle, slot) {
        if (slot.handles.length === 0) {
            return true; // slot is not limited to specific handles
        }
        return !!Object.values(particle.connections).find(handleConn => {
            return slot.handles.includes(handleConn.handle) ||
                (handleConn.handle && handleConn.handle.id && slot.handles.map(sh => sh.id).includes(handleConn.handle.id));
        });
    }
    static tagsOrNameMatch(consumeSlotSpec, provideSlotSpec, consumeSlotConn, provideSlot) {
        const consumeTags = [].concat(consumeSlotSpec.tags || [], consumeSlotConn ? consumeSlotConn.tags : [], consumeSlotConn && consumeSlotConn.targetSlot ? consumeSlotConn.targetSlot.tags : []);
        const provideTags = [].concat(provideSlotSpec.tags || [], provideSlot ? provideSlot.tags : [], provideSlot ? provideSlot.name : (provideSlotSpec.name ? provideSlotSpec.name : []));
        if (consumeTags.length > 0 && consumeTags.some(t => provideTags.includes(t))) {
            return true;
        }
        return consumeSlotSpec.name === (provideSlot ? provideSlot.name : provideSlotSpec.name);
    }
    static replaceOldSlot(recipe, oldSlot, newSlot) {
        if (oldSlot && (!oldSlot.id || oldSlot.id !== newSlot.id)) {
            if (oldSlot.sourceConnection !== undefined) {
                if (newSlot.sourceConnection === undefined)
                    return false;
                const clonedSlot = SlotUtils.getClonedSlot(oldSlot.sourceConnection.recipe, newSlot);
                oldSlot.sourceConnection.providedSlots[oldSlot.name] = clonedSlot;
            }
            while (oldSlot.consumeConnections.length > 0) {
                const conn = oldSlot.consumeConnections[0];
                conn.disconnectFromSlot();
                SlotUtils.connectSlotConnection(conn, newSlot);
            }
        }
        return true;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ResolveWalker extends RecipeWalker {
    constructor(tactic, arc, options) {
        super(tactic);
        this.arc = arc;
        this.options = options;
    }
    onHandle(recipe, handle) {
        const error = (label) => {
            if (this.options && this.options.errors) {
                this.options.errors.set(handle, label);
            }
            return [];
        };
        const arc = this.arc;
        if (handle.connections.length === 0 ||
            (handle.id && handle.storageKey) || (!handle.type) ||
            (!handle.fate)) {
            return error('No connections to handle or missing handle information');
        }
        let mappable;
        if (!handle.id) {
            // Handle doesn't have an ID, finding by type and tags.
            const counts = RecipeUtil.directionCounts(handle);
            switch (handle.fate) {
                case 'use':
                    mappable = arc.findStoresByType(handle.type, { tags: handle.tags });
                    break;
                case 'map':
                case 'copy':
                    mappable = arc.context.findStoresByType(handle.type, { tags: handle.tags, subtype: true });
                    break;
                case 'create':
                case '`slot':
                case '?':
                    mappable = [];
                    break;
                default:
                    throw new Error(`unexpected fate ${handle.fate}`);
            }
        }
        else if (!handle.storageKey) {
            // Handle specified by the ID, but not yet mapped to storage.
            let storeById;
            switch (handle.fate) {
                case 'use':
                    storeById = arc.findStoreById(handle.id);
                    break;
                case 'map':
                case 'copy':
                    storeById = arc.context.findStoreById(handle.id);
                    break;
                case 'create':
                case '`slot':
                case '?':
                    break;
                default:
                    throw new Error(`unexpected fate ${handle.fate}`);
            }
            if (storeById) {
                mappable = [storeById];
            }
            else {
                return error('cannot find associated store');
            }
        }
        if (mappable.length === 0) {
            return error('Cannot find a handle matching requested type and tags.');
        }
        mappable = mappable.filter(incomingHandle => {
            for (const existingHandle of recipe.handles) {
                if (incomingHandle.id === existingHandle.id &&
                    existingHandle !== handle) {
                    return false;
                }
            }
            return true;
        });
        if (mappable.length === 0) {
            // TODO(jopra): Reconsider this behaviour.
            // Tracked at https://github.com/PolymerLabs/arcs/issues/3389
            return error('The only handles matching the requested type and tags are already present in this recipe');
        }
        return mappable.map(store => ((recipe, updateHandle) => {
            updateHandle.mapToStorage(store);
            return 0;
        }));
    }
    onSlotConnection(_recipe, slotConnection) {
        const error = (label) => {
            if (this.options && this.options.errors) {
                this.options.errors.set(slotConnection, label);
            }
            return [];
        };
        const arc = this.arc;
        if (slotConnection.isConnected()) {
            return error('Slot connection is already connected');
        }
        const slotSpec = slotConnection.getSlotSpec();
        const particle = slotConnection.particle;
        const { local, remote } = SlotUtils.findAllSlotCandidates(particle, slotSpec, arc);
        const allSlots = [...local, ...remote];
        // SlotUtils handles a multi-slot case.
        if (allSlots.length !== 1) {
            return error('There are multiple matching slots (match is ambiguous)');
        }
        const selectedSlot = allSlots[0];
        return (recipe, slotConnection) => {
            SlotUtils.connectSlotConnection(slotConnection, selectedSlot);
            return 1;
        };
    }
    onPotentialSlotConnection(_recipe, particle, slotSpec) {
        const error = (label) => {
            if (this.options && this.options.errors) {
                this.options.errors.set(particle, label);
            }
            return [];
        };
        const arc = this.arc;
        const { local, remote } = SlotUtils.findAllSlotCandidates(particle, slotSpec, arc);
        const allSlots = [...local, ...remote];
        // SlotUtils handles a multi-slot case.
        if (allSlots.length !== 1) {
            return error('There are multiple matching slots for this slot spec (match is ambiguous)');
        }
        const selectedSlot = allSlots[0];
        return (_recipe, particle, slotSpec) => {
            const newSlotConnection = particle.addSlotConnection(slotSpec.name);
            SlotUtils.connectSlotConnection(newSlotConnection, selectedSlot);
            return 1;
        };
    }
    // TODO(lindner): add typeof checks here and figure out where handle is coming from.
    onObligation(recipe, obligation) {
        // TODO(jopra): Log errors from here.
        const fromParticle = obligation.from.instance;
        const toParticle = obligation.to.instance;
        for (const fromConnection of Object.values(fromParticle.connections)) {
            for (const toConnection of Object.values(toParticle.connections)) {
                if (fromConnection.handle && fromConnection.handle === toConnection.handle) {
                    return (recipe, obligation) => {
                        recipe.removeObligation(obligation);
                        return 1;
                    };
                }
            }
        }
        return [];
    }
}
class ResolveRecipeAction extends Action {
    withOptions(options) {
        this.options = options;
    }
    async generate(inputParams) {
        return ResolveWalker.walk(this.getResults(inputParams), new ResolveWalker(ResolveWalker.Permuted, this.arc, this.options), this);
    }
}
// Provides basic recipe resolution for recipes against a particular arc.
class RecipeResolver {
    constructor(arc) {
        this.resolver = new ResolveRecipeAction(arc);
    }
    // Attempts to run basic resolution on the given recipe. Returns a new
    // instance of the recipe normalized and resolved if possible. Returns null if
    // normalization or attempting to resolve slot connection fails.
    async resolve(recipe, options) {
        recipe = recipe.clone();
        if (!recipe.normalize(options)) {
            console.warn(`could not normalize a recipe: ${[...options.errors.values()].join('\n')}.\n${recipe.toString()}`);
            return null;
        }
        this.resolver.withOptions(options); // Smuggle error data around
        const result = await this.resolver.generateFrom([{ result: recipe, score: 1 }]);
        if (result.length === 0) {
            if (options && options.errors) {
                options.errors.set(recipe, 'Resolver generated 0 recipes');
            }
            return null;
        }
        return result[0].result;
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Services {
    static register(name, service) {
        Services.registry[name] = service;
    }
    static async request(request) {
        let { service: name, invoke, call } = request;
        if (call) {
            [name, invoke] = call.split('.');
        }
        const service = Services.registry[name];
        if (service) {
            if (service[invoke]) {
                return await service[invoke](request);
            }
        }
        return null;
    }
}
Services.registry = {};
Object.freeze(Services);
Services.register('test', {
    async classify(request) {
        return { data: `it's a pig, that don't fly straight` };
    }
});

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ParticleExecutionHost {
    constructor(slotComposer, arc, ports) {
        this._portByParticle = new Map();
        this.nextIdentifier = 0;
        this.idleVersion = 0;
        this.particles = [];
        this.close = () => {
            ports.forEach(port => port.close());
            this._apiPorts.forEach(apiPort => apiPort.close());
        };
        this.arc = arc;
        this.slotComposer = slotComposer;
        this._apiPorts = ports.map(port => new PECOuterPortImpl(port, arc));
    }
    choosePortForParticle(particle) {
        assert(!this._portByParticle.has(particle), `port already found for particle '${particle.spec.name}'`);
        const port = this._apiPorts.find(port => particle.isJavaParticle() === port.supportsJavaParticle());
        assert(!!port, `No port found for '${particle.spec.name}'`);
        this._portByParticle.set(particle, port);
        return this.getPort(particle);
    }
    getPort(particle) {
        assert(this._portByParticle.has(particle), `Cannot get port for particle '${particle.spec.name}'`);
        return this._portByParticle.get(particle);
    }
    stop() {
        this._apiPorts.forEach(apiPort => apiPort.Stop());
    }
    get idle() {
        if (this.idlePromise == undefined) {
            this.idlePromise = new Promise((resolve, reject) => {
                this.idleResolve = resolve;
            });
        }
        this.idleVersion = this.nextIdentifier;
        this._apiPorts.forEach(apiPort => apiPort.AwaitIdle(this.nextIdentifier++));
        return this.idlePromise;
    }
    get messageCount() {
        return [...this._apiPorts.values()].map(apiPort => apiPort.messageCount).reduce((prev, current) => prev + current, 0);
    }
    sendEvent(particle, slotName, event) {
        this.getPort(particle).UIEvent(particle, slotName, event);
    }
    instantiate(particle, stores) {
        this.particles.push(particle);
        const apiPort = this.choosePortForParticle(particle);
        stores.forEach((store, name) => {
            apiPort.DefineHandle(store, store.type.resolvedType(), name);
        });
        apiPort.InstantiateParticle(particle, particle.id.toString(), particle.spec, stores);
    }
    reinstantiate(particle, stores) {
        assert(this.particles.find(p => p === particle), `Cannot reinstantiate nonexistent particle ${particle.name}`);
        const apiPort = this.getPort(particle);
        stores.forEach((store, name) => {
            apiPort.DefineHandle(store, store.type.resolvedType(), name);
        });
        apiPort.ReinstantiateParticle(particle.id.toString(), particle.spec, stores);
    }
    reload(particles) {
        // Create a mapping from port to given list of particles
        const portMap = new Map();
        particles.forEach(particle => {
            const port = this.getPort(particle);
            let list = portMap.get(port);
            if (!list) {
                list = [particle];
                portMap.set(port, list);
            }
            else {
                list.push(particle);
            }
        });
        // Reload particles based on ports
        portMap.forEach((particles, port) => {
            port.ReloadParticles(particles, particles.map(p => p.id.toString()));
        });
    }
    startRender({ particle, slotName, providedSlots, contentTypes }) {
        this.getPort(particle).StartRender(particle, slotName, providedSlots, contentTypes);
    }
    stopRender({ particle, slotName }) {
        this.getPort(particle).StopRender(particle, slotName);
    }
    innerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) {
        // Note: Transformations are not supported in Java PEC.
        this.getPort(transformationParticle).InnerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content);
    }
    resolveIfIdle(version, relevance) {
        if (version === this.idleVersion) {
            this.idlePromise = undefined;
            this.idleResolve(relevance);
        }
    }
}
class PECOuterPortImpl extends PECOuterPort {
    constructor(port, arc) {
        super(port, arc);
        this.arc = arc;
    }
    onRender(particle, slotName, content) {
        if (this.arc.pec.slotComposer) {
            this.arc.pec.slotComposer.renderSlot(particle, slotName, content);
        }
    }
    onInitializeProxy(handle, callback) {
        const target = {};
        handle.on('change', data => this.SimpleCallback(callback, data), target);
    }
    async onSynchronizeProxy(handle, callback) {
        const data = await handle.modelForSynchronization();
        this.SimpleCallback(callback, data);
    }
    async onHandleGet(handle, callback) {
        const data = await handle.get();
        this.SimpleCallback(callback, data);
    }
    async onHandleToList(handle, callback) {
        const data = await handle.toList();
        this.SimpleCallback(callback, data);
    }
    onHandleSet(handle, data, particleId, barrier) {
        // TODO: Awaiting this promise causes tests to fail...
        floatingPromiseToAudit(handle.set(data, particleId, barrier));
    }
    onHandleClear(handle, particleId, barrier) {
        // TODO: Awaiting this promise causes tests to fail...
        floatingPromiseToAudit(handle.clear(particleId, barrier));
    }
    async onHandleStore(handle, callback, data, particleId) {
        // TODO(shans): fix typing once we have types for Singleton/Collection/etc
        // tslint:disable-next-line: no-any
        await handle.store(data.value, data.keys, particleId);
        this.SimpleCallback(callback, {});
    }
    async onHandleRemove(handle, callback, data, particleId) {
        // TODO(shans): fix typing once we have types for Singleton/Collection/etc
        // tslint:disable-next-line: no-any
        await handle.remove(data.id, data.keys, particleId);
        this.SimpleCallback(callback, {});
    }
    async onHandleRemoveMultiple(handle, callback, data, particleId) {
        await handle.removeMultiple(data, particleId);
        this.SimpleCallback(callback, {});
    }
    async onHandleStream(handle, callback, pageSize, forward) {
        this.SimpleCallback(callback, await handle.stream(pageSize, forward));
    }
    async onStreamCursorNext(handle, callback, cursorId) {
        this.SimpleCallback(callback, await handle.cursorNext(cursorId));
    }
    onStreamCursorClose(handle, cursorId) {
        handle.cursorClose(cursorId);
    }
    onIdle(version, relevance) {
        this.arc.pec.resolveIfIdle(version, relevance);
    }
    async onGetBackingStore(callback, storageKey, type) {
        if (!storageKey) {
            storageKey = this.arc.storageProviderFactory.baseStorageKey(type, this.arc.storageKey || 'volatile');
        }
        const store = await this.arc.storageProviderFactory.baseStorageFor(type, storageKey);
        // TODO(shans): THIS IS NOT SAFE!
        //
        // Without an auditor on the runtime side that inspects what is being fetched from
        // this store, particles with a reference can access any data of that reference's type.
        //
        // TOODO(sjmiles): randomizing the id as a workaround for https://github.com/PolymerLabs/arcs/issues/2936
        this.GetBackingStoreCallback(store, callback, type.collectionOf(), type.toString(), `${store.id}:${`String(Math.random())`.slice(2, 9)}`, storageKey);
    }
    onConstructInnerArc(callback, particle) {
        const arc = this.arc.createInnerArc(particle);
        this.ConstructArcCallback(callback, arc);
    }
    async onArcCreateHandle(callback, arc, type, name) {
        // At the moment, inner arcs are not persisted like their containers, but are instead
        // recreated when an arc is deserialized. As a consequence of this, dynamically
        // created handles for inner arcs must always be volatile to prevent storage
        // in firebase.
        const store = await arc.createStore(type, name, null, [], 'volatile');
        // Store belongs to the inner arc, but the transformation particle,
        // which itself is in the outer arc gets access to it.
        this.CreateHandleCallback(store, callback, type, name, store.id);
    }
    onArcMapHandle(callback, arc, handle) {
        assert(this.arc.findStoreById(handle.id), `Cannot map nonexistent handle ${handle.id}`);
        // TODO: create hosted handles map with specially generated ids instead of returning the real ones?
        this.MapHandleCallback({}, callback, handle.id);
    }
    onArcCreateSlot(callback, arc, transformationParticle, transformationSlotName, handleId) {
        let hostedSlotId;
        if (this.arc.pec.slotComposer) {
            hostedSlotId = this.arc.pec.slotComposer.createHostedSlot(arc, transformationParticle, transformationSlotName, handleId);
        }
        this.CreateSlotCallback({}, callback, hostedSlotId);
    }
    async onArcLoadRecipe(arc, recipe, callback) {
        const manifest = await Manifest.parse(recipe, { loader: arc.loader, fileName: '' });
        const successResponse = {
            providedSlotIds: {}
        };
        let error = undefined;
        // TODO(wkorman): Consider reporting an error or at least warning if
        // there's more than one recipe since currently we silently ignore them.
        let recipe0 = manifest.recipes[0];
        if (recipe0) {
            for (const slot of recipe0.slots) {
                slot.id = slot.id || `slotid-${arc.generateID()}`;
                if (slot.sourceConnection) {
                    const particlelocalName = slot.sourceConnection.particle.localName;
                    if (particlelocalName) {
                        successResponse.providedSlotIds[`${particlelocalName}.${slot.name}`] = slot.id;
                    }
                }
            }
            const missingHandles = [];
            for (const handle of recipe0.handles) {
                const fromHandle = this.arc.findStoreById(handle.id) || manifest.findStoreById(handle.id);
                if (fromHandle) {
                    handle.mapToStorage(fromHandle);
                }
                else {
                    missingHandles.push(handle);
                    continue;
                }
            }
            if (missingHandles.length > 0) {
                let recipeToResolve = recipe0;
                // We're resolving both against the inner and the outer arc.
                for (const resolver of [new RecipeResolver(arc /* inner */), new RecipeResolver(this.arc /* outer */)]) {
                    recipeToResolve = await resolver.resolve(recipeToResolve) || recipeToResolve;
                }
                if (recipeToResolve === recipe0) {
                    error = `Recipe couldn't load due to missing handles [recipe=${recipe0}, missingHandles=${missingHandles.join('\n')}].`;
                }
                else {
                    recipe0 = recipeToResolve;
                }
            }
            if (!error) {
                const options = { errors: new Map() };
                // If we had missing handles but we made it here, then we ran recipe
                // resolution which will have already normalized the recipe.
                if ((missingHandles.length > 0) || recipe0.normalize(options)) {
                    if (recipe0.isResolved()) {
                        // TODO: pass tags through too, and reconcile with similar logic
                        // in Arc.deserialize.
                        for (const store of manifest.stores) {
                            if (store instanceof StorageStub) {
                                this.arc._registerStore(await store.inflate(), []);
                            }
                            else {
                                this.arc._registerStore(store, []);
                            }
                        }
                        // TODO: Awaiting this promise causes tests to fail...
                        floatingPromiseToAudit(arc.instantiate(recipe0));
                    }
                    else {
                        error = `Recipe is not resolvable:\n${recipe0.toString({ showUnresolved: true })}`;
                    }
                }
                else {
                    error = `Recipe ${recipe0} could not be normalized:\n${[...options.errors.values()].join('\n')}`;
                }
            }
        }
        else {
            error = 'No recipe defined';
        }
        this.SimpleCallback(callback, error ? { error } : successResponse);
    }
    // TODO(sjmiles): experimental `output` impl
    onOutput(particle, content) {
        const composer = this.arc.pec.slotComposer;
        if (composer && composer['delegateOutput']) {
            composer['delegateOutput'](this.arc, particle, content);
        }
    }
    onReportExceptionInHost(exception) {
        if (!exception.particleName) {
            exception.particleName = this.arc.loadedParticleInfo.get(exception.particleId).spec.name;
        }
        reportSystemException(exception);
    }
    // TODO(sjmiles): experimental `services` impl
    async onServiceRequest(particle, request, callback) {
        const response = await Services.request(request);
        this.SimpleCallback(callback, response);
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var Exists;
(function (Exists) {
    Exists[Exists["ShouldExist"] = 0] = "ShouldExist";
    Exists[Exists["ShouldCreate"] = 1] = "ShouldCreate";
    Exists[Exists["MayExist"] = 2] = "MayExist";
})(Exists || (Exists = {}));
// Interface that drivers must support.
// 
// Note the threading of a version number here; each model provided
// by the driver to the Store (using the receiver) is paired with a version,
// as is each model sent from the Store to the driver (using Driver.send()).
// 
// This threading is used to track whether driver state has changed while
// the Store is processing a particular model. send() should always fail
// if the version isn't exactly 1 greater than the current internal version.
class Driver {
    constructor(storageKey, exists) {
        this.storageKey = storageKey;
        this.exists = exists;
    }
}
class DriverFactory {
    static clearRegistrationsForTesting() {
        this.providers = new Set();
    }
    static async driverInstance(storageKey, exists) {
        for (const provider of this.providers) {
            if (provider.willSupport(storageKey)) {
                return provider.driver(storageKey, exists);
            }
        }
        return null;
    }
    static register(storageDriverProvider) {
        this.providers.add(storageDriverProvider);
    }
    static unregister(storageDriverProvider) {
        this.providers.delete(storageDriverProvider);
    }
    static willSupport(storageKey) {
        for (const provider of this.providers) {
            if (provider.willSupport(storageKey)) {
                return true;
            }
        }
        return false;
    }
}
DriverFactory.providers = new Set();

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class VolatileMemory {
    constructor() {
        this.entries = new Map();
    }
}
class VolatileDriver extends Driver {
    constructor(storageKey, exists, memory) {
        super(storageKey, exists);
        this.pendingVersion = 0;
        this.pendingModel = null;
        const keyAsString = storageKey.toString();
        this.memory = memory;
        switch (exists) {
            case Exists.ShouldCreate:
                if (this.memory.entries.has(keyAsString)) {
                    throw new Error(`requested creation of memory location ${storageKey} can't proceed as location already exists`);
                }
                this.data = { data: null, version: 0, drivers: [] };
                this.memory.entries.set(keyAsString, this.data);
                break;
            case Exists.ShouldExist:
                if (!this.memory.entries.has(keyAsString)) {
                    throw new Error(`requested connection to memory location ${storageKey} can't proceed as location doesn't exist`);
                }
            /* falls through */
            case Exists.MayExist:
                {
                    const data = this.memory.entries.get(keyAsString);
                    if (data) {
                        this.data = data;
                        this.pendingModel = data.data;
                        this.pendingVersion = data.version;
                    }
                    else {
                        this.data = { data: null, version: 0, drivers: [] };
                        this.memory.entries.set(keyAsString, this.data);
                    }
                    break;
                }
            default:
                throw new Error(`unknown Exists code ${exists}`);
        }
        this.data.drivers.push(this);
    }
    registerReceiver(receiver) {
        this.receiver = receiver;
        if (this.pendingModel) {
            receiver(this.pendingModel, this.pendingVersion);
            this.pendingModel = null;
        }
    }
    async send(model, version) {
        // This needs to contain an "empty" await, otherwise there's
        // a synchronous send / onReceive loop that can be established
        // between multiple Stores/Drivers writing to the same location.
        await 0;
        if (this.data.version !== version - 1) {
            return false;
        }
        this.data.data = model;
        this.data.version += 1;
        this.data.drivers.forEach(driver => {
            if (driver === this) {
                return;
            }
            driver.receiver(model, this.data.version);
        });
        return true;
    }
    async write(key, value) {
        throw new Error('Method not implemented.');
    }
    async read(key) {
        throw new Error('Method not implemented.');
    }
}
/**
 * Provides Volatile storage drivers. Volatile storage is local to an individual
 * running Arc. It lives for as long as that Arc instance, and then gets
 * deleted when the Arc is stopped.
 */
class VolatileStorageDriverProvider {
    constructor(arc) {
        this.arc = arc;
    }
    willSupport(storageKey) {
        return storageKey.protocol === 'volatile' && storageKey.arcId.equal(this.arc.id);
    }
    async driver(storageKey, exists) {
        if (!this.willSupport(storageKey)) {
            throw new Error(`This provider does not support storageKey ${storageKey.toString()}`);
        }
        return new VolatileDriver(storageKey, exists, this.arc.volatileMemory);
    }
    static register(arc) {
        DriverFactory.register(new VolatileStorageDriverProvider(arc));
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Arc {
    constructor({ id, context, pecFactories, slotComposer, loader, storageKey, storageProviderFactory, speculative, innerArc, stub, inspectorFactory }) {
        this._activeRecipe = new Recipe();
        this._recipeDeltas = [];
        this.dataChangeCallbacks = new Map();
        // All the stores, mapped by store ID
        this.storesById = new Map();
        // storage keys for referenced handles
        this.storageKeys = {};
        // Map from each store to a set of tags. public for debug access
        this.storeTags = new Map();
        // Map from each store to its description (originating in the manifest).
        this.storeDescriptions = new Map();
        this.innerArcsByParticle = new Map();
        this.instantiateMutex = new Mutex();
        this.idGenerator = IdGenerator.newSession();
        this.loadedParticleInfo = new Map();
        // Volatile storage local to this Arc instance.
        this.volatileMemory = new VolatileMemory();
        // TODO: context should not be optional.
        this._context = context || new Manifest({ id });
        // TODO: pecFactories should not be optional. update all callers and fix here.
        this.pecFactories = pecFactories && pecFactories.length > 0 ? pecFactories.slice() : [FakePecFactory(loader).bind(null)];
        // TODO(sjmiles): FIXME: currently some UiBrokers need to recover arc from composer in order to forward events
        if (slotComposer && !slotComposer['arc']) {
            slotComposer['arc'] = this;
        }
        if (typeof id === 'string') {
            // TODO(csilvestrini): Replace this warning with an exception.
            console.error(`Arc created with string ID ${id}!!! This should be an object of type Id instead. This warning will turn into an ` +
                `exception soon (end of April 2019).`);
            this.id = ArcId.fromString(id);
        }
        else {
            this.id = id;
        }
        this.isSpeculative = !!speculative; // undefined => false
        this.isInnerArc = !!innerArc; // undefined => false
        this.isStub = !!stub;
        this._loader = loader;
        this.inspectorFactory = inspectorFactory;
        this.inspector = inspectorFactory && inspectorFactory.create(this);
        this.storageKey = storageKey;
        const ports = this.pecFactories.map(f => f(this.generateID(), this.idGenerator));
        this.pec = new ParticleExecutionHost(slotComposer, this, ports);
        this.storageProviderFactory = storageProviderFactory || new StorageProviderFactory(this.id);
        this.volatileStorageDriverProvider = new VolatileStorageDriverProvider(this);
        DriverFactory.register(this.volatileStorageDriverProvider);
    }
    get loader() {
        return this._loader;
    }
    get modality() {
        if (this.pec.slotComposer && this.pec.slotComposer.modality) {
            return this.pec.slotComposer.modality;
        }
        if (!this.activeRecipe.isEmpty()) {
            return this.activeRecipe.modality;
        }
        return Modality.union(this.context.allRecipes.map(recipe => recipe.modality));
    }
    dispose() {
        for (const innerArc of this.innerArcs) {
            innerArc.dispose();
        }
        // TODO: disconnect all associated store event handlers
        this.pec.stop();
        this.pec.close();
        // Slot contexts and consumers from inner and outer arcs can be interwoven. Slot composer
        // is therefore disposed in its entirety with an outer Arc's disposal.
        if (!this.isInnerArc && this.pec.slotComposer) {
            // Just a sanity check that we're not disposing a SlotComposer used by some other arc.
            const allArcs = this.allDescendingArcs;
            this.pec.slotComposer.consumers.forEach(consumer => assert(allArcs.includes(consumer.arc)));
            this.pec.slotComposer.dispose();
        }
        DriverFactory.unregister(this.volatileStorageDriverProvider);
    }
    // Returns a promise that spins sending a single `AwaitIdle` message until it
    // sees no other messages were sent.
    async _waitForIdle() {
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const messageCount = this.pec.messageCount;
            const innerArcs = this.innerArcs;
            // tslint:disable-next-line: no-any
            await Promise.all([this.pec.idle, ...innerArcs.map(async (arc) => arc.idle)]);
            // We're idle if no new inner arcs appeared and this.pec had exactly 2 messages,
            // one requesting the idle status, and one answering it.
            if (this.innerArcs.length === innerArcs.length
                && this.pec.messageCount === messageCount + 2)
                break;
        }
    }
    get idle() {
        if (this.waitForIdlePromise) {
            return this.waitForIdlePromise;
        }
        // Store one active completion promise for use by any subsequent callers.
        // We explicitly want to avoid, for example, multiple simultaneous
        // attempts to identify idle state each sending their own `AwaitIdle`
        // message and expecting settlement that will never arrive.
        const promise = this._waitForIdle().then(() => this.waitForIdlePromise = null);
        this.waitForIdlePromise = promise;
        return promise;
    }
    findInnerArcs(particle) {
        return this.innerArcsByParticle.get(particle) || [];
    }
    // Inner arcs of this arc's transformation particles.
    // Does *not* include inner arcs of this arc's inner arcs.
    get innerArcs() {
        return [].concat(...this.innerArcsByParticle.values());
    }
    // This arc and all its descendants.
    // *Does* include inner arcs of this arc's inner arcs.
    get allDescendingArcs() {
        return [this].concat(...this.innerArcs.map(arc => arc.allDescendingArcs));
    }
    createInnerArc(transformationParticle) {
        const id = this.generateID('inner');
        const innerArc = new Arc({ id, pecFactories: this.pecFactories, slotComposer: this.pec.slotComposer, loader: this._loader, context: this.context, innerArc: true, speculative: this.isSpeculative, inspectorFactory: this.inspectorFactory });
        let particleInnerArcs = this.innerArcsByParticle.get(transformationParticle);
        if (!particleInnerArcs) {
            particleInnerArcs = [];
            this.innerArcsByParticle.set(transformationParticle, particleInnerArcs);
        }
        particleInnerArcs.push(innerArc);
        return innerArc;
    }
    async _serializeHandle(handle, context, id) {
        const type = handle.type.getContainedType() || handle.type;
        if (type instanceof InterfaceType) {
            context.interfaces += type.interfaceInfo.toString() + '\n';
        }
        const key = this.storageProviderFactory.parseStringAsKey(handle.storageKey);
        const tags = this.storeTags.get(handle) || new Set();
        const handleTags = [...tags].map(a => `#${a}`).join(' ');
        const actualHandle = this.activeRecipe.findHandle(handle.id);
        const originalId = actualHandle ? actualHandle.originalId : null;
        let combinedId = `'${handle.id}'`;
        if (originalId) {
            combinedId += `!!'${originalId}'`;
        }
        switch (key.protocol) {
            case 'firebase':
            case 'pouchdb':
                context.handles += `store ${id} of ${handle.type.toString()} ${combinedId} @${handle.version === null ? 0 : handle.version} ${handleTags} at '${handle.storageKey}'\n`;
                break;
            case 'volatile': {
                // TODO(sjmiles): emit empty data for stores marked `volatile`: shell will supply data
                const volatile = handleTags.includes('volatile');
                let serializedData = [];
                if (!volatile) {
                    // TODO: include keys in serialized [big]collections?
                    serializedData = (await handle.toLiteral()).model.map((model) => {
                        const { id, value } = model;
                        const index = model['index']; // TODO: Invalid Type
                        if (value == null) {
                            return null;
                        }
                        let result;
                        if (value.rawData) {
                            result = { $id: id };
                            for (const field of Object.keys(value.rawData)) {
                                result[field] = value.rawData[field];
                            }
                        }
                        else {
                            result = value;
                        }
                        if (index !== undefined) {
                            result.$index = index;
                        }
                        return result;
                    });
                }
                if (handle.referenceMode && serializedData.length > 0) {
                    const storageKey = serializedData[0].storageKey;
                    if (!context.dataResources.has(storageKey)) {
                        const storeId = `${id}_Data`;
                        context.dataResources.set(storageKey, storeId);
                        // TODO: can't just reach into the store for the backing Store like this, should be an
                        // accessor that loads-on-demand in the storage objects.
                        if (handle instanceof StorageProviderBase) {
                            await handle.ensureBackingStore();
                            await this._serializeHandle(handle.backingStore, context, storeId);
                        }
                    }
                    const storeId = context.dataResources.get(storageKey);
                    serializedData.forEach(a => { a.storageKey = storeId; });
                }
                const indent = '  ';
                const data = JSON.stringify(serializedData);
                context.resources += `resource ${id}Resource\n`
                    + indent + 'start\n'
                    + data.split('\n').map(line => indent + line).join('\n')
                    + '\n';
                context.handles += `store ${id} of ${handle.type.toString()} ${combinedId} @${handle.version || 0} ${handleTags} in ${id}Resource\n`;
                break;
            }
            default:
                throw new Error(`unknown storageKey protocol ${key.protocol}`);
        }
    }
    async _serializeHandles() {
        const context = { handles: '', resources: '', interfaces: '', dataResources: new Map() };
        let id = 0;
        const importSet = new Set();
        const handlesToSerialize = new Set();
        const contextSet = new Set(this.context.stores.map(store => store.id));
        for (const handle of this._activeRecipe.handles) {
            if (handle.fate === 'map') {
                importSet.add(this.context.findManifestUrlForHandleId(handle.id));
            }
            else {
                // Immediate value handles have values inlined in the recipe and are not serialized.
                if (handle.immediateValue)
                    continue;
                handlesToSerialize.add(handle.id);
            }
        }
        for (const url of importSet.values()) {
            context.resources += `import '${url}'\n`;
        }
        for (const handle of this._stores) {
            if (!handlesToSerialize.has(handle.id) || contextSet.has(handle.id)) {
                continue;
            }
            await this._serializeHandle(handle, context, `Store${id++}`);
        }
        return context.resources + context.interfaces + context.handles;
    }
    _serializeParticles() {
        const particleSpecs = [];
        // Particles used directly.
        particleSpecs.push(...this._activeRecipe.particles.map(entry => entry.spec));
        // Particles referenced in an immediate mode.
        particleSpecs.push(...this._activeRecipe.handles
            .filter(h => h.immediateValue)
            .map(h => h.immediateValue));
        const results = [];
        particleSpecs.forEach(spec => {
            for (const connection of spec.handleConnections) {
                if (connection.type instanceof InterfaceType) {
                    results.push(connection.type.interfaceInfo.toString());
                }
            }
            results.push(spec.toString());
        });
        return results.join('\n');
    }
    _serializeStorageKey() {
        if (this.storageKey) {
            return `storageKey: '${this.storageKey}'\n`;
        }
        return '';
    }
    async serialize() {
        await this.idle;
        return `
meta
  name: '${this.id}'
  ${this._serializeStorageKey()}

${await this._serializeHandles()}

${this._serializeParticles()}

@active
${this.activeRecipe.toString()}`;
    }
    // Writes `serialization` to the ArcInfo child key under the Arc's storageKey.
    // This does not directly use serialize() as callers may want to modify the
    // contents of the serialized arc before persisting.
    async persistSerialization(serialization) {
        const storage = this.storageProviderFactory;
        const key = storage.parseStringAsKey(this.storageKey).childKeyForArcInfo();
        const arcInfoType = new ArcType();
        const store = await storage.connectOrConstruct('store', arcInfoType, key.toString());
        store.referenceMode = false;
        // TODO: storage refactor: make sure set() is available here (or wrap store in a Handle-like adaptor).
        await store.set(arcInfoType.newInstance(this.id, serialization));
    }
    static async deserialize({ serialization, pecFactories, slotComposer, loader, fileName, context, inspectorFactory }) {
        const manifest = await Manifest.parse(serialization, { loader, fileName, context });
        const arc = new Arc({
            id: Id.fromString(manifest.meta.name),
            storageKey: manifest.meta.storageKey,
            slotComposer,
            pecFactories,
            loader,
            storageProviderFactory: manifest.storageProviderFactory,
            context,
            inspectorFactory
        });
        await Promise.all(manifest.stores.map(async (storeStub) => {
            const tags = manifest.storeTags.get(storeStub);
            const store = await storeStub.inflate();
            arc._registerStore(store, tags);
        }));
        const recipe = manifest.activeRecipe.clone();
        const options = { errors: new Map() };
        assert(recipe.normalize(options), `Couldn't normalize recipe ${recipe.toString()}:\n${[...options.errors.values()].join('\n')}`);
        await arc.instantiate(recipe);
        return arc;
    }
    get context() {
        return this._context;
    }
    get activeRecipe() { return this._activeRecipe; }
    get allRecipes() { return [this.activeRecipe].concat(this.context.allRecipes); }
    get recipes() { return [this.activeRecipe]; }
    get recipeDeltas() { return this._recipeDeltas; }
    loadedParticleSpecs() {
        return [...this.loadedParticleInfo.values()].map(({ spec }) => spec);
    }
    async reinstantiateParticle(recipeParticle) {
        const info = await this._getParticleInstantiationInfo(recipeParticle);
        this.pec.reinstantiate(recipeParticle, info.stores);
    }
    async _instantiateParticle(recipeParticle) {
        if (!recipeParticle.id) {
            recipeParticle.id = this.generateID('particle');
        }
        const info = await this._getParticleInstantiationInfo(recipeParticle);
        this.pec.instantiate(recipeParticle, info.stores);
    }
    async _getParticleInstantiationInfo(recipeParticle) {
        const info = { spec: recipeParticle.spec, stores: new Map() };
        this.loadedParticleInfo.set(recipeParticle.id.toString(), info);
        // if supported, provide particle caching via a BloblUrl representing spec.implFile
        if (!recipeParticle.isJavaParticle()) {
            await this._provisionSpecUrl(recipeParticle.spec);
        }
        for (const [name, connection] of Object.entries(recipeParticle.connections)) {
            if (connection.handle.fate !== '`slot') {
                const store = this.findStoreById(connection.handle.id);
                assert(store, `can't find store of id ${connection.handle.id}`);
                assert(info.spec.handleConnectionMap.get(name) !== undefined, 'can\'t connect handle to a connection that doesn\'t exist');
                info.stores.set(name, store);
            }
        }
        return info;
    }
    async _provisionSpecUrl(spec) {
        if (!spec.implBlobUrl) {
            // if supported, construct spec.implBlobUrl for spec.implFile
            if (this.loader && this.loader['provisionObjectUrl']) {
                const url = await this.loader['provisionObjectUrl'](spec.implFile);
                if (url) {
                    spec.setImplBlobUrl(url);
                }
                else {
                    throw new Error(`Expected url for ${spec.implFile} but got ${url}`);
                }
            }
        }
    }
    generateID(component = '') {
        return this.idGenerator.newChildId(this.id, component);
    }
    get _stores() {
        return [...this.storesById.values()];
    }
    // Makes a copy of the arc used for speculative execution.
    async cloneForSpeculativeExecution() {
        const arc = new Arc({ id: this.generateID(),
            pecFactories: this.pecFactories,
            context: this.context,
            loader: this._loader,
            speculative: true,
            innerArc: this.isInnerArc,
            inspectorFactory: this.inspectorFactory });
        const storeMap = new Map();
        for (const store of this._stores) {
            const clone = await arc.storageProviderFactory.construct(store.id, store.type, 'volatile');
            await clone.cloneFrom(store);
            storeMap.set(store, clone);
            if (this.storeDescriptions.has(store)) {
                arc.storeDescriptions.set(clone, this.storeDescriptions.get(store));
            }
        }
        this.loadedParticleInfo.forEach((info, id) => {
            const stores = new Map();
            info.stores.forEach((store, name) => stores.set(name, storeMap.get(store)));
            arc.loadedParticleInfo.set(id, { spec: info.spec, stores });
        });
        const { cloneMap } = this._activeRecipe.mergeInto(arc._activeRecipe);
        this._recipeDeltas.forEach(recipe => arc._recipeDeltas.push({
            particles: recipe.particles.map(p => cloneMap.get(p)),
            handles: recipe.handles.map(h => cloneMap.get(h)),
            slots: recipe.slots.map(s => cloneMap.get(s)),
            patterns: recipe.patterns
        }));
        for (const [particle, innerArcs] of this.innerArcsByParticle.entries()) {
            arc.innerArcsByParticle.set(cloneMap.get(particle), await Promise.all(innerArcs.map(async (arc) => arc.cloneForSpeculativeExecution())));
        }
        for (const v of storeMap.values()) {
            // FIXME: Tags
            arc._registerStore(v, []);
        }
        return arc;
    }
    /**
     * Instantiates the given recipe in the Arc.
     *
     * Executes the following steps:
     *
     * - Merges the recipe into the Active Recipe
     * - Populates missing slots.
     * - Processes the Handles and creates stores for them.
     * - Instantiates the new Particles
     * - Passes these particles for initialization in the PEC
     *
     * Waits for completion of an existing Instantiate before returning.
     */
    async instantiate(recipe) {
        assert(recipe.isResolved(), `Cannot instantiate an unresolved recipe: ${recipe.toString({ showUnresolved: true })}`);
        assert(recipe.isCompatible(this.modality), `Cannot instantiate recipe ${recipe.toString()} with [${recipe.modality.names}] modalities in '${this.modality.names}' arc`);
        const release = await this.instantiateMutex.acquire();
        try {
            await this._doInstantiate(recipe);
        }
        finally {
            release();
        }
    }
    async mergeIntoActiveRecipe(recipe) {
        const { handles, particles, slots } = recipe.mergeInto(this._activeRecipe);
        this._recipeDeltas.push({ particles, handles, slots, patterns: recipe.patterns });
        // TODO(mmandlis): Get rid of populating the missing local slot IDs here,
        // it should be done at planning stage.
        slots.forEach(slot => slot.id = slot.id || `slotid-${this.generateID().toString()}`);
        for (const recipeHandle of handles) {
            const store = this.context.findStoreById(recipeHandle.id);
            // TODO(sjmiles): I added `(store instanceof StorageStub)` clause below because the context generators used
            // in shells/* work today by creating and updating inflated stores in the context.
            if (['copy', 'create'].includes(recipeHandle.fate) ||
                ((recipeHandle.fate === 'map')
                    && (store instanceof StorageStub)
                    && store.isBackedByManifest())) {
                let type = recipeHandle.type;
                if (recipeHandle.fate === 'create') {
                    assert(type.maybeEnsureResolved(), `Can't assign resolved type to ${type}`);
                }
                type = type.resolvedType();
                assert(type.isResolved(), `Can't create handle for unresolved type ${type}`);
                const newStore = await this.createStore(type, /* name= */ null, this.generateID().toString(), recipeHandle.tags, recipeHandle.immediateValue ? 'volatile' : null);
                if (recipeHandle.immediateValue) {
                    const particleSpec = recipeHandle.immediateValue;
                    const type = recipeHandle.type;
                    assert(type instanceof InterfaceType && type.interfaceInfo.particleMatches(particleSpec));
                    const particleClone = particleSpec.clone().toLiteral();
                    particleClone.id = newStore.id;
                    // TODO(shans): clean this up when we have interfaces for Singleton, Collection, etc.
                    // tslint:disable-next-line: no-any
                    await newStore.set(particleClone);
                }
                else if (['copy', 'map'].includes(recipeHandle.fate)) {
                    const copiedStoreRef = this.context.findStoreById(recipeHandle.id);
                    const copiedStore = await copiedStoreRef.inflate(this.storageProviderFactory);
                    assert(copiedStore, `Cannot find store ${recipeHandle.id}`);
                    assert(copiedStore.version !== null, `Copied store ${recipeHandle.id} doesn't have version.`);
                    await newStore.cloneFrom(copiedStore);
                    this._tagStore(newStore, this.context.findStoreTags(copiedStoreRef));
                    newStore.name = copiedStore.name && `Copy of ${copiedStore.name}`;
                    const copiedStoreDesc = this.getStoreDescription(copiedStore);
                    if (copiedStoreDesc) {
                        this.storeDescriptions.set(newStore, copiedStoreDesc);
                    }
                }
                recipeHandle.id = newStore.id;
                recipeHandle.fate = 'use';
                recipeHandle.storageKey = newStore.storageKey;
                continue;
                // TODO: move the call to ParticleExecutionHost's DefineHandle to here
            }
            // TODO(shans/sjmiles): This shouldn't be possible, but at the moment the
            // shell pre-populates all arcs with a set of handles so if a recipe explicitly
            // asks for one of these there's a conflict. Ideally these will end up as a
            // part of the context and will be populated on-demand like everything else.
            if (this.storesById.has(recipeHandle.id)) {
                continue;
            }
            if (recipeHandle.fate !== '`slot') {
                let storageKey = recipeHandle.storageKey;
                if (!storageKey) {
                    storageKey = this.keyForId(recipeHandle.id);
                }
                assert(storageKey, `couldn't find storage key for handle '${recipeHandle}'`);
                const type = recipeHandle.type.resolvedType();
                assert(type.isResolved());
                const store = await this.storageProviderFactory.connect(recipeHandle.id, type, storageKey);
                assert(store, `store '${recipeHandle.id}' was not found (${storageKey})`);
                this._registerStore(store, recipeHandle.tags);
            }
        }
        return { handles, particles, slots };
    }
    // Critical section for instantiate,
    async _doInstantiate(recipe) {
        const { handles, particles, slots } = await this.mergeIntoActiveRecipe(recipe);
        await Promise.all(particles.map(recipeParticle => this._instantiateParticle(recipeParticle)));
        if (this.pec.slotComposer) {
            // TODO: pass slot-connections instead
            await this.pec.slotComposer.initializeRecipe(this, particles);
        }
        if (this.inspector) {
            this.inspector.recipeInstantiated(particles, this.activeRecipe.toString());
        }
    }
    async createStore(type, name, id, tags, storageKey) {
        assert(type instanceof Type, `can't createStore with type ${type} that isn't a Type`);
        if (type instanceof RelationType) {
            type = new CollectionType(type);
        }
        if (id == undefined) {
            id = this.generateID().toString();
        }
        if (storageKey == undefined && this.storageKey) {
            storageKey =
                this.storageProviderFactory.parseStringAsKey(this.storageKey)
                    .childKeyForHandle(id)
                    .toString();
        }
        // TODO(sjmiles): use `volatile` for volatile stores
        const hasVolatileTag = (tags) => tags && tags.includes('volatile');
        if (storageKey == undefined || hasVolatileTag(tags)) {
            storageKey = 'volatile';
        }
        const store = await this.storageProviderFactory.construct(id, type, storageKey);
        assert(store, `failed to create store with id [${id}]`);
        store.name = name;
        this._registerStore(store, tags);
        return store;
    }
    _registerStore(store, tags) {
        assert(!this.storesById.has(store.id), `Store already registered '${store.id}'`);
        tags = tags || [];
        tags = Array.isArray(tags) ? tags : [tags];
        this.storesById.set(store.id, store);
        this.storeTags.set(store, new Set(tags));
        this.storageKeys[store.id] = store.storageKey;
        store.on('change', () => this._onDataChange(), this);
        Runtime.getRuntime().registerStore(store, tags);
    }
    _tagStore(store, tags) {
        assert(this.storesById.has(store.id) && this.storeTags.has(store), `Store not registered '${store.id}'`);
        const storeTags = this.storeTags.get(store);
        tags = tags || new Set();
        tags.forEach(tag => storeTags.add(tag));
    }
    _onDataChange() {
        for (const callback of this.dataChangeCallbacks.values()) {
            callback();
        }
    }
    onDataChange(callback, registration) {
        this.dataChangeCallbacks.set(registration, callback);
    }
    clearDataChange(registration) {
        this.dataChangeCallbacks.delete(registration);
    }
    // Convert a type to a normalized key that we can use for
    // equality testing.
    //
    // TODO: we should be testing the schemas for compatiblity instead of using just the name.
    // TODO: now that this is only used to implement findStoresByType we can probably replace
    // the check there with a type system equality check or similar.
    static _typeToKey(type) {
        const elementType = type.getContainedType();
        if (elementType) {
            const key = this._typeToKey(elementType);
            if (key) {
                return `list:${key}`;
            }
        }
        else if (type instanceof EntityType) {
            return type.entitySchema.name;
        }
        else if (type instanceof InterfaceType) {
            // TODO we need to fix this too, otherwise all handles of interface type will
            // be of the 'same type' when searching by type.
            return type.interfaceInfo;
        }
        else if (type instanceof TypeVariable && type.isResolved()) {
            return Arc._typeToKey(type.resolvedType());
        }
        return null;
    }
    findStoresByType(type, options) {
        const typeKey = Arc._typeToKey(type);
        let stores = [...this.storesById.values()].filter(handle => {
            if (typeKey) {
                const handleKey = Arc._typeToKey(handle.type);
                if (typeKey === handleKey) {
                    return true;
                }
            }
            else {
                if (type instanceof TypeVariable && !type.isResolved() && handle.type instanceof EntityType) {
                    return true;
                }
                // elementType will only be non-null if type is either Collection or BigCollection; the tag
                // comparison ensures that handle.type is the same sort of collection.
                const elementType = type.getContainedType();
                if (elementType && elementType instanceof TypeVariable && !elementType.isResolved() && type.tag === handle.type.tag) {
                    return true;
                }
            }
            return false;
        });
        if (options && options.tags && options.tags.length > 0) {
            stores = stores.filter(store => options.tags.filter(tag => !this.storeTags.get(store).has(tag)).length === 0);
        }
        // Quick check that a new handle can fulfill the type contract.
        // Rewrite of this method tracked by https://github.com/PolymerLabs/arcs/issues/1636.
        return stores.filter(s => !!Handle.effectiveType(type, [{ type: s.type, direction: (s.type instanceof InterfaceType) ? 'host' : 'inout' }]));
    }
    findStoreById(id) {
        const store = this.storesById.get(id);
        if (store == null) {
            return this._context.findStoreById(id);
        }
        return store;
    }
    findStoreTags(store) {
        if (this.storeTags.has(store)) {
            return this.storeTags.get(store);
        }
        return this._context.findStoreTags(store);
    }
    getStoreDescription(store) {
        assert(store, 'Cannot fetch description for nonexistent store');
        return this.storeDescriptions.get(store) || store.description;
    }
    getVersionByStore({ includeArc = true, includeContext = false }) {
        const versionById = {};
        if (includeArc) {
            this.storesById.forEach((handle, id) => versionById[id] = handle.version);
        }
        if (includeContext) {
            this._context.allStores.forEach(handle => versionById[handle.id] = handle.version);
        }
        return versionById;
    }
    keyForId(id) {
        return this.storageKeys[id];
    }
    toContextString() {
        const results = [];
        const stores = [...this.storesById.values()].sort(compareComparables);
        stores.forEach(store => {
            results.push(store.toString([...this.storeTags.get(store)]));
        });
        // TODO: include stores entities
        // TODO: include (remote) slots?
        if (!this._activeRecipe.isEmpty()) {
            results.push(this._activeRecipe.toString());
        }
        return results.join('\n');
    }
    get apiChannelMappingId() {
        return this.id.toString();
    }
    get idGeneratorForTesting() {
        return this.idGenerator;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class RuntimeCacheService {
    constructor() {
        this.map = new Map();
        this.nextID = 0;
    }
    getOrCreateCache(name) {
        if (!this.map.has(name)) {
            this.map.set(name, new Map());
        }
        return this.map.get(name);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];
class JsonldToManifest {
    static convert(jsonld, theClass = undefined) {
        const obj = JSON.parse(jsonld);
        const classes = {};
        const properties = {};
        if (!obj['@graph']) {
            obj['@graph'] = [obj];
        }
        for (const item of obj['@graph']) {
            if (item['@type'] === 'rdf:Property') {
                properties[item['@id']] = item;
            }
            else if (item['@type'] === 'rdfs:Class') {
                classes[item['@id']] = item;
                item['subclasses'] = [];
                item['superclass'] = null;
            }
        }
        for (const clazz of Object.values(classes)) {
            if (clazz['rdfs:subClassOf'] !== undefined) {
                if (clazz['rdfs:subClassOf'].length == undefined) {
                    clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];
                }
                for (const subClass of clazz['rdfs:subClassOf']) {
                    const superclass = subClass['@id'];
                    if (clazz['superclass'] == undefined) {
                        clazz['superclass'] = [];
                    }
                    if (classes[superclass]) {
                        classes[superclass].subclasses.push(clazz);
                        clazz['superclass'].push(classes[superclass]);
                    }
                    else {
                        clazz['superclass'].push({ '@id': superclass });
                    }
                }
            }
        }
        for (const clazz of Object.values(classes)) {
            if (clazz['subclasses'].length === 0 && theClass == undefined) {
                theClass = clazz;
            }
        }
        const relevantProperties = [];
        for (const property of Object.values(properties)) {
            let domains = property['schema:domainIncludes'];
            if (!domains) {
                domains = { '@id': theClass['@id'] };
            }
            if (!domains.length) {
                domains = [domains];
            }
            domains = domains.map(a => a['@id']);
            if (domains.includes(theClass['@id'])) {
                const name = property['@id'].split(':')[1];
                let type = property['schema:rangeIncludes'];
                if (!type) {
                    console.log(property);
                }
                if (!type.length) {
                    type = [type];
                }
                type = type.map(a => a['@id'].split(':')[1]);
                type = type.filter(type => supportedTypes.includes(type));
                if (type.length > 0) {
                    relevantProperties.push({ name, type });
                }
            }
        }
        const className = theClass['@id'].split(':')[1];
        const superNames = theClass && theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];
        let s = '';
        for (const superName of superNames) {
            s += `import 'https://schema.org/${superName}'\n\n`;
        }
        s += `schema ${className}`;
        if (superNames.length > 0) {
            s += ` extends ${superNames.join(', ')}`;
        }
        if (relevantProperties.length > 0) {
            for (const property of relevantProperties) {
                let type;
                if (property.type.length > 1) {
                    type = '(' + property.type.join(' or ') + ')';
                }
                else {
                    type = property.type[0];
                }
                s += `\n  ${type} ${property.name}`;
            }
        }
        s += '\n';
        return s;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const nob = () => Object.create(null);

const debounce = (key, action, delay) => {
  if (key) {
    clearTimeout(key);
  }
  if (action && delay) {
    return setTimeout(action, delay);
  }
};

const XenStateMixin = Base => class extends Base {
  constructor() {
    super();
    this._pendingProps = nob();
    this._props = this._getInitialProps() || nob();
    this._lastProps = nob();
    this._state = this._getInitialState() || nob();
    this._lastState = nob();
  }
  _getInitialProps() {
  }
  _getInitialState() {
  }
  _getProperty(name) {
    return this._pendingProps[name] || this._props[name];
  }
  _setProperty(name, value) {
    // dirty checking opportunity
    if (this._validator || this._wouldChangeProp(name, value)) {
      this._pendingProps[name] = value;
      this._invalidateProps();
    }
  }
  _wouldChangeValue(map, name, value) {
    // Important dirty-checking behavior controlled here,
    // can be overridden.
    // The default implementation will use strict reference checking.
    // To modify structured values one must create a new Object to
    // replace the old one.
    return (map[name] !== value);
    // an example of dirty-checking that instead simply punts on structured data
    //return (typeof value === 'object') || (map[name] !== value);
  }
  _wouldChangeProp(name, value) {
    return this._wouldChangeValue(this._props, name, value);
  }
  _wouldChangeState(name, value) {
    return this._wouldChangeValue(this._state, name, value);
  }
  _setProps(props) {
    // TODO(sjmiles): should be a replace instead of a merge?
    Object.assign(this._pendingProps, props);
    this._invalidateProps();
  }
  _invalidateProps() {
    this._propsInvalid = true;
    this._invalidate();
  }
  _setState(object) {
    let dirty = false;
    const state = this._state;
    for (const property in object) {
      const value = object[property];
      if (this._wouldChangeState(property, value)) {
        dirty = true;
        state[property] = value;
      }
    }
    if (dirty) {
      this._invalidate();
      return true;
    }
  }
  _async(fn) {
    return Promise.resolve().then(fn.bind(this));
  }
  _invalidate() {
    if (!this._validator) {
      this._validator = this._async(this._validate);
    }
  }
  _getStateArgs() {
    return [this._props, this._state, this._lastProps, this._lastState];
  }
  _validate() {
    const stateArgs = this._getStateArgs();
    // try..catch to ensure we nullify `validator` before return
    try {
      // TODO(sjmiles): should be a replace instead of a merge
      Object.assign(this._props, this._pendingProps);
      if (this._propsInvalid) {
        // TODO(sjmiles): should/can have different timing from rendering?
        this._willReceiveProps(...stateArgs);
        this._propsInvalid = false;
      }
      if (this._shouldUpdate(...stateArgs)) {
        // TODO(sjmiles): consider throttling update to rAF
        this._ensureMount();
        this._doUpdate(...stateArgs);
      }
    } catch (x) {
      console.error(x);
    }
    // nullify validator _after_ methods so state changes don't reschedule validation
    this._validator = null;
    // save the old props and state
    this._lastProps = Object.assign(nob(), this._props);
    this._lastState = Object.assign(nob(), this._state);
  }
  _doUpdate(...stateArgs) {
    this._update(...stateArgs);
    this._didUpdate(...stateArgs);
  }
  _ensureMount() {
  }
  _willReceiveProps() {
  }
  _shouldUpdate() {
    return true;
  }
  _update() {
  }
  _didUpdate() {
  }
  _debounce(key, func, delay) {
    key = `_debounce_${key}`;
    this._state[key] = debounce(this._state[key], func, delay != null ? delay : 16);
  }
};

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Particle that interoperates with DOM.
 */
class DomParticleBase extends Particle$1 {
    /**
     * Override to return a String defining primary markup.
     */
    get template() {
        return '';
    }
    /**
     * Override to return a String defining primary markup for the given slot name.
     */
    getTemplate(slotName) {
        // TODO: only supports a single template for now. add multiple templates support.
        return this.template;
    }
    /**
     * Override to return a String defining the name of the template for the given slot name.
     */
    getTemplateName(slotName) {
        // TODO: only supports a single template for now. add multiple templates support.
        return `default`;
    }
    /**
     * Override to return false if the Particle won't use it's slot.
     */
    shouldRender(stateArgs) {
        return true;
    }
    /**
     * Override to return a dictionary to map into the template.
     */
    render(stateArgs) {
        return {};
    }
    renderSlot(slotName, contentTypes) {
        const stateArgs = this._getStateArgs();
        const slot = this.getSlot(slotName);
        if (!slot) {
            return; // didn't receive StartRender.
        }
        // Set this to support multiple slots consumed by a particle, without needing
        // to pass slotName to particle's render method, where it useless in most cases.
        this.currentSlotName = slotName;
        contentTypes.forEach(ct => slot.requestedContentTypes.add(ct));
        // TODO(sjmiles): redundant, same answer for every slot
        if (this.shouldRender(...stateArgs)) {
            const content = {};
            if (slot.requestedContentTypes.has('template')) {
                content.template = this.getTemplate(slot.slotName);
            }
            if (slot.requestedContentTypes.has('model')) {
                content.model = this.render(...stateArgs);
            }
            content.templateName = this.getTemplateName(slot.slotName);
            // Backwards-compatibility and convenience code:
            //  - Rewrites slotid="slotName" to slotid$="{{$slotName}}" in templates.
            //  - Enhances the model with `$slotName` fields.
            if (slot.providedSlots.size > 0) {
                if (content.template) {
                    if (typeof content.template === 'string') {
                        content.template = this.slotNamesToModelReferences(slot, content.template);
                    }
                    else {
                        content.template = Object.entries(content.template).reduce((templateDictionary, [templateName, templateValue]) => {
                            templateDictionary[templateName] = this.slotNamesToModelReferences(slot, templateValue);
                            return templateDictionary;
                        }, {});
                    }
                }
                if (content.model) {
                    const slotIDs = {};
                    slot.providedSlots.forEach((slotId, slotName) => slotIDs[`$${slotName}`] = slotId);
                    content.model = this.enhanceModelWithSlotIDs(content.model, slotIDs);
                }
            }
            slot.render(content);
        }
        else if (slot.isRendered) {
            // Send empty object, to clear rendered slot contents.
            slot.render({});
        }
        this.currentSlotName = undefined;
    }
    slotNamesToModelReferences(slot, template) {
        slot.providedSlots.forEach((slotId, slotName) => {
            // TODO: This is a simple string replacement right now,
            // ensuring that 'slotid' is an attribute on an HTML element would be an improvement.
            // TODO(sjmiles): clone original id as `slotname` for human readability
            template = template.replace(new RegExp(`slotid="${slotName}"`, 'gi'), `slotname="${slotName}" slotid$="{{$${slotName}}}"`);
        });
        return template;
    }
    // We put slot IDs at the top-level of the model as well as in models for sub-templates.
    // This is temporary and should go away when we move from sub-IDs to [(Entity, Slot)] constructs.
    enhanceModelWithSlotIDs(model, slotIDs, topLevel = true) {
        if (topLevel) {
            model = { ...slotIDs, ...model };
        }
        if (model.hasOwnProperty('$template') && model.hasOwnProperty('models') && Array.isArray(model['models'])) {
            model['models'] = model['models'].map(m => this.enhanceModelWithSlotIDs(m, slotIDs));
        }
        for (const [key, value] of Object.entries(model)) {
            if (!!value && typeof value === 'object') {
                model[key] = this.enhanceModelWithSlotIDs(value, slotIDs, false);
            }
        }
        return model;
    }
    _getStateArgs() {
        return [];
    }
    forceRenderTemplate(slotName = '') {
        this.slotProxiesByName.forEach((slot, name) => {
            if (!slotName || (name === slotName)) {
                slot.requestedContentTypes.add('template');
            }
        });
    }
    fireEvent(slotName, { handler, data }) {
        if (this[handler]) {
            this[handler]({ data });
        }
    }
    async setParticleDescription(pattern) {
        if (typeof pattern === 'string') {
            return super.setParticleDescription(pattern);
        }
        if (pattern.template && pattern.model) {
            await super.setDescriptionPattern('_template_', pattern.template);
            await super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));
            return undefined;
        }
        else {
            throw new Error('Description pattern must either be string or have template and model');
        }
    }
    /**
     * Remove all entities from named handle.
     */
    async clearHandle(handleName) {
        const handle = this.handles.get(handleName);
        if (handle instanceof Singleton || handle instanceof Collection) {
            await handle.clear();
        }
        else {
            throw new Error('Singleton/Collection required');
        }
    }
    /**
     * Merge entities from Array into named handle.
     */
    async mergeEntitiesToHandle(handleName, entities) {
        const idMap = {};
        const handle = this.handles.get(handleName);
        if (handle instanceof Collection) {
            const handleEntities = await handle.toList();
            handleEntities.forEach(entity => idMap[entity.id] = entity);
            for (const entity of entities) {
                if (!idMap[this.idFor(entity)]) {
                    await handle.store(entity);
                }
            }
        }
        else {
            throw new Error('Collection required');
        }
    }
    /**
     * Append entities from Array to named handle.
     */
    async appendEntitiesToHandle(handleName, entities) {
        const handle = this.handles.get(handleName);
        if (handle) {
            if (handle instanceof Collection || handle instanceof BigCollection) {
                await Promise.all(entities.map(entity => handle.store(entity)));
            }
            else {
                throw new Error('Collection required');
            }
        }
    }
    /**
     * Create an entity from each rawData, and append to named handle.
     */
    async appendRawDataToHandle(handleName, rawDataArray) {
        const handle = this.handles.get(handleName);
        if (handle && handle.entityClass) {
            if (handle instanceof Collection || handle instanceof BigCollection) {
                const entityClass = handle.entityClass;
                await Promise.all(rawDataArray.map(raw => handle.store(new entityClass(raw))));
            }
            else {
                throw new Error('Collection required');
            }
        }
    }
    /**
     * Modify value of named handle. A new entity is created
     * from `rawData` (`new [EntityClass](rawData)`).
     */
    async updateSingleton(handleName, rawData) {
        const handle = this.handles.get(handleName);
        if (handle && handle.entityClass) {
            if (handle instanceof Singleton) {
                const entity = new handle.entityClass(rawData);
                await handle.set(entity);
                return entity;
            }
            else {
                throw new Error('Singleton required');
            }
        }
        return undefined;
    }
    /**
     * Modify or insert `entity` into named handle.
     * Modification is done by removing the old entity and reinserting the new one.
     */
    async updateCollection(handleName, entity) {
        // Set the entity into the right place in the set. If we find it
        // already present replace it, otherwise, add it.
        // TODO(dstockwell): Replace this with happy entity mutation approach.
        const handle = this.handles.get(handleName);
        if (handle) {
            if (handle instanceof Collection || handle instanceof BigCollection) {
                await handle.remove(entity);
                await handle.store(entity);
            }
            else {
                throw new Error('Collection required');
            }
        }
    }
    /**
     * Return array of Entities dereferenced from array of Share-Type Entities
     */
    async derefShares(shares) {
        let entities = [];
        this.startBusy();
        try {
            const derefPromises = shares.map(async (share) => share.ref.dereference());
            entities = await Promise.all(derefPromises);
        }
        finally {
            this.doneBusy();
        }
        return entities;
    }
    /**
     * Returns array of Entities found in BOXED data `box` that are owned by `userid`
     */
    async boxQuery(box, userid) {
        if (!box) {
            return [];
        }
        else {
            const matches = box.filter(item => userid === item.fromKey);
            return await this.derefShares(matches);
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Particle that interoperates with DOM and uses a simple state system
 * to handle updates.
 */
class DomParticle extends XenStateMixin(DomParticleBase) {
    /**
     * Override if necessary, to do things when props change.
     */
    willReceiveProps(...args) {
    }
    /**
     * Override if necessary, to modify superclass config.
     */
    update(...args) {
    }
    /**
     * Override to return false if the Particle won't use
     * it's slot.
     */
    shouldRender(...args) {
        return true;
    }
    /**
     * Override to return a dictionary to map into the template.
     */
    render(...args) {
        return {};
    }
    /**
     * Copy values from `state` into the particle's internal state,
     * triggering an update cycle unless currently updating.
     */
    setState(state) {
        return this._setState(state);
    }
    /**
     * Getters and setters for working with state/props.
     */
    get state() {
        return this._state;
    }
    /**
     * Syntactic sugar: `this.state = {state}` is equivalent to `this.setState(state)`.
     */
    set state(state) {
        this.setState(state);
    }
    get props() {
        return this._props;
    }
    /**
     * Override if necessary, to modify superclass config.
     */
    get config() {
        // TODO(sjmiles): getter that does work is a bad idea, this is temporary
        return {
            handleNames: this.spec.inputs.map(i => i.name),
            // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from
            // .arcs files, instead of .ptcl ones.
            slotNames: this.spec.slandleConnectionNames()
        };
    }
    // affordances for aliasing methods to remove `_`
    _willReceiveProps(...args) {
        this.willReceiveProps(...args);
    }
    _update(...args) {
        this.update(...args);
        if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?
            this.relevance = 1; // TODO: improve relevance signal.
        }
        this.config.slotNames.forEach(s => this.renderSlot(s, ['model']));
    }
    _async(fn) {
        // asynchrony in Particle code must be bookended with start/doneBusy
        this.startBusy();
        const done = () => {
            try {
                fn.call(this);
            }
            finally {
                this.doneBusy();
            }
        };
        // TODO(sjmiles): superclass uses Promise.resolve(),
        // but here use a short timeout for a wider debounce
        return setTimeout(done, 10);
    }
    async setHandles(handles) {
        this.configureHandles(handles);
        this.handles = handles;
        // TODO(sjmiles): we must invalidate at least once, is there a way to know
        // whether handleSync/update will be called?
        this._invalidate();
    }
    /**
     * This is called once during particle setup. Override to control sync and update
     * configuration on specific handles (via their configure() method).
     * `handles` is a map from names to handle instances.
     */
    configureHandles(handles) {
        // Example: handles.get('foo').configure({keepSynced: false});
    }
    async onHandleSync(handle, model) {
        this._setProperty(handle.name, model);
    }
    async onHandleUpdate({ name }, { data, added, removed }) {
        if (data !== undefined) {
            //console.log('update.data:', JSON.stringify(data, null, '  '));
            this._setProps({ [name]: data });
        }
        if (added) {
            //console.log('update.added:', JSON.stringify(added, null, '  '));
            const prop = (this.props[name] || []).concat(added);
            // TODO(sjmiles): generally improper to set `this._props` directly, this is a special case
            this._props[name] = prop;
            this._setProps({ [name]: prop });
        }
        if (removed) {
            //console.log('update.removed:', JSON.stringify(removed, null, '  '));
            const prop = this.props[name];
            if (Array.isArray(prop)) {
                removed.forEach(removed => {
                    // TODO(sjmiles): linear search is inefficient
                    const index = prop.findIndex(entry => this.idFor(entry) === this.idFor(removed));
                    if (index >= 0) {
                        prop.splice(index, 1);
                    }
                    else {
                        console.warn(`dom-particle::onHandleUpdate: couldn't find item to remove`);
                    }
                });
                this._setProps({ [name]: prop });
            }
        }
    }
    fireEvent(slotName, { handler, data }) {
        if (this[handler]) {
            // TODO(sjmiles): remove `this._state` parameter
            this[handler]({ data }, this._state);
        }
    }
    debounce(key, func, delay) {
        const subkey = `_debounce_${key}`;
        const state = this.state;
        if (!state[subkey]) {
            state[subkey] = true;
            this.startBusy();
        }
        const idleThenFunc = () => {
            this.doneBusy();
            func();
            state[subkey] = null;
        };
        // TODO(sjmiles): rewrite Xen debounce so caller has idle control
        super._debounce(key, idleThenFunc, delay);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Particle that does transformation stuff with DOM.
 */
class TransformationDomParticle extends DomParticle {
    getTemplate(slotName) {
        // TODO: add support for multiple slots.
        return this._state.template;
    }
    getTemplateName(slotName) {
        // TODO: add support for multiple slots.
        return this._state.templateName;
    }
    render(props, state) {
        return state.renderModel;
    }
    shouldRender(props, state) {
        return Boolean((state.template || state.templateName) && state.renderModel);
    }
    renderHostedSlot(slotName, hostedSlotId, content) {
        this.combineHostedTemplate(slotName, hostedSlotId, content);
        this.combineHostedModel(slotName, hostedSlotId, content);
    }
    // abstract
    combineHostedTemplate(slotName, hostedSlotId, content) {
    }
    combineHostedModel(slotName, hostedSlotId, content) {
    }
    // Helper methods that may be reused in transformation particles to combine hosted content.
    static propsToItems(propsValues) {
        return propsValues ? propsValues.map(e => ({ subId: Entity.id(e), ...e })) : [];
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class MultiplexerDomParticle extends TransformationDomParticle {
    constructor() {
        super(...arguments);
        this._itemSubIdByHostedSlotId = new Map();
        this._connByHostedConn = new Map();
    }
    async _mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc) {
        const otherMappedHandles = [];
        const otherConnections = [];
        let index = 2;
        const skipConnectionNames = [listHandleName, particleHandleName];
        for (const [connectionName, otherHandle] of handles) {
            if (skipConnectionNames.includes(connectionName)) {
                continue;
            }
            // TODO(wkorman): For items with embedded recipes we may need a map
            // (perhaps id to index) to make sure we don't map a handle into the inner
            // arc multiple times unnecessarily.
            // TODO(lindner): type erasure to avoid mismatch of Store vs Handle in arc.mapHandle
            // tslint:disable-next-line: no-any
            const otherHandleStore = otherHandle.storage;
            otherMappedHandles.push(`use '${await arc.mapHandle(otherHandleStore)}' as v${index}`);
            const hostedOtherConnection = hostedParticle.handleConnections.find(conn => conn.isCompatibleType(otherHandle.type));
            if (hostedOtherConnection) {
                otherConnections.push(`${hostedOtherConnection.name} = v${index++}`);
                // TODO(wkorman): For items with embedded recipes where we may have a
                // different particle rendering each item, we need to track
                // |connByHostedConn| keyed on the particle type.
                this._connByHostedConn.set(hostedOtherConnection.name, connectionName);
            }
        }
        return [otherMappedHandles, otherConnections];
    }
    async setHandles(handles) {
        this.handleIds = {};
        const arc = await this.constructInnerArc();
        const listHandleName = 'list';
        const particleHandleName = 'hostedParticle';
        const particleHandle = handles.get(particleHandleName);
        let hostedParticle = null;
        let otherMappedHandles = [];
        let otherConnections = [];
        if (particleHandle) {
            // Typecast to any; the get() method doesn't exist on raw Handles.
            // tslint:disable-next-line: no-any
            hostedParticle = await particleHandle.get();
            if (hostedParticle) {
                [otherMappedHandles, otherConnections] =
                    await this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc);
            }
        }
        this.setState({
            arc,
            type: handles.get(listHandleName).type,
            hostedParticle,
            otherMappedHandles,
            otherConnections
        });
        await super.setHandles(handles);
    }
    async update({ list }, { arc, type, hostedParticle, otherMappedHandles, otherConnections }, oldProps, oldState) {
        //console.warn(`[${this.spec.name}]::update`, list, arc);
        if (!list || !arc) {
            return;
        }
        if (oldProps.list === list && oldState.arc === arc) {
            return;
        }
        if (list.length > 0) {
            this.relevance = 0.1;
        }
        for (const [index, item] of this.getListEntries(list)) {
            let resolvedHostedParticle = hostedParticle;
            const id = Entity.id(item);
            if (this.handleIds[id]) {
                const itemHandle = await this.handleIds[id];
                // tslint:disable-next-line: no-any
                itemHandle.set(item);
                continue;
            }
            const itemHandlePromise = arc.createHandle(type.getContainedType(), `item${index}`);
            this.handleIds[id] = itemHandlePromise;
            const itemHandle = await itemHandlePromise;
            if (!resolvedHostedParticle) {
                // If we're muxing on behalf of an item with an embedded recipe, the
                // hosted particle should be retrievable from the item itself. Else we
                // just skip this item.
                if (!item.renderParticleSpec) {
                    continue;
                }
                resolvedHostedParticle =
                    ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));
                // Re-map compatible handles and compute the connections specific
                // to this item's render particle.
                const listHandleName = 'list';
                const particleHandleName = 'renderParticle';
                [otherMappedHandles, otherConnections] =
                    await this._mapParticleConnections(listHandleName, particleHandleName, resolvedHostedParticle, this.handles, arc);
            }
            // TODO(jopra): Using the [0] item may not be desired.
            const hostedSlotName = resolvedHostedParticle.slandleConnectionNames()[0];
            const slotNames = this.spec.slandleConnectionNames();
            assert(slotNames.length > 0, 'there must be at least one slot');
            // TODO(jopra): Using the [0] item may not be desired.
            const slotName = slotNames[0];
            const slotId = await arc.createSlot(this, slotName, itemHandle._id);
            if (!slotId) {
                continue;
            }
            this._itemSubIdByHostedSlotId.set(slotId, id);
            try {
                const recipe = this.constructInnerRecipe(resolvedHostedParticle, item, itemHandle, { name: hostedSlotName, id: slotId }, { connections: otherConnections, handles: otherMappedHandles });
                await arc.loadRecipe(recipe);
                // tslint:disable-next-line: no-any
                itemHandle.set(item);
            }
            catch (e) {
                console.log(e);
            }
        }
    }
    combineHostedModel(slotName, hostedSlotId, content) {
        const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);
        if (!subId) {
            return;
        }
        const items = this._state.renderModel ? this._state.renderModel.items : [];
        const listIndex = items.findIndex(item => item.subId === subId);
        const item = { ...content.model, subId };
        if (listIndex >= 0 && listIndex < items.length) {
            items[listIndex] = item;
        }
        else {
            items.push(item);
        }
        this.setState({ renderModel: { items } });
    }
    combineHostedTemplate(slotName, hostedSlotId, content) {
        const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);
        if (!subId) {
            return;
        }
        assert(content.templateName, `Template name is missing for slot '${slotName}' (hosted slot ID: '${hostedSlotId}')`);
        const templateName = { ...this._state.templateName, [subId]: `${content.templateName}` };
        this.setState({ templateName });
        if (content.template) {
            let template = content.template;
            // Append subid$={{subid}} attribute to all provided slots, to make it usable for the transformation particle.
            template = template.replace(new RegExp('slotid="[a-z]+"', 'gi'), '$& subid$="{{subId}}"');
            // Replace hosted particle connection in template with the corresponding particle connection names.
            // TODO: make this generic!
            this._connByHostedConn.forEach((conn, hostedConn) => {
                template = template.replace(new RegExp(`{{${hostedConn}.description}}`, 'g'), `{{${conn}.description}}`);
            });
            this.setState({ template: { ...this._state.template, [content.templateName]: template } });
            this.forceRenderTemplate();
        }
    }
    // Called with the list of items and by default returns the direct result of
    // `Array.entries()`. Subclasses can override this method to alter the item
    // order or otherwise permute the items as desired before their slots are
    // created and contents are rendered.
    // tslint:disable-next-line: no-any
    getListEntries(list) {
        return list.entries();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();
class Loader {
    path(fileName) {
        return fileName.replace(/[/][^/]+$/, '/');
    }
    join(prefix, path) {
        if (/^https?:\/\//.test(path)) {
            return path;
        }
        // TODO: replace this with something that isn't hacky
        if (path[0] === '/' || path[1] === ':') {
            return path;
        }
        prefix = this.path(prefix);
        path = this.normalizeDots(`${prefix}${path}`);
        return path;
    }
    // convert `././foo/bar/../baz` to `./foo/baz`
    normalizeDots(path) {
        // only unix slashes
        path = path.replace(/\\/g, '/');
        // remove './'
        path = path.replace(/\/\.\//g, '/');
        // remove 'foo/..'
        const norm = s => s.replace(/(?:^|\/)[^./]*\/\.\./g, '');
        for (let n = norm(path); n !== path; path = n, n = norm(path))
            ;
        // remove '//' except after `:`
        path = path.replace(/([^:])(\/\/)/g, '$1/');
        return path;
    }
    async loadResource(file) {
        if (/^https?:\/\//.test(file)) {
            return this._loadURL(file);
        }
        return this.loadFile(file, 'utf-8');
    }
    async loadWasmBinary(spec) {
        // TODO: use spec.implBlobUrl if present?
        this.mapParticleUrl(spec.implFile);
        const target = this.resolve(spec.implFile);
        if (/^https?:\/\//.test(target)) {
            return fetch(target).then(res => res.arrayBuffer());
        }
        else {
            return this.loadFile(target);
        }
    }
    mapParticleUrl(path) { }
    resolve(path) {
        return path;
    }
    async loadFile(file, encoding) {
        return new Promise((resolve, reject) => {
            fs.readFile(file, { encoding }, (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(encoding ? data : data.buffer);
                }
            });
        });
    }
    async _loadURL(url) {
        const fetcher = (url) => fetch(url).then(async (res) => res.ok ? res.text() : Promise.reject(new Error(`HTTP ${res.status}: ${res.statusText}`)));
        if (/\/\/schema.org\//.test(url)) {
            if (url.endsWith('/Thing')) {
                return fetcher('https://schema.org/Product.jsonld').then(data => JsonldToManifest.convert(data, { '@id': 'schema:Thing' }));
            }
            return fetcher(url + '.jsonld').then(data => JsonldToManifest.convert(data));
        }
        return fetcher(url);
    }
    /**
     * Returns a particle class implementation by loading and executing
     * the code defined by a particle.  In the following example `x.js`
     * will be loaded and executed:
     *
     * ```
     * Particle foo in 'x.js'
     * ```
     */
    async loadParticleClass(spec) {
        const clazz = await this.requireParticle(spec.implFile);
        clazz.spec = spec;
        return clazz;
    }
    /**
     * Loads a particle class from the given filename by loading the
     * script contained in `fileName` and executing it as a script.
     *
     * Protected for use in tests.
     */
    async requireParticle(fileName) {
        if (fileName === null)
            fileName = '';
        const src = await this.loadResource(fileName);
        // Note. This is not real isolation.
        const script = new vm.Script(src, { filename: fileName, displayErrors: true });
        const result = [];
        // TODO(lindner): restrict Math.random here.
        const self = {
            defineParticle(particleWrapper) {
                result.push(particleWrapper);
            },
            console,
            fetch,
            setTimeout,
            importScripts: s => null //console.log(`(skipping browser-space import for [${s}])`)
        };
        script.runInNewContext(self, { filename: fileName, displayErrors: true });
        assert(result.length > 0 && typeof result[0] === 'function', `Error while instantiating particle implementation from ${fileName}`);
        return this.unwrapParticle(result[0]);
    }
    setParticleExecutionContext(pec) {
        this.pec = pec;
    }
    /**
     * executes the defineParticle() code and returns the results which should be a class definition.
     */
    unwrapParticle(particleWrapper) {
        assert(this.pec);
        return particleWrapper({ Particle: Particle$1, DomParticle, TransformationDomParticle, MultiplexerDomParticle, Reference: ClientReference.newClientReference(this.pec), html });
    }
    clone() {
        return new Loader();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class DescriptionDomFormatter extends DescriptionFormatter {
    constructor() {
        super(...arguments);
        this.nextID = 0;
    }
    _isSelectedDescription(desc) {
        return super._isSelectedDescription(desc) || (!!desc.template && !!desc.model);
    }
    _combineSelectedDescriptions(selectedDescriptions, options) {
        const suggestionByParticleDesc = new Map();
        for (const particleDesc of selectedDescriptions) {
            if (this.seenParticles.has(particleDesc._particle)) {
                continue;
            }
            let { template, model } = this._retrieveTemplateAndModel(particleDesc, suggestionByParticleDesc.size, options || {});
            const success = Object.keys(model).map(tokenKey => {
                const tokens = this._initSubTokens(model[tokenKey], particleDesc);
                return tokens.map(token => {
                    const tokenValue = this.tokenToString(token);
                    if (tokenValue == undefined) {
                        return false;
                    }
                    else if (tokenValue && tokenValue.template && tokenValue.model) {
                        // Dom token.
                        template = template.replace(`{{${tokenKey}}}`, tokenValue.template);
                        delete model[tokenKey];
                        model = { ...model, ...tokenValue.model };
                    }
                    else { // Text token.
                        // Replace tokenKey, in case multiple selected suggestions use the same key.
                        const newTokenKey = `${tokenKey}${++this.nextID}`;
                        template = template.replace(`{{${tokenKey}}}`, `{{${newTokenKey}}}`);
                        delete model[tokenKey];
                        model[newTokenKey] = tokenValue;
                    }
                    return true;
                }).every(t => !!t);
            });
            if (success.every(s => !!s)) {
                suggestionByParticleDesc.set(particleDesc, { template, model });
            }
        }
        // Populate suggestions list while maintaining original particles order.
        const suggestions = [];
        selectedDescriptions.forEach(desc => {
            if (suggestionByParticleDesc.has(desc)) {
                suggestions.push(suggestionByParticleDesc.get(desc));
            }
        });
        if (suggestions.length > 0) {
            const result = this._joinDescriptions(suggestions);
            if (!options || !options.skipFormatting) {
                result.template += '.';
            }
            return result;
        }
    }
    _retrieveTemplateAndModel(particleDesc, index, options) {
        if (particleDesc['_template_'] && particleDesc['_model_']) {
            return {
                template: particleDesc['_template_'],
                model: JSON.parse(particleDesc['_model_'])
            };
        }
        assert(particleDesc.pattern, 'Description must contain template and model, or pattern');
        let template = '';
        const model = {};
        const tokens = this._initTokens(particleDesc.pattern, particleDesc);
        tokens.forEach((token, i) => {
            if (token.text) {
                template = template.concat(`${(index === 0 && i === 0 && !options.skipFormatting) ? token.text[0].toUpperCase() + token.text.slice(1) : token.text}`);
            }
            else { // handle or slot handle.
                const sanitizedFullName = token.fullName.replace(/[.{}_$]/g, '');
                let attribute = '';
                // TODO(mmandlis): capitalize the data in the model instead.
                if (i === 0 && !options.skipFormatting) {
                    // Capitalize the first letter in the token.
                    template = template.concat(`<style>
            [firstletter]::first-letter { text-transform: capitalize; }
            [firstletter] {display: inline-block}
            </style>`);
                    attribute = ' firstletter';
                }
                template = template.concat(`<span${attribute}>{{${sanitizedFullName}}}</span>`);
                model[sanitizedFullName] = token.fullName;
            }
        });
        return { template, model };
    }
    _capitalizeAndPunctuate(sentence) {
        if (typeof sentence === 'string') {
            return { template: super._capitalizeAndPunctuate(sentence), model: {} };
        }
        // Capitalize the first element in the DOM template.
        const tokens = sentence.template.match(/<[a-zA-Z0-9]+>{{([a-zA-Z0-9]*)}}<\/[a-zA-Z0-9]+>/);
        if (tokens && tokens.length > 1 && sentence.model[tokens[1]]) {
            const modelToken = sentence.model[tokens[1]];
            if (modelToken.length > 0) {
                sentence.model[tokens[1]] = `${modelToken[0].toUpperCase()}${modelToken.substr(1)}`;
            }
        }
        sentence.template += '.';
        return sentence;
    }
    _joinDescriptions(descs) {
        // If all tokens are strings, just join them.
        if (descs.every(desc => typeof desc === 'string')) {
            return super._joinDescriptions(descs);
        }
        const result = { template: '', model: {} };
        const count = descs.length;
        descs.forEach((desc, i) => {
            if (typeof desc === 'string') {
                desc = { template: desc, model: {} };
            }
            result.template += desc.template;
            result.model = { ...result.model, ...desc.model };
            let delim;
            if (i < count - 2) {
                delim = ', ';
            }
            else if (i === count - 2) {
                delim = ['', '', ' and ', ', and '][Math.min(3, count)];
            }
            if (delim) {
                result.template += delim;
            }
        });
        return result;
    }
    _joinTokens(tokens) {
        // If all tokens are strings, just join them.
        if (tokens.every(token => typeof token === 'string')) {
            return super._joinTokens(tokens);
        }
        tokens = tokens.map(token => {
            if (typeof token !== 'object') {
                return {
                    template: `<span>{{text${++this.nextID}}}</span>`,
                    model: { [`text${this.nextID}`]: token }
                };
            }
            return token;
        });
        const nonEmptyTokens = tokens.filter(token => token && !!token.template && !!token.model);
        return {
            template: nonEmptyTokens.map(token => token.template).join(''),
            model: nonEmptyTokens.map(token => token.model).reduce((prev, curr) => ({ ...prev, ...curr }), {})
        };
    }
    _combineDescriptionAndValue(token, description, storeValue) {
        if (!!description.template && !!description.model) {
            return {
                template: `${description.template} (${storeValue.template})`,
                model: { ...description.model, ...storeValue.model }
            };
        }
        const descKey = `${token.handleName}Description${++this.nextID}`;
        return {
            template: `<span>{{${descKey}}}</span> (${storeValue.template})`,
            model: { [descKey]: description, ...storeValue.model }
        };
    }
    _formatEntityProperty(handleName, properties, value) {
        const key = `${handleName}${properties.join('')}Value${++this.nextID}`;
        return {
            template: `<b>{{${key}}}</b>`,
            model: { [`${key}`]: value }
        };
    }
    _formatCollection(handleName, values) {
        const handleKey = `${handleName}${++this.nextID}`;
        if (values[0].rawData.name) {
            if (values.length > 2) {
                return {
                    template: `<b>{{${handleKey}FirstName}}</b> plus <b>{{${handleKey}OtherCount}}</b> other items`,
                    model: { [`${handleKey}FirstName`]: values[0].rawData.name, [`${handleKey}OtherCount`]: values.length - 1 }
                };
            }
            return {
                template: values.map((v, i) => `<b>{{${handleKey}${i}}}</b>`).join(', '),
                model: Object.assign({}, ...values.map((v, i) => ({ [`${handleKey}${i}`]: v.rawData.name })))
            };
        }
        return {
            template: `<b>{{${handleKey}Length}}</b> items`,
            model: { [`${handleKey}Length`]: values.length }
        };
    }
    _formatBigCollection(handleName, firstValue) {
        return {
            template: `collection of items like {{${handleName}FirstName}}`,
            model: { [`${handleName}FirstName`]: firstValue.rawData.name }
        };
    }
    _formatSingleton(handleName, value) {
        const formattedValue = super._formatSingleton(handleName, value);
        if (formattedValue) {
            return {
                template: `<b>{{${handleName}Var}}</b>`,
                model: { [`${handleName}Var`]: formattedValue }
            };
        }
        return undefined;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var IconStyles = `
  icon {
    font-family: "Material Icons";
    font-size: 24px;
    font-style: normal;
    -webkit-font-feature-settings: "liga";
    -webkit-font-smoothing: antialiased;
    cursor: pointer;
    user-select: none;
    flex-shrink: 0;
    /* partial FOUC prevention */
    display: inline-block;
    width: 24px;
    height: 24px;
    overflow: hidden;
  }
  icon[hidden] {
    /* required because of display rule above,
    display rule required for overflow: hidden */
    display: none;
  }
`;

/**
 * @license
 * Copyright (c) 2016 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/* Annotator */
// tree walker that generates arbitrary data using visitor function `cb`
// `cb` is called as `cb(node, key, notes)`
// where
//   `node` is a visited node.
//   `key` is a handle which identifies the node in a map generated by `Annotator.locateNodes`.
class Annotator {
  constructor(cb) {
    this.cb = cb;
  }
  // For subtree at `node`, produce annotation object `notes`.
  // the content of `notes` is completely determined by the behavior of the
  // annotator callback function supplied at the constructor.
  annotate(node, notes, opts) {
    this.notes = notes;
    this.opts = opts || 0;
    this.key = this.opts.key || 0;
    notes.locator = this._annotateSubtree(node);
    return notes;
  }
  // walking subtree at `node`
  _annotateSubtree(node) {
    let childLocators;
    for (let i = 0, child = node.firstChild, previous = null, neo; child; i++) {
      // returns a locator only if a node in the subtree requires one
      const childLocator = this._annotateNode(child);
      // only when necessary, maintain a sparse array of locators
      if (childLocator) {
        (childLocators = childLocators || {})[i] = childLocator;
      }
      // `child` may have been evacipated by visitor
      neo = previous ? previous.nextSibling : node.firstChild;
      if (neo === child) {
        previous = child;
        child = child.nextSibling;
      } else {
        child = neo;
        i--;
      }
    }
    // is falsey unless there was at least one childLocator
    return childLocators;
  }
  _annotateNode(node) {
    // visit node
    const key = this.key++;
    const shouldLocate = this.cb(node, key, this.notes, this.opts);
    // recurse
    const locators = this._annotateSubtree(node);
    if (shouldLocate || locators) {
      const cl = Object.create(null);
      cl.key = key;
      if (locators) {
        cl.sub = locators;
      }
      return cl;
    }
  }
}

const locateNodes = function(root, locator, map) {
  map = map || [];
  for (const n in locator) {
    const loc = locator[n];
    if (loc) {
      const node = root.childNodes[n];
      // TODO(sjmiles): text-nodes sometimes evacipate when stamped, so map to the parentElement instead
      map[loc.key] = (node.nodeType === Node.TEXT_NODE) ? node.parentElement : node;
      if (loc.sub) {
        // recurse
        locateNodes(node, loc.sub, map);
      }
    }
  }
  return map;
};

/* Annotation Producer */
// must return `true` for any node whose key we wish to track
const annotatorImpl = function(node, key, notes, opts) {
  let tracking = false;
  // hook
  if (opts.annotator && opts.annotator(node, key, notes, opts)) {
    tracking = true;
  }
  // default
  switch (node.nodeType) {
    case Node.DOCUMENT_FRAGMENT_NODE:
      break;
    case Node.ELEMENT_NODE:
      return tracking || annotateElementNode(node, key, notes);
    case Node.TEXT_NODE:
      return tracking || annotateTextNode(node, key, notes);
  }
  return tracking;
};

const annotateTextNode = function(node, key, notes) {
  if (annotateMustache(node, key, notes, 'textContent', node.textContent)) {
    node.textContent = '';
    return true;
  }
};

const annotateElementNode = function(node, key, notes) {
  if (node.hasAttributes()) {
    let noted = false;
    for (let a$ = node.attributes, i = a$.length - 1, a; i >= 0 && (a = a$[i]); i--) {
      if (
        annotateEvent(node, key, notes, a.name, a.value) ||
        annotateMustache(node, key, notes, a.name, a.value) ||
        annotateDirective(node, key, notes, a.name, a.value)
      ) {
        node.removeAttribute(a.name);
        noted = true;
      }
    }
    return noted;
  }
};

const annotateMustache = function(node, key, notes, property, mustache) {
  if (mustache.slice(0, 2) === '{{') {
    if (property === 'class') {
      property = 'className';
    }
    let value = mustache.slice(2, -2);
    const override = value.split(':');
    if (override.length === 2) {
      property = override[0];
      value = override[1];
    }
    takeNote(notes, key, 'mustaches', property, value);
    if (value[0] === '$') {
      takeNote(notes, 'xlate', value, true);
    }
    return true;
  }
};

const annotateEvent = function(node, key, notes, name, value) {
  if (name.slice(0, 3) === 'on-') {
    if (value.slice(0, 2) === '{{') {
      value = value.slice(2, -2);
      console.warn(
        `Xen: event handler for '${name}' expressed as a mustache, which is not supported. Using literal value '${value}' instead.`
      );
    }
    takeNote(notes, key, 'events', name.slice(3), value);
    return true;
  }
};

const annotateDirective = function(node, key, notes, name, value) {
  if (name === 'xen:forward') {
    takeNote(notes, key, 'events', 'xen:forward', value);
    return true;
  }
};

const takeNote = function(notes, key, group, name, note) {
  const n$ = notes[key] || (notes[key] = Object.create(null));
  (n$[group] || (n$[group] = {}))[name] = note;
};

const annotator = new Annotator(annotatorImpl);

const annotate = function(root, key, opts) {
  return (root._notes ||
    (root._notes = annotator.annotate(root.content, {/*ids:{}*/}, key, opts))
  );
};

/* Annotation Consumer */
const mapEvents = function(notes, map, mapper) {
  // add event listeners
  for (const key in notes) {
    const node = map[key];
    const events = notes[key] && notes[key].events;
    if (node && events) {
      for (const name in events) {
        mapper(node, name, events[name]);
      }
    }
  }
};

const listen = function(controller, node, eventName, handlerName) {
  node.addEventListener(eventName, function(e) {
    if (controller[handlerName]) {
      return controller[handlerName](e, e.detail);
    } else if (controller.defaultHandler) {
      return controller.defaultHandler(handlerName, e);
    }
  });
};

const set$1 = function(notes, map, scope, controller) {
  if (scope) {
    for (const key in notes) {
      const node = map[key];
      if (node) {
        // everybody gets a scope
        node.scope = scope;
        // now get your regularly scheduled bindings
        const mustaches = notes[key].mustaches;
        for (const name in mustaches) {
          const property = mustaches[name];
          if (property in scope) {
            _set(node, name, scope[property], controller);
          }
        }
      }
    }
  }
};

const _set = function(node, property, value, controller) {
  // TODO(sjmiles): the property conditionals here could be precompiled
  const modifier = property.slice(-1);
  if (property === 'style%' || property === 'style' || property === 'xen:style') {
    if (typeof value === 'string') {
      node.style.cssText = value;
    } else {
      Object.assign(node.style, value);
    }
  } else if (modifier == '$') {
    const n = property.slice(0, -1);
    if (typeof value === 'boolean' || value === undefined) {
      setBoolAttribute(node, n, Boolean(value));
    } else {
      node.setAttribute(n, value);
    }
  } else if (property === 'textContent') {
    if (value && (value.$template || value.template)) {
      _setSubTemplate(node, value, controller);
    } else {
      node.textContent = (value || '');
    }
  } else if (property === 'unsafe-html') {
    node.innerHTML = value || '';
  } else if (property === 'value') {
    // TODO(sjmiles): specifically dirty-check `value` to avoid resetting input elements
    if (node.value !== value) {
      node.value = value;
    }
  } else {
    node[property] = value;
  }
};

const setBoolAttribute = function(node, attr, state) {
  node[
    (state === undefined ? !node.hasAttribute(attr) : state)
      ? 'setAttribute'
      : 'removeAttribute'
  ](attr, '');
};

const _setSubTemplate = function(node, value, controller) {
  // TODO(sjmiles): subtemplate iteration ability specially implemented to support arcs (serialization boundary)
  // TODO(sjmiles): Aim to re-implement as a plugin.
  let {template, models} = value;
  if (!template) {
    const container = node.getRootNode();
    template = container.querySelector(`template[${value.$template}]`);
  } else {
    template = maybeStringToTemplate(template);
  }
  _renderSubtemplates(node, controller, template, models);
};

const _renderSubtemplates = function(container, controller, template, models) {
  let child = container.firstElementChild;
  let next;
  if (template && models) {
    models && models.forEach((model, i)=>{
      next = child && child.nextElementSibling;
      // use existing node if possible
      if (!child) {
        const dom = stamp(template).events(controller);
        child = dom.root.firstElementChild;
        if (child) {
          child._subtreeDom = dom;
          container.appendChild(child);
          if (!template._shapeWarning && dom.root.firstElementChild) {
            template._shapeWarning = true;
            console.warn(`xen-template: subtemplate has multiple root nodes: only the first is used.`, template);
          }
        }
      }
      if (child) {
        child._subtreeDom.set(model);
        child = next;
      }
    });
  }
  // remove extra nodes
  while (child) {
    next = child.nextElementSibling;
    child.remove();
    child = next;
  }
};

//window.stampCount = 0;
//window.stampTime = 0;

const stamp = function(template, opts) {
  //const startTime = performance.now();
  //window.stampCount++;
  template = maybeStringToTemplate(template);
  // construct (or use memoized) notes
  const notes = annotate(template, opts);
  // CRITICAL TIMING ISSUE #1:
  // importNode can have side-effects, like CustomElement callbacks (before we
  // can do any work on the imported subtree, before we can mapEvents, e.g.).
  // we could clone into an inert document (say a new template) and process the nodes
  // before importing if necessary.
  const root = document.importNode(template.content, true);
  // templates don't require a single container element, but sometimes they do have one...
  // capture the fire element, because it's harder to find after we insert the nodes into DOM
  const firstElement = root.firstElementChild;
  // map DOM to keys
  const map = locateNodes(root, notes.locator);
  // return dom manager
  const dom = {
    root,
    notes,
    map,
    firstElement,
    $(slctr) {
      return this.root.querySelector(slctr);
    },
    set: function(scope) {
      scope && set$1(notes, map, scope, this.controller);
      return this;
    },
    events: function(controller) {
      // TODO(sjmiles): originally `controller` was expected to be an Object with event handler
      // methods on it (typically a custom-element stamping a template).
      // In Arcs, we want to attach a generic handler (Function) for any event on this node.
      // Subtemplate stamping gets involved because they need to reuse whichever controller.
      // I suspect this can be simplified, but right now I'm just making it go.
      if (controller && typeof controller !== 'function') {
        controller = listen.bind(this, controller);
      }
      this.controller = controller;
      if (controller) {
        mapEvents(notes, map, controller);
      }
      return this;
    },
    // support event-forwarding when stamping descendent template DOM
    // i.e. for objects (say, elements) that consume templates as input
    // see also: support for `xen:forward` attribute above
    forward: function() {
      mapEvents(notes, map, (node, eventName, handlerName) => {
        node.addEventListener(eventName, e => {
          //console.log(`xen::forward: forwarding [${eventName}]`);
          const wrapper = {eventName, handlerName, detail: e.detail, target: e.target};
          fire(node, 'xen:forward', wrapper, {bubbles: true});
        });
      });
      return this;
    },
    appendTo: function(node) {
      if (this.root) {
        // TODO(sjmiles): assumes this.root is a fragment
        node.appendChild(this.root);
      } else {
        console.warn('Xen: cannot appendTo, template stamped no DOM');
      }
      // TODO(sjmiles): this.root is no longer a fragment
      this.root = node;
      return this;
    }
  };
  //window.stampTime += performance.now() - startTime;
  return dom;
};

const fire = (node, eventName, detail, init) => {
  const eventInit = init || {};
  eventInit.detail = detail;
  const event = new CustomEvent(eventName, eventInit);
  node.dispatchEvent(event);
  return event.detail;
};

const maybeStringToTemplate = template => {
  // TODO(sjmiles): need to memoize this somehow
  return (typeof template === 'string') ? createTemplate(template) : template;
};

const createTemplate = innerHTML => {
  return Object.assign(document.createElement('template'), {innerHTML});
};

const Template = {
  createTemplate,
  setBoolAttribute,
  stamp,
  takeNote
};

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Predicates {
}
/** A Predicate that always succeeds */
Predicates.alwaysTrue = () => true;
/** A Predicate that always fails */
Predicates.alwaysFalse = () => false;

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Represents a single slot in the rendering system.
 */
class SlotContext {
    constructor(id, sourceSlotConsumer = null) {
        this.slotConsumers = [];
        this.id = id;
        this.sourceSlotConsumer = sourceSlotConsumer;
    }
    addSlotConsumer(slotConsumer) {
        this.slotConsumers.push(slotConsumer);
        slotConsumer.slotContext = this;
    }
    clearSlotConsumers() {
        this.slotConsumers.forEach(slotConsumer => slotConsumer.slotContext = null);
        this.slotConsumers.length = 0;
    }
}
/**
 * Represents a slot created by a transformation particle in the inner arc.
 *
 * Render calls for that slot are routed to the transformation particle,
 * which receives them as innerArcRender calls.
 *
 * TODO:
 * Today startRender/stopRender calls for particles rendering into this slot are governed by the
 * availability of the container on the transformation particle. This should be optional and only
 * used if the purpose of the innerArc is rendering to the outer arc. It should be possible for
 * the particle which doesn't consume a slot to create an inner arc with hosted slots, which
 * today is not feasible.
 */
class HostedSlotContext extends SlotContext {
    constructor(id, transformationSlotConsumer, storeId) {
        super(id, transformationSlotConsumer);
        this._containerAvailable = false;
        assert(transformationSlotConsumer);
        this.storeId = storeId;
        transformationSlotConsumer.addHostedSlotContexts(this);
    }
    onRenderSlot(consumer, content, handler) {
        this.sourceSlotConsumer.arc.pec.innerArcRender(this.sourceSlotConsumer.consumeConn.particle, this.sourceSlotConsumer.consumeConn.name, this.id, consumer.formatHostedContent(content));
    }
    addSlotConsumer(consumer) {
        super.addSlotConsumer(consumer);
        if (this.containerAvailable)
            consumer.startRender();
    }
    get containerAvailable() { return this._containerAvailable; }
    set containerAvailable(containerAvailable) {
        if (this._containerAvailable === containerAvailable)
            return;
        this._containerAvailable = containerAvailable;
        for (const consumer of this.slotConsumers) {
            if (containerAvailable) {
                consumer.startRender();
            }
            else {
                consumer.stopRender();
            }
        }
    }
}
/**
 * Represents a slot provided by a particle through a provide connection or one of the root slots
 * provided by the shell. Holds container (eg div element) and its additional info.
 * Must be initialized either with a container (for root slots provided by the shell) or
 * tuple of sourceSlotConsumer and spec (ProvidedSlotSpec) of the slot.
 */
class ProvidedSlotContext extends SlotContext {
    constructor(id, name, tags, container, spec, sourceSlotConsumer = null) {
        super(id, sourceSlotConsumer);
        this.tags = [];
        assert(Boolean(container) !== Boolean(spec), `Exactly one of either container or slotSpec may be set`);
        assert(Boolean(spec) === Boolean(spec), `Spec and source slot can only be set together`);
        this.name = name;
        this.tags = tags || [];
        this._container = container;
        // The context's accompanying ProvidedSlotSpec (see particle-spec.js).
        // Initialized to a default spec, if the container is one of the shell provided top root-contexts.
        this.spec = spec || new ProvideSlotConnectionSpec({ name });
        if (this.sourceSlotConsumer) {
            this.sourceSlotConsumer.directlyProvidedSlotContexts.push(this);
        }
        // The list of handles this context is restricted to.
        this.handles = this.spec && this.sourceSlotConsumer
            ? this.spec.handles.map(handle => this.sourceSlotConsumer.consumeConn.particle.connections[handle].handle).filter(a => a !== undefined)
            : [];
    }
    onRenderSlot(consumer, content, handler) {
        consumer.setContent(content, handler);
    }
    get container() {
        return this._container;
    }
    get containerAvailable() {
        return Boolean(this._container);
    }
    static createContextForContainer(id, name, container, tags) {
        return new ProvidedSlotContext(id, name, tags, container, null);
    }
    isSameContainer(container) {
        if (this.spec.isSet) {
            if (Boolean(this.container) !== Boolean(container)) {
                return false;
            }
            if (!this.container) {
                return true;
            }
            return Object.keys(this.container).length === Object.keys(container).length &&
                Object.keys(this.container).every(key => Object.keys(container).some(newKey => newKey === key)) &&
                Object.values(this.container).every(currentContainer => Object.values(container).some(newContainer => newContainer === currentContainer));
        }
        return (!container && !this.container) || (this.container === container);
    }
    set container(container) {
        if (this.isSameContainer(container)) {
            return;
        }
        const originalContainer = this.container;
        this._container = container;
        this.slotConsumers.forEach(slotConsumer => slotConsumer.onContainerUpdate(this.container, originalContainer));
    }
    addSlotConsumer(slotConsumer) {
        super.addSlotConsumer(slotConsumer);
        if (this.container) {
            slotConsumer.onContainerUpdate(this.container, null);
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotConsumer {
    constructor(arc, consumeConn, containerKind) {
        this.directlyProvidedSlotContexts = [];
        this.hostedSlotContexts = [];
        // Contains `container` and other modality specific rendering information
        // (eg for `dom`: model, template for dom renderer) by sub id. Key is `undefined` for singleton slot.
        this._renderingBySubId = new Map();
        this.innerContainerBySlotId = {};
        this.arc = arc;
        this.consumeConn = consumeConn;
        this.containerKind = containerKind;
    }
    getRendering(subId) {
        return this._renderingBySubId.get(subId);
    }
    get renderings() {
        return [...this._renderingBySubId.entries()];
    }
    addRenderingBySubId(subId, rendering) {
        this._renderingBySubId.set(subId, rendering);
    }
    addHostedSlotContexts(context) {
        context.containerAvailable = Boolean(this.slotContext.containerAvailable);
        this.hostedSlotContexts.push(context);
    }
    get allProvidedSlotContexts() {
        return [...this.generateProvidedContexts()];
    }
    findProvidedContext(predicate) {
        return this.generateProvidedContexts(predicate).next().value;
    }
    *generateProvidedContexts(predicate = Predicates.alwaysTrue) {
        for (const context of this.directlyProvidedSlotContexts) {
            if (predicate(context))
                yield context;
        }
        for (const hostedContext of this.hostedSlotContexts) {
            for (const hostedConsumer of hostedContext.slotConsumers) {
                yield* hostedConsumer.generateProvidedContexts(predicate);
            }
        }
    }
    onContainerUpdate(newContainer, originalContainer) {
        assert(this.slotContext instanceof ProvidedSlotContext, 'Container can only be updated in non-hosted context');
        const context = this.slotContext;
        if (newContainer !== originalContainer) {
            const contextContainerBySubId = new Map();
            if (context && context.spec.isSet) {
                Object.keys(context.container || {}).forEach(subId => contextContainerBySubId.set(subId, context.container[subId]));
            }
            else {
                contextContainerBySubId.set(undefined, context.container);
            }
            for (const [subId, container] of contextContainerBySubId) {
                if (!this._renderingBySubId.has(subId)) {
                    this._renderingBySubId.set(subId, {});
                }
                const rendering = this.getRendering(subId);
                if (!rendering.container || !this.isSameContainer(rendering.container, container)) {
                    if (rendering.container) {
                        // The rendering already had a container, but it's changed. The original container needs to be cleared.
                        this.clearContainer(rendering);
                    }
                    rendering.container = this.createNewContainer(container, subId);
                }
            }
            for (const [subId, rendering] of this.renderings) {
                if (!contextContainerBySubId.has(subId)) {
                    this.deleteContainer(rendering.container);
                    this._renderingBySubId.delete(subId);
                }
            }
        }
        if (Boolean(newContainer) !== Boolean(originalContainer)) {
            if (newContainer) {
                this.startRender();
            }
            else {
                this.stopRender();
            }
        }
        this.hostedSlotContexts.forEach(ctx => ctx.containerAvailable = Boolean(newContainer));
    }
    createProvidedContexts() {
        assert(this.consumeConn.getSlotSpec(), `Missing consume connection spec`);
        return this.consumeConn.getSlotSpec().provideSlotConnections.map(spec => new ProvidedSlotContext(this.consumeConn.providedSlots[spec.name].id, spec.name, /* tags=*/ [], /* container= */ null, spec, this));
    }
    updateProvidedContexts() {
        this.allProvidedSlotContexts.forEach(providedContext => {
            providedContext.container = providedContext.sourceSlotConsumer.getInnerContainer(providedContext.id);
        });
    }
    startRender() {
        if (this.consumeConn && this.startRenderCallback) {
            const providedSlots = new Map(this.allProvidedSlotContexts.map(context => [context.name, context.id]));
            this.startRenderCallback({
                particle: this.consumeConn.particle,
                slotName: this.consumeConn.name,
                providedSlots,
                contentTypes: this.constructRenderRequest()
            });
        }
    }
    stopRender() {
        if (this.consumeConn && this.stopRenderCallback) {
            this.stopRenderCallback({ particle: this.consumeConn.particle, slotName: this.consumeConn.name });
        }
    }
    setContent(content, handler) {
        if (content && Object.keys(content).length > 0 && this.description) {
            content.descriptions = this._populateHandleDescriptions();
        }
        this.eventHandler = handler;
        for (const [subId, rendering] of this.renderings) {
            this.setContainerContent(rendering, this.formatContent(content, subId), subId);
        }
    }
    _populateHandleDescriptions() {
        if (!this.consumeConn)
            return null; // TODO: remove null ability
        const descriptions = new Map();
        Object.values(this.consumeConn.particle.connections).forEach(handleConn => {
            if (handleConn.handle) {
                descriptions[`${handleConn.name}.description`] =
                    this.description.getHandleDescription(handleConn.handle).toString();
            }
        });
        return descriptions;
    }
    getInnerContainer(slotId) {
        return this.innerContainerBySlotId[slotId];
    }
    _initInnerSlotContainer(slotId, subId, container) {
        if (subId) {
            if (!this.innerContainerBySlotId[slotId]) {
                this.innerContainerBySlotId[slotId] = {};
            }
            assert(!this.innerContainerBySlotId[slotId][subId], `Multiple ${slotId}:${subId} inner slots cannot be provided`);
            this.innerContainerBySlotId[slotId][subId] = container;
        }
        else {
            this.innerContainerBySlotId[slotId] = container;
        }
    }
    _clearInnerSlotContainers(subIds) {
        subIds.forEach(subId => {
            if (subId) {
                Object.values(this.innerContainerBySlotId).forEach(inner => delete inner[subId]);
            }
            else {
                this.innerContainerBySlotId = {};
            }
        });
    }
    isSameContainer(container, contextContainer) {
        return (!container && !contextContainer) || (container === contextContainer);
    }
    // abstract
    constructRenderRequest() { return []; }
    dispose() { }
    createNewContainer(contextContainer, subId) { return null; }
    deleteContainer(container) { }
    clearContainer(rendering) { }
    setContainerContent(rendering, content, subId) { }
    formatContent(content, subId) { return null; }
    formatHostedContent(content) { return null; }
    static clear(container) { }
    static findRootContainers(topContainer) { return {}; }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const templateByName = () => Runtime.getRuntime().getCacheService().getOrCreateCache('templateByName');
// this style sheet is installed in every particle shadow-root
let commonStyleTemplate;
class SlotDomConsumer extends SlotConsumer {
    constructor(arc, consumeConn, containerKind) {
        super(arc, consumeConn, containerKind);
        this._observer = this._initMutationObserver();
    }
    constructRenderRequest() {
        const request = ['model'];
        const prefixes = [this.templatePrefix];
        if (!SlotDomConsumer.hasTemplate(prefixes.join('::'))) {
            request.push('template');
        }
        return request;
    }
    static hasTemplate(templatePrefix) {
        return [...templateByName().keys()].find(key => key.startsWith(templatePrefix));
    }
    isSameContainer(container, contextContainer) {
        return container.parentNode === contextContainer;
    }
    createNewContainer(contextContainer, subId) {
        assert(contextContainer, 'contextContainer cannot be null');
        const newContainer = document.createElement(this.containerKind || 'div');
        if (this.consumeConn) {
            newContainer.setAttribute('particle-host', this.consumeConn.getQualifiedName());
        }
        contextContainer.appendChild(newContainer);
        //return newContainer;
        // TODO(sjmiles): introduce tree scope
        newContainer.attachShadow({ mode: `open` });
        return newContainer.shadowRoot;
    }
    deleteContainer(container) {
        // step out of shadowDOM if container is a shadowRoot
        container = container.host || container;
        if (container.parentNode) {
            container.parentNode.removeChild(container);
        }
    }
    formatContent(content, subId) {
        assert(this.slotContext instanceof ProvidedSlotContext, 'Content formatting can only be done for provided SlotContext');
        const contextSpec = this.slotContext.spec;
        const newContent = {};
        // Format model.
        if (Object.keys(content).indexOf('model') >= 0) {
            if (content.model) {
                let formattedModel;
                if (contextSpec.isSet && this.consumeConn.getSlotSpec().isSet) {
                    formattedModel = this._modelForSetSlotConsumedAsSetSlot(content.model, subId);
                }
                else if (contextSpec.isSet && !this.consumeConn.getSlotSpec().isSet) {
                    formattedModel = this._modelForSetSlotConsumedAsSingletonSlot(content.model, subId);
                }
                else {
                    formattedModel = this._modelForSingletonSlot(content.model, subId);
                }
                if (!formattedModel)
                    return undefined;
                // Merge descriptions into model.
                newContent.model = { ...formattedModel, ...content.descriptions };
            }
            else {
                newContent.model = undefined;
            }
        }
        // Format template name and template.
        if (content.templateName) {
            newContent.templateName = typeof content.templateName === 'string' ? content.templateName : content.templateName[subId];
            if (content.template) {
                newContent.template = typeof content.template === 'string' ? content.template : content.template[newContent.templateName];
            }
        }
        return newContent;
    }
    _modelForSingletonSlot(model, subId) {
        assert(!subId, 'subId should be absent for a Singleton Slot');
        return model;
    }
    _modelForSetSlotConsumedAsSetSlot(model, subId) {
        assert(model.items && model.items.every(item => item.subId), 'model for a Set Slot consumed as a Set Slot needs to have items array, with every element having subId');
        return model.items.find(item => item.subId === subId);
    }
    _modelForSetSlotConsumedAsSingletonSlot(model, subId) {
        assert(model.subId, 'model for a Set Slot consumed as a Singleton Slot needs to have subId');
        return subId === model.subId ? model : null;
    }
    setContainerContent(rendering, content, subId) {
        if (!rendering.container) {
            return;
        }
        if (!content || Object.keys(content).length === 0) {
            this.clearContainer(rendering);
            rendering.model = null;
            return;
        }
        this._setTemplate(rendering, this.templatePrefix, content.templateName, content.template);
        rendering.model = content.model;
        this._onUpdate(rendering);
    }
    clearContainer(rendering) {
        if (rendering.liveDom) {
            rendering.liveDom.root.textContent = '';
        }
        rendering.liveDom = null;
    }
    dispose() {
        if (this._observer) {
            this._observer.disconnect();
        }
        this.renderings.forEach(([subId, { container }]) => this.deleteContainer(container));
    }
    static clear(container) {
        container.textContent = '';
    }
    static clearCache() {
        templateByName().clear();
    }
    static findRootContainers(topContainer) {
        const containerBySlotId = {};
        Array.from(topContainer.querySelectorAll('[slotid]')).forEach(container => {
            //assert(this.isDirectInnerSlot(container), 'Unexpected inner slot');
            const slotId = container.getAttribute('slotid');
            assert(!containerBySlotId[slotId], `Duplicate root slot ${slotId}`);
            containerBySlotId[slotId] = container;
        });
        return containerBySlotId;
    }
    createTemplateElement(template) {
        return Object.assign(document.createElement('template'), { innerHTML: template });
    }
    get templatePrefix() {
        return this.consumeConn.getQualifiedName();
    }
    _setTemplate(rendering, templatePrefix, templateName, template) {
        if (templateName) {
            rendering.templateName = [templatePrefix, templateName].filter(s => s).join('::');
            if (template) {
                if (templateByName().has(rendering.templateName)) {
                    // TODO: check whether the new template is different from the one that was previously used.
                    // Template is being replaced.
                    this.clearContainer(rendering);
                }
                templateByName().set(rendering.templateName, this.createTemplateElement(template));
            }
        }
    }
    _onUpdate(rendering) {
        this._observe(rendering.container);
        if (rendering.templateName) {
            const template = templateByName().get(rendering.templateName);
            assert(template, `No template for ${rendering.templateName}`);
            this._stampTemplate(rendering, template);
        }
        this._updateModel(rendering);
    }
    _observe(container) {
        assert(container, 'Cannot observe without a container');
        if (this._observer) {
            this._observer.observe(container, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['subid']
            });
        }
    }
    _stampTemplate(rendering, template) {
        if (!rendering.liveDom) {
            // TODO(sjmiles): normally I would create this template as part of module startup,
            // but this file is node-test-dependency, and `createTemplate` requires `document`
            // see https://github.com/PolymerLabs/arcs/issues/2827
            if (!commonStyleTemplate) {
                commonStyleTemplate = Template.createTemplate(`<style>${IconStyles}</style>`);
            }
            // provision common stylesheet
            Template.stamp(commonStyleTemplate).appendTo(rendering.container);
            const mapper = this._eventMapper.bind(this, this.eventHandler);
            rendering.liveDom = Template
                .stamp(template)
                .events(mapper)
                .appendTo(rendering.container);
        }
    }
    _eventMapper(eventHandler, node, eventName, handlerName) {
        node.addEventListener(eventName, event => {
            // TODO(sjmiles): we have an extremely minimalist approach to events here, this is useful IMO for
            // finding the smallest set of features that we are going to need.
            // First problem: click event firing multiple times as it bubbles up the tree, minimalist solution
            // is to enforce a 'first listener' rule by executing `stopPropagation`.
            event.stopPropagation();
            // TODO(sjmiles): affordance for forwarded events (events produced by a template that is lexically
            // scoped to the mapped template [e.g. dom-repeater])
            if (eventName === 'xen:forward') {
                node = event.detail.target;
                handlerName = event.detail.handlerName;
            }
            // collate keyboard information
            const { altKey, ctrlKey, metaKey, shiftKey, code, key, repeat } = event;
            const detail = {
                // TODO(sjmiles): `key` is a data-key (as in key-value pair), may be confusing vs keyboard `keys`
                key: node.key,
                value: node.value,
                keys: { altKey, ctrlKey, metaKey, shiftKey, code, key, repeat }
            };
            eventHandler({
                detail,
                handler: handlerName,
                // TODO(sjmiles): deprecated
                data: detail
            });
        });
    }
    _updateModel(rendering) {
        if (rendering.liveDom) {
            rendering.liveDom.set(rendering.model);
        }
    }
    initInnerContainers(container) {
        Array.from(container.querySelectorAll('[slotid]')).forEach(innerContainer => {
            if (!this.isDirectInnerSlot(container, innerContainer)) {
                // Skip inner slots of an inner slot of the given slot.
                return;
            }
            const slotId = this.getNodeValue(innerContainer, 'slotid');
            const providedContext = this.findProvidedContext(ctx => ctx.id === slotId);
            if (!providedContext) {
                console.warn(`Slot ${this.consumeConn.getSlotSpec().name} has unexpected inner slot ${slotId}`);
                return;
            }
            const subId = this.getNodeValue(innerContainer, 'subid');
            assert(Boolean(subId) === providedContext.spec.isSet, `Sub-id ${subId} for slot ${providedContext.name} doesn't match set spec: ${providedContext.spec.isSet}`);
            providedContext.sourceSlotConsumer._initInnerSlotContainer(slotId, subId, innerContainer);
        });
    }
    // get a value from node that could be an attribute, if not a property
    getNodeValue(node, name) {
        // TODO(sjmiles): remember that attribute names from HTML are lower-case
        return node[name] || node.getAttribute(name);
    }
    isDirectInnerSlot(container, innerContainer) {
        if (innerContainer === container) {
            return true;
        }
        const parentOf = elt => elt.parentNode;
        let parentNode = parentOf(innerContainer);
        while (parentNode) {
            if (parentNode === container) {
                return true;
            }
            // only some HTMLNodes have `getAttribute` (i.e. HTMLElement)
            if (parentNode.getAttribute && parentNode.getAttribute('slotid')) {
                // this is an inner slot of an inner slot.
                return false;
            }
            parentNode = parentOf(parentNode);
        }
        // innerContainer won't be a child node of container if the method is triggered
        // by mutation observer record and innerContainer was removed.
        return false;
    }
    _initMutationObserver() {
        if (this.consumeConn) {
            return new MutationObserver(async (records) => {
                this._observer.disconnect();
                const updateContainersBySubId = new Map();
                for (const [subId, { container }] of this.renderings) {
                    if (records.some(r => this.isDirectInnerSlot(container, r.target))) {
                        updateContainersBySubId.set(subId, container);
                    }
                }
                const containers = [...updateContainersBySubId.values()];
                if (containers.length > 0) {
                    this._clearInnerSlotContainers([...updateContainersBySubId.keys()]);
                    containers.forEach(container => this.initInnerContainers(container));
                    this.updateProvidedContexts();
                    // Reactivate the observer.
                    containers.forEach(container => this._observe(container));
                }
            });
        }
        return null;
    }
    formatHostedContent(content) {
        if (content.templateName) {
            if (typeof content.templateName === 'string') {
                content.templateName = `${this.consumeConn.getQualifiedName()}::${content.templateName}`;
            }
            else {
                // TODO(mmandlis): add support for hosted particle rendering set slot.
                throw new Error('TODO: Implement this!');
            }
        }
        return content;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class HeadlessSlotDomConsumer extends SlotDomConsumer {
    constructor(arc, consumeConn) {
        super(arc, consumeConn);
        this._content = {};
        this.contentAvailable = new Promise(resolve => this._contentAvailableResolve = resolve);
    }
    setContent(content, handler) {
        super.setContent(content, handler);
        // Mimics the behaviour of DomSlotConsumer::setContent, where template is only set at first,
        // and model is overriden every time.
        if (content) {
            this._content.templateName = content.templateName;
            if (content.template) {
                this._content.template = content.template;
            }
            this._content.model = content.model;
            this._contentAvailableResolve();
        }
        else {
            this._content = {};
        }
    }
    createNewContainer(container, subId) {
        return container;
    }
    isSameContainer(container, contextContainer) {
        return container === contextContainer;
    }
    getInnerContainer(slotId) {
        const model = Array.from(this.renderings, ([_, { model }]) => model)[0];
        const providedContext = this.findProvidedContext(ctx => ctx.id === slotId);
        if (!providedContext) {
            console.warn(`Cannot find provided spec for ${slotId} in ${this.consumeConn.getQualifiedName()}`);
            return;
        }
        if (providedContext.spec.isSet && model && model.items && model.items.models) {
            const innerContainers = {};
            for (const itemModel of model.items.models) {
                assert(itemModel.id);
                innerContainers[itemModel.id] = itemModel.id;
            }
            return innerContainers;
        }
        return slotId;
    }
    createTemplateElement(template) {
        return template;
    }
    static findRootContainers(container) {
        return container;
    }
    static clear(container) { }
    _onUpdate(rendering) { }
    _stampTemplate(template) { }
    _initMutationObserver() { return null; }
    _observe() { }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ModalityHandler {
    constructor(slotConsumerClass, descriptionFormatter) {
        this.slotConsumerClass = slotConsumerClass;
        this.descriptionFormatter = descriptionFormatter;
    }
    static createHeadlessHandler() {
        return new ModalityHandler(HeadlessSlotDomConsumer);
    }
}
ModalityHandler.headlessHandler = new ModalityHandler(HeadlessSlotDomConsumer);
ModalityHandler.basicHandler = new ModalityHandler(SlotConsumer, DescriptionFormatter);
ModalityHandler.domHandler = new ModalityHandler(SlotDomConsumer, DescriptionDomFormatter);

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotComposer {
    /**
     * |options| must contain:
     * - modalityName: the UI modality the slot-composer renders to (for example: dom).
     * - modalityHandler: the handler for UI modality the slot-composer renders to.
     * - rootContainer: the top level container to be used for slots.
     * and may contain:
     * - containerKind: the type of container wrapping each slot-context's container  (for example, div).
     */
    constructor(options) {
        this._consumers = [];
        this._contexts = [];
        //    assert(options.modalityHandler && options.modalityHandler.constructor === ModalityHandler,
        //           `Missing or invalid modality handler: ${options.modalityHandler}`);
        assert(options.modalityHandler, `Missing or invalid modality handler: ${options.modalityHandler}`);
        // TODO: Support rootContext for backward compatibility, remove when unused.
        options.rootContainer = options.rootContainer || options.rootContext || (options.containers || Object).root;
        assert((options.rootContainer !== undefined)
            !==
                (options.noRoot === true), 'Root container is mandatory unless it is explicitly skipped');
        this._containerKind = options.containerKind;
        if (options.modalityName) {
            this.modality = Modality.create([options.modalityName]);
        }
        this.modalityHandler = options.modalityHandler;
        if (options.noRoot) {
            return;
        }
        const containerByName = options.containers
            || this.modalityHandler.slotConsumerClass.findRootContainers(options.rootContainer) || {};
        if (Object.keys(containerByName).length === 0) {
            // fallback to single 'root' slot using the rootContainer.
            containerByName['root'] = options.rootContainer;
        }
        Object.keys(containerByName).forEach(slotName => {
            this._contexts.push(ProvidedSlotContext.createContextForContainer(`rootslotid-${slotName}`, slotName, containerByName[slotName], [`${slotName}`]));
        });
    }
    get consumers() { return this._consumers; }
    get containerKind() { return this._containerKind; }
    getSlotConsumer(particle, slotName) {
        return this.consumers.find(s => s.consumeConn.particle === particle && s.consumeConn.name === slotName);
    }
    findContainerByName(name) {
        const contexts = this.findContextsByName(name);
        if (contexts.length === 0) {
            // TODO this is a no-op, but throwing here breaks tests
            console.warn(`No containers for '${name}'`);
        }
        else if (contexts.length === 1) {
            return contexts[0].container;
        }
        console.warn(`Ambiguous containers for '${name}'`);
        return undefined;
    }
    findContextsByName(name) {
        const providedSlotContexts = this._contexts.filter(ctx => ctx instanceof ProvidedSlotContext);
        return providedSlotContexts.filter(ctx => ctx.name === name);
    }
    findContextById(slotId) {
        return this._contexts.find(({ id }) => id === slotId);
    }
    createHostedSlot(innerArc, transformationParticle, transformationSlotName, storeId) {
        const transformationSlotConsumer = this.getSlotConsumer(transformationParticle, transformationSlotName);
        assert(transformationSlotConsumer, `Transformation particle ${transformationParticle.name} with consumed ${transformationSlotName} not found`);
        const hostedSlotId = innerArc.generateID().toString();
        this._contexts.push(new HostedSlotContext(hostedSlotId, transformationSlotConsumer, storeId));
        return hostedSlotId;
    }
    _addSlotConsumer(slot) {
        slot.startRenderCallback = slot.arc.pec.startRender.bind(slot.arc.pec);
        slot.stopRenderCallback = slot.arc.pec.stopRender.bind(slot.arc.pec);
        this._consumers.push(slot);
    }
    async initializeRecipe(arc, recipeParticles) {
        const newConsumers = [];
        // Create slots for each of the recipe's particles slot connections.
        recipeParticles.forEach(p => {
            p.getSlandleConnections().forEach(cs => {
                if (!cs.targetSlot) {
                    assert(!cs.getSlotSpec().isRequired, `No target slot for particle's ${p.name} required consumed slot: ${cs.name}.`);
                    return;
                }
                const slotConsumer = new this.modalityHandler.slotConsumerClass(arc, cs, this._containerKind);
                const providedContexts = slotConsumer.createProvidedContexts();
                this._contexts = this._contexts.concat(providedContexts);
                newConsumers.push(slotConsumer);
            });
        });
        // Set context for each of the slots.
        newConsumers.forEach(consumer => {
            this._addSlotConsumer(consumer);
            const context = this.findContextById(consumer.consumeConn.targetSlot.id);
            assert(context, `No context found for ${consumer.consumeConn.getQualifiedName()}`);
            context.addSlotConsumer(consumer);
        });
        // Calculate the Descriptions only once per-Arc
        const allArcs = this.consumers.map(consumer => consumer.arc);
        const uniqueArcs = [...new Set(allArcs).values()];
        // get arc -> description
        const descriptions = await Promise.all(uniqueArcs.map(arc => Description.create(arc)));
        // create a mapping from the zipped uniqueArcs and descriptions
        const consumerByArc = new Map(descriptions.map((description, index) => [uniqueArcs[index], description]));
        // ... and apply to each consumer
        for (const consumer of this.consumers) {
            consumer.description = consumerByArc.get(consumer.arc);
        }
    }
    renderSlot(particle, slotName, content) {
        const slotConsumer = this.getSlotConsumer(particle, slotName);
        assert(slotConsumer, `Cannot find slot (or hosted slot) ${slotName} for particle ${particle.name}`);
        slotConsumer.slotContext.onRenderSlot(slotConsumer, content, async (eventlet) => {
            slotConsumer.arc.pec.sendEvent(particle, slotName, eventlet);
            // This code is a temporary hack implemented in #2011 which allows to route UI events from
            // multiplexer to hosted particles. Multiplexer assembles UI from multiple pieces rendered
            // by hosted particles. Hosted particles can render DOM elements with a key containing a
            // handle ID of the store, which contains the entity they render. The code below attempts
            // to find the hosted particle using the store matching the 'key' attribute on the event,
            // which has been extracted from DOM.
            // TODO: FIXIT!
            if (eventlet.data && eventlet.data.key) {
                // We fire off multiple async operations and don't wait.
                for (const ctx of slotConsumer.hostedSlotContexts) {
                    if (!ctx.storeId)
                        continue;
                    for (const hostedConsumer of ctx.slotConsumers) {
                        const store = hostedConsumer.arc.findStoreById(ctx.storeId);
                        assert(store);
                        // TODO(shans): clean this up when we have interfaces for Singleton, Collection, etc
                        // tslint:disable-next-line: no-any
                        store.get().then(value => {
                            if (value && (value.id === eventlet.data.key)) {
                                hostedConsumer.arc.pec.sendEvent(hostedConsumer.consumeConn.particle, hostedConsumer.consumeConn.name, eventlet);
                            }
                        });
                    }
                }
            }
        });
    }
    getAvailableContexts() {
        return this._contexts;
    }
    dispose() {
        this.consumers.forEach(consumer => consumer.dispose());
        this._contexts.forEach(context => {
            context.clearSlotConsumers();
            if (context instanceof ProvidedSlotContext && context.container) {
                this.modalityHandler.slotConsumerClass.clear(context.container);
            }
        });
        this._contexts = this._contexts.filter(c => !c.sourceSlotConsumer);
        this._consumers.length = 0;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A helper class for NodeJS tests that mimics SlotComposer without relying on DOM APIs.
 */
class FakeSlotComposer extends SlotComposer {
    constructor(options = {}) {
        if (options.modalityHandler === undefined) {
            options.modalityHandler = ModalityHandler.createHeadlessHandler();
        }
        super({
            rootContainer: { 'root': 'root-context' },
            ...options
        });
    }
    renderSlot(particle, slotName, content) {
        super.renderSlot(particle, slotName, content);
        // In production updateProvidedContexts() is done in DOM Mutation Observer.
        // We don't have it in tests, so we do it here.
        const slotConsumer = this.getSlotConsumer(particle, slotName);
        if (slotConsumer)
            slotConsumer.updateProvidedContexts();
    }
    // Accessors for testing.
    get contexts() {
        return this._contexts;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// To start with, this class will simply hide the runtime classes that are
// currently imported by ArcsLib.js. Once that refactoring is done, we can
// think about what the api should actually look like.
class Runtime {
    constructor(loader, composerClass, context) {
        this.arcById = new Map();
        this.cacheService = new RuntimeCacheService();
        this.loader = loader;
        this.composerClass = composerClass;
        this.context = context || new Manifest({ id: 'manifest:default' });
        this.ramDiskMemory = new VolatileMemory();
        runtime = this;
        // user information. One persona per runtime for now.
    }
    static getRuntime() {
        if (runtime == null) {
            runtime = new Runtime();
        }
        return runtime;
    }
    static clearRuntimeForTesting() {
        if (runtime !== null) {
            runtime.destroy();
            runtime = null;
        }
    }
    static newForNodeTesting(context) {
        return new Runtime(new Loader(), FakeSlotComposer, context);
    }
    getCacheService() {
        return this.cacheService;
    }
    getRamDiskMemory() {
        return this.ramDiskMemory;
    }
    destroy() {
    }
    newArc(name, storageKeyPrefix, options) {
        const id = IdGenerator.newSession().newArcId(name);
        const storageKey = storageKeyPrefix + id.toString();
        return new Arc({ id, storageKey, loader: this.loader, slotComposer: new this.composerClass(), context: this.context, ...options });
    }
    // Stuff the shell needs
    /**
     * Given an arc name, return either:
     * (1) the already running arc
     * (2) a deserialized arc (TODO: needs implementation)
     * (3) a newly created arc
     */
    runArc(name, storageKeyPrefix, options) {
        if (!this.arcById[name]) {
            // TODO: Support deserializing serialized arcs.
            this.arcById[name] = this.newArc(name, storageKeyPrefix, options);
        }
        return this.arcById[name];
    }
    // TODO: This is a temporary method to allow sharing stores with other Arcs.
    registerStore(store, tags) {
        if (!this.context.findStoreById(store.id) && tags.includes('shared')) {
            // tslint:disable-next-line: no-any
            this.context['_addStore'](store, tags);
        }
        // TODO: clear stores, when arc is being disposed.
    }
    /**
     * Given an arc, returns it's description as a string.
     */
    static async getArcDescription(arc) {
        // Verify that it's one of my arcs, and make this non-static, once I have
        // Runtime objects in the calling code.
        return (await Description.create(arc)).getArcDescription();
    }
    /**
     * Parse a textual manifest and return a Manifest object. See the Manifest
     * class for the options accepted.
     */
    static async parseManifest(content, options) {
        return Manifest.parse(content, options);
    }
    /**
     * Load and parse a manifest from a resource (not striclty a file) and return
     * a Manifest object. The loader determines the semantics of the fileName. See
     * the Manifest class for details.
     */
    static async loadManifest(fileName, loader, options) {
        return Manifest.load(fileName, loader, options);
    }
}
let runtime = null;

/**
 * Implementation of KeyStorage using a Map, used for testing only.
 */
class WebCryptoMemoryKeyStorage {
    constructor() {
        this.storageMap = new Map();
    }
    find(keyFingerPrint) {
        return Promise.resolve(this.storageMap.get(keyFingerPrint));
    }
    async write(keyFingerprint, key) {
        this.storageMap.set(keyFingerprint, key);
        return Promise.resolve(keyFingerprint);
    }
    static getInstance() {
        return new WebCryptoMemoryKeyStorage();
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const crypto = new WebCrypto();

/* eslint-disable header/header */
// ISC License (ISC)
//
// Copyright 2017 Rhett Robinson
//
// Permission to use, copy, modify, and/or distribute this software for any purpose
// with or without fee is hereby granted, provided that the above copyright notice
// and this permission notice appear in all copies.
//
//     THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
//     INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.
// Originally forked from https://github.com/rrhett/typescript-base64-arraybuffer/blob/master/src/base64.ts
// For the base64 encoding pieces.
/*
 * Most of the key management operatins deals with ArrayBuffers/TypedArrays. Although atob and btoa are built into
 * JS, they are not convenient to use for ArrayBuffers.
 */
const alphabet = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/'
];
const values = {};
for (let i = 0; i < 64; ++i) {
    values[alphabet[i]] = i;
}
function encode(bytes) {
    const array = new Uint8Array(bytes);
    const base64 = [];
    let index = 0;
    let quantum;
    let value;
    /* tslint:disable:no-bitwise */
    // Grab as many sets of 3 bytes as we can, that form 24 bits.
    while (index + 2 < array.byteLength) {
        quantum = (array[index] << 16) | (array[index + 1] << 8) | array[index + 2];
        // 24 bits will become 4 base64 chars.
        value = (quantum >> 18) & 0x3f;
        base64.push(alphabet[value]);
        value = (quantum >> 12) & 0x3f;
        base64.push(alphabet[value]);
        value = (quantum >> 6) & 0x3f;
        base64.push(alphabet[value]);
        value = quantum & 0x3f;
        base64.push(alphabet[value]);
        index += 3;
    }
    // At this point, there are 0, 1 or 2 bytes left.
    if (index + 1 === array.byteLength) {
        // 8 bits; shift by 4 to pad on the right with 0s to make 12 bits total.
        quantum = array[index] << 4;
        value = (quantum >> 6) & 0x3f;
        base64.push(alphabet[value]);
        value = quantum & 0x3f;
        base64.push(alphabet[value]);
        base64.push('==');
    }
    else if (index + 2 === array.byteLength) {
        // 16 bits; shift by 2 to pad on the right with 0s to make 18 bits total.
        quantum = (array[index] << 10) | (array[index + 1] << 2);
        value = (quantum >> 12) & 0x3f;
        base64.push(alphabet[value]);
        value = (quantum >> 6) & 0x3f;
        base64.push(alphabet[value]);
        value = quantum & 0x3f;
        base64.push(alphabet[value]);
        base64.push('=');
    }
    /* tslint:enable:no-bitwise */
    return base64.join('');
}
function decode(str) {
    let size = str.length;
    if (size === 0) {
        return new Uint8Array(new ArrayBuffer(0));
    }
    if (size % 4 !== 0) {
        throw new Error('Bad length: ' + size);
    }
    if (!str.match(/^[a-zA-Z0-9+/]+={0,2}$/)) {
        throw new Error('Invalid base64 encoded value');
    }
    // Every 4 base64 chars = 24 bits = 3 bytes. But, we also need to figure out
    // padding, if any.
    let bytes = 3 * (size / 4);
    let numPad = 0;
    if (str.charAt(size - 1) === '=') {
        numPad++;
        bytes--;
    }
    if (str.charAt(size - 2) === '=') {
        numPad++;
        bytes--;
    }
    const buffer = new Uint8Array(new ArrayBuffer(bytes));
    let index = 0;
    let bufferIndex = 0;
    let quantum;
    if (numPad > 0) {
        size -= 4; // handle the last one specially
    }
    /* tslint:disable:no-bitwise */
    while (index < size) {
        quantum = 0;
        for (let i = 0; i < 4; ++i) {
            quantum = (quantum << 6) | values[str.charAt(index + i)];
        }
        // quantum is now a 24-bit value.
        buffer[bufferIndex++] = (quantum >> 16) & 0xff;
        buffer[bufferIndex++] = (quantum >> 8) & 0xff;
        buffer[bufferIndex++] = quantum & 0xff;
        index += 4;
    }
    if (numPad > 0) {
        // if numPad == 1, there is one =, and we have 18 bits with 2 0s at end.
        // if numPad == 2, there is two ==, and we have 12 bits with 4 0s at end.
        // First, grab my quantum.
        quantum = 0;
        for (let i = 0; i < 4 - numPad; ++i) {
            quantum = (quantum << 6) | values[str.charAt(index + i)];
        }
        if (numPad === 1) {
            // quantum is 18 bits, but really represents two bytes.
            quantum = quantum >> 2;
            buffer[bufferIndex++] = (quantum >> 8) & 0xff;
            buffer[bufferIndex++] = quantum & 0xff;
        }
        else {
            // quantum is 12 bits, but really represents only one byte.
            quantum = quantum >> 4;
            buffer[bufferIndex++] = quantum & 0xff;
        }
    }
    /* tslint:enable:no-bitwise */
    return buffer;
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const DEVICE_KEY_ALGORITHM = 'RSA-OAEP';
const X509_CERTIFICATE_ALGORITHM = 'RSA-OAEP';
const X509_CERTIFICATE_HASH_ALGORITHM = 'SHA-1';
const DEVICE_KEY_HASH_ALGORITHM = 'SHA-512';
const STORAGE_KEY_ALGORITHM = 'AES-GCM';
const ARCS_CRYPTO_STORE_NAME = 'ArcsKeyManagementStore';
const ARCS_CRYPTO_INDEXDB_NAME = 'ArcsKeyManagement';
/**
 * A CryptoKey or CryptoKeyPair that is capable of being stored in IndexDB key storage.
 */
class WebCryptoStorableKey {
    constructor(key) {
        this.key = key;
    }
    algorithm() {
        return this.key.algorithm ? this.key.algorithm.name :
            this.key.publicKey.algorithm.name;
    }
    storableKey() {
        return this.key;
    }
}
/**
 * An AES-GCM symmetric key in raw formatted encrypted using an RSA-OAEP public key.
 * We use a symmetrically derived key for the shared secret instead of just random numbers. There are two
 * reasons for this.
 *
 * First, WebCrypto treats CryptoKeys specially in that the material is can be setup to
 * never be exposed the application, so when we generate these secrets, we can hide them from JS by declaring
 * them non-extractable or usable for wrapping or encrypting only.
 *
 * Secondly, we eventually want to move off of RSA-OAEP and use ECDH, and ECDH doesn't support encryption or wrapping
 * of randomly generated bits.
 */
class WebCryptoWrappedKey {
    constructor(wrappedKeyData, wrappedBy) {
        this.wrappedKeyData = wrappedKeyData;
        this.wrappedBy = wrappedBy;
    }
    algorithm() {
        return this.wrappedBy.algorithm();
    }
    unwrap(privKey) {
        const webPrivKey = privKey;
        return crypto.subtle.unwrapKey('raw', this.wrappedKeyData, webPrivKey.cryptoKey(), {
            name: privKey.algorithm()
        }, {
            name: STORAGE_KEY_ALGORITHM,
        }, true, ['encrypt', 'decrypt']).then(key => new WebCryptoSessionKey(key));
    }
    rewrap(privKey, pubKey) {
        return this.unwrap(privKey).then(skey => skey.disposeToWrappedKeyUsing(pubKey));
    }
    export() {
        return encode(this.wrappedKeyData.buffer);
    }
    fingerprint() {
        return Promise.resolve(encode(this.wrappedKeyData.buffer));
    }
}
/**
 * An implementation of PrivateKey using WebCrypto.
 */
class WebCryptoPrivateKey extends WebCryptoStorableKey {
    constructor(key) {
        super(key);
    }
    cryptoKey() {
        return this.storableKey();
    }
}
/**
 * An implementation of PublicKey using WebCrypto.
 */
class WebCryptoPublicKey extends WebCryptoStorableKey {
    constructor(key) {
        super(key);
    }
    cryptoKey() {
        return this.storableKey();
    }
    static digest(str) {
        return WebCryptoPublicKey.sha256(str);
    }
    static hex(buffer) {
        const hexCodes = [];
        const view = new DataView(buffer);
        for (let i = 0; i < view.byteLength; i += 4) {
            // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
            const value = view.getUint32(i);
            // toString(16) will give the hex representation of the number without padding
            const stringValue = value.toString(16);
            // We use concatenation and slice for padding
            const padding = '00000000';
            const paddedValue = (padding + stringValue).slice(-padding.length);
            hexCodes.push(paddedValue);
        }
        // Join all the hex strings into one
        return hexCodes.join('');
    }
    static sha256(str) {
        // We transform the string into an arraybuffer.
        const buffer = new Uint8Array(str.split('').map(x => x.charCodeAt(0)));
        return crypto.subtle.digest('SHA-256', buffer).then((hash) => WebCryptoPublicKey.hex(hash));
    }
    fingerprint() {
        return crypto.subtle.exportKey('jwk', this.cryptoKey())
            // Use the modulus 'n' as the fingerprint since 'e' is fixed
            .then(key => WebCryptoPublicKey.digest(key['n']));
    }
}
class WebCryptoSessionKey {
    constructor(sessionKey) {
        this.sessionKey = sessionKey;
    }
    // Visible/Used for testing only.
    decrypt(buffer, iv) {
        return crypto.subtle.decrypt({
            name: this.algorithm(),
            iv,
        }, this.sessionKey, buffer);
    }
    // Visible/Used for testing only.
    encrypt(buffer, iv) {
        return crypto.subtle.encrypt({
            name: this.algorithm(),
            iv
        }, this.sessionKey, buffer);
    }
    /**
     * This encodes the session key as a hexadecimal string.
     * TODO: this is a temporary hack for the provisioning App's QR-scanning procedure which will be
     * removed once the the key-blessing algorithm is implemented.
     */
    export() {
        return crypto.subtle.exportKey('raw', this.sessionKey).then((raw) => {
            const buf = new Uint8Array(raw);
            let res = '';
            buf.forEach((x) => res += (x < 16 ? '0' : '') + x.toString(16));
            return res;
        });
    }
    algorithm() {
        return this.sessionKey.algorithm.name;
    }
    /**
     * Encrypts this session key with the private key, and makes a best effort to destroy the session
     * key material (presumably erased during garbage collection).
     * @param pkey
     */
    disposeToWrappedKeyUsing(pkey) {
        try {
            const webPkey = pkey;
            const rawWrappedKey = crypto.subtle.wrapKey('raw', this.sessionKey, pkey.cryptoKey(), {
                //these are the wrapping key's algorithm options
                name: webPkey.algorithm(),
            });
            return rawWrappedKey.then(rawKey => new WebCryptoWrappedKey(new Uint8Array(rawKey), pkey));
        }
        finally {
            // Hopefully this frees the underlying key material
            this.sessionKey = null;
        }
    }
    isDisposed() {
        return this.sessionKey != null;
    }
}
class WebCryptoDeviceKey extends WebCryptoStorableKey {
    algorithm() {
        return this.publicKey().algorithm();
    }
    constructor(key) {
        super(key);
    }
    privateKey() {
        return new WebCryptoPrivateKey(this.key.privateKey);
    }
    publicKey() {
        return new WebCryptoPublicKey(this.key.publicKey);
    }
    /**
     * Returns a fingerprint of the public key of the devicekey pair.
     */
    fingerprint() {
        return this.publicKey().fingerprint();
    }
}
/**
 * Implementation of KeyGenerator using WebCrypto interface.
 */
class WebCryptoKeyGenerator {
    generateWrappedStorageKey(deviceKey) {
        const generatedKey = crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']);
        return generatedKey.then(key => new WebCryptoSessionKey(key))
            .then(skey => skey.disposeToWrappedKeyUsing(deviceKey.publicKey()));
    }
    static getInstance() {
        // TODO: may want to reuse instance in future
        return new WebCryptoKeyGenerator();
    }
    generateAndStoreRecoveryKey() {
        // TODO: Implement
        throw new Error('Not implemented');
    }
    generateDeviceKey() {
        const generatedKey = crypto.subtle.generateKey({
            hash: { name: DEVICE_KEY_HASH_ALGORITHM },
            // TODO: Note, RSA-OAEP is deprecated, we should move to ECDH in the future, but it
            // doesn't use key-wrapping, instead it uses a different mechanism: key-derivation.
            name: DEVICE_KEY_ALGORITHM,
            modulusLength: 2048,
            // exponent is only allowed to be 3 or 65537 for RSA
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
        }, 
        // false means the key material is not visible to the application
        false, ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']);
        return generatedKey.then(key => new WebCryptoDeviceKey(key));
    }
    /**
     * Decodes X509 PEM certificates, extracts their key material, and returns a PublicKey.
     * @param pemKey
     */
    importKey(pemKey) {
        const key = rs.KEYUTIL.getKey(pemKey);
        const jwk = rs.KEYUTIL.getJWKFromKey(key);
        return crypto.subtle.importKey('jwk', jwk, {
            name: X509_CERTIFICATE_ALGORITHM,
            hash: { name: X509_CERTIFICATE_HASH_ALGORITHM }
        }, true, ['encrypt', 'wrapKey']).then(ikey => new WebCryptoPublicKey(ikey));
    }
    async importWrappedKey(wrappedKey, wrappedBy) {
        const decodedKey = decode(wrappedKey);
        return Promise.resolve(new WebCryptoWrappedKey(decodedKey, wrappedBy));
    }
}
/**
 * The Web Crypto spec states that IndexDB may be used to store CryptoKey objects without ever exposing
 * key material to the application: https://www.w3.org/TR/WebCryptoAPI/#concepts-key-storage
 */
class WebCryptoKeyIndexedDBStorage {
    async runOnStore(fn) {
        try {
            const db = await idb.open(ARCS_CRYPTO_INDEXDB_NAME, 1, upgradeDB => upgradeDB.createObjectStore(ARCS_CRYPTO_STORE_NAME, { keyPath: 'keyFingerPrint' }));
            const tx = db.transaction(ARCS_CRYPTO_STORE_NAME, 'readwrite');
            const store = tx.objectStore(ARCS_CRYPTO_STORE_NAME);
            const result = await fn(store);
            await tx.complete;
            db.close();
            return Promise.resolve(result);
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    async find(keyId) {
        const result = await this.runOnStore(async (store) => {
            return store.get(keyId);
        });
        if (!result) {
            return Promise.resolve(null);
        }
        if (result.key && result.key['privateKey'] && result.key['publicKey']) {
            return Promise.resolve(new WebCryptoDeviceKey(result.key));
        }
        else if (result.key instanceof CryptoKey) {
            return Promise.resolve(new WebCryptoPublicKey(result.key));
        }
        else if (result.key instanceof Uint8Array) {
            const wrappedBy = await this.find(result.wrappingKeyFingerprint);
            return Promise.resolve(new WebCryptoWrappedKey(result.key, wrappedBy));
        }
        throw new Error('Unrecognized key type found in keystore.');
    }
    async write(keyFingerPrint, key) {
        if (key instanceof WebCryptoStorableKey) {
            const skey = key;
            await this.runOnStore(async (store) => {
                return store.put({ keyFingerPrint, key: skey.storableKey() });
            });
            return keyFingerPrint;
        }
        else if (key instanceof WebCryptoWrappedKey) {
            const wrappedKey = key;
            const wrappingKeyFingerprint = await wrappedKey.wrappedBy.fingerprint();
            await this.runOnStore(async (store) => {
                return store.put({ keyFingerPrint, key: wrappedKey.wrappedKeyData,
                    wrappingKeyFingerprint });
            });
            return keyFingerPrint;
        }
        throw new Error('Can\'t write key that isn\'t StorableKey or WrappedKey.');
    }
    static getInstance() {
        // TODO: If IndexDB open/close is expensive, we may want to reuse instances.
        return new WebCryptoKeyIndexedDBStorage();
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class KeyManager {
    static getGenerator() {
        return WebCryptoKeyGenerator.getInstance();
        // return AndroidWebViewKeyGenerator.getInstance()
    }
    static getStorage() {
        // TODO: move this hackery to the platform/ directory for node vs worker vs web?
        const globalScope = typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : global);
        return globalScope['indexedDB'] != null ? WebCryptoKeyIndexedDBStorage.getInstance() : WebCryptoMemoryKeyStorage.getInstance();
        // return AndroidWebViewKeyStorage.getInstance()
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
commonjsGlobal.logLevel = 2;

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// Debugging is initialized either by /devtools/src/run-mark-connected.js, which is
// injected by the devtools extension content script in the browser env,
// or used directly when debugging nodeJS.

// Data needs to be referenced via a global object, otherwise extension and
// Arcs have different instances.
const root = typeof window === 'object' ? window : global;

if (!root._arcDebugPromise) {
  root._arcDebugPromise = new Promise(resolve => {
    root._arcDebugPromiseResolve = resolve;
  });
}

class DevtoolsBroker {
  static get onceConnected() {
    return root._arcDebugPromise;
  }
  static markConnected() {
    root._arcDebugPromiseResolve();
  }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class AbstractDevtoolsChannel {
    constructor() {
        this.debouncedMessages = [];
        this.messageListeners = new Map();
        this.timer = null;
    }
    send(message) {
        this.ensureNoCycle(message);
        this.debouncedMessages.push(message);
        // Temporary workaround for WebRTC slicing messages above 2^18 characters.
        // Need to find a proper fix. Is there some config in WebRTC to fix this?
        // If not prefer to slice messages based on their serialized form.
        // Maybe zip them for transport?
        if (this.debouncedMessages.length > 10) {
            this._empty();
        }
        else if (!this.timer) {
            this.timer = setTimeout(() => this._empty(), 100);
        }
    }
    listen(arcOrId, messageType, listener) {
        assert(messageType);
        assert(arcOrId);
        const arcId = typeof arcOrId === 'string' ? arcOrId : arcOrId.id.toString();
        const key = `${arcId}/${messageType}`;
        let listeners = this.messageListeners.get(key);
        if (!listeners) {
            this.messageListeners.set(key, listeners = []);
        }
        listeners.push(listener);
    }
    forArc(arc) {
        return new ArcDevtoolsChannel(arc, this);
    }
    async _handleMessage(msg) {
        const listeners = this.messageListeners.get(`${msg.arcId}/${msg.messageType}`);
        if (!listeners) {
            console.warn(`No one is listening to ${msg.messageType} message`);
        }
        else {
            await Promise.all(listeners.map(l => l(msg)));
        }
    }
    _empty() {
        this._flush(this.debouncedMessages);
        this.debouncedMessages = [];
        clearTimeout(this.timer);
        this.timer = null;
    }
    _flush(_messages) {
        throw new Error('Not implemented in an abstract class');
    }
    // tslint:disable-next-line: no-any
    ensureNoCycle(object, objectPath = []) {
        if (!object || typeof object !== 'object')
            return;
        assert(objectPath.indexOf(object) === -1, 'Message cannot contain a cycle');
        objectPath.push(object);
        (Array.isArray(object) ? object : Object.values(object)).forEach(element => this.ensureNoCycle(element, objectPath));
        objectPath.pop();
    }
}
class ArcDevtoolsChannel {
    constructor(arc, channel) {
        this.channel = channel;
        this.arcId = arc.id.toString();
    }
    send(message) {
        this.channel.send({
            meta: { arcId: this.arcId },
            ...message
        });
    }
    listen(messageType, callback) {
        this.channel.listen(this.arcId, messageType, callback);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class DevtoolsChannel extends AbstractDevtoolsChannel {
    constructor() {
        super();
        this.server = new WebSocket.Server({ port: 8787 });
        this.server.on('connection', (ws) => {
            this.socket = ws;
            this.socket.on('message', (msg) => {
                if (msg === 'init') {
                    DevtoolsBroker.markConnected();
                }
                else {
                    void this._handleMessage(JSON.parse(msg));
                }
            });
        });
    }
    _flush(messages) {
        if (this.socket) {
            this.socket.send(JSON.stringify(messages));
        }
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
let channel = null;
let isConnected = false;
let onceConnectedResolve = null;
let onceConnected = new Promise(resolve => onceConnectedResolve = resolve);
DevtoolsBroker.onceConnected.then(() => {
    DevtoolsConnection.ensure();
    onceConnectedResolve(channel);
    isConnected = true;
});
class DevtoolsConnection {
    static get isConnected() {
        return isConnected;
    }
    static get onceConnected() {
        return onceConnected;
    }
    static get() {
        return channel;
    }
    static ensure() {
        if (!channel)
            channel = new DevtoolsChannel();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Particle that can render and process events.
 */
class UiSimpleParticle extends Particle$1 {
    /**
     * Override if necessary, to modify superclass config.
     */
    get config() {
        // TODO(sjmiles): getter that does work is a bad idea, this is temporary
        return {
            handleNames: this.spec.inputs.map(i => i.name),
            // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from
            // .arcs files, instead of .ptcl ones.
            slotNames: this.spec.slandleConnectionNames()
        };
    }
    /**
     * Override to return a template.
     */
    get template() {
        return '';
    }
    /**
     * Override to return a String defining primary markup for the given slot name.
     */
    // getTemplate(slotName: string): string {
    //   // TODO: only supports a single template for now. add multiple templates support.
    //   return this.template;
    // }
    /**
     * Override to return a String defining the name of the template for the given slot name.
     */
    // getTemplateName(slotName: string): string {
    //   // TODO: only supports a single template for now. add multiple templates support.
    //   return `default`;
    // }
    /**
     * Override to return false if the Particle isn't ready to `render()`
     */
    shouldRender(...args) {
        return true;
    }
    renderOutput(...args) {
        const renderModel = this.render(...args);
        if (renderModel) {
            this.renderModel(renderModel);
        }
    }
    // This is the default output 'packet', other implementations (modalities) could
    // output other things, or choose different output packets based on hints from 'model'
    renderModel(model) {
        this.output({
            template: this.template,
            model
        });
    }
    /**
     * Override to return a dictionary to map into the template.
     */
    render(stateArgs) {
        return {};
    }
    _getStateArgs() {
        return [];
    }
    // forceRenderTemplate(slotName: string = ''): void {
    //   this.slotProxiesByName.forEach((slot: SlotProxy, name: string) => {
    //     if (!slotName || (name === slotName)) {
    //       slot.requestedContentTypes.add('template');
    //     }
    //   });
    // }
    fireEvent(slotName, { handler, data }) {
        if (this[handler]) {
            this[handler]({ data });
        }
    }
    async setParticleDescription(pattern) {
        if (typeof pattern === 'string') {
            return super.setParticleDescription(pattern);
        }
        if (pattern.template && pattern.model) {
            await super.setDescriptionPattern('_template_', pattern.template);
            await super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));
            return undefined;
        }
        else {
            throw new Error('Description pattern must either be string or have template and model');
        }
    }
    /**
     * Remove all entities from named handle.
     */
    async clearHandle(handleName) {
        const handle = this.handles.get(handleName);
        if (handle instanceof Singleton || handle instanceof Collection) {
            await handle.clear();
        }
        else {
            throw new Error('Singleton/Collection required');
        }
    }
    /**
     * Merge entities from Array into named handle.
     */
    async mergeEntitiesToHandle(handleName, entities) {
        const idMap = {};
        const handle = this.handles.get(handleName);
        if (handle instanceof Collection) {
            const handleEntities = await handle.toList();
            handleEntities.forEach(entity => idMap[entity.id] = entity);
            for (const entity of entities) {
                if (!idMap[this.idFor(entity)]) {
                    await handle.store(entity);
                }
            }
        }
        else {
            throw new Error('Collection required');
        }
    }
    /**
     * Append entities from Array to named handle.
     */
    async appendEntitiesToHandle(handleName, entities) {
        const handle = this.handles.get(handleName);
        if (handle) {
            if (handle instanceof Collection || handle instanceof BigCollection) {
                await Promise.all(entities.map(entity => handle.store(entity)));
            }
            else {
                throw new Error('Collection required');
            }
        }
    }
    /**
     * Create an entity from each rawData, and append to named handle.
     */
    async appendRawDataToHandle(handleName, rawDataArray) {
        const handle = this.handles.get(handleName);
        if (handle && handle.entityClass) {
            if (handle instanceof Collection || handle instanceof BigCollection) {
                const entityClass = handle.entityClass;
                await Promise.all(rawDataArray.map(raw => handle.store(new entityClass(raw))));
            }
            else {
                throw new Error('Collection required');
            }
        }
    }
    /**
     * Modify value of named handle. A new entity is created
     * from `rawData` (`new [EntityClass](rawData)`).
     */
    async updateSingleton(handleName, rawData) {
        const handle = this.handles.get(handleName);
        if (handle && handle.entityClass) {
            if (handle instanceof Singleton) {
                const entity = new handle.entityClass(rawData);
                await handle.set(entity);
                return entity;
            }
            else {
                throw new Error('Singleton required');
            }
        }
        return undefined;
    }
    /**
     * Modify or insert `entity` into named handle.
     * Modification is done by removing the old entity and reinserting the new one.
     */
    async updateCollection(handleName, entity) {
        // Set the entity into the right place in the set. If we find it
        // already present replace it, otherwise, add it.
        // TODO(dstockwell): Replace this with happy entity mutation approach.
        const handle = this.handles.get(handleName);
        if (handle) {
            if (handle instanceof Collection || handle instanceof BigCollection) {
                await handle.remove(entity);
                await handle.store(entity);
            }
            else {
                throw new Error('Collection required');
            }
        }
    }
    // TODO(sjmiles): experimental: high-level handle set
    async set(name, value) {
        const handle = this.handles.get(name);
        if (handle) {
            // TODO(sjmiles): cannot test class of `handle` because I have no
            // references to those classes, i.e. `handle is Singleton`, throws
            // because Singleton is undefined.
            if (handle.type['isEntity']) {
                const entity = value.entityClass ? value : new (handle.entityClass)(value);
                return await handle['set'](entity);
            }
            else if (handle.type['isCollection']) {
                if (Array.isArray(value)) {
                    await this.clearHandle(name);
                    await this.appendRawDataToHandle(name, value);
                }
            }
        }
    }
    /**
     * Return array of Entities dereferenced from array of Share-Type Entities
     */
    async derefShares(shares) {
        let entities = [];
        this.startBusy();
        try {
            const derefPromises = shares.map(async (share) => share.ref.dereference());
            entities = await Promise.all(derefPromises);
        }
        finally {
            this.doneBusy();
        }
        return entities;
    }
    /**
     * Returns array of Entities found in BOXED data `box` that are owned by `userid`
     */
    async boxQuery(box, userid) {
        if (!box) {
            return [];
        }
        else {
            const matches = box.filter(item => userid === item.fromKey);
            return await this.derefShares(matches);
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Particle that interoperates with DOM and uses a simple state system
 * to handle updates.
 */
// TODO(sjmiles): seems like this is really `UiStatefulParticle` but it's
// used so often, I went with the simpler name
class UiParticle extends XenStateMixin(UiSimpleParticle) {
    /**
     * Override if necessary, to do things when props change.
     * Avoid if possible, use `update` instead.
     */
    willReceiveProps(...args) {
    }
    // affordance so subclasses can avoid `_`
    _willReceiveProps(...args) {
        this.willReceiveProps(...args);
    }
    /**
     * Override to do things when props or state change.
     */
    update(...args) {
    }
    /**
     * Override to return a dictionary to map into the template.
     */
    render(...args) {
        return {};
    }
    /**
     * Copy values from `state` into the particle's internal state,
     * triggering an update cycle unless currently updating.
     */
    setState(state) {
        return this._setState(state);
    }
    /**
     * Getters and setters for working with state/props.
     */
    get state() {
        return this._state;
    }
    /**
     * Syntactic sugar: `this.state = {state}` is equivalent to `this.setState(state)`.
     * This is actually a merge, not an assignment.
     */
    set state(state) {
        this.setState(state);
    }
    get props() {
        return this._props;
    }
    _update(...args) {
        this.update(...args);
        //
        if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?
            this.relevance = 1; // TODO: improve relevance signal.
            this.renderOutput(...args);
        }
    }
    _async(fn) {
        // asynchrony in Particle code must be bookended with start/doneBusy
        this.startBusy();
        const done = () => {
            try {
                fn.call(this);
            }
            finally {
                this.doneBusy();
            }
        };
        // TODO(sjmiles): superclass uses Promise.resolve(),
        // but here use a short timeout for a wider debounce
        return setTimeout(done, 10);
    }
    async setHandles(handles) {
        this.configureHandles(handles);
        this.handles = handles;
        // TODO(sjmiles): we must invalidate at least once, is there a way to know
        // whether handleSync/update will be called?
        this._invalidate();
    }
    /**
     * This is called once during particle setup. Override to control sync and update
     * configuration on specific handles (via their configure() method).
     * `handles` is a map from names to handle instances.
     */
    configureHandles(handles) {
        // Example: handles.get('foo').configure({keepSynced: false});
    }
    async onHandleSync(handle, model) {
        this._setProperty(handle.name, model);
    }
    async onHandleUpdate({ name }, { data, added, removed }) {
        if (data !== undefined) {
            //console.log('update.data:', JSON.stringify(data, null, '  '));
            this._setProps({ [name]: data });
        }
        if (added) {
            //console.log('update.added:', JSON.stringify(added, null, '  '));
            const prop = (this.props[name] || []).concat(added);
            // TODO(sjmiles): generally improper to set `this._props` directly, this is a special case
            this._props[name] = prop;
            this._setProps({ [name]: prop });
        }
        if (removed) {
            //console.log('update.removed:', JSON.stringify(removed, null, '  '));
            const prop = this.props[name];
            if (Array.isArray(prop)) {
                removed.forEach(removed => {
                    // TODO(sjmiles): linear search is inefficient
                    const index = prop.findIndex(entry => this.idFor(entry) === this.idFor(removed));
                    if (index >= 0) {
                        prop.splice(index, 1);
                    }
                    else {
                        console.warn(`dom-particle::onHandleUpdate: couldn't find item to remove`);
                    }
                });
                this._setProps({ [name]: prop });
            }
        }
    }
    fireEvent(slotName, { handler, data }) {
        if (this[handler]) {
            // TODO(sjmiles): remove deprecated `this._state` parameter
            this[handler]({ data }, this._state);
        }
    }
    debounce(key, func, delay) {
        const subkey = `_debounce_${key}`;
        const state = this.state;
        if (!state[subkey]) {
            state[subkey] = true;
            this.startBusy();
        }
        const idleThenFunc = () => {
            this.doneBusy();
            func();
            state[subkey] = null;
        };
        // TODO(sjmiles): rewrite Xen debounce so caller has idle control
        super._debounce(key, idleThenFunc, delay);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Particle that does transformation.
 */
class UiTransformationParticle extends UiParticle {
    getTemplate(slotName) {
        // TODO: add support for multiple slots.
        return this.state.template;
    }
    getTemplateName(slotName) {
        // TODO: add support for multiple slots.
        return this.state.templateName;
    }
    render(props, state) {
        return state.renderModel;
    }
    shouldRender(props, state) {
        return Boolean((state.template || state.templateName) && state.renderModel);
    }
    // Helper methods that may be reused in transformation particles to combine hosted content.
    static propsToItems(propsValues) {
        return propsValues ? propsValues.map(e => ({ subId: Entity.id(e), ...e })) : [];
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class UiMultiplexerParticle extends UiTransformationParticle {
    async setHandles(handles) {
        this.plexeds = [];
        const arc = await this.constructInnerArc();
        const listHandleName = 'list';
        const particleHandleName = 'hostedParticle';
        const particleHandle = handles.get(particleHandleName);
        let hostedParticle = null;
        let otherMappedHandles = [];
        let otherConnections = [];
        if (particleHandle) {
            hostedParticle = await particleHandle['get']();
            if (hostedParticle) {
                ({ otherMappedHandles, otherConnections } =
                    await this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc));
            }
        }
        this.setState({
            arc,
            type: handles.get(listHandleName).type,
            hostedParticle,
            otherMappedHandles,
            otherConnections
        });
        await super.setHandles(handles);
    }
    async update({ list }, { arc, type, hostedParticle, otherMappedHandles, otherConnections }, oldProps, oldState) {
        //console.warn(`[${this.spec.name}]::update`, list, arc);
        if (!list || !arc) {
            return;
        }
        if (oldProps.list === list && oldState.arc === arc) {
            return;
        }
        if (list.length > 0) {
            this.relevance = 0.1;
        }
        // TODO(sjmiles): needs safety for re-entrant update
        //const slotIds = [];
        for (const [index, item] of this.getListEntries(list)) {
            //const id = await this.updateEntry(index, item, {arc, type, hostedParticle, otherConnections, otherMappedHandles});
            //slotIds.push(id);
            await this.updateEntry(index, item, { arc, type, hostedParticle, otherConnections, otherMappedHandles });
        }
        //console.warn('m-d-p', slotIds);
        // clear data from unused particles/handles
        for (let i = list.length, plexed; (plexed = this.plexeds[i]); i++) {
            plexed.then(plexed => plexed.handle['clear']());
        }
    }
    async updateEntry(index, item, { hostedParticle, arc, type, otherConnections, otherMappedHandles }) {
        if (!hostedParticle && !item.renderParticleSpec) {
            // If we're muxing on behalf of an item with an embedded recipe, the
            // hosted particle should be retrievable from the item itself. Else we
            // just skip this item.
            return;
        }
        //console.log(`RenderEx:updateEntry: %c[${index}]`, 'color: #A00; font-weight: bold;');
        // Map innerArc/slot by index. Index maps closely to rendering contexts.
        // Rendering contexts are expensive, we want maximal coherence.
        const plexed = await this.requirePlexed(index, item, { hostedParticle, arc, type, otherConnections, otherMappedHandles });
        // TODO(sjmiles): work out a proper cast (and conditional), or fix upstream type
        plexed.handle['set'](item);
        return plexed.slotId;
    }
    async requirePlexed(index, item, { arc, type, hostedParticle, otherConnections, otherMappedHandles }) {
        let promise = this.plexeds[index];
        if (!promise) {
            // eslint-disable-next-line no-async-promise-executor
            promise = new Promise(async (resolve) => {
                const handle = await this.acquireItemHandle(index, { arc, item, type });
                const hosting = await this.resolveHosting(item, { arc, hostedParticle, otherConnections, otherMappedHandles });
                const result = { arc, handle, hosting, slotId: null };
                result.slotId = await this.createInnards(item, result);
                resolve(result);
            });
            this.plexeds[index] = promise;
        }
        return await promise;
    }
    async resolveHosting(item, { arc, hostedParticle, otherConnections, otherMappedHandles }) {
        return hostedParticle ?
            { hostedParticle, otherConnections, otherMappedHandles }
            : await this.resolveHostedParticle(item, arc);
    }
    async acquireItemHandle(index, { arc, item, type }) {
        const handlePromise = arc.createHandle(type.getContainedType(), `item${index}`);
        return await handlePromise;
    }
    async resolveHostedParticle(item, arc) {
        const hostedParticle = ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));
        // Re-map compatible handles and compute the connections specific
        // to this item's render particle.
        const listHandleName = 'list';
        const particleHandleName = 'renderParticle';
        const { otherConnections, otherMappedHandles } = await this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, this.handles, arc);
        return { otherConnections, otherMappedHandles, hostedParticle };
    }
    async _mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc) {
        const otherMappedHandles = [];
        const otherConnections = [];
        let index = 2;
        const skipConnectionNames = [listHandleName, particleHandleName];
        for (const [connectionName, otherHandle] of handles) {
            if (!skipConnectionNames.includes(connectionName)) {
                // TODO(wkorman): For items with embedded recipes we may need a map
                // (perhaps id to index) to make sure we don't map a handle into the inner
                // arc multiple times unnecessarily.
                // TODO(lindner): type erasure to avoid mismatch of Store vs Handle in arc.mapHandle
                // tslint:disable-next-line: no-any
                const otherHandleStore = otherHandle.storage;
                otherMappedHandles.push(`use '${await arc.mapHandle(otherHandleStore)}' as v${index}`);
                //
                const hostedOtherConnection = hostedParticle.handleConnections.find(conn => conn.isCompatibleType(otherHandle.type));
                if (hostedOtherConnection) {
                    otherConnections.push(`${hostedOtherConnection.name} = v${index++}`);
                    // TODO(wkorman): For items with embedded recipes where we may have a
                    // different particle rendering each item, we need to track
                    // |connByHostedConn| keyed on the particle type.
                    //this._connByHostedConn.set(hostedOtherConnection.name, connectionName);
                }
            }
        }
        return { otherMappedHandles, otherConnections };
    }
    async createInnards(item, { arc, handle, hosting: { hostedParticle, otherMappedHandles, otherConnections } }) {
        const hostedSlotName = [...hostedParticle.slotConnections.keys()][0];
        const slotName = [...this.spec.slotConnections.values()][0].name;
        const slotId = await arc.createSlot(this, slotName, handle._id);
        if (slotId) {
            try {
                const recipe = this.constructInnerRecipe(hostedParticle, item, handle, { name: hostedSlotName, id: slotId }, { connections: otherConnections, handles: otherMappedHandles });
                await arc.loadRecipe(recipe);
            }
            catch (e) {
                console.warn(e);
            }
        }
        return slotId;
    }
    // Called with the list of items and by default returns the direct result of
    // `Array.entries()`. Subclasses can override this method to alter the item
    // order or otherwise permute the items as desired before their slots are
    // created and contents are rendered.
    getListEntries(list) {
        return list.entries();
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const html$1 = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();
class PlatformLoaderBase extends Loader {
    constructor(urlMap) {
        super();
        this._urlMap = urlMap || [];
    }
    async loadResource(name) {
        const path = this.resolve(name);
        return super.loadResource(path);
    }
    resolve(path) {
        let url = this._urlMap[path];
        if (!url && path) {
            // TODO(sjmiles): inefficient!
            const macro = Object.keys(this._urlMap).sort((a, b) => b.length - a.length).find(k => path.slice(0, k.length) === k);
            if (macro) {
                url = this._urlMap[macro] + path.slice(macro.length);
            }
        }
        url = this.normalizeDots(url || path);
        return url;
    }
    mapParticleUrl(path) {
        if (!path) {
            return undefined;
        }
        const parts = path.split('/');
        const suffix = parts.pop();
        const folder = parts.join('/');
        const resolved = this.resolve(folder);
        if (!suffix.endsWith('.wasm')) {
            const name = suffix.split('.').shift();
            this._urlMap[name] = resolved;
        }
        this._urlMap['$here'] = resolved;
        this._urlMap['$module'] = resolved;
    }
    unwrapParticle(particleWrapper, log) {
        return particleWrapper({
            // Particle base
            Particle: Particle$1,
            // Dom-flavored Particles (deprecated?)
            DomParticle,
            MultiplexerDomParticle,
            TransformationDomParticle,
            // Ui-flavored Particles
            UiParticle,
            UiMultiplexerParticle,
            // utilities
            resolver: this.resolve.bind(this),
            log: log || (() => { }),
            html: html$1
        });
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class PlatformLoader extends PlatformLoaderBase {
    async requireParticle(fileName) {
        const path = this.resolve(fileName);
        // inject path to this particle into the UrlMap,
        // allows "foo.js" particle to invoke `importScripts(resolver('foo/othermodule.js'))`
        this.mapParticleUrl(path);
        return super.requireParticle(path);
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const pecIndustry = loader => {
    return (pecId, idGenerator) => {
        const channel = new MessageChannel();
        const _throwAway = new ParticleExecutionContext(channel.port1, pecId, idGenerator, loader);
        return channel.port2;
    };
};

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ArcStoresFetcher {
    constructor(arc, arcDevtoolsChannel) {
        this.watchedHandles = new Set();
        this.arc = arc;
        this.arcDevtoolsChannel = arcDevtoolsChannel;
        arcDevtoolsChannel.listen('fetch-stores', async () => arcDevtoolsChannel.send({
            messageType: 'fetch-stores-result',
            messageBody: await this.listStores()
        }));
    }
    onRecipeInstantiated() {
        for (const store of this.arc._stores) {
            if (!this.watchedHandles.has(store.id)) {
                this.watchedHandles.add(store.id);
                store.on('change', async () => this.arcDevtoolsChannel.send({
                    messageType: 'store-value-changed',
                    messageBody: {
                        id: store.id.toString(),
                        value: await this.dereference(store)
                    }
                }), this);
            }
        }
    }
    async listStores() {
        const find = (manifest) => {
            let tags = [...manifest.storeTags];
            if (manifest.imports) {
                manifest.imports.forEach(imp => tags = tags.concat(find(imp)));
            }
            return tags;
        };
        return {
            arcStores: await this.digestStores([...this.arc.storeTags]),
            contextStores: await this.digestStores(find(this.arc.context))
        };
    }
    async digestStores(stores) {
        const result = [];
        for (const [store, tags] of stores) {
            result.push({
                name: store.name,
                tags: tags ? [...tags] : [],
                id: store.id,
                storage: store.storageKey,
                type: store.type,
                description: store.description,
                value: await this.dereference(store)
            });
        }
        return result;
    }
    // tslint:disable-next-line: no-any
    async dereference(store) {
        if (store.toList) {
            return store.toList();
        }
        else if (store.get) {
            return store.get();
        }
        else {
            return `(don't know how to dereference)`;
        }
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function now() {
    const time = process.hrtime();
    return time[0] * 1000 + time[1] / 1000000;
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Provides access to device hardware resource metrics for a node process.
class DeviceInfo {
    // Returns the number of logical cores.
    static hardwareConcurrency() {
        return os.cpus().length;
    }
    // Returns the device memory in gigabytes.
    static deviceMemory() {
        // Convert bytes to gigabytes.
        return os.totalmem() / Math.pow(1024, 3);
    }
}

/**
 * @license
 * Copyright 2015 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const events = [];
let pid;
let now$1;
if (typeof document === 'object') {
    pid = 42;
    now$1 = () => {
        return performance.now() * 1000;
    };
}
else {
    pid = process.pid;
    now$1 = () => {
        const t = process.hrtime();
        return t[0] * 1000000 + t[1] / 1000;
    };
}
let flowId = 0;
function parseInfo(info) {
    if (!info) {
        return {};
    }
    if (typeof info === 'function') {
        return parseInfo(info());
    }
    if (info.toTraceInfo) {
        return parseInfo(info.toTraceInfo());
    }
    return info;
}
const streamingCallbacks = [];
function pushEvent(event) {
    event.pid = pid;
    event.tid = 0;
    if (!event.args) {
        delete event.args;
    }
    if (!event.ov) {
        delete event.ov;
    }
    if (!event.cat) {
        event.cat = '';
    }
    // Only keep events in memory if we're not streaming them.
    if (streamingCallbacks.length === 0)
        events.push(event);
    void Promise.resolve().then(() => {
        for (const { callback, predicate } of streamingCallbacks) {
            if (!predicate || predicate(event))
                callback(event);
        }
    });
}
const module_ = { exports: {} };
// tslint:disable-next-line: variable-name
const Tracing = module_.exports;
module_.exports.enabled = false;
module_.exports.enable = () => {
    if (!module_.exports.enabled) {
        module_.exports.enabled = true;
        init();
    }
};
function init() {
    const result = {
        async wait(v) {
            return v;
        },
        start() {
            return this;
        },
        end() {
            return this;
        },
        step() {
            return this;
        },
        addArgs() {
        },
        async endWith(v) {
            return v;
        },
    };
    module_.exports.wrap = (info, fn) => {
        return fn;
    };
    module_.exports.start = (info) => {
        return result;
    };
    module_.exports.flow = (info) => {
        return result;
    };
    if (!module_.exports.enabled) {
        return;
    }
    module_.exports.wrap = (info, fn) => {
        return (...args) => {
            const t = module_.exports.start(info);
            try {
                return fn(...args);
            }
            finally {
                t.end();
            }
        };
    };
    function startSyncTrace(info) {
        info = parseInfo(info);
        let args = info.args;
        const begin = now$1();
        return {
            addArgs(extraArgs) {
                args = { ...(args || {}), ...extraArgs };
            },
            end(endInfo = {}, flow) {
                endInfo = parseInfo(endInfo);
                if (endInfo.args) {
                    args = { ...(args || {}), ...endInfo.args };
                }
                endInfo = { ...info, ...endInfo };
                this.endTs = now$1();
                pushEvent({
                    ph: 'X',
                    ts: begin,
                    dur: this.endTs - begin,
                    cat: endInfo.cat,
                    name: endInfo.name,
                    ov: endInfo.overview,
                    args,
                    // Arcs Devtools Specific:
                    flowId: flow && flow.id(),
                    seq: endInfo.sequence
                });
            },
            beginTs: begin
        };
    }
    module_.exports.start = (info) => {
        let trace = startSyncTrace(info);
        let flow;
        const baseInfo = { cat: info.cat, name: info.name + ' (async)', overview: info.overview, sequence: info.sequence };
        return {
            async wait(v, info) {
                const flowExisted = !!flow;
                if (!flowExisted) {
                    flow = module_.exports.flow(baseInfo);
                }
                trace.end(info, flow);
                if (flowExisted) {
                    flow.step({ ts: trace.beginTs, ...baseInfo });
                }
                else {
                    flow.start({ ts: trace.endTs });
                }
                trace = null;
                try {
                    return await v;
                }
                finally {
                    trace = startSyncTrace(baseInfo);
                }
            },
            addArgs(extraArgs) {
                trace.addArgs(extraArgs);
            },
            end(endInfo) {
                trace.end(endInfo, flow);
                if (flow) {
                    flow.end({ ts: trace.beginTs });
                }
            },
            async endWith(v, endInfo) {
                if (Promise.resolve(v) === v) { // If v is a promise.
                    v = this.wait(v, null);
                    try {
                        return await v;
                    }
                    finally {
                        this.end(endInfo);
                    }
                }
                else { // If v is not a promise.
                    this.end(endInfo);
                    return v;
                }
            }
        };
    };
    module_.exports.flow = (info) => {
        info = parseInfo(info);
        const id = flowId++;
        let started = false;
        return {
            start(startInfo) {
                const ts = (startInfo && startInfo.ts) || now$1();
                started = true;
                pushEvent({
                    ph: 's',
                    ts,
                    cat: info.cat,
                    name: info.name,
                    ov: info.overview,
                    args: info.args,
                    id,
                    seq: info.sequence
                });
                return this;
            },
            end(endInfo) {
                if (!started)
                    return this;
                const ts = (endInfo && endInfo.ts) || now$1();
                endInfo = parseInfo(endInfo);
                pushEvent({
                    ph: 'f',
                    bp: 'e',
                    ts,
                    cat: info.cat,
                    name: info.name,
                    ov: info.overview,
                    args: endInfo && endInfo.args,
                    id,
                    seq: info.sequence
                });
                return this;
            },
            step(stepInfo) {
                if (!started)
                    return this;
                const ts = (stepInfo && stepInfo.ts) || now$1();
                stepInfo = parseInfo(stepInfo);
                pushEvent({
                    ph: 't',
                    ts,
                    cat: info.cat,
                    name: info.name,
                    ov: info.overview,
                    args: stepInfo && stepInfo.args,
                    id,
                    seq: info.sequence
                });
                return this;
            },
            id: () => id
        };
    };
    module_.exports.save = () => {
        return { traceEvents: events };
    };
    module_.exports.download = () => {
        const a = document.createElement('a');
        a.download = 'trace.json';
        a.href = 'data:text/plain;base64,' + btoa(JSON.stringify(module_.exports.save()));
        a.click();
    };
    module_.exports.now = now$1;
    module_.exports.stream = (callback, predicate) => {
        // Once we start streaming we no longer keep events in memory.
        events.length = 0;
        streamingCallbacks.push({ callback, predicate });
    };
    module_.exports.__clearForTests = () => {
        events.length = 0;
        streamingCallbacks.length = 0;
    };
}
init();

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// TODO(wkorman): Incorporate debug levels. Consider outputting
// preamble in the specified color via ANSI escape codes. Consider
// sharing with similar log factory logic in `xen.js`. See `log-web.js`.
const _logFactory = (preamble, color, log='log') => {
  return console[log].bind(console, `(${preamble})`);
};

const factory = global.logLevel < 1 ? () => () => {} : _logFactory;

const logFactory = (...args) => factory(...args);

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Suggestion {
    constructor(plan, hash, rank, versionByStore) {
        // TODO: update Description class to be serializable.
        this.descriptionByModality = {};
        this.versionByStore = {};
        // List of search resolved token groups, this suggestion corresponds to.
        this.searchGroups = [];
        assert(plan, `plan cannot be null`);
        assert(hash, `hash cannot be null`);
        this.plan = plan;
        this.planString = this.plan.toString();
        this.hash = hash;
        this.rank = rank;
        this.versionByStore = versionByStore;
        // TODO(mmandlis): backward compatility for existing suggestions that include undefined
        // versions. Code can be deleted, after we upgrade above 0_6 or wipe out the storage.
        for (const store in this.versionByStore) {
            if (this.versionByStore[store] === undefined) {
                delete this.versionByStore[store];
            }
        }
    }
    static create(plan, hash, relevance) {
        assert(plan, `plan cannot be null`);
        assert(hash, `hash cannot be null`);
        const suggestion = new Suggestion(plan, hash, relevance ? relevance.calcRelevanceScore() : 0, relevance ? relevance.versionByStore : {});
        suggestion.setSearch(plan.search);
        return suggestion;
    }
    get descriptionText() {
        return this.getDescription('text');
    }
    getDescription(modality) {
        return this.descriptionByModality[modality];
    }
    setDescription(description, modality, descriptionFormatter = DescriptionFormatter) {
        this.descriptionByModality['text'] = description.getRecipeSuggestion();
        for (const planModality of this.plan.modality.names || []) {
            if (modality.names.includes(planModality)) {
                this.descriptionByModality[planModality] =
                    description.getRecipeSuggestion(descriptionFormatter);
            }
        }
    }
    isEquivalent(other) {
        return (this.hash === other.hash) && (this.descriptionText === other.descriptionText);
    }
    isEqual(other) {
        return this.isEquivalent(other) &&
            this.rank === other.rank &&
            this._isSameSearch(other) &&
            this._isSameDescription(other) &&
            this._isSameVersions(other);
    }
    _isSameSearch(other) {
        return this.searchGroups.length === other.searchGroups.length &&
            this.searchGroups.every(search => other.hasSearchGroup(search));
    }
    _isSameDescription(other) {
        return Object.keys(this.descriptionByModality).length === Object.keys(other.descriptionByModality).length &&
            Object.keys(this.descriptionByModality).every(key => JSON.stringify(this.descriptionByModality[key]) === JSON.stringify(other.descriptionByModality[key]));
    }
    _isSameVersions(other) {
        const storeIds = Object.keys(this.versionByStore);
        return storeIds.length === Object.keys(other.versionByStore).length &&
            storeIds.every(id => this.versionByStore[id] === other.versionByStore[id]);
    }
    static compare(s1, s2) {
        return s2.rank - s1.rank;
    }
    hasSearch(search) {
        return this.hasSearchGroup(search.split(' '));
    }
    hasSearchGroup(tokens) {
        return this.searchGroups.some(group => tokens.every(token => group.includes(token)));
    }
    setSearch(search) {
        this.searchGroups = [];
        if (search) {
            this._addSearch(search.resolvedTokens);
        }
    }
    mergeSearch(suggestion) {
        let updated = false;
        if (suggestion.searchGroups.length === 0) {
            this._addSearch(['']);
        }
        for (const other of suggestion.searchGroups) {
            if (this._addSearch(other)) {
                if (this.searchGroups.length === 1) {
                    this.searchGroups.push(['']);
                }
                updated = true;
            }
        }
        this.searchGroups.sort();
        return updated;
    }
    _addSearch(searchGroup) {
        const equivalentGroup = (group, otherGroup) => {
            return group.length === otherGroup.length &&
                group.every(token => otherGroup.includes(token));
        };
        if (!this.searchGroups.find(group => equivalentGroup(group, searchGroup))) {
            this.searchGroups.push(searchGroup);
            return true;
        }
        return false;
    }
    toLiteral() {
        return {
            plan: this.planString,
            hash: this.hash,
            rank: this.rank,
            // Needs to JSON.strigify because store IDs may contain invalid FB key symbols.
            versionByStore: JSON.stringify(this.versionByStore),
            searchGroups: this.searchGroups,
            descriptionByModality: this.descriptionByModality
        };
    }
    static async fromLiteral({ plan, hash, rank, versionByStore, searchGroups, descriptionByModality }, { context, loader }) {
        const manifest = await Manifest.parse(plan, { loader, context, fileName: '' });
        assert(manifest.recipes.length === 1);
        const recipe = manifest.recipes[0];
        const options = { errors: new Map() };
        assert(recipe.normalize(options), `can't normalize deserialized suggestion: ${plan} ${JSON.stringify([...options.errors])}`);
        const suggestion = new Suggestion(recipe, hash, rank, JSON.parse(versionByStore || '{}'));
        suggestion.searchGroups = searchGroups || [];
        suggestion.descriptionByModality = descriptionByModality;
        return suggestion;
    }
    async instantiate(arc) {
        // For now shell is responsible for creating and setting the new arc.
        assert(arc, `Cannot instantiate suggestion without and arc`);
        const plan = await this.getResolvedPlan(arc);
        assert(plan && plan.isResolved(), `can't resolve plan: ${this.plan.toString({ showUnresolved: true })}`);
        return arc.instantiate(plan);
    }
    async getResolvedPlan(arc) {
        if (this.plan.isResolved()) {
            return this.plan;
        }
        // TODO(mmandlis): Is this still needed? Find out why and fix.
        const recipeResolver = new RecipeResolver(arc);
        return recipeResolver.resolve(this.plan);
    }
    isUpToDate(arc, plan) {
        const arcVersionByStoreId = arc.getVersionByStore({ includeArc: true, includeContext: true });
        return plan.handles.every(handle => arcVersionByStoreId[handle.id] === this.versionByStore[handle.id]);
    }
    isVisible(arc, filter, options) {
        const logReason = (label) => {
            if (options && options.reasons) {
                options.reasons.push(label);
            }
        };
        const slandles = this.plan.handles.filter(handle => handle.type.isSlot()
            || handle.type.isCollectionType() && handle.type.collectionType.isSlot()).length;
        if (slandles + this.plan.slots.length === 0) {
            logReason(`No slots`);
            return false;
        }
        if (!this.descriptionText) {
            logReason(`No description`);
            return false;
        }
        if (!arc.modality.isCompatible(this.plan.modality.names)) {
            logReason(`Incompatible modalities ${this.plan.modality.names.join(', ')} with Arc modalities: ${arc.modality.names.join(', ')}`);
            return false;
        }
        if (filter.showAll) {
            return true;
        }
        if (filter.search) {
            if (!this.descriptionText.toLowerCase().includes(filter.search) && !this.hasSearch(filter.search)) {
                logReason(`Description doesn't match search filter: ${filter.search}`);
                return false;
            }
            return true;
        }
        if (!this.plan.slots.find(isRoot) &&
            !((this.plan.slotConnections || []).find(sc => sc.name === 'root'))) {
            // suggestion uses only non 'root' slots.
            // TODO: should check against slot-composer's root contexts instead.
            return true;
        }
        const usesHandlesFromActiveRecipe = this.plan.handles.some(handle => {
            // TODO(mmandlis): find a generic way to exclude system handles (eg Theme),
            // either by tagging or by exploring connection directions etc.
            return !!handle.id &&
                !!arc.activeRecipe.handles.find(activeHandle => activeHandle.id === handle.id);
        });
        if (!usesHandlesFromActiveRecipe) {
            logReason(`No active recipe handles`);
            return false;
        }
        const usesRemoteNonRootSlots = this.plan.slots.some(slot => {
            return !isRoot(slot) && Boolean(arc.pec.slotComposer.findContextById(slot.id));
        });
        if (!usesRemoteNonRootSlots) {
            logReason(`No remote non-root slots.`);
            return false;
        }
        return true;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const error = logFactory('PlanningResult', '#ff0090', 'error');
class PlanningResult {
    constructor(envOptions, store) {
        this.suggestions = [];
        this.lastUpdated = new Date();
        this.generations = [];
        this.contextual = true;
        this.changeCallbacks = [];
        this.envOptions = envOptions;
        assert(envOptions.context, `context cannot be null`);
        assert(envOptions.loader, `loader cannot be null`);
        this.store = store;
        if (this.store) {
            this.storeCallback = () => this.load();
            this.store.on('change', this.storeCallback, this);
        }
    }
    registerChangeCallback(callback) {
        this.changeCallbacks.push(callback);
    }
    onChanged() {
        for (const callback of this.changeCallbacks) {
            callback();
        }
    }
    async load() {
        const value = await this.store.get() || {};
        if (value.suggestions) {
            if (await this.fromLiteral(value)) {
                return true;
            }
        }
        return false;
    }
    async flush() {
        try {
            await this.store.set(this.toLiteral());
        }
        catch (e) {
            error('Failed storing suggestions: ', e);
            throw e;
        }
    }
    async clear() {
        return this.store.clear();
    }
    dispose() {
        this.changeCallbacks = [];
        this.store.off('change', this.storeCallback);
        this.store.dispose();
    }
    static formatSerializableGenerations(generations) {
        // Make a copy of everything and assign IDs to recipes.
        const idMap = new Map(); // Recipe -> ID
        let lastID = 0;
        const assignIdAndCopy = recipe => {
            idMap.set(recipe, lastID);
            const { result, score, derivation, description, hash, valid, active, irrelevant } = recipe;
            const resultString = result.toString({ showUnresolved: true, showInvalid: false, details: '' });
            const resolved = result.isResolved();
            return { result: resultString, resolved, score, derivation, description, hash, valid, active, irrelevant, id: lastID++ };
        };
        generations = generations.map(pop => ({
            record: pop.record,
            generated: pop.generated.map(assignIdAndCopy)
        }));
        // Change recipes in derivation to IDs and compute resolved stats.
        return generations.map(pop => {
            const population = pop.generated;
            const record = pop.record;
            // Adding those here to reuse recipe resolution computation.
            record.resolvedDerivations = 0;
            record.resolvedDerivationsByStrategy = {};
            for (const item of population) {
                item.derivation = item.derivation.map(derivItem => {
                    let parent;
                    let strategy;
                    if (derivItem.parent) {
                        parent = idMap.get(derivItem.parent);
                    }
                    if (derivItem.strategy) {
                        strategy = derivItem.strategy.constructor.name;
                    }
                    return { parent, strategy };
                });
                if (item.resolved) {
                    record.resolvedDerivations++;
                    const strategy = item.derivation[0].strategy;
                    if (record.resolvedDerivationsByStrategy[strategy] === undefined) {
                        record.resolvedDerivationsByStrategy[strategy] = 0;
                    }
                    record.resolvedDerivationsByStrategy[strategy]++;
                }
            }
            const populationMap = {};
            for (const item of population) {
                if (populationMap[item.derivation[0].strategy] == undefined) {
                    populationMap[item.derivation[0].strategy] = [];
                }
                populationMap[item.derivation[0].strategy].push(item);
            }
            const result = { population: [], record };
            for (const strategy of Object.keys(populationMap)) {
                result.population.push({ strategy, recipes: populationMap[strategy] });
            }
            return result;
        });
    }
    _set({ suggestions, lastUpdated = new Date(), generations = [], contextual = true }) {
        this.suggestions = suggestions;
        this.generations = generations;
        this.lastUpdated = lastUpdated;
        this.contextual = contextual;
        this.onChanged();
    }
    merge({ suggestions, lastUpdated = new Date(), generations = [], contextual = true }, arc) {
        const newSuggestions = [];
        const removeIndexes = [];
        const arcVersionByStore = arc.getVersionByStore({ includeArc: true, includeContext: true });
        for (const newSuggestion of suggestions) {
            const index = this.suggestions.findIndex(suggestion => suggestion.isEquivalent(newSuggestion));
            if (index >= 0) {
                if (this.suggestions[index].isEqual(newSuggestion)) {
                    continue; // skip suggestion, if identical to an existing one.
                }
                const outdatedStores = Object.keys(newSuggestion.versionByStore).filter(storeId => {
                    const currentVersion = this.suggestions[index].versionByStore[storeId];
                    return currentVersion === undefined || newSuggestion.versionByStore[storeId] < currentVersion;
                });
                if (outdatedStores.length > 0) {
                    console.warn(`New suggestions has older store versions:\n ${outdatedStores.map(id => `${id}: ${this.suggestions[index].versionByStore[id]} -> ${newSuggestion.versionByStore[id]}`).join(';')}`);
                    // Note: This happens due to #2638. Revisit, when fixed.
                    // assert(false);
                }
                removeIndexes.push(index);
                newSuggestion.mergeSearch(this.suggestions[index]);
            }
            if (this._isUpToDate(newSuggestion, arcVersionByStore)) {
                newSuggestions.push(newSuggestion);
            }
        }
        // Keep suggestions (1) not marked for remove (2) up-to-date with the arcs store versions and
        // (3) not in active recipe.
        const jointSuggestions = this.suggestions.filter((suggestion, index) => {
            return !removeIndexes.some(removeIndex => removeIndex === index) &&
                this._isUpToDate(suggestion, arcVersionByStore) &&
                !RecipeUtil.matchesRecipe(arc.activeRecipe, suggestion.plan);
        });
        if (jointSuggestions.length === this.suggestions.length && newSuggestions.length === 0) {
            return false;
        }
        jointSuggestions.push(...newSuggestions);
        this._set({ suggestions: jointSuggestions, generations: this.generations.concat(...generations), lastUpdated, contextual: contextual && this.contextual });
        return true;
    }
    _isUpToDate(suggestion, versionByStore) {
        for (const handle of suggestion.plan.handles) {
            const arcVersion = versionByStore[handle.id] || 0;
            const relevanceVersion = suggestion.versionByStore[handle.id] || 0;
            if (relevanceVersion < arcVersion) {
                return false;
            }
        }
        return true;
    }
    isEquivalent(suggestions) {
        return PlanningResult.isEquivalent(this.suggestions, suggestions);
    }
    static isEquivalent(oldSuggestions, newSuggestions) {
        assert(newSuggestions, `New suggestions cannot be null.`);
        return oldSuggestions &&
            oldSuggestions.length === newSuggestions.length &&
            oldSuggestions.every(suggestion => newSuggestions.find(newSuggestion => suggestion.isEquivalent(newSuggestion)));
    }
    async fromLiteral({ suggestions, generations, lastUpdated, contextual }) {
        const deserializedSuggestions = [];
        for (const suggestion of suggestions) {
            deserializedSuggestions.push(await Suggestion.fromLiteral(suggestion, this.envOptions));
        }
        if (this.isEquivalent(deserializedSuggestions)) {
            return false;
        }
        this._set({
            suggestions: deserializedSuggestions,
            generations: JSON.parse(generations || '[]'),
            lastUpdated: new Date(lastUpdated),
            contextual
        });
        return true;
    }
    toLiteral() {
        return {
            suggestions: this.suggestions.map(suggestion => suggestion.toLiteral()),
            generations: JSON.stringify(this.generations),
            lastUpdated: this.lastUpdated.toString(),
            contextual: this.contextual
        };
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Strategizer {
    constructor(strategies, evaluators, ruleset) {
        this._generation = 0;
        this._internalPopulation = [];
        this._population = [];
        this._generated = [];
        this._terminal = [];
        this._strategies = strategies;
        this._evaluators = evaluators;
        this._ruleset = ruleset;
        this.populationHash = new Map();
    }
    // Latest generation number.
    get generation() {
        return this._generation;
    }
    // All individuals in the current population.
    get population() {
        return this._population;
    }
    // Individuals of the latest generation.
    get generated() {
        return this._generated;
    }
    /**
     * @return Individuals from the previous generation that were not descended from in the
     * current generation.
     */
    get terminal() {
        assert(this._terminal);
        return this._terminal;
    }
    async generate() {
        // Generate
        const generation = this.generation + 1;
        const generatedResults = await Promise.all(this._strategies.map(async (strategy) => {
            const recipeFilter = (recipe) => this._ruleset.isAllowed(strategy, recipe);
            return strategy.generate({
                generation: this.generation,
                generated: this.generated.filter(recipeFilter),
                terminal: this.terminal.filter(recipeFilter),
                population: this.population.filter(recipeFilter)
            });
        }));
        const record = {
            generation,
            sizeOfLastGeneration: this.generated.length,
            generatedDerivationsByStrategy: {}
        };
        for (let i = 0; i < this._strategies.length; i++) {
            record.generatedDerivationsByStrategy[this._strategies[i].constructor.name] = generatedResults[i].length;
        }
        let generated = [].concat(...generatedResults);
        // TODO: get rid of this additional asynchrony
        generated = await Promise.all(generated.map(async (result) => {
            if (result.hash) {
                result.hash = await result.hash;
            }
            return result;
        }));
        record.generatedDerivations = generated.length;
        record.nullDerivations = 0;
        record.invalidDerivations = 0;
        record.duplicateDerivations = 0;
        record.duplicateSameParentDerivations = 0;
        record.nullDerivationsByStrategy = {};
        record.invalidDerivationsByStrategy = {};
        record.duplicateDerivationsByStrategy = {};
        record.duplicateSameParentDerivationsByStrategy = {};
        generated = generated.filter(result => {
            const strategy = result.derivation[0].strategy.constructor.name;
            if (result.hash) {
                const existingResult = this.populationHash.get(result.hash);
                if (existingResult) {
                    if (result.derivation[0].parent === existingResult) {
                        record.nullDerivations += 1;
                        if (record.nullDerivationsByStrategy[strategy] == undefined) {
                            record.nullDerivationsByStrategy[strategy] = 0;
                        }
                        record.nullDerivationsByStrategy[strategy]++;
                    }
                    else if (existingResult.derivation.map(a => a.parent).indexOf(result.derivation[0].parent) !== -1) {
                        record.duplicateSameParentDerivations += 1;
                        if (record.duplicateSameParentDerivationsByStrategy[strategy] ==
                            undefined) {
                            record.duplicateSameParentDerivationsByStrategy[strategy] = 0;
                        }
                        record.duplicateSameParentDerivationsByStrategy[strategy]++;
                    }
                    else {
                        record.duplicateDerivations += 1;
                        if (record.duplicateDerivationsByStrategy[strategy] == undefined) {
                            record.duplicateDerivationsByStrategy[strategy] = 0;
                        }
                        record.duplicateDerivationsByStrategy[strategy]++;
                        this.populationHash.get(result.hash).derivation.push(result.derivation[0]);
                    }
                    return false;
                }
                this.populationHash.set(result.hash, result);
            }
            if (result.valid === false) {
                record.invalidDerivations++;
                record.invalidDerivationsByStrategy[strategy] = (record.invalidDerivationsByStrategy[strategy] || 0) + 1;
                return false;
            }
            return true;
        });
        const terminalMap = new Map();
        for (const candidate of this.generated) {
            terminalMap.set(candidate.result, candidate);
        }
        // TODO(piotrs): This is inefficient, improve at some point.
        for (const result of this.populationHash.values()) {
            for (const { parent } of result.derivation) {
                if (parent && terminalMap.has(parent.result)) {
                    terminalMap.delete(parent.result);
                }
            }
        }
        const terminal = [...terminalMap.values()];
        record.survivingDerivations = generated.length;
        generated.sort((a, b) => {
            if (a.score > b.score) {
                return -1;
            }
            if (a.score < b.score) {
                return 1;
            }
            return 0;
        });
        const evaluations = await Promise.all(this._evaluators.map(async (strategy) => {
            return strategy.evaluate(this, generated);
        }));
        const fitness = Strategizer._mergeEvaluations(evaluations, generated);
        assert(fitness.length === generated.length);
        for (let i = 0; i < fitness.length; i++) {
            this._internalPopulation.push({
                fitness: fitness[i],
                individual: generated[i],
            });
        }
        // TODO: Instead of push+sort, merge `internalPopulation` with `generated`.
        this._internalPopulation.sort((x, y) => y.fitness - x.fitness);
        // Publish
        this._terminal = terminal;
        this._generation = generation;
        this._generated = generated;
        this._population = this._internalPopulation.map(x => x.individual);
        return record;
    }
    static _mergeEvaluations(evaluations, generated) {
        const n = generated.length;
        const mergedEvaluations = [];
        for (let i = 0; i < n; i++) {
            let merged = NaN;
            for (const evaluation of evaluations) {
                const fitness = evaluation[i];
                if (isNaN(fitness)) {
                    continue;
                }
                if (isNaN(merged)) {
                    merged = fitness;
                }
                else {
                    // TODO: how should evaluations be combined?
                    merged = (merged * i + fitness) / (i + 1);
                }
            }
            if (isNaN(merged)) {
                // TODO: What should happen when there was no evaluation?
                merged = 0.5;
            }
            mergedEvaluations.push(merged);
        }
        return mergedEvaluations;
    }
}
class StrategizerWalker extends RecipeWalker {
    constructor(tactic) {
        super(tactic);
    }
    createDescendant(recipe, score) {
        assert(this.currentAction instanceof Strategy, 'no current strategy');
        // Note that the currentAction assertion in the superclass method is now
        // guaranteed to succeed.
        super.createDescendant(recipe, score);
    }
    static over(results, walker, strategy) {
        return super.walk(results, walker, strategy);
    }
}
// TODO: Doc call convention, incl strategies are stateful.
class Strategy extends Action {
    constructor(arc, args) {
        super(arc, args);
    }
    async activate(strategizer) {
        // Returns estimated ability to generate/evaluate.
        // TODO: What do these numbers mean? Some sort of indication of the accuracy of the
        // generated individuals and evaluations.
        return { generate: 0, evaluate: 0 };
    }
    async evaluate(strategizer, individuals) {
        return individuals.map(() => NaN);
    }
}
class RulesetBuilder {
    constructor() {
        this._orderingRules = new Map();
    }
    /**
     * When invoked for strategies (A, B), ensures that B will never follow A in
     * the chain of derivations of all generated recipes.
     *
     * Following sequences are therefore valid: A, B, AB, AAABB, AC, DBC, CADCBCBD
     * Following sequences are therefore invalid: BA, ABA, BCA, DBCA
     *
     * Transitive closure of the ordering is computed.
     * I.e. For orderings (A, B) and (B, C), the ordering (A, C) is implied.
     *
     * Method can be called with multiple strategies at once.
     * E.g. (A, B, C) implies (A, B), (B, C) and transitively (A, C).
     *
     * Method can be called with arrays of strategies, which represent groups.
     * The ordering in the group is not enforced, but the ordering between them is.
     * E.g. ([A, B], [C, D], E) is a shorthand for:
     * (A, C), (A, D), (B, C), (B, D), (C, E), (D, E).
     */
    order(...strategiesOrGroups) {
        for (let i = 0; i < strategiesOrGroups.length - 1; i++) {
            const current = strategiesOrGroups[i];
            const next = strategiesOrGroups[i + 1];
            for (const strategy of Array.isArray(current) ? current : [current]) {
                let set = this._orderingRules.get(strategy);
                if (!set) {
                    this._orderingRules.set(strategy, set = new Set());
                }
                for (const nextStrategy of Array.isArray(next) ? next : [next]) {
                    set.add(nextStrategy);
                }
            }
        }
        return this;
    }
    build() {
        // Making the ordering transitive.
        const beingExpanded = new Set();
        const alreadyExpanded = new Set();
        for (const strategy of this._orderingRules.keys()) {
            this._transitiveClosureFor(strategy, beingExpanded, alreadyExpanded);
        }
        return new Ruleset(this._orderingRules);
    }
    _transitiveClosureFor(strategy, beingExpanded, alreadyExpanded) {
        assert(!beingExpanded.has(strategy), 'Detected a loop in the ordering rules');
        const followingStrategies = this._orderingRules.get(strategy);
        if (alreadyExpanded.has(strategy))
            return followingStrategies || new Set();
        if (followingStrategies) {
            beingExpanded.add(strategy);
            for (const following of followingStrategies) {
                for (const expanded of this._transitiveClosureFor(following, beingExpanded, alreadyExpanded)) {
                    followingStrategies.add(expanded);
                }
            }
            beingExpanded.delete(strategy);
        }
        alreadyExpanded.add(strategy);
        return followingStrategies || new Set();
    }
}
class Ruleset {
    constructor(orderingRules) {
        this._orderingRules = orderingRules;
    }
    isAllowed(strategy, recipe) {
        const forbiddenAncestors = this._orderingRules.get(strategy.constructor);
        if (!forbiddenAncestors)
            return true;
        // TODO: This can be sped up with AND-ing bitsets of derivation strategies and forbiddenAncestors.
        return !recipe.derivation.some(d => forbiddenAncestors.has(d.strategy.constructor));
    }
}
// tslint:disable-next-line: variable-name
Ruleset.Builder = RulesetBuilder;

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class AddMissingHandles extends Strategy {
    // TODO: move generation to use an async generator.
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onRecipe(recipe) {
                // Don't add use handles while there are outstanding constraints
                if (recipe.connectionConstraints.length > 0) {
                    return undefined;
                }
                // Don't add use handles to a recipe with free handles
                if (recipe.getFreeHandles().length > 0) {
                    return undefined;
                }
                // TODO: "description" handles are always created, and in the future they need to be "optional" (blocked by optional handles
                // not being properly supported in arc instantiation). For now just hardcode skiping them.
                const disconnectedConnections = recipe.getFreeConnections();
                if (disconnectedConnections.length === 0) {
                    return undefined;
                }
                return (recipe) => {
                    disconnectedConnections.forEach(({ particle, connSpec }) => {
                        const cloneParticle = recipe.updateToClone({ particle }).particle;
                        const handleConnection = cloneParticle.addConnectionName(connSpec.name);
                        const handle = recipe.newHandle();
                        handle.fate = '?';
                        handleConnection.connectToHandle(handle);
                    });
                    return 0;
                };
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class AssignHandles extends Strategy {
    async generate(inputParams) {
        const self = this;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onHandle(recipe, handle) {
                if (!['?', 'use', 'copy', 'map'].includes(handle.fate)) {
                    return undefined;
                }
                if (handle.connections.length === 0) {
                    return undefined;
                }
                if (handle.id) {
                    return undefined;
                }
                if (!handle.type) {
                    return undefined;
                }
                // TODO: using the connection to retrieve type information is wrong.
                // Once validation of recipes generates type information on the handle
                // we should switch to using that instead.
                const counts = RecipeUtil.directionCounts(handle);
                if (counts['any'] > 0) { // Number of unknown handle directions.
                    return undefined;
                }
                const score = this._getScore(counts, handle.tags);
                if (counts.out > 0 && handle.fate === 'map') {
                    return undefined;
                }
                const stores = self.getMappableStores(handle.fate, handle.type, handle.tags, counts);
                if (handle.fate !== '?' && stores.size < 2) {
                    // These handles are mapped by resolve-recipe strategy.
                    return undefined;
                }
                const responses = [...stores.keys()].map(store => ((recipe, clonedHandle) => {
                    assert(store.id);
                    if (recipe.findHandleByID(store.id)) {
                        // TODO: Why don't we link the handle connections to the existingHandle?
                        return 0;
                    }
                    clonedHandle.mapToStorage(store);
                    if (clonedHandle.fate === '?') {
                        clonedHandle.fate = stores.get(store);
                    }
                    else {
                        assert(clonedHandle.fate, stores.get(store));
                    }
                    return score;
                }));
                return responses;
            }
            _getScore(counts, tags) {
                let score = -1;
                if (counts.in === 0 || counts.out === 0) {
                    if (counts.out === 0) {
                        score = 1;
                    }
                    else {
                        score = 0;
                    }
                }
                // TODO: Why is score negative, where there are both - in and out?
                if (tags.length > 0) {
                    score += 4;
                }
                return score;
            }
        }(StrategizerWalker.Permuted), this);
    }
    getMappableStores(fate, type, tags, counts) {
        const stores = new Map();
        if (fate === 'use' || fate === '?') {
            this.arc.findStoresByType(type, { tags }).forEach(store => stores.set(store, 'use'));
        }
        if (fate === 'map' || fate === 'copy' || fate === '?') {
            this.arc.context.findStoresByType(type, { tags, subtype: true }).forEach(store => stores.set(store, fate === '?' ? (counts.out > 0 ? 'copy' : 'map') : fate));
        }
        return stores;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// This strategy coalesces unresolved terminal recipes (i.e. those that cannot
// be modified by any strategy apart from this one) by finding unresolved
// use/? handle and finding a matching create/? handle in another recipe and
// merging those.
class CoalesceRecipes extends Strategy {
    constructor(arc, { recipeIndex }) {
        super(arc);
        this.recipeIndex = recipeIndex;
    }
    getResults(inputParams) {
        // Coalescing for terminal recipes that are either unresolved recipes or have no UI.
        return inputParams.terminal.filter(result => !result.result.isResolved() || result.result.slots.length === 0);
    }
    async generate(inputParams) {
        const arc = this.arc;
        const index = this.recipeIndex;
        await index.ready;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onPotentialSlotConnection(recipe, particle, slotSpec) {
                const results = [];
                // TODO: It is possible that provided-slot wasn't matched due to different handles, but actually
                // these handles are coalescable? Add support for this.
                for (const providedSlot of index.findProvidedSlot(particle, slotSpec)) {
                    // Don't grow recipes above 10 particles, otherwise we might never stop.
                    if (recipe.particles.length + providedSlot.recipe.particles.length > 10)
                        continue;
                    if (RecipeUtil.matchesRecipe(arc.activeRecipe, providedSlot.recipe)) {
                        // skip candidate recipe, if matches the shape of the arc's active recipe
                        continue;
                    }
                    results.push((recipe, particle, slotSpec) => {
                        const otherToHandle = index.findCoalescableHandles(recipe, providedSlot.recipe);
                        const { cloneMap } = providedSlot.recipe.mergeInto(recipe);
                        const mergedSlot = cloneMap.get(providedSlot);
                        const newSlotConnection = particle.addSlotConnection(slotSpec.name);
                        newSlotConnection.connectToSlot(mergedSlot);
                        this._connectOtherHandles(otherToHandle, cloneMap, false);
                        // Clear verbs and recipe name after coalescing two recipes.
                        recipe.verbs.splice(0);
                        recipe.name = null;
                        return 1;
                    });
                }
                if (results.length > 0) {
                    return results;
                }
                return undefined;
            }
            // Find a provided slot for unfulfilled consume connection.
            onSlotConnection(recipe, slotConnection) {
                if (slotConnection.isResolved()) {
                    return undefined;
                }
                if (!slotConnection.name || !slotConnection.particle) {
                    return undefined;
                }
                if (slotConnection.targetSlot) {
                    return undefined;
                }
                // TODO: also support a consume slot connection that is NOT required,
                // but no other connections are resolved.
                const results = [];
                // TODO: It is possible that provided-slot wasn't matched due to different handles, but actually
                // these handles are coalescable? Add support for this.
                for (const providedSlot of index.findProvidedSlot(slotConnection.particle, slotConnection.spec)) {
                    // Don't grow recipes above 10 particles, otherwise we might never stop.
                    if (recipe.particles.length + providedSlot.recipe.particles.length > 10)
                        continue;
                    if (RecipeUtil.matchesRecipe(arc.activeRecipe, providedSlot.recipe)) {
                        // skip candidate recipe, if matches the shape of the arc's active recipe
                        continue;
                    }
                    if (RecipeUtil.matchesRecipe(recipe, providedSlot.recipe)) {
                        // skip candidate recipe, if matches the shape of the currently explored recipe
                        continue;
                    }
                    results.push((recipe, slotConnection) => {
                        const otherToHandle = index.findCoalescableHandles(recipe, providedSlot.recipe);
                        const { cloneMap } = providedSlot.recipe.mergeInto(slotConnection.recipe);
                        const mergedSlot = cloneMap.get(providedSlot);
                        slotConnection.connectToSlot(mergedSlot);
                        this._connectOtherHandles(otherToHandle, cloneMap, false);
                        // Clear verbs and recipe name after coalescing two recipes.
                        recipe.verbs.splice(0);
                        recipe.name = null;
                        return 1;
                    });
                }
                if (results.length > 0) {
                    return results;
                }
                return undefined;
            }
            onSlot(recipe, slot) {
                // Find slots that according to their provided-spec must be consumed, but have no consume connection.
                if (slot.consumeConnections.length > 0) {
                    return undefined; // slot has consume connections.
                }
                if (!slot.sourceConnection || !slot.spec.isRequired) {
                    return undefined; // either a remote slot (no source connection), or a not required one.
                }
                const results = [];
                for (const { recipeParticle, slotSpec, matchingHandles } of index.findConsumeSlotConnectionMatch(slot.sourceConnection.particle, slot.spec)) {
                    // Don't grow recipes above 10 particles, otherwise we might never stop.
                    if (recipe.particles.length + recipeParticle.recipe.particles.length > 10)
                        continue;
                    if (RecipeUtil.matchesRecipe(arc.activeRecipe, recipeParticle.recipe)) {
                        // skip candidate recipe, if matches the shape of the arc's active recipe
                        continue;
                    }
                    if (RecipeUtil.matchesRecipe(recipe, recipeParticle.recipe)) {
                        // skip candidate recipe, if matches the shape of the currently explored recipe
                        continue;
                    }
                    results.push((recipe, slot) => {
                        // Find other handles that may be merged, as recipes are being coalesced.
                        const otherToHandle = index.findCoalescableHandles(recipe, recipeParticle.recipe, new Set(slot.handles.concat(matchingHandles.map(({ handle, matchingConn }) => matchingConn.handle))));
                        const { cloneMap } = recipeParticle.recipe.mergeInto(slot.recipe);
                        const slotConn = recipeParticle.getSlotConnectionByName(slot.name);
                        let mergedSlotConn = cloneMap.get(slotConn);
                        if (!mergedSlotConn) {
                            const clonedParticle = cloneMap.get(recipeParticle);
                            mergedSlotConn = clonedParticle.addSlotConnection(slotSpec.name);
                        }
                        mergedSlotConn.connectToSlot(slot);
                        for (const { handle, matchingConn } of matchingHandles) {
                            // matchingConn in the mergedSlotConnection's recipe should be connected to `handle` in the slot's recipe.
                            const mergedMatchingConn = cloneMap.get(matchingConn);
                            const disconnectedHandle = mergedMatchingConn.handle;
                            const clonedHandle = slot.findHandleByID(handle.id);
                            if (disconnectedHandle === clonedHandle) {
                                continue; // this handle was already reconnected
                            }
                            while (disconnectedHandle.connections.length > 0) {
                                const conn = disconnectedHandle.connections[0];
                                conn.disconnectHandle();
                                conn.connectToHandle(clonedHandle);
                            }
                            recipe.removeHandle(disconnectedHandle);
                        }
                        this._connectOtherHandles(otherToHandle, cloneMap, false);
                        // Clear verbs and recipe name after coalescing two recipes.
                        recipe.verbs.splice(0);
                        recipe.name = null;
                        // TODO: Merge description/patterns of both recipes.
                        // TODO: Unify common code in slot and handle recipe coalescing.
                        return 1;
                    });
                }
                if (results.length > 0) {
                    return results;
                }
                return undefined;
            }
            onHandle(recipe, handle) {
                if (!index.coalescableFates.includes(handle.fate)
                    || handle.id
                    || handle.connections.length === 0
                    || handle.name === 'descriptions')
                    return undefined;
                const results = [];
                for (const otherHandle of index.findHandleMatch(handle, index.coalescableFates)) {
                    // Don't grow recipes above 10 particles, otherwise we might never stop.
                    if (recipe.particles.length + otherHandle.recipe.particles.length > 10)
                        continue;
                    // This is a poor man's proxy for the other handle being an output of a recipe.
                    if (otherHandle.findConnectionByDirection('in'))
                        continue;
                    // We ignore type variables not constrained for reading, otherwise
                    // generic recipes would apply - which we currently don't want here.
                    if (otherHandle.type.hasVariable) {
                        let resolved = otherHandle.type.resolvedType();
                        // TODO: getContainedType returns non-null for references ... is that correct here?
                        resolved = resolved.getContainedType() || resolved;
                        if (resolved instanceof TypeVariable && !resolved.canReadSubset)
                            continue;
                    }
                    if (RecipeUtil.matchesRecipe(arc.activeRecipe, otherHandle.recipe)) {
                        // skip candidate recipe, if matches the shape of the arc's active recipe
                        continue;
                    }
                    if (RecipeUtil.matchesRecipe(recipe, otherHandle.recipe)) {
                        // skip candidate recipe, if matches the shape of the currently explored recipe
                        continue;
                    }
                    results.push((recipe, handle) => {
                        // Find other handles in the original recipe that could be coalesced with handles in otherHandle's recipe.
                        const otherToHandle = index.findCoalescableHandles(recipe, otherHandle.recipe, new Set([handle, otherHandle]));
                        const { cloneMap } = otherHandle.recipe.mergeInto(handle.recipe);
                        // Connect the handle that the recipes are being coalesced on.
                        cloneMap.get(otherHandle).mergeInto(handle);
                        // Connect all other connectable handles.
                        this._connectOtherHandles(otherToHandle, cloneMap, true);
                        // Clear verbs and recipe name after coalescing two recipes.
                        recipe.verbs.splice(0);
                        recipe.name = null;
                        // TODO: Merge description/patterns of both recipes.
                        return 1;
                    });
                }
                return results;
            }
            _connectOtherHandles(otherToHandle, cloneMap, verifyTypes) {
                otherToHandle.forEach((otherHandle, handle) => {
                    const otherHandleClone = cloneMap.get(otherHandle);
                    // For coalescing that was triggered by handle coalescing (vs slot or slot connection)
                    // once the main handle (one that triggered coalescing) was coalesced, types may have changed.
                    // Need to verify all the type information for the "other" coalescable handles is still valid.
                    // TODO(mmandlis): This is relying on only ever considering a single "other" handles to coalesce,
                    // so the handle either is still a valid match or not.
                    // In order to do it right for multiple handles, we need to try ALL handles,
                    // then fallback to all valid N-1 combinations, then N-2 etc.
                    if (verifyTypes) {
                        if (!this._reverifyHandleTypes(handle, otherHandleClone)) {
                            return;
                        }
                    }
                    otherHandleClone.mergeInto(handle);
                });
            }
            // Returns true, if both handles have types that can be coalesced.
            _reverifyHandleTypes(handle, otherHandle) {
                assert(handle.recipe === otherHandle.recipe);
                const cloneMap = new Map();
                const recipeClone = handle.recipe.clone(cloneMap);
                recipeClone.normalize();
                return Handle.effectiveType(cloneMap.get(handle).type, [...cloneMap.get(handle).connections, ...cloneMap.get(otherHandle).connections]);
            }
        }(StrategizerWalker.Independent), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ConvertConstraintsToConnections extends Strategy {
    async generate(inputParams) {
        const arcModality = this.arc.modality;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onRecipe(recipe) {
                if (recipe.connectionConstraints.length === 0) {
                    return undefined;
                }
                const modality = arcModality.intersection(recipe.modality);
                // The particles & handles Sets are used as input to RecipeUtil's shape functionality
                // (this is the algorithm that "finds" the constraint set in the recipe).
                // They track which particles/handles need to be found/created.
                const particles = new Set();
                const handleNames = new Map();
                const handles = new Set();
                // The map object tracks the connections between particles that need to be found/created.
                // It's another input to RecipeUtil.makeShape.
                const map = {};
                const particlesByName = {};
                let handleNameIndex = 0;
                function nameForHandle(handle, existingNames) {
                    if (existingNames.has(handle)) {
                        return existingNames.get(handle);
                    }
                    if (handle.localName) {
                        if (!handles.has(handle.localName)) {
                            existingNames.set(handle, handle.localName);
                            return handle.localName;
                        }
                    }
                    while (!handles.has('handle' + handleNameIndex)) {
                        handleNameIndex++;
                    }
                    existingNames.set(handle, 'handle' + handleNameIndex);
                    return 'handle' + (handleNameIndex++);
                }
                let handleCount = 0;
                const obligations = [];
                for (const constraint of recipe.connectionConstraints) {
                    const from = constraint.from;
                    const to = constraint.to;
                    // Don't process constraints if their listed particles don't match the current modality.
                    if (from instanceof ParticleEndPoint
                        && to instanceof ParticleEndPoint
                        && (!from.particle.isCompatible(modality) || !to.particle.isCompatible(modality))) {
                        return undefined;
                    }
                    // Set up initial mappings & input to RecipeUtil.
                    let handle;
                    let handleIsConcrete = false;
                    let createObligation = false;
                    if (from instanceof ParticleEndPoint) {
                        particles.add(from.particle.name);
                        if (map[from.particle.name] == undefined) {
                            map[from.particle.name] = {};
                            particlesByName[from.particle.name] = from.particle;
                        }
                        if (from.connection) {
                            handleIsConcrete = true;
                            handle = map[from.particle.name][from.connection];
                        }
                        else {
                            createObligation = true;
                        }
                    }
                    if (from instanceof HandleEndPoint) {
                        handle = { handle: nameForHandle(from.handle, handleNames), direction: reverseArrow(constraint.direction), localName: from.handle.localName };
                        handles.add(handle.handle);
                    }
                    if (to instanceof ParticleEndPoint) {
                        particles.add(to.particle.name);
                        if (map[to.particle.name] == undefined) {
                            map[to.particle.name] = {};
                            particlesByName[to.particle.name] = to.particle;
                        }
                        if (to.connection) {
                            handleIsConcrete = true;
                            if (!handle) {
                                handle =
                                    map[to.particle.name][to.connection];
                            }
                        }
                        else {
                            createObligation = true;
                        }
                    }
                    if (to instanceof HandleEndPoint) {
                        handle = { handle: nameForHandle(to.handle, handleNames), direction: constraint.direction, localName: to.handle.localName };
                        handles.add(handle.handle);
                    }
                    if (handle == undefined) {
                        handle = { handle: 'v' + handleCount++, direction: constraint.direction };
                        if (handleIsConcrete) {
                            handles.add(handle.handle);
                        }
                    }
                    if (from instanceof TagEndPoint) {
                        handle.tags = from.tags;
                    }
                    else if (to instanceof TagEndPoint) {
                        handle.tags = to.tags;
                    }
                    if (createObligation) {
                        obligations.push({
                            from: from._clone(),
                            to: to._clone(),
                            direction: constraint.direction
                        });
                    }
                    const unionDirections = (a, b) => {
                        if (a === '=') {
                            return '=';
                        }
                        if (b === '=') {
                            return '=';
                        }
                        if (a !== b) {
                            return '=';
                        }
                        return a;
                    };
                    let direction = constraint.direction;
                    if (from instanceof ParticleEndPoint) {
                        const connection = from.connection;
                        if (connection) {
                            const existingHandle = map[from.particle.name][connection];
                            if (existingHandle) {
                                direction = unionDirections(direction, existingHandle.direction);
                                if (direction == null) {
                                    return undefined;
                                }
                            }
                            map[from.particle.name][connection] = { handle: handle.handle, direction, tags: handle.tags, localName: handle.localName };
                        }
                    }
                    direction = reverseArrow(constraint.direction);
                    if (to instanceof ParticleEndPoint) {
                        const connection = to.connection;
                        if (connection) {
                            const existingHandle = map[to.particle.name][connection];
                            if (existingHandle) {
                                direction = unionDirections(direction, existingHandle.direction);
                                if (direction == null) {
                                    return undefined;
                                }
                            }
                            map[to.particle.name][connection] = { handle: handle.handle, direction, tags: handle.tags, localName: handle.localName };
                        }
                    }
                }
                const shape = RecipeUtil.makeShape([...particles.values()], [...handles.values()], map);
                const results = RecipeUtil.find(recipe, shape);
                const processedResults = results.filter(match => {
                    // Ensure that every handle is either matched, or an input of at least one
                    // connected particle in the constraints.
                    const resolvedHandles = {};
                    for (const particle of Object.keys(map)) {
                        for (const connection of Object.keys(map[particle])) {
                            const handle = map[particle][connection].handle;
                            if (resolvedHandles[handle]) {
                                continue;
                            }
                            if (match.match[handle]) {
                                resolvedHandles[handle] = true;
                            }
                            else {
                                const spec = particlesByName[particle];
                                resolvedHandles[handle] = spec.isOutput(connection);
                            }
                        }
                    }
                    return Object.values(resolvedHandles).every(value => value);
                }).map(match => {
                    return (recipe) => {
                        const score = recipe.connectionConstraints.length + match.score;
                        const recipeMap = recipe.updateToClone(match.match);
                        for (const particle of Object.keys(map)) {
                            let recipeParticle = recipeMap[particle];
                            if (!recipeParticle) {
                                recipeParticle = recipe.newParticle(particle);
                                recipeParticle.spec = particlesByName[particle];
                                recipeMap[particle] = recipeParticle;
                            }
                            for (const connection of Object.keys(map[particle])) {
                                const handle = map[particle][connection];
                                let recipeHandleConnection = recipeParticle.connections[connection];
                                if (recipeHandleConnection == undefined) {
                                    recipeHandleConnection =
                                        recipeParticle.addConnectionName(connection);
                                }
                                let recipeHandle = recipeMap[handle.handle];
                                if (recipeHandle == null && recipeHandleConnection.handle == null) {
                                    recipeHandle = recipe.newHandle();
                                    recipeHandle.fate = 'create';
                                    recipeHandle.tags = handle.tags || [];
                                    recipeMap[handle.handle] = recipeHandle;
                                }
                                if (recipeHandleConnection.handle == null) {
                                    recipeHandleConnection.connectToHandle(recipeHandle);
                                }
                            }
                        }
                        recipe.clearConnectionConstraints();
                        for (const obligation of obligations) {
                            if ((obligation.from instanceof ParticleEndPoint) && (obligation.to instanceof ParticleEndPoint)) {
                                const from = new InstanceEndPoint(recipeMap[obligation.from.particle.name], obligation.from.connection);
                                const to = new InstanceEndPoint(recipeMap[obligation.to.particle.name], obligation.to.connection);
                                recipe.newObligation(from, to, obligation.direction);
                            }
                            else {
                                throw new Error('constraints with a particle endpoint at one end but not at the other are not supported');
                            }
                        }
                        return score;
                    };
                });
                return processedResults;
            }
        }(StrategizerWalker.Independent), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class CreateDescriptionHandle extends Strategy {
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onHandleConnection(recipe, handleConnection) {
                if (handleConnection.handle) {
                    return undefined;
                }
                if (handleConnection.name !== 'descriptions') {
                    return undefined;
                }
                return (recipe, handleConnection) => {
                    return this._createAndConnectHandle(handleConnection);
                };
            }
            onPotentialHandleConnection(recipe, particle, connectionSpec) {
                if (connectionSpec.name !== 'descriptions') {
                    return undefined;
                }
                return (recipe, particle, connectionSpec) => {
                    return this._createAndConnectHandle(particle.addConnectionName(connectionSpec.name));
                };
            }
            _createAndConnectHandle(handleConnection) {
                const handle = handleConnection.recipe.newHandle();
                handle.fate = 'create';
                handleConnection.connectToHandle(handle);
                return 1;
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class CreateHandleGroup extends Strategy {
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onRecipe(recipe) {
                // Resolve constraints before assuming connections are free.
                if (recipe.connectionConstraints.length > 0)
                    return undefined;
                const freeConnections = recipe.getFreeConnections();
                let maximalGroup = null;
                for (const writer of freeConnections.filter(({ connSpec }) => connSpec.isOutput)) {
                    const compatibleConnections = [writer];
                    let effectiveType = Handle.effectiveType(null, compatibleConnections.map(cc => cc.connSpec));
                    let typeCandidate = null;
                    const involvedParticles = new Set([writer.particle]);
                    let foundSomeReader = false;
                    for (const reader of freeConnections.filter(({ connSpec }) => connSpec.isInput)) {
                        if (!involvedParticles.has(reader.particle) &&
                            (typeCandidate = Handle.effectiveType(effectiveType, [reader.connSpec])) !== null) {
                            compatibleConnections.push(reader);
                            involvedParticles.add(reader.particle);
                            effectiveType = typeCandidate;
                            foundSomeReader = true;
                        }
                    }
                    // Only make a 'create' group for a writer->reader case.
                    if (!foundSomeReader)
                        continue;
                    for (const otherWriter of freeConnections.filter(({ connSpec }) => connSpec.isOutput)) {
                        if (!involvedParticles.has(otherWriter.particle) &&
                            (typeCandidate = Handle.effectiveType(effectiveType, [otherWriter.connSpec])) !== null) {
                            compatibleConnections.push(otherWriter);
                            involvedParticles.add(otherWriter.particle);
                            effectiveType = typeCandidate;
                        }
                    }
                    if (!maximalGroup || compatibleConnections.length > maximalGroup.length) {
                        maximalGroup = compatibleConnections;
                    }
                }
                if (!maximalGroup) {
                    return undefined;
                }
                return (recipe) => {
                    const newHandle = recipe.newHandle();
                    newHandle.fate = 'create';
                    for (const { particle, connSpec } of maximalGroup) {
                        const cloneParticle = recipe.updateToClone({ particle }).particle;
                        const conn = cloneParticle.addConnectionName(connSpec.name);
                        conn.connectToHandle(newHandle);
                    }
                    return 0;
                };
            }
        }(StrategizerWalker.Independent), this);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class FindHostedParticle extends Strategy {
    async generate(inputParams) {
        const arc = this.arc;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onPotentialHandleConnection(recipe, particle, connectionSpec) {
                const matchingParticleSpecs = this._findMatchingParticleSpecs(arc, connectionSpec, connectionSpec.type);
                if (!matchingParticleSpecs) {
                    return undefined;
                }
                const results = [];
                for (const particleSpec of matchingParticleSpecs) {
                    results.push((recipe, particle, connectionSpec) => {
                        const handleConnection = particle.addConnectionName(connectionSpec.name);
                        const handle = RecipeUtil.constructImmediateValueHandle(handleConnection, particleSpec, arc.generateID());
                        assert(handle); // Type matching should have been ensure by the checks above;
                        handleConnection.connectToHandle(handle);
                    });
                }
                return results;
            }
            _findMatchingParticleSpecs(arc, connectionSpec, connectionType) {
                if (!connectionSpec) {
                    return undefined;
                }
                if (connectionSpec.direction !== 'host') {
                    return undefined;
                }
                assert(connectionType instanceof InterfaceType);
                const iface = connectionType;
                const particles = [];
                for (const particle of arc.context.allParticles) {
                    // This is what interfaceInfo.particleMatches() does, but we also do
                    // canEnsureResolved at the end:
                    const ifaceClone = iface.interfaceInfo.cloneWithResolutions(new Map());
                    // If particle doesn't match the requested interface.
                    if (ifaceClone.restrictType(particle) === false)
                        continue;
                    // If we still have unresolvable interface after matching a particle.
                    // This can happen if both interface and particle have type variables.
                    // TODO: What to do here? We need concrete type for the particle spec
                    //       handle, but we don't have one.
                    if (!ifaceClone.canEnsureResolved())
                        continue;
                    particles.push(particle);
                }
                return particles;
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class FindRequiredParticle extends Strategy {
    async generate(inputParams) {
        const arc = this.arc;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onRequiredParticle(_recipe, particle) {
                // TODO: This strategy only matches particles based on slots, and only slots in the recipe gets modified.
                //       This strategy should do the same for handles as well.
                const particlesMatch = arc.activeRecipe.particles.filter(arcParticle => particle.matches(arcParticle));
                return particlesMatch.map(particleMatch => ((recipe, particle) => {
                    if (!particle.matches(particleMatch))
                        return undefined;
                    for (const slotConn of particle.getSlotConnections()) {
                        const oldSlot = slotConn.targetSlot;
                        const matchedSlotConn = particleMatch.getSlotConnectionByName(slotConn.name);
                        const newSlot = matchedSlotConn.targetSlot;
                        if (!SlotUtils.replaceOldSlot(recipe, oldSlot, newSlot))
                            return undefined;
                        for (const [pname, oldPSlot] of Object.entries(slotConn.providedSlots)) {
                            const pslot = matchedSlotConn.providedSlots[pname];
                            if (!SlotUtils.replaceOldSlot(recipe, oldPSlot, pslot))
                                return undefined;
                        }
                        // remove particle from require section
                        for (const requires of recipe.requires) {
                            if (requires.particles.indexOf(particle) !== -1) {
                                requires.removeParticle(particle);
                            }
                        }
                    }
                    return 0;
                }));
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class GroupHandleConnections extends Strategy {
    constructor(arc, args) {
        super(arc, args);
        this._walker = new class extends StrategizerWalker {
            onRecipe(recipe) {
                // Only apply this strategy if ALL handle connections are named and have types.
                if (recipe.getUnnamedUntypedConnections()) {
                    return undefined;
                }
                // All particles must have spec.
                if (recipe.particles.some(p => !p.spec)) {
                    return undefined;
                }
                // Find all unique types used in the recipe that have unbound handle connections.
                const types = new Set();
                recipe.getFreeConnections().forEach(({ connSpec }) => {
                    if (!Array.from(types).find(type => TypeChecker.compareTypes({ type }, { type: connSpec.type }))) {
                        types.add(connSpec.type);
                    }
                });
                const groupsByType = new Map();
                for (const type of types) {
                    const sortedParticles = [...recipe.particles].sort((p1, p2) => {
                        return p2.getUnboundConnections(type).length - p1.getUnboundConnections(type).length;
                    }).filter(p => p.getUnboundConnections(type).length > 0);
                    assert(sortedParticles.length > 0);
                    // Handle connections of the same particle cannot be bound to the same handle. Iterate
                    // on handle connections of the particle with the most connections of the given type,
                    // and group each of them with same typed handle connections of other particles.
                    const particleWithMostConnectionsOfType = sortedParticles[0];
                    const groups = [];
                    let allTypeHandleConnections = recipe.getFreeConnections(type)
                        .filter(c => c.particle !== particleWithMostConnectionsOfType);
                    let iteration = 0;
                    while (allTypeHandleConnections.length > 0) {
                        for (const connSpec of particleWithMostConnectionsOfType.spec.handleConnections) {
                            if (!TypeChecker.compareTypes({ type }, { type: connSpec.type })) {
                                continue;
                            }
                            if (!groups.find(g => g.particle === particleWithMostConnectionsOfType && g.connSpec === connSpec)) {
                                groups.push({ particle: particleWithMostConnectionsOfType, connSpec, group: [] });
                            }
                            const group = groups.find(g => g.particle === particleWithMostConnectionsOfType && g.connSpec === connSpec).group;
                            // filter all connections where this particle is already in a group.
                            const possibleConnections = allTypeHandleConnections.filter(c => !group.find(gc => gc.particle === c.particle));
                            let selectedConn = possibleConnections.find(({ connSpec }) => connSpec.isInput !== connSpec.isInput || connSpec.isOutput !== connSpec.isOutput);
                            // TODO: consider tags.
                            // TODO: Slots handle restrictions should also be accounted for when grouping.
                            if (!selectedConn) {
                                if (possibleConnections.length === 0 || iteration === 0) {
                                    // During first iteration only bind opposite direction connections ("in" with "out" and vice versa)
                                    // to ensure each group has both direction connections as much as possible.
                                    continue;
                                }
                                selectedConn = possibleConnections[0];
                            }
                            group.push(selectedConn);
                            allTypeHandleConnections = allTypeHandleConnections.filter(({ connSpec }) => connSpec !== selectedConn.connSpec);
                        }
                        iteration++;
                    }
                    // Remove groups where no connections were bound together.
                    for (let i = 0; i < groups.length; ++i) {
                        if (groups[i].group.length === 0) {
                            groups.splice(i, 1);
                        }
                        else {
                            groups[i].group.push({ particle: groups[i].particle, connSpec: groups[i].connSpec });
                        }
                    }
                    if (groups.length !== 0) {
                        groupsByType.set(type, groups);
                    }
                }
                if (groupsByType.size > 0) {
                    return (recipe) => {
                        groupsByType.forEach((groups, type) => {
                            groups.forEach(({ group }) => {
                                const recipeHandle = recipe.newHandle();
                                for (const { particle, connSpec } of group) {
                                    const particleClone = recipe.updateToClone({ particle }).particle;
                                    if (!particleClone.connections[connSpec.name]) {
                                        particleClone.addConnectionName(connSpec.name);
                                    }
                                    const conn = particleClone.connections[connSpec.name];
                                    conn.connectToHandle(recipeHandle);
                                }
                            });
                        });
                        return 0;
                    };
                }
                return undefined;
            }
        }(StrategizerWalker.Permuted);
    }
    get walker() {
        return this._walker;
    }
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), this.walker, this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class InitPopulation extends Strategy {
    constructor(arc, { contextual = false, recipeIndex }) {
        super(arc, { contextual });
        this._contextual = contextual;
        this._recipeIndex = recipeIndex;
        this._loadedParticles = new Set(this.arc.loadedParticleSpecs().map(spec => spec.implFile));
    }
    async generate({ generation }) {
        if (generation !== 0) {
            return [];
        }
        await this._recipeIndex.ready;
        const results = this._contextual
            ? this._contextualResults()
            : this._allResults();
        return results.map(({ recipe, score = 1 }) => ({
            result: recipe,
            score,
            derivation: [{ strategy: this, parent: undefined }],
            hash: recipe.digest(),
            valid: Object.isFrozen(recipe)
        }));
    }
    _contextualResults() {
        const results = [];
        for (const particle of this.arc.activeRecipe.particles) {
            for (const [name, slotSpec] of particle.spec.slotConnections) {
                for (const providedSlotSpec of slotSpec.provideSlotConnections) {
                    results.push(...this._recipeIndex.findConsumeSlotConnectionMatch(particle, providedSlotSpec).map(({ recipeParticle }) => ({ recipe: recipeParticle.recipe })));
                }
            }
        }
        for (const handle of [].concat(...this.arc.allDescendingArcs.map(arc => arc.activeRecipe.handles))) {
            results.push(...this._recipeIndex.findHandleMatch(handle, ['use', '?']).map(otherHandle => ({ recipe: otherHandle.recipe })));
        }
        return results;
    }
    _allResults() {
        return this._recipeIndex.recipes.map(recipe => ({
            recipe,
            score: 1 - recipe.getParticlesByImplFile(this._loadedParticles).length
        }));
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class InitSearch extends Strategy {
    constructor(arc, { search }) {
        super(arc, { search });
        this._search = search;
    }
    async generate({ generation }) {
        if (this._search == null || generation !== 0) {
            return [];
        }
        const recipe = new Recipe();
        recipe.setSearchPhrase(this._search);
        assert(recipe.normalize());
        assert(!recipe.isResolved());
        return [{
                result: recipe,
                score: 0,
                derivation: [{ strategy: this, parent: undefined }],
                hash: recipe.digest(),
                valid: true
            }];
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class MapSlots extends Strategy {
    async generate(inputParams) {
        const arc = this.arc;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onPotentialSlotConnection(recipe, particle, slotSpec) {
                const { local, remote } = SlotUtils.findAllSlotCandidates(particle, slotSpec, arc);
                // ResolveRecipe handles one-slot case.
                if (local.length + remote.length < 2) {
                    return undefined;
                }
                // If there are any local slots, prefer them over remote slots.
                // TODO: There should not be any preference over local slots vs. remote slots.
                // Strategies should be responsible for making all possible recipes. Ranking of 
                // recipes is done later. 
                const slotList = local.length > 0 ? local : remote;
                return slotList.map(slot => ((recipe, particle, slotSpec) => {
                    const newSlotConnection = particle.addSlotConnection(slotSpec.name);
                    SlotUtils.connectSlotConnection(newSlotConnection, slot);
                    return 1;
                }));
            }
            // TODO: this deals with cases where a SlotConnection has been
            // created during parsing, so that provided slots inside the 
            // connection can be connected to consume connections.
            // Long term, we shouldn't have to do this, so we won't need
            // to deal with the case of a disconnected SlotConnection.
            onSlotConnection(recipe, slotConnection) {
                // don't try to connect verb constraints
                // TODO: is this right? Should constraints be connectible, in order to precompute the
                // recipe side once the verb is substituted?
                if (slotConnection.getSlotSpec() == undefined) {
                    return undefined;
                }
                if (slotConnection.isConnected()) {
                    return;
                }
                const slotSpec = slotConnection.getSlotSpec();
                const particle = slotConnection.particle;
                const { local, remote } = SlotUtils.findAllSlotCandidates(particle, slotSpec, arc);
                if (local.length + remote.length < 2) {
                    return undefined;
                }
                // If there are any local slots, prefer them over remote slots.
                const slotList = local.length > 0 ? local : remote;
                return slotList.map(slot => ((recipe, slotConnection) => {
                    SlotUtils.connectSlotConnection(slotConnection, slot);
                    return 1;
                }));
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/*
 * Match free handles (i.e. handles that aren't connected to any connections)
 * to connections.
 */
class MatchFreeHandlesToConnections extends Strategy {
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onHandle(recipe, handle) {
                if (handle.connections.length > 0) {
                    return;
                }
                const matchingConnections = recipe.getFreeConnections();
                return matchingConnections.map(({ particle, connSpec }) => {
                    return (recipe, handle) => {
                        const cloneParticle = recipe.updateToClone({ particle }).particle;
                        const newConnection = cloneParticle.addConnectionName(connSpec.name);
                        newConnection.connectToHandle(handle);
                        return 1;
                    };
                });
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class MatchParticleByVerb extends Strategy {
    async generate(inputParams) {
        const arc = this.arc;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onParticle(recipe, particle) {
                if (particle.name) {
                    // Particle already has explicit name.
                    return undefined;
                }
                const modality = arc.modality.intersection(recipe.modality);
                const particleSpecs = arc.context.findParticlesByVerb(particle.primaryVerb)
                    .filter(spec => spec.isCompatible(modality));
                return particleSpecs.map(spec => {
                    return (recipe, particle) => {
                        const score = 1;
                        particle.name = spec.name;
                        particle.spec = spec;
                        return score;
                    };
                });
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class MatchRecipeByVerb extends Strategy {
    async generate(inputParams) {
        const arc = this.arc;
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onParticle(recipe, particle) {
                if (particle.name) {
                    // Particle already has explicit name.
                    return undefined;
                }
                let recipes = arc.context.findRecipesByVerb(particle.primaryVerb);
                // Extract slot information from recipe. This is extracted in the form:
                // {consume-slot-name: targetSlot: <slot>, providedSlots: {provide-slot-name: <slot>}}
                //
                // Note that slots are only included if connected to other components of the recipe - e.g.
                // the target slot has a source connection.
                const slotConstraints = {};
                for (const consumeSlot of particle.getSlotConnections()) {
                    const targetSlot = consumeSlot.targetSlot && consumeSlot.targetSlot.sourceConnection ? consumeSlot.targetSlot : null;
                    slotConstraints[consumeSlot.name] = { targetSlot, providedSlots: {} };
                    for (const providedSlot of Object.keys(consumeSlot.providedSlots)) {
                        const sourceSlot = consumeSlot.providedSlots[providedSlot].consumeConnections.length > 0 ? consumeSlot.providedSlots[providedSlot] : null;
                        slotConstraints[consumeSlot.name].providedSlots[providedSlot] = sourceSlot;
                    }
                }
                const handleConstraints = { named: {}, unnamed: [] };
                for (const handleConnection of Object.values(particle.connections)) {
                    handleConstraints.named[handleConnection.name] = { direction: handleConnection.direction, handle: handleConnection.handle };
                }
                for (const unnamedConnection of particle.unnamedConnections) {
                    handleConstraints.unnamed.push({ direction: unnamedConnection.direction, handle: unnamedConnection.handle });
                }
                recipes = recipes.filter(recipe => MatchRecipeByVerb.satisfiesSlotConstraints(recipe, slotConstraints))
                    .filter(recipe => MatchRecipeByVerb.satisfiesHandleConstraints(recipe, handleConstraints));
                return recipes.map(recipe => {
                    return (outputRecipe, particleForReplacing) => {
                        const { particles } = recipe.mergeInto(outputRecipe);
                        particleForReplacing.remove();
                        for (const consumeSlot of Object.keys(slotConstraints)) {
                            const constraints = slotConstraints[consumeSlot];
                            if (constraints.targetSlot || Object.values(constraints.providedSlots).filter(a => a).length > 0) {
                                let slotMapped = false;
                                for (const particle of particles) {
                                    if (MatchRecipeByVerb.slotsMatchConstraint(particle, particle.getSlotSpecs(), consumeSlot, constraints.providedSlots)) {
                                        if (constraints.targetSlot) {
                                            const { mappedSlot } = outputRecipe.updateToClone({ mappedSlot: constraints.targetSlot });
                                            // if slotConnection doesn't exist, then create it before connecting it to slot.
                                            const consumeConn = particle.getSlotConnectionByName(consumeSlot) || particle.addSlotConnection(consumeSlot);
                                            consumeConn.targetSlot = mappedSlot;
                                            mappedSlot.consumeConnections.push(consumeConn);
                                        }
                                        for (const slotName of Object.keys(constraints.providedSlots)) {
                                            const slot = constraints.providedSlots[slotName];
                                            if (!slot) {
                                                continue;
                                            }
                                            const { mappedSlot } = outputRecipe.updateToClone({ mappedSlot: slot });
                                            const consumeConn = particle.getSlotConnectionByName(consumeSlot) || particle.addSlotConnection(consumeSlot);
                                            consumeConn.providedSlots[slotName].remove();
                                            consumeConn.providedSlots[slotName] = mappedSlot;
                                            mappedSlot._sourceConnection = consumeConn;
                                        }
                                        slotMapped = true;
                                        break;
                                    }
                                }
                                assert(slotMapped);
                            }
                        }
                        function tryApplyHandleConstraint(name, connSpec, particle, constraint, handle) {
                            let connection = particle.connections[name];
                            if (connection && connection.handle) {
                                return false;
                            }
                            if (!MatchRecipeByVerb.connectionMatchesConstraint(connection || connSpec, constraint)) {
                                return false;
                            }
                            connection = connection || particle.addConnectionName(connSpec.name);
                            for (let i = 0; i < handle.connections.length; i++) {
                                const candidate = handle.connections[i];
                                // TODO candidate.name === name triggers test failures
                                // tslint:disable-next-line: triple-equals
                                if (candidate.particle === particleForReplacing && candidate.name == name) {
                                    connection._handle = handle;
                                    handle.connections[i] = connection;
                                    return true;
                                }
                            }
                            return false;
                        }
                        function applyHandleConstraint(name, constraint, handle) {
                            const { mappedHandle } = outputRecipe.updateToClone({ mappedHandle: handle });
                            for (const particle of particles) {
                                if (name) {
                                    if (tryApplyHandleConstraint(name, particle.spec.getConnectionByName(name), particle, constraint, mappedHandle)) {
                                        return true;
                                    }
                                }
                                else {
                                    for (const connSpec of particle.spec.handleConnections) {
                                        if (tryApplyHandleConstraint(name, connSpec, particle, constraint, mappedHandle)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            return false;
                        }
                        for (const name in handleConstraints.named) {
                            if (handleConstraints.named[name].handle) {
                                assert(applyHandleConstraint(name, handleConstraints.named[name], handleConstraints.named[name].handle));
                            }
                        }
                        for (const connection of handleConstraints.unnamed) {
                            if (connection.handle) {
                                assert(applyHandleConstraint(null, connection, connection.handle));
                            }
                        }
                        return 1;
                    };
                });
            }
        }(StrategizerWalker.Permuted), this);
    }
    static satisfiesHandleConstraints(recipe, handleConstraints) {
        for (const handleName in handleConstraints.named) {
            if (!MatchRecipeByVerb.satisfiesHandleConnection(recipe, handleName, handleConstraints.named[handleName])) {
                return false;
            }
        }
        for (const handleConstraint of handleConstraints.unnamed) {
            if (!MatchRecipeByVerb.satisfiesUnnamedHandleConnection(recipe, handleConstraint)) {
                return false;
            }
        }
        return true;
    }
    static satisfiesUnnamedHandleConnection(recipe, handleConstraint) {
        // refuse to match unnamed handle connections unless some type information is present.
        if (!handleConstraint.handle) {
            return false;
        }
        for (const particle of recipe.particles) {
            for (const connection of Object.values(particle.connections)) {
                if (MatchRecipeByVerb.connectionMatchesConstraint(connection, handleConstraint)) {
                    return true;
                }
            }
            if (particle.spec) {
                for (const connectionSpec of particle.spec.handleConnections) {
                    if (MatchRecipeByVerb.connectionSpecMatchesConstraint(connectionSpec, handleConstraint)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    static satisfiesHandleConnection(recipe, handleName, handleConstraint) {
        for (const particle of recipe.particles) {
            if (particle.connections[handleName]) {
                if (MatchRecipeByVerb.connectionMatchesConstraint(particle.connections[handleName], handleConstraint)) {
                    return true;
                }
            }
            else if (particle.spec && particle.spec.getConnectionByName(handleName)) {
                if (MatchRecipeByVerb.connectionSpecMatchesConstraint(particle.spec.getConnectionByName(handleName), handleConstraint)) {
                    return true;
                }
            }
        }
        return false;
    }
    static connectionSpecMatchesConstraint(connSpec, handleConstraint) {
        if (connSpec.direction !== handleConstraint.direction) {
            return false;
        }
        return true;
    }
    static connectionMatchesConstraint(connection, handleConstraint) {
        if (connection.direction !== handleConstraint.direction) {
            return false;
        }
        if (!handleConstraint.handle) {
            return true;
        }
        const connections = [...handleConstraint.handle.connections, connection];
        return Boolean(Handle.effectiveType(handleConstraint.handle.mappedType, connections));
    }
    static satisfiesSlotConstraints(recipe, slotConstraints) {
        for (const slotName in slotConstraints) {
            if (!MatchRecipeByVerb.satisfiesSlotConnection(recipe, slotName, slotConstraints[slotName])) {
                return false;
            }
        }
        return true;
    }
    static satisfiesSlotConnection(recipe, slotName, constraints) {
        for (const particle of recipe.particles) {
            if (!particle.spec)
                continue;
            if (MatchRecipeByVerb.slotsMatchConstraint(particle, particle.getSlotSpecs(), slotName, constraints)) {
                return true;
            }
        }
        return false;
    }
    static slotsMatchConstraint(particle, slotSpecs, name, constraints) {
        if (!slotSpecs.get(name)) {
            return false;
        }
        const slotConn = particle.getSlotConnectionBySpec(slotSpecs.get(name));
        if (slotConn && slotConn.targetSlot && constraints.targetSlot) {
            return false;
        }
        for (const provideName in constraints.providedSlots) {
            if (slotSpecs.get(name).provideSlotConnections.find(spec => spec.name === provideName) === undefined) {
                return false;
            }
        }
        return true;
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class NameUnnamedConnections extends Strategy {
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onHandleConnection(recipe, handleConnection) {
                if (handleConnection.name) {
                    // it is already named.
                    return;
                }
                if (!handleConnection.particle.spec) {
                    // the particle doesn't have spec yet.
                    return;
                }
                const possibleSpecConns = handleConnection.findSpecsForUnnamedHandles();
                return possibleSpecConns.map(specConn => {
                    return (recipe, handleConnection) => {
                        handleConnection.particle.nameConnection(handleConnection, specConn.name);
                        return 1;
                    };
                });
            }
        }(StrategizerWalker.Permuted), this);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ResolveRecipe extends Strategy {
    async generate(inputParams) {
        return StrategizerWalker.over(this.getResults(inputParams), new ResolveWalker(ResolveWalker.Permuted, this.arc), this);
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SearchTokensToParticles extends Strategy {
    constructor(arc, options) {
        super(arc, options);
        const thingByToken = {};
        const thingByPhrase = {};
        arc.context.allParticles.forEach(p => {
            this._addThing(p.name, { spec: p }, thingByToken, thingByPhrase);
            p.verbs.forEach(verb => this._addThing(verb, { spec: p }, thingByToken, thingByPhrase));
        });
        arc.context.allRecipes.forEach(r => {
            const packaged = { innerRecipe: r };
            this._addThing(r.name, packaged, thingByToken, thingByPhrase);
            r.verbs.forEach(verb => this._addThing(verb, packaged, thingByToken, thingByPhrase));
        });
        class SearchWalker extends StrategizerWalker {
            constructor(tactic, arc, recipeIndex) {
                super(tactic);
                this.recipeIndex = recipeIndex;
            }
            onRecipe(recipe) {
                if (!recipe.search || !recipe.search.unresolvedTokens.length) {
                    return undefined;
                }
                const byToken = {};
                const resolvedTokens = new Set();
                const _addThingsByToken = (token, things) => {
                    things.forEach(thing => {
                        byToken[token] = byToken[token] || [];
                        byToken[token].push(thing);
                        token.split(' ').forEach(t => resolvedTokens.add(t));
                    });
                };
                for (const [phrase, things] of Object.entries(thingByPhrase)) {
                    const tokens = phrase.split(' ');
                    if (tokens.every(token => recipe.search.unresolvedTokens.includes(token)) &&
                        recipe.search.phrase.includes(phrase)) {
                        _addThingsByToken(phrase, things);
                    }
                }
                for (const token of recipe.search.unresolvedTokens) {
                    if (resolvedTokens.has(token)) {
                        continue;
                    }
                    const things = thingByToken[token];
                    if (things) {
                        _addThingsByToken(token, things);
                    }
                }
                if (resolvedTokens.size === 0) {
                    return undefined;
                }
                const flatten = (arr) => [].concat(...arr);
                const product = (...sets) => sets.reduce((acc, set) => flatten(acc.map(x => set.map(y => [...x, y]))), [[]]);
                const possibleCombinations = product(...Object.values(byToken).map(v => flatten(v)));
                return possibleCombinations.map(combination => {
                    return recipe => {
                        resolvedTokens.forEach(token => recipe.search.resolveToken(token));
                        combination.forEach(({ spec, innerRecipe }) => {
                            if (spec) {
                                const particle = recipe.newParticle(spec.name);
                                particle.spec = spec;
                            }
                            else {
                                const otherToHandle = this.recipeIndex.findCoalescableHandles(recipe, innerRecipe);
                                assert(innerRecipe);
                                const { cloneMap } = innerRecipe.mergeInto(recipe);
                                otherToHandle.forEach((otherHandle, handle) => cloneMap.get(otherHandle).mergeInto(handle));
                            }
                        });
                        return resolvedTokens.size;
                    };
                });
            }
        }
        this._walker = new SearchWalker(StrategizerWalker.Permuted, arc, options['recipeIndex']);
    }
    get walker() {
        return this._walker;
    }
    getResults(inputParams) {
        assert(inputParams);
        const generated = super.getResults(inputParams).filter(result => !result.result.isResolved());
        const terminal = inputParams.terminal;
        return [...generated, ...terminal];
    }
    _addThing(token, thing, thingByToken, thingByPhrase) {
        if (!token) {
            return;
        }
        this._addThingByToken(token.toLowerCase(), thing, thingByToken);
        // split DoSomething into "do something" and add the phrase
        const phrase = token.replace(/([^A-Z])([A-Z])/g, '$1 $2').replace(/([A-Z][^A-Z])/g, ' $1').replace(/[\s]+/g, ' ').trim();
        if (phrase !== token) {
            this._addThingByToken(phrase.toLowerCase(), thing, thingByPhrase);
        }
    }
    _addThingByToken(key, thing, thingByKey) {
        assert(key === key.toLowerCase());
        thingByKey[key] = thingByKey[key] || [];
        if (!thingByKey[key].find(t => t === thing)) {
            thingByKey[key].push(thing);
        }
    }
    async generate(inputParams) {
        await this.walker.recipeIndex.ready;
        return StrategizerWalker.over(this.getResults(inputParams), this.walker, this);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// tslint:disable-next-line: variable-name
const Empty = new Ruleset.Builder().build();
// tslint:disable-next-line: variable-name
const ExperimentalPhased = new Ruleset.Builder().order([
    InitPopulation,
    InitSearch
], SearchTokensToParticles, [
    MatchRecipeByVerb,
    MatchParticleByVerb
], ConvertConstraintsToConnections, GroupHandleConnections, [
    AddMissingHandles,
    AssignHandles,
    MatchFreeHandlesToConnections,
], MapSlots, CreateDescriptionHandle, ResolveRecipe).build();
// tslint:disable-next-line: variable-name
const ExperimentalLinear = new Ruleset.Builder().order(InitPopulation, InitSearch, SearchTokensToParticles, MatchRecipeByVerb, MatchParticleByVerb, ConvertConstraintsToConnections, GroupHandleConnections, MatchFreeHandlesToConnections, AddMissingHandles, AssignHandles, MapSlots, CreateDescriptionHandle, ResolveRecipe).build();

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SearchTokensToHandles extends Strategy {
    async generate(inputParams) {
        const arc = this.arc;
        // Finds stores matching the provided token and compatible with the provided handle's type,
        // which are not already mapped into the provided handle's recipe
        const findMatchingStores = (token, handle) => {
            const counts = RecipeUtil.directionCounts(handle);
            let stores;
            stores = arc.findStoresByType(handle.type, { tags: [`${token}`] });
            let fate = 'use';
            if (stores.length === 0) {
                stores = arc.context.findStoresByType(handle.type, { tags: [`${token}`], subtype: counts.out === 0 });
                fate = counts.out === 0 ? 'map' : 'copy';
            }
            stores = stores.filter(store => !handle.recipe.handles.find(handle => handle.id === store.id));
            return stores.map(store => ({ store, fate, token }));
        };
        return StrategizerWalker.over(this.getResults(inputParams), new class extends StrategizerWalker {
            onHandle(recipe, handle) {
                if (!recipe.search || recipe.search.unresolvedTokens.length === 0) {
                    return undefined;
                }
                if (handle.isResolved() || handle.connections.length === 0) {
                    return undefined;
                }
                const possibleMatches = [];
                for (const token of recipe.search.unresolvedTokens) {
                    possibleMatches.push(...findMatchingStores(token, handle));
                }
                if (possibleMatches.length === 0) {
                    return undefined;
                }
                return possibleMatches.map(match => {
                    return (recipe, handle) => {
                        handle.fate = match.fate;
                        handle.mapToStorage(match.store);
                        recipe.search.resolveToken(match.token);
                        return 0;
                    };
                });
            }
        }(StrategizerWalker.Permuted), this);
    }
}

class Relevance {
    constructor() {
        // stores a copy of arc.getVersionByStore
        this.versionByStore = {};
        // public for testing
        this.relevanceMap = new Map();
    }
    static create(arc, recipe) {
        const relevance = new Relevance();
        const versionByStore = arc.getVersionByStore({ includeArc: true, includeContext: true });
        recipe.handles.forEach(handle => {
            if (handle.id && versionByStore[handle.id] !== undefined) {
                relevance.versionByStore[handle.id] = versionByStore[handle.id];
            }
        });
        return relevance;
    }
    apply(relevance) {
        for (const key of relevance.keys()) {
            if (this.relevanceMap.has(key)) {
                this.relevanceMap.set(key, this.relevanceMap.get(key).concat(relevance.get(key)));
            }
            else {
                this.relevanceMap.set(key, relevance.get(key));
            }
        }
    }
    calcRelevanceScore() {
        let relevance = 1;
        let hasNegative = false;
        for (const rList of this.relevanceMap.values()) {
            const particleRelevance = Relevance.particleRelevance(rList);
            if (particleRelevance < 0) {
                hasNegative = true;
            }
            relevance *= Math.abs(particleRelevance);
        }
        return relevance * (hasNegative ? -1 : 1);
    }
    // Returns false, if at least one of the particles relevance lists ends with a negative score.
    isRelevant(plan) {
        const hasUi = plan.particles.some(p => p.getSlotConnectionNames().length > 0);
        let rendersUi = false;
        for (const [particle, rList] of this.relevanceMap) {
            if (rList[rList.length - 1] < 0) {
                continue;
            }
            else if (particle.getSlotConnectionNames().length) {
                rendersUi = true;
                break;
            }
        }
        // If the recipe has UI rendering particles, at least one of the particles must render UI.
        return hasUi === rendersUi;
    }
    static scaleRelevance(relevance) {
        if (relevance == undefined) {
            relevance = 5;
        }
        relevance = Math.max(-1, Math.min(relevance, 10));
        // TODO: might want to make this geometric or something instead;
        return relevance / 5;
    }
    static particleRelevance(relevanceList) {
        let relevance = 1;
        let hasNegative = false;
        relevanceList.forEach(r => {
            const scaledRelevance = Relevance.scaleRelevance(r);
            if (scaledRelevance < 0) {
                hasNegative = true;
            }
            relevance *= Math.abs(scaledRelevance);
        });
        return relevance * (hasNegative ? -1 : 1);
    }
    calcParticleRelevance(particle) {
        if (this.relevanceMap.has(particle)) {
            return Relevance.particleRelevance(this.relevanceMap.get(particle));
        }
        return -1;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const logsFactory = (preamble, color) => ({
    log: logFactory(preamble, color, 'log'),
    warn: logFactory(preamble, color, 'warn'),
    error: logFactory(preamble, color, 'error')
});

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const { log } = logsFactory('planner', 'olive');
const suggestionByHash = () => Runtime.getRuntime().getCacheService().getOrCreateCache('suggestionByHash');
class Planner {
    // TODO: Use context.arc instead of arc
    init(arc, { strategies = Planner.AllStrategies, ruleset = Empty, strategyArgs = {}, speculator = undefined, inspectorFactory = undefined, noSpecEx = false }) {
        strategyArgs = Object.freeze({ ...strategyArgs });
        this.arc = arc;
        const strategyImpls = strategies.map(strategy => new strategy(arc, strategyArgs));
        this.strategizer = new Strategizer(strategyImpls, [], ruleset);
        this.speculator = speculator;
        if (inspectorFactory) {
            this.inspector = inspectorFactory.create(this);
        }
        this.noSpecEx = noSpecEx;
    }
    // Specify a timeout value less than zero to disable timeouts.
    async plan(timeout, generations = []) {
        const trace = Tracing.start({ cat: 'planning', name: 'Planner::plan', overview: true, args: { timeout } });
        timeout = timeout || -1;
        const allResolved = [];
        const start = now();
        do {
            const record = await trace.wait(this.strategizer.generate());
            const generated = this.strategizer.generated;
            trace.addArgs({
                generated: generated.length,
                generation: this.strategizer.generation
            });
            if (generations) {
                generations.push({ generated, record });
            }
            const resolved = this.strategizer.generated
                .map(individual => individual.result)
                .filter(recipe => recipe.isResolved());
            allResolved.push(...resolved);
            const elapsed = now() - start;
            if (timeout >= 0 && elapsed > timeout) {
                console.warn(`Planner.plan timed out [elapsed=${Math.floor(elapsed)}ms, timeout=${timeout}ms].`);
                break;
            }
        } while (this.strategizer.generated.length + this.strategizer.terminal.length > 0);
        trace.end();
        if (generations.length && this.inspector) {
            this.inspector.strategizingRecord(PlanningResult.formatSerializableGenerations(generations), { label: 'Planner', keep: true });
        }
        return allResolved;
    }
    _speculativeThreadCount() {
        // TODO(wkorman): We'll obviously have to rework the below when we do
        // speculation in the cloud.
        const cores = DeviceInfo.hardwareConcurrency();
        const memory = DeviceInfo.deviceMemory();
        // For now, allow occupying half of the available cores while constraining
        // total memory used to at most a quarter of what's available. In the
        // absence of resource information we just run two in parallel as a
        // perhaps-low-end-device-oriented balancing act.
        const minCores = 2;
        if (!cores || !memory) {
            return minCores;
        }
        // A rough estimate of memory used per thread in gigabytes.
        const memoryPerThread = 0.125;
        const quarterMemory = memory / 4;
        const maxThreadsByMemory = quarterMemory / memoryPerThread;
        const maxThreadsByCores = cores / 2;
        return Math.max(minCores, Math.min(maxThreadsByMemory, maxThreadsByCores));
    }
    _splitToGroups(items, groupCount) {
        const groups = [];
        if (!items || items.length === 0)
            return groups;
        const groupItemSize = Math.max(1, Math.floor(items.length / groupCount));
        let startIndex = 0;
        for (let i = 0; i < groupCount && startIndex < items.length; i++) {
            groups.push(items.slice(startIndex, startIndex + groupItemSize));
            startIndex += groupItemSize;
        }
        // Add any remaining items to the end of the last group.
        if (startIndex < items.length) {
            groups[groups.length - 1].push(...items.slice(startIndex, items.length));
        }
        return groups;
    }
    async suggest(timeout, generations = []) {
        const trace = Tracing.start({ cat: 'planning', name: 'Planner::suggest', overview: true, args: { timeout } });
        const plans = await trace.wait(this.plan(timeout, generations));
        // We don't actually know how many threads the VM will decide to use to
        // handle the parallel speculation, but at least we know we won't kick off
        // more than this number and so can somewhat limit resource utilization.
        // TODO(wkorman): Rework this to use a fixed size 'thread' pool for more
        // efficient work distribution.
        const threadCount = this._speculativeThreadCount();
        const planGroups = this._splitToGroups(plans, threadCount);
        const results = await trace.wait(Promise.all(planGroups.map(async (group, groupIndex) => {
            const results = [];
            for (const plan of group) {
                const hash = ((hash) => hash.substring(hash.length - 4))(await plan.digest());
                if (RecipeUtil.matchesRecipe(this.arc.activeRecipe, plan)) {
                    this._updateGeneration(generations, hash, (g) => g.active = true);
                    continue;
                }
                const planTrace = Tracing.start({
                    cat: 'speculating',
                    sequence: `speculator_${groupIndex}`,
                    overview: true,
                    args: { groupIndex }
                });
                const suggestion = await this.retriveOrCreateSuggestion(hash, plan, this.arc);
                if (!suggestion) {
                    this._updateGeneration(generations, hash, (g) => g.irrelevant = true);
                    planTrace.end({ name: '[Irrelevant suggestion]', args: { hash, groupIndex } });
                    continue;
                }
                this._updateGeneration(generations, hash, g => g.description = suggestion.descriptionText);
                suggestion.groupIndex = groupIndex;
                results.push(suggestion);
                planTrace.end({ name: suggestion.descriptionText, args: { rank: suggestion.rank, hash, groupIndex } });
            }
            return results;
        })));
        const suggestionResults = [].concat(...results);
        return trace.endWith(suggestionResults);
    }
    static clearCache() {
        suggestionByHash().clear();
    }
    async retriveOrCreateSuggestion(hash, plan, arc) {
        const cachedSuggestion = suggestionByHash().get(hash);
        if (cachedSuggestion && cachedSuggestion.isUpToDate(arc, plan)) {
            return cachedSuggestion;
        }
        let relevance = undefined;
        let description = null;
        if (this._shouldSpeculate(plan)) {
            log(`speculatively executing [${plan.name}]`);
            const result = await this.speculator.speculate(this.arc, plan, hash);
            if (!result) {
                return undefined;
            }
            const speculativeArc = result.speculativeArc;
            relevance = result.relevance;
            description = await Description.create(speculativeArc, relevance);
            log(`[${plan.name}] => [${description.getRecipeSuggestion()}]`);
        }
        else {
            const speculativeArc = await arc.cloneForSpeculativeExecution();
            await speculativeArc.mergeIntoActiveRecipe(plan);
            relevance = Relevance.create(arc, plan);
            description = await Description.create(speculativeArc, relevance);
        }
        const suggestion = Suggestion.create(plan, hash, relevance);
        suggestion.setDescription(description, this.arc.modality, this.arc.pec.slotComposer ?
            this.arc.pec.slotComposer.modalityHandler.descriptionFormatter
            : undefined);
        suggestionByHash().set(hash, suggestion);
        return suggestion;
    }
    _shouldSpeculate(plan) {
        if (!this.speculator || this.noSpecEx) {
            return false;
        }
        if (plan.handleConnections.some(({ type }) => type.toString() === `[Description {Text key, Text value}]`)) {
            return true;
        }
        const planPatternsWithTokens = plan.patterns.filter(p => p.includes('${'));
        const particlesWithTokens = plan.particles.filter(p => !!p.spec.pattern && p.spec.pattern.includes('${'));
        if (planPatternsWithTokens.length === 0 && particlesWithTokens.length === 0) {
            return false;
        }
        // Check if recipe description use out handle connections.
        for (const pattern of planPatternsWithTokens) {
            const allTokens = Description.getAllTokens(pattern);
            for (const tokens of allTokens) {
                const particle = plan.particles.find(p => p.name === tokens[0]);
                assert(particle);
                const handleConn = particle.getConnectionByName(tokens[1]);
                if (handleConn && handleConn.handle && RecipeUtil.directionCounts(handleConn.handle).out > 0) {
                    return true;
                }
            }
        }
        // Check if particle descriptions use out handle connections.
        for (const particle of particlesWithTokens) {
            const allTokens = Description.getAllTokens(particle.spec.pattern);
            for (const tokens of allTokens) {
                const handleConn = particle.getConnectionByName(tokens[0]);
                if (handleConn && handleConn.handle && RecipeUtil.directionCounts(handleConn.handle).out > 0) {
                    return true;
                }
            }
        }
        return false;
    }
    _updateGeneration(generations, hash, handler) {
        if (generations) {
            generations.forEach(g => {
                g.generated.forEach(gg => {
                    assert(typeof gg.hash === 'string');
                    if (typeof gg.hash === 'string' && gg.hash.endsWith(hash)) {
                        handler(gg);
                    }
                });
            });
        }
    }
}
// tslint:disable-next-line: variable-name
Planner.InitializationStrategies = [
    InitPopulation,
    InitSearch
];
// tslint:disable-next-line: variable-name
Planner.ResolutionStrategies = [
    SearchTokensToParticles,
    SearchTokensToHandles,
    GroupHandleConnections,
    CreateHandleGroup,
    ConvertConstraintsToConnections,
    MapSlots,
    AssignHandles,
    MatchParticleByVerb,
    MatchRecipeByVerb,
    NameUnnamedConnections,
    AddMissingHandles,
    CreateDescriptionHandle,
    MatchFreeHandlesToConnections,
    ResolveRecipe,
    FindHostedParticle,
    CoalesceRecipes,
    FindRequiredParticle
];
// tslint:disable-next-line: variable-name
Planner.AllStrategies = Planner.InitializationStrategies.concat(Planner.ResolutionStrategies);

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SuggestDomConsumer extends SlotDomConsumer {
    constructor(arc, containerKind, suggestion, eventHandler) {
        super(arc, /* consumeConn= */ undefined, containerKind);
        this._suggestion = suggestion;
        this._suggestionContent = SuggestDomConsumer._extractContent(this._suggestion);
        this._eventHandler = eventHandler;
    }
    get suggestion() {
        return this._suggestion;
    }
    get templatePrefix() {
        return 'suggest';
    }
    formatContent(content) {
        return {
            template: `<suggestion-element inline key="{{hash}}" on-click="">${content.template}</suggestion-element>`,
            templateName: 'suggestion',
            model: { hash: this.suggestion.hash, ...content.model }
        };
    }
    onContainerUpdate(container, originalContainer) {
        super.onContainerUpdate(container, originalContainer);
        if (container) {
            this.setContent(this._suggestionContent, this._eventHandler);
        }
    }
    static _extractContent(suggestion) {
        return suggestion.getDescription(Modality.Name.Dom) || { template: suggestion.descriptionText };
    }
    static render(arc, container, suggestion) {
        const content = SuggestDomConsumer._extractContent(suggestion);
        if (!content) {
            return undefined;
        }
        const suggestionContainer = Object.assign(document.createElement('suggestion-element'), { plan: suggestion });
        container.appendChild(suggestionContainer, container.firstElementChild);
        const rendering = { container: suggestionContainer, model: content.model };
        const consumer = new SlotDomConsumer(arc);
        consumer.addRenderingBySubId(undefined, rendering);
        consumer.eventHandler = (() => { });
        consumer._stampTemplate(rendering, consumer.createTemplateElement(content.template));
        consumer._onUpdate(rendering);
        return consumer;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class HeadlessSuggestDomConsumer extends SuggestDomConsumer {
    constructor(arc, containerKind, suggestion, eventHandler) {
        super(arc, containerKind, suggestion, eventHandler);
        this._suggestionContent = this._suggestionContent.template ? this._suggestionContent : {
            template: `<dummy-suggestion>${this._suggestionContent}</dummy-element>`,
            templateName: 'dummy-suggestion',
            model: {}
        };
        this._setContentPromise = null;
        this._content = {};
        this.contentAvailable = new Promise(resolve => this._contentAvailableResolve = resolve);
    }
    get suggestion() { return this._suggestion; }
    get templatePrefix() { return 'suggest'; }
    onContainerUpdate(container, originalContainer) {
        super.onContainerUpdate(container, originalContainer);
        if (container) {
            this.setContent(this._suggestionContent, this._eventHandler);
        }
    }
    static render(arc, container, suggestion) {
        return undefined;
    }
    setContent(content, handler) {
        super.setContent(content, handler);
        // Mimics the behaviour of DomSlotConsumer::setContent, where template is only set at first,
        // and model is overriden every time.
        if (content) {
            this._content.templateName = content.templateName;
            if (content.template) {
                this._content.template = content.template;
            }
            this._content.model = content.model;
            this._contentAvailableResolve();
        }
        else {
            this._content = {};
        }
    }
    createNewContainer(container, subId) {
        return container;
    }
    isSameContainer(container, contextContainer) {
        return container === contextContainer;
    }
    getInnerContainer(slotId) {
        const model = Array.from(this.renderings, ([_, { model }]) => model)[0];
        const providedContext = this.findProvidedContext(ctx => ctx.id === slotId);
        if (!providedContext) {
            console.warn(`Cannot find provided spec for ${slotId} in ${this.consumeConn.getQualifiedName()}`);
            return;
        }
        if (providedContext.spec.isSet && model && model.items && model.items.models) {
            const innerContainers = {};
            for (const itemModel of model.items.models) {
                assert(itemModel.id);
                innerContainers[itemModel.id] = itemModel.id;
            }
            return innerContainers;
        }
        return slotId;
    }
    createTemplateElement(template) {
        return template;
    }
    static findRootContainers(container) {
        return container;
    }
    static clear(container) { }
    _onUpdate(rendering) { }
    _stampTemplate(template) { }
    _initMutationObserver() { return null; }
    _observe() { }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class PlanningModalityHandler extends ModalityHandler {
    constructor(slotConsumerClass, suggestionConsumerClass, descriptionFormatter) {
        super(slotConsumerClass, descriptionFormatter);
        this.suggestionConsumerClass = suggestionConsumerClass;
    }
    static createHeadlessHandler() {
        return new PlanningModalityHandler(HeadlessSlotDomConsumer, HeadlessSuggestDomConsumer);
    }
}
PlanningModalityHandler.domHandler = new PlanningModalityHandler(SlotDomConsumer, SuggestDomConsumer, DescriptionDomFormatter);

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class RelevantContextRecipes extends Strategy {
    constructor(context, modality) {
        super();
        this._recipes = [];
        for (let recipe of context.allRecipes) {
            if (!recipe.isCompatible(modality)) {
                continue;
            }
            recipe = recipe.clone();
            const options = { errors: new Map() };
            if (recipe.normalize(options)) {
                this._recipes.push(recipe);
            }
            else {
                console.warn(`could not normalize a context recipe: ${[...options.errors.values()].join('\n')}.\n${recipe.toString()}`);
            }
        }
    }
    async generate({ generation }) {
        if (generation !== 0) {
            return [];
        }
        return this._recipes.map(recipe => ({
            result: recipe,
            score: 1,
            derivation: [{ strategy: this, parent: undefined }],
            hash: recipe.digest(),
            valid: Object.isFrozen(recipe),
        }));
    }
}
// tslint:disable-next-line: variable-name
const IndexStrategies = [
    ConvertConstraintsToConnections,
    AddMissingHandles,
    ResolveRecipe,
    MatchFreeHandlesToConnections,
    // This one is not in-line with 'transparent' interfaces, but it operates on
    // recipes without looking at the context and cannot run after AddUseHandles.
    // We will revisit this list when we take a stab at recipe interfaces.
    CreateHandleGroup
];
class RecipeIndex {
    constructor(arc) {
        this._isReady = false;
        const trace = Tracing.start({ cat: 'indexing', name: 'RecipeIndex::constructor', overview: true });
        const idGenerator = IdGenerator.newSession();
        const arcStub = new Arc({
            id: idGenerator.newArcId('index-stub'),
            context: new Manifest({ id: idGenerator.newArcId('empty-context') }),
            loader: arc.loader,
            slotComposer: new SlotComposer({
                modalityHandler: PlanningModalityHandler.createHeadlessHandler(),
                noRoot: true
            }),
            stub: true
        });
        const strategizer = new Strategizer([
            new RelevantContextRecipes(arc.context, arc.modality),
            ...IndexStrategies.map(S => new S(arcStub, { recipeIndex: this }))
        ], [], Empty);
        this.ready = trace.endWith((async () => {
            do {
                const record = await strategizer.generate();
            } while (strategizer.generated.length + strategizer.terminal.length > 0);
            const population = strategizer.population;
            const candidates = new Set(population);
            for (const result of population) {
                for (const deriv of result.derivation) {
                    if (deriv.parent)
                        candidates.delete(deriv.parent);
                }
            }
            this._recipes = [...candidates].map(r => r.result);
            this._isReady = true;
        })());
    }
    static create(arc) {
        return new RecipeIndex(arc);
    }
    get recipes() {
        if (!this._isReady)
            throw Error('await on recipeIndex.ready before accessing');
        return this._recipes;
    }
    ensureReady() {
        assert(this._isReady, 'await on recipeIndex.ready before accessing');
    }
    /**
     * Given provided handle and requested fates, finds handles with
     * matching type and requested fate.
     */
    findHandleMatch(handle, requestedFates) {
        this.ensureReady();
        const particleNames = handle.connections.map(conn => conn.particle.name);
        const results = [];
        for (const recipe of this._recipes) {
            if (recipe.particles.some(particle => !particle.name)) {
                // Skip recipes where not all verbs are resolved to specific particles
                // to avoid trying to coalesce a recipe with itself.
                continue;
            }
            for (const otherHandle of recipe.handles) {
                if (requestedFates && !(requestedFates.includes(otherHandle.fate))) {
                    continue;
                }
                if (!this.doesHandleMatch(handle, otherHandle)) {
                    continue;
                }
                // If we're connecting the same sets of particles, that's probably not OK.
                // This is a poor workaround for connecting the exact same recipes together, to be improved.
                const otherParticleNames = otherHandle.connections.map(conn => conn.particle.name);
                const connectedParticles = new Set([...particleNames, ...otherParticleNames]);
                if (connectedParticles.size === particleNames.length
                    && particleNames.length === otherParticleNames.length)
                    continue;
                results.push(otherHandle);
            }
        }
        return results;
    }
    doesHandleMatch(handle, otherHandle) {
        if (Boolean(handle.id) && Boolean(otherHandle.id) && handle.id !== otherHandle.id) {
            // Either at most one of the handles has an ID, or they are the same.
            return false;
        }
        // TODO was otherHandle.name, is localName correct
        if (otherHandle.connections.length === 0 || otherHandle.localName === 'descriptions') {
            return false;
        }
        // If we're connecting only create/use/? handles, we require communication.
        // We don't do that if at least one handle is map/copy, as in such case
        // everyone can be a reader.
        // We inspect both fate and originalFate as copy ends up as use in an
        // active recipe, and ? could end up as anything.
        const fates = [handle.originalFate, handle.fate, otherHandle.originalFate, otherHandle.fate];
        if (!fates.includes('copy') && !fates.includes('map')) {
            const counts = RecipeUtil.directionCounts(handle);
            const otherCounts = RecipeUtil.directionCounts(otherHandle);
            // Someone has to read and someone has to write.
            if (otherCounts.in + counts.in === 0 || otherCounts.out + counts.out === 0) {
                return false;
            }
        }
        // If requesting handle has tags, we should have overlap.
        if (handle.tags.length > 0 && !handle.tags.some(t => otherHandle.tags.includes(t))) {
            return false;
        }
        // If types don't match.
        if (!Handle.effectiveType(handle.mappedType, [...handle.connections, ...otherHandle.connections])) {
            return false;
        }
        return true;
    }
    /**
     * Given a particle and a slot spec for a slot that particle could provide, find consume slot connections that
     * could be connected to the potential slot.
     */
    findConsumeSlotConnectionMatch(particle, providedSlotSpec) {
        // TODO: Construct a set of failure reasons for debugging & feedback to developers.
        this.ensureReady();
        const consumeConns = [];
        for (const recipe of this._recipes) {
            if (recipe.particles.some(recipeParticle => !recipeParticle.name)) {
                // Skip recipes where not all verbs are resolved to specific particles
                // to avoid trying to coalesce a recipe with itself.
                continue;
            }
            for (const recipeParticle of recipe.particles) {
                if (!recipeParticle.spec)
                    continue;
                // Match slot connections
                for (const [name, slotSpec] of recipeParticle.spec.slotConnections) {
                    const recipeSlotConn = recipeParticle.getSlotConnectionByName(name);
                    if (recipeSlotConn && recipeSlotConn.targetSlot)
                        continue;
                    if (SlotUtils.specMatch(slotSpec, providedSlotSpec) && SlotUtils.tagsOrNameMatch(slotSpec, providedSlotSpec)) {
                        // TODO: check slot was retrieved by name, tagsOrNameMatch is always true?
                        const slotConn = particle.getSlotConnectionByName(providedSlotSpec.name);
                        let matchingHandles = [];
                        if (providedSlotSpec.handles.length !== 0 || (slotConn && !SlotUtils.handlesMatch(recipeParticle, slotConn))) {
                            matchingHandles = this._getMatchingHandles(recipeParticle, particle, providedSlotSpec.handles);
                            if (matchingHandles.length === 0) {
                                continue;
                            }
                        }
                        consumeConns.push({ recipeParticle, slotSpec, matchingHandles });
                    }
                }
            }
        }
        return consumeConns;
    }
    findProvidedSlot(particle, slotSpec) {
        this.ensureReady();
        const providedSlots = [];
        for (const recipe of this._recipes) {
            if (recipe.particles.some(particle => !particle.name)) {
                // Skip recipes where not all verbs are resolved to specific particles
                // to avoid trying to coalesce a recipe with itself.
                continue;
            }
            for (const consumeConn of recipe.slotConnections) {
                for (const providedSlot of Object.values(consumeConn.providedSlots)) {
                    if (SlotUtils.slotMatches(particle, slotSpec, providedSlot)) {
                        providedSlots.push(providedSlot);
                    }
                }
            }
        }
        return providedSlots;
    }
    _getMatchingHandles(particle, providingParticle, handleNames) {
        const matchingHandles = [];
        for (const slotHandleConnName of handleNames) {
            const providedHandleConn = providingParticle.getConnectionByName(slotHandleConnName);
            if (!providedHandleConn)
                continue;
            const matchingConns = Object.values(particle.connections).filter(handleConn => {
                return handleConn.direction !== 'host'
                    && (!handleConn.handle || !handleConn.handle.id || handleConn.handle.id === providedHandleConn.handle.id)
                    && Handle.effectiveType(providedHandleConn.handle.mappedType, [handleConn]);
            });
            matchingConns.forEach(matchingConn => {
                if (this._fatesAndDirectionsMatch(providedHandleConn, matchingConn)) {
                    matchingHandles.push({ handle: providedHandleConn.handle, matchingConn });
                }
            });
        }
        return matchingHandles;
    }
    /**
     * Helper function that determines whether handle connections in a provided slot
     * and a potential consuming slot connection could be match, considering their fates and directions.
     *
     * - `slotHandleConn` is a handle connection restricting the provided slot.
     * - `matchingHandleConn` - a handle connection of a particle, whose slot connection is explored
     *    as a potential match to a slot above.
     */
    _fatesAndDirectionsMatch(slotHandleConn, matchingHandleConn) {
        const matchingHandle = matchingHandleConn.handle;
        const allMatchingHandleConns = matchingHandle ? matchingHandle.connections : [matchingHandleConn];
        const matchingHandleConnsHasOutput = allMatchingHandleConns.find(conn => conn.isOutput);
        if (!slotHandleConn.handle) {
            throw new Error(`Unexpected empty Handle`);
        }
        switch (slotHandleConn.handle.fate) {
            case 'create':
                // matching handle not defined or its fate is 'create' or '?'.
                return !matchingHandle || ['use', '?'].includes(matchingHandle.fate);
            case 'use':
                // matching handle is not defined or its fate is either 'use' or '?'.
                return !matchingHandle || ['use', '?'].includes(matchingHandle.fate);
            case 'copy':
                // Any handle fate, except explicit 'create'.
                return !matchingHandle || matchingHandle.fate !== 'create';
            case 'map':
                // matching connections don't have output direction and matching handle's fate isn't copy.
                return !matchingHandleConnsHasOutput && (!matchingHandle || matchingHandle.fate !== 'copy');
            case '?':
                return false;
            default:
                throw new Error(`Unexpected fate ${slotHandleConn.handle.fate}`);
        }
    }
    get coalescableFates() {
        return ['create', 'use', '?'];
    }
    findCoalescableHandles(recipe, otherRecipe, usedHandles) {
        assert(recipe !== otherRecipe, 'Cannot coalesce handles in the same recipe');
        const otherToHandle = new Map();
        usedHandles = usedHandles || new Set();
        for (const handle of recipe.handles) {
            if (usedHandles.has(handle) || !this.coalescableFates.includes(handle.fate)) {
                continue;
            }
            for (const otherHandle of otherRecipe.handles) {
                if (usedHandles.has(otherHandle) || !this.coalescableFates.includes(otherHandle.fate)) {
                    continue;
                }
                if (this.doesHandleMatch(handle, otherHandle)) {
                    otherToHandle.set(handle, otherHandle);
                    usedHandles.add(handle);
                    usedHandles.add(otherHandle);
                }
            }
        }
        return otherToHandle;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A Set implementation that performs deep equality of its elements instead of
 * strict equality. Every element needs to have a unique string representation,
 * which will be used as a simple way to compute deep equality.
 */
class DeepSet {
    constructor(...elements) {
        /** All elements stored in the set. */
        this.elementSet = new Set();
        /** The unique string representation of every element in the set. */
        this.stringSet = new Set();
        elements.forEach(e => this.add(e));
    }
    add(element) {
        const repr = element.toUniqueString();
        if (this.stringSet.has(repr)) {
            return;
        }
        this.stringSet.add(repr);
        this.elementSet.add(element);
    }
    addAll(other) {
        other.elementSet.forEach(e => this.add(e));
    }
    map(transform) {
        const result = new DeepSet();
        for (const elem of this) {
            result.add(transform(elem));
        }
        return result;
    }
    [Symbol.iterator]() {
        return this.elementSet[Symbol.iterator]();
    }
    asSet() {
        return this.elementSet;
    }
    toArray() {
        return [...this.elementSet];
    }
    get size() {
        return this.elementSet.size;
    }
    get isEmpty() {
        return this.size === 0;
    }
    /**
     * Returns true if this DeepSet is equal to the other DeepSet (deep equals,
     * computed via toUniqueString() for each DeepSet).
     */
    equals(other) {
        return this.toUniqueString() === other.toUniqueString();
    }
    /** Unique string representation of this DeepSet. */
    toUniqueString() {
        const strings = [...this.stringSet];
        strings.sort();
        return '{' + strings.join(', ') + '}';
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An ordered set of elements. Backed by an Array and a Set. Lookups are backed
 * by the Set so they are quick, and order is maintained by the Array. Elements
 * can be added to the OrderedSet multiple times.
 */
class OrderedSet {
    constructor() {
        this.set = new Set();
        this.array = [];
    }
    add(element) {
        this.set.add(element);
        this.array.push(element);
    }
    addAll(other) {
        other.set.forEach(e => this.set.add(e));
        this.array.push(...other.array);
    }
    has(element) {
        return this.set.has(element);
    }
    copy() {
        const copy = new OrderedSet();
        copy.addAll(this);
        return copy;
    }
    get length() {
        return this.array.length;
    }
    asSet() {
        return this.set;
    }
    asArray() {
        return this.array;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Represents the set of implicit and explicit claims that flow along a path in
 * the graph, i.e. tags, node IDs and edge IDs.
 */
class Flow {
    constructor(nodeIds = new Set(), edgeIds = new OrderedSet(), tags = new Set()) {
        this.nodeIds = nodeIds;
        this.edgeIds = edgeIds;
        this.tags = tags;
    }
    /** Modifies the current Flow (in place) by applying the given FlowModifier. */
    modify(modifier) {
        this.edgeIds.addAll(modifier.edgeIds);
        modifier.nodeIds.forEach(n => this.nodeIds.add(n));
        modifier.tagOperations.forEach((operation, tag) => {
            if (operation === 'add') {
                this.tags.add(tag);
            }
            else {
                this.tags.delete(tag);
            }
        });
    }
    copy() {
        return new Flow(new Set(this.nodeIds), this.edgeIds.copy(), new Set(this.tags));
    }
    copyAndModify(modifier) {
        const copy = this.copy();
        copy.modify(modifier);
        return copy;
    }
    /** Evaluates the given FlowCheck against the current Flow. */
    evaluateCheck(check) {
        if ('operator' in check) {
            if (check.operator === 'or') {
                // Only one child expression needs to pass.
                return check.children.some(childExpr => this.evaluateCheck(childExpr));
            }
            else {
                // 'and' operator. Every child expression needs to pass.
                return check.children.every(childExpr => this.evaluateCheck(childExpr));
            }
        }
        else {
            return this.checkCondition(check);
        }
    }
    /** Evaluates the given CheckCondition against the current Flow. */
    checkCondition(condition) {
        let result;
        switch (condition.type) {
            case 'node':
                result = this.nodeIds.has(condition.value);
                break;
            case 'edge':
                result = this.edgeIds.has(condition.value);
                break;
            case 'tag':
                result = this.tags.has(condition.value);
                break;
            default:
                throw new Error('Unknown condition type.');
        }
        // Flip the result if the check condition was negated.
        return condition.negated ? !result : result;
    }
    toUniqueString() {
        const elements = [];
        for (const nodeId of this.nodeIds) {
            elements.push('node:' + nodeId);
        }
        for (const tag of this.tags) {
            elements.push('tag:' + tag);
        }
        // NOTE: We use asSet() here for the edge IDs instead of asList(), and thus
        // treat all different orderings of edges (i.e. paths) as equivalent,
        // provided they visit the exact same edges. This helps dedupe visiting
        // the same series of cycles in different orders, significantly reducing the
        // search space.
        for (const edgeId of this.edgeIds.asSet()) {
            elements.push('edge:' + edgeId);
        }
        elements.sort();
        return '{' + elements.join(', ') + '}';
    }
}
/** A set of unique flows. */
class FlowSet extends DeepSet {
    /**
     * Copies the current FlowSet, and applies the given modifier to every flow in
     * the copy.
     */
    copyAndModify(modifier) {
        return this.map(flow => flow.copyAndModify(modifier));
    }
}
var TagOperation;
(function (TagOperation) {
    TagOperation["Add"] = "add";
    TagOperation["Remove"] = "remove";
})(TagOperation || (TagOperation = {}));
/** Represents a sequence of modifications that can be made to a flow. */
class FlowModifier {
    constructor(
    /** Node IDs to add. */
    nodeIds = new Set(), 
    /** Edge IDs to add. */
    edgeIds = new OrderedSet(), 
    /** Tags to add/remove. Maps from tag name to operation. */
    tagOperations = new Map()) {
        this.nodeIds = nodeIds;
        this.edgeIds = edgeIds;
        this.tagOperations = tagOperations;
    }
    /**
     * Creates a new FlowModifier from the given list of strings. Each string must
     * start with either a plus or minus symbol (indicating whether the condition
     * is added or removed), then give one of 'tag', 'node', or 'edge', followed
     * by the tag/node/edge ID respectively. (Tags can be added or removed. Nodes
     * and edges can only be added.) e.g. '+node:P2', '+edge:E1', '-tag:trusted'.
     */
    static parse(...conditions) {
        const modifier = new FlowModifier();
        for (const condition of conditions) {
            const firstChar = condition[0];
            if (!'+-'.includes(firstChar)) {
                throw new Error(`'${condition}' must start with either + or -`);
            }
            const operator = firstChar === '+' ? TagOperation.Add : TagOperation.Remove;
            const [type, value] = condition.slice(1).split(':', 2);
            if (operator === TagOperation.Remove && type !== 'tag') {
                throw new Error(`The - operator can only be used with tags. Got '${condition}'.`);
            }
            switch (type) {
                case 'tag':
                    modifier.tagOperations.set(value, operator);
                    break;
                case 'node':
                    modifier.nodeIds.add(value);
                    break;
                case 'edge':
                    modifier.edgeIds.add(value);
                    break;
                default:
                    throw new Error(`Unknown type: '${condition}'`);
            }
        }
        return modifier;
    }
    static fromClaims(edge, claims) {
        const modifier = new FlowModifier();
        if (claims) {
            for (const claim of claims) {
                if (claim.type === ClaimType.IsTag) {
                    modifier.tagOperations.set(claim.tag, claim.isNot ? TagOperation.Remove : TagOperation.Add);
                }
            }
        }
        modifier.edgeIds.add(edge.edgeId);
        modifier.nodeIds.add(edge.start.nodeId);
        return modifier;
    }
    copy() {
        return new FlowModifier(new Set(this.nodeIds), this.edgeIds.copy(), new Map(this.tagOperations));
    }
    /** Copies the current FlowModifier, and then applies the given modifications to the copy. */
    copyAndModify(modifier) {
        const copy = this.copy();
        copy.edgeIds.addAll(modifier.edgeIds);
        modifier.nodeIds.forEach(n => copy.nodeIds.add(n));
        modifier.tagOperations.forEach((op, tag) => copy.tagOperations.set(tag, op));
        return copy;
    }
    toFlow() {
        const flow = new Flow();
        flow.modify(this);
        return flow;
    }
    toUniqueString() {
        const elements = [];
        // The edgeIds list is ordered, but for de-duping we still want to sort them. 
        for (const edgeId of this.edgeIds.asSet()) {
            elements.push('+edge:' + edgeId);
        }
        for (const nodeId of this.nodeIds) {
            elements.push('+node:' + nodeId);
        }
        for (const [tag, op] of this.tagOperations) {
            const sign = op === TagOperation.Add ? '+' : '-';
            elements.push(sign + 'tag:' + tag);
        }
        elements.sort();
        return '{' + elements.join(', ') + '}';
    }
}
/** A set of FlowModifiers. */
class FlowModifierSet extends DeepSet {
    /** Copies the current FlowModifierSet, and extends each modifier in the copy with the given extra modifier. */
    copyAndModify(extraModifier) {
        return this.map(modifier => modifier.copyAndModify(extraModifier));
    }
}
/** Represents a node in a FlowGraph. Can be a particle, handle, etc. */
class Node$1 {
    constructor() {
        /**
         * Boolean indicating whether this node has direct ingress or not (e.g. from a
         * external datastore).
         */
        this.ingress = false;
    }
    get inNodes() {
        return this.inEdges.map(e => e.start);
    }
    get outNodes() {
        return this.outEdges.map(e => e.end);
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ParticleNode extends Node$1 {
    constructor(nodeId, particle) {
        super();
        this.inEdgesByName = new Map();
        this.outEdgesByName = new Map();
        this.nodeId = nodeId;
        this.name = particle.name;
    }
    addInEdge(edge) {
        this.inEdgesByName.set(edge.connectionName, edge);
    }
    addOutEdge(edge) {
        this.outEdgesByName.set(edge.connectionName, edge);
    }
    get inEdges() {
        return [...this.inEdgesByName.values()];
    }
    get outEdges() {
        return [...this.outEdgesByName.values()];
    }
    /**
     * Iterates through all of the relevant in-edges leading into this particle, that flow out into the given out-edge. The out-edge may have a
     * 'derives from' claim that restricts which edges flow into it.
     */
    inEdgesFromOutEdge(outEdge) {
        assert(this.outEdges.includes(outEdge), 'Particle does not have the given out-edge.');
        if (outEdge.derivesFrom && outEdge.derivesFrom.length) {
            return outEdge.derivesFrom;
        }
        return this.inEdges;
    }
}
class ParticleInput {
    constructor(edgeId, particleNode, otherEnd, connection) {
        this.edgeId = edgeId;
        this.start = otherEnd;
        this.end = particleNode;
        this.connectionName = connection.name;
        this.label = `${particleNode.name}.${this.connectionName}`;
        this.connectionSpec = connection.spec;
        this.modifier = FlowModifier.fromClaims(this, connection.handle.claims);
    }
    get type() {
        return this.connectionSpec.type;
    }
}
class ParticleOutput {
    constructor(edgeId, particleNode, otherEnd, connection) {
        this.edgeId = edgeId;
        this.start = particleNode;
        this.end = otherEnd;
        this.connectionName = connection.name;
        this.connectionSpec = connection.spec;
        this.label = `${particleNode.name}.${this.connectionName}`;
        this.modifier = FlowModifier.fromClaims(this, connection.spec.claims);
        this.derivesFrom = [];
    }
    get type() {
        return this.connectionSpec.type;
    }
    computeDerivedFromEdges() {
        assert(this.derivesFrom.length === 0, '"Derived from" edges have already been computed.');
        if (this.connectionSpec.claims) {
            for (const claim of this.connectionSpec.claims) {
                if (claim.type === ClaimType.DerivesFrom) {
                    const derivedFromEdge = this.start.inEdgesByName.get(claim.parentHandle.name);
                    assert(derivedFromEdge, `Handle '${claim.parentHandle.name}' is not an in-edge.`);
                    this.derivesFrom.push(derivedFromEdge);
                }
            }
        }
        if (this.derivesFrom.length === 0 && this.type.tag === 'Reference') {
            this.getEdgesCompatibleWithReference().forEach(e => this.derivesFrom.push(e));
        }
    }
    /**
     * Returns the list of edges from which the given edge could have derived. The
     * given edge must be a particle output of a Reference type. The logic behind
     * which input/output edges could be the source of an output reference is
     * described at go/arcs-dataflow-references.
     */
    getEdgesCompatibleWithReference() {
        if (this.type.tag !== 'Reference') {
            assert(false, 'Must be a Reference.');
        }
        const particleNode = this.start;
        const outRef = this.type;
        const result = [];
        // The output reference could have come from any compatible input type, or a
        // compatible input reference.
        for (const inEdge of particleNode.inEdges) {
            if (isTypeCompatibleWithReference(inEdge.type, outRef, /* canBeReference= */ true)) {
                result.push(inEdge);
            }
        }
        // The output reference could come from any compatible output type, but *not*
        // from an output reference type.
        for (const outEdge of particleNode.outEdges) {
            if (outEdge === this) {
                continue;
            }
            if (outEdge instanceof ParticleOutput && isTypeCompatibleWithReference(outEdge.type, outRef, /* canBeReference= */ false)) {
                result.push(outEdge);
            }
        }
        return result;
    }
}
/** Creates a new node for every given particle. */
function createParticleNodes(particles) {
    const nodes = new Map();
    particles.forEach((particle, index) => {
        const nodeId = 'P' + index;
        nodes.set(particle, new ParticleNode(nodeId, particle));
    });
    return nodes;
}
/**
 * Checks if the given type is a possible source of the given output reference.
 *
 * @param canBeReference controls whether a reference type is allowed to be the
 *     source of the output reference
 */
function isTypeCompatibleWithReference(type, target, canBeReference) {
    switch (type.tag) {
        case 'Entity':
            if (TypeChecker.compareTypes({ type, direction: 'in' }, { type: target.getContainedType(), direction: 'out' })) {
                return true;
            }
            if (canBeReference) {
                // Entities can contain references. One of them might be the origin.
                for (const field of Object.values(type.getEntitySchema().fields)) {
                    if (isSchemaFieldCompatibleWithReference(field, target)) {
                        return true;
                    }
                }
            }
            return false;
        case 'Reference':
            return canBeReference
                ? isTypeCompatibleWithReference(type.getContainedType(), target, canBeReference)
                : false;
        case 'Collection':
        case 'BigCollection':
            return isTypeCompatibleWithReference(type.getContainedType(), target, canBeReference);
        default:
            return false;
    }
}
/**
 * Checks if the given schema field is a possible source of the given output
 * reference. Equivalent to isTypeCompatibleWithReference, except handles schema
 * fields, which have no proper types, instead of actual Type objects.
 *
 * canBeReference is implicitly true when calling this method, because a schema
 * can only contain the target type via a reference (schemas can't contain whole
 * sub-entities).
 */
// tslint:disable-next-line: no-any
function isSchemaFieldCompatibleWithReference(field, target) {
    switch (field.kind) {
        case 'schema-reference': {
            const referencedType = field.schema.model;
            if (isTypeCompatibleWithReference(referencedType, target, /* canBeReference= */ true)) {
                return true;
            }
            return false;
        }
        case 'schema-collection':
            return isSchemaFieldCompatibleWithReference(field.schema, target);
        case 'schema-primitive':
            return false;
        default:
            throw new Error(`Unsupported field: ${field}`);
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class HandleNode extends Node$1 {
    constructor(nodeId, handle) {
        super();
        this.inEdges = [];
        this.outEdges = [];
        this.nodeId = nodeId;
        this.storeId = handle.id;
        // Handles with the 'use', 'map' or 'copy' fate can come from sources
        // external to the recipe, and so should be treated as ingress. 
        if (handle.fate !== 'create') {
            this.ingress = true;
        }
    }
    /** Returns a list of all pairs of particles that are connected through this handle, in string form. */
    get connectionsAsStrings() {
        const connections = [];
        this.inEdges.forEach(inEdge => {
            this.outEdges.forEach(outEdge => {
                connections.push(`${inEdge.label} -> ${outEdge.label}`);
            });
        });
        return connections;
    }
    addInEdge(edge) {
        this.inEdges.push(edge);
    }
    addOutEdge(edge) {
        this.outEdges.push(edge);
    }
    inEdgesFromOutEdge(outEdge) {
        assert(this.outEdges.includes(outEdge), 'Handle does not have the given out-edge.');
        return this.inEdges;
    }
}
/** Creates a new node for every given handle. */
function createHandleNodes(handles) {
    const nodes = new Map();
    handles.forEach((handle, index) => {
        const nodeId = 'H' + index;
        nodes.set(handle, new HandleNode(nodeId, handle));
    });
    return nodes;
}
/** Adds a connection between the given particle and handle nodes. */
function addHandleConnection(direction, particleNode, handleNode, connection, edgeId) {
    if (direction === 'in') {
        const edge = new ParticleInput(edgeId, particleNode, handleNode, connection);
        particleNode.addInEdge(edge);
        handleNode.addOutEdge(edge);
        return edge;
    }
    else {
        const edge = new ParticleOutput(edgeId, particleNode, handleNode, connection);
        particleNode.addOutEdge(edge);
        handleNode.addInEdge(edge);
        return edge;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotNode extends Node$1 {
    constructor(nodeId, slot) {
        super();
        // For now, slots can only have in-edges (from the particles that consume them).
        // TODO: These should be inout edges, because slots can bubble up user events back to these same particles.
        this.inEdges = [];
        this.outEdges = [];
        this.nodeId = nodeId;
    }
    addInEdge(edge) {
        this.inEdges.push(edge);
    }
    addOutEdge(edge) {
        throw new Error(`Slots can't have out-edges (yet).`);
    }
    inEdgesFromOutEdge(outEdge) {
        throw new Error(`Slots can't have out-edges (yet).`);
    }
}
class SlotInput {
    constructor(edgeId, particleNode, slotNode, connection) {
        this.edgeId = edgeId;
        this.start = particleNode;
        this.end = slotNode;
        this.connectionName = connection.name;
        this.label = `${particleNode.name}.${this.connectionName}`;
        this.modifier = FlowModifier.fromClaims(this, []);
    }
    get check() {
        return this.end.check;
    }
}
function createSlotNodes(slots) {
    const nodes = new Map();
    slots.forEach((slot, index) => {
        const nodeId = 'S' + index;
        nodes.set(slot, new SlotNode(nodeId, slot));
    });
    return nodes;
}
/** Adds a connection between the given particle and slot nodes, where the particle "consumes" the slot. */
function addSlotConnection(particleNode, slotNode, connection, edgeId) {
    const edge = new SlotInput(edgeId, particleNode, slotNode, connection);
    particleNode.addOutEdge(edge);
    slotNode.addInEdge(edge);
    return edge;
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Data structure for representing the connectivity graph of a recipe. Used to perform static analysis on a resolved recipe.
 */
class FlowGraph {
    constructor(recipe, manifest) {
        /** Maps from edge ID to Edge. */
        this.edgeMap = new Map();
        /** Maps from HandleConnectionSpec to HandleNode. */
        this.handleSpecMap = new Map();
        if (!recipe.isResolved()) {
            throw new Error('Recipe must be resolved.');
        }
        // Create the nodes of the graph.
        const particleNodes = createParticleNodes(recipe.particles);
        const handleNodes = createHandleNodes(recipe.handles);
        const slotNodes = createSlotNodes(recipe.slots);
        this.particles = [...particleNodes.values()];
        this.handles = [...handleNodes.values()];
        this.slots = [...slotNodes.values()];
        this.nodes = [...this.particles, ...this.handles, ...this.slots];
        this.particleMap = new Map(this.particles.map(n => [n.name, n]));
        this.manifest = manifest;
        let edgeIdCounter = 0;
        // Add edges to the nodes.
        recipe.handleConnections.forEach(connection => {
            const particleNode = particleNodes.get(connection.particle);
            const handleNode = handleNodes.get(connection.handle);
            this.handleSpecMap.set(connection.spec, handleNode);
            // Function to construct a new edge in the graph.
            const addEdgeWithDirection = (direction) => {
                const edgeId = 'E' + edgeIdCounter++;
                const edge = addHandleConnection(direction, particleNode, handleNode, connection, edgeId);
                this.edgeMap.set(edgeId, edge);
            };
            if (connection.direction === 'inout') {
                // An inout handle connection is represented by two edges.
                addEdgeWithDirection('in');
                addEdgeWithDirection('out');
            }
            else if (connection.direction === 'in' || connection.direction === 'out') {
                addEdgeWithDirection(connection.direction);
            }
            else {
                throw new Error(`Unsupported handle connection direction: ${connection.direction}`);
            }
        });
        // Add edges from particles to the slots that they consume (one-way only, for now).
        recipe.slotConnections.forEach(connection => {
            const particleNode = particleNodes.get(connection.particle);
            const slotNode = slotNodes.get(connection.targetSlot);
            const edgeId = 'E' + edgeIdCounter++;
            const edge = addSlotConnection(particleNode, slotNode, connection, edgeId);
            this.edgeMap.set(edgeId, edge);
            // Copy the Check object from the "provide" connection onto the SlotNode.
            // (Checks are defined by the particle that provides the slot, but are
            // applied to the particle that consumes the slot.)
            for (const providedSlotSpec of connection.getSlotSpec().provideSlotConnections) {
                const providedSlot = connection.providedSlots[providedSlotSpec.name];
                const providedSlotNode = slotNodes.get(providedSlot);
                providedSlotNode.check = providedSlotSpec.check ? this.createFlowCheck(providedSlotSpec.check) : null;
            }
        });
        this.edges.forEach(edge => {
            // Attach check objects to particle in-edges. Must be done in a separate
            // pass after all edges have been created, since checks can reference
            // other nodes/edges.
            if (edge instanceof ParticleInput && edge.connectionSpec.check) {
                edge.check = this.createFlowCheck(edge.connectionSpec.check);
            }
            // Compute the list of 'derived from' edges for all out-edges. This must
            // also be done in a separate pass since we can't guarantee the ordering
            // in which the edges were created.
            if (edge instanceof ParticleOutput) {
                edge.computeDerivedFromEdges();
            }
        });
    }
    get edges() {
        return [...this.edgeMap.values()];
    }
    /** Returns a list of all pairwise particle connections, in string form: 'P1.foo -> P2.bar'. */
    get connectionsAsStrings() {
        const connections = [];
        for (const handleNode of this.handles) {
            handleNode.connectionsAsStrings.forEach(c => connections.push(c));
        }
        return connections;
    }
    /** Converts a list of edge IDs into a path string using the edge labels. */
    edgeIdsToPath(edgeIds) {
        return edgeIds.map(edgeId => this.edgeMap.get(edgeId).label).join(' -> ');
    }
    /** Converts an "is from handle" check into the node ID that we need to search for. */
    handleCheckToNodeId(check) {
        return this.handleSpecMap.get(check.parentHandle).nodeId;
    }
    /** Converts an "is from output" check into the edge ID that we need to search for. */
    outputCheckToEdgeId(check) {
        const edge = this.edges.find(edge => {
            if (edge instanceof ParticleOutput) {
                return (edge.connectionSpec === check.output);
            }
            return false;
        });
        assert(edge, `Output with id ${check.output.name} does not exist.`);
        return edge.edgeId;
    }
    /** Converts an "is from store" check into the node ID that we need to search for. */
    storeCheckToNodeId(check) {
        const storeId = this.resolveStoreRefToID(check.storeRef);
        const handle = this.handles.find(h => h.storeId === storeId);
        assert(handle, `Store with id ${storeId} is not connected by a handle.`);
        return handle.nodeId;
    }
    /** Converts a StoreReference into a store ID. */
    resolveStoreRefToID(storeRef) {
        if (storeRef.type === 'id') {
            const store = this.manifest.findStoreById(storeRef.store);
            assert(store, `Store with id '${storeRef.store}' not found.`);
            return store.id;
        }
        else {
            const store = this.manifest.findStoreByName(storeRef.store);
            assert(store, `Store with name ${storeRef.store} not found.`);
            return store.id;
        }
    }
    /** Converts a particle Check object into a FlowCheck object (the internal representation used by FlowGraph). */
    createFlowCheck(originalCheck, expression) {
        expression = expression || originalCheck.expression;
        if (expression.type === 'and' || expression.type === 'or') {
            return {
                originalCheck,
                operator: expression.type,
                children: expression.children.map(child => this.createFlowCheck(originalCheck, child)),
            };
        }
        else {
            return { ...this.createFlowCondition(expression), originalCheck };
        }
    }
    /** Converts a particle CheckCondition into a FlowCondition object (the internal representation used by FlowGraph). */
    createFlowCondition(condition) {
        switch (condition.type) {
            case CheckType.HasTag:
                return { type: 'tag', negated: condition.isNot, value: condition.tag };
            case CheckType.IsFromHandle:
                return { type: 'node', negated: condition.isNot, value: this.handleCheckToNodeId(condition) };
            case CheckType.IsFromOutput:
                return { type: 'edge', negated: condition.isNot, value: this.outputCheckToEdgeId(condition) };
            case CheckType.IsFromStore:
                return { type: 'node', negated: condition.isNot, value: this.storeCheckToNodeId(condition) };
            default:
                throw new Error('Unknown CheckType');
        }
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/** Runs the dataflow analyser on the given recipe. */
function analyseDataflow(recipe, manifest) {
    const graph = new FlowGraph(recipe, manifest);
    return [graph, validateGraph(graph)];
}
/** Failure result reported when a check statement is not satisfied. */
class CheckFailure {
    constructor(check, flow) {
        this.check = check;
        this.flow = flow;
    }
    getFailureMessage(graph) {
        return `'${this.check}' failed for path: ${graph.edgeIdsToPath(this.flow.edgeIds.asArray())}`;
    }
}
/**
 * Failure result reported when there is no data ingress into an edge with a
 * check statement.
 */
class IngressFailure {
    constructor(check) {
        this.check = check;
    }
    getFailureMessage(graph) {
        return `'${this.check}' failed: no data ingress.`;
    }
}
/** Result from validating an entire graph. */
class ValidationResult {
    constructor() {
        this.checkFailures = [];
        this.ingressFailures = [];
    }
    addCheckFailure(check, flow) {
        this.checkFailures.push(new CheckFailure(check, flow));
    }
    addIngressFailure(check) {
        this.ingressFailures.push(new IngressFailure(check));
    }
    addAllFailures(other) {
        other.checkFailures.forEach(f => this.addCheckFailure(f.check, f.flow));
        other.ingressFailures.forEach(f => this.addIngressFailure(f.check));
    }
    get isValid() {
        return this.checkFailures.length === 0 && this.ingressFailures.length === 0;
    }
    getFailureMessages(graph) {
        return [
            ...this.ingressFailures.map(f => f.getFailureMessage(graph)),
            ...this.checkFailures.map(f => f.getFailureMessage(graph)),
        ];
    }
}
/** Returns true if all checks in the graph pass. */
function validateGraph(graph) {
    const solver = new Solver(graph.edges);
    solver.resolve();
    return solver.validateAllChecks();
}
/**
 * A flow expression for an edge. When fully resolved, it contains a set of
 * resolved flows into the edge. When unresolved, it contains references to each
 * parent edge, and a set of modifiers which should be applied to the flow from
 * that edge.
 */
class EdgeExpression {
    constructor(edge) {
        /** Fully resolved flows coming into this edge. */
        this.resolvedFlows = new FlowSet();
        /**
         * Edges upon which this edge depends. Not yet resolved. Maps from a parent
         * edge to the set of modifiers which should be applied to it.
         */
        this.unresolvedFlows = new Map();
        this.edge = edge;
        const modifier = edge.modifier || new FlowModifier();
        const parentEdges = edge.start.inEdgesFromOutEdge(edge);
        if (parentEdges.length > 0) {
            // Indicate that this edge inherits from its parents (and apply 
            // modifiers).
            parentEdges.forEach(e => this.inheritFromEdge(e, modifier));
        }
        if (edge.start.ingress) {
            this.resolvedFlows.add(modifier.toFlow());
        }
    }
    get isResolved() {
        return this.unresolvedFlows.size === 0;
    }
    get parents() {
        return [...this.unresolvedFlows.keys()];
    }
    /**
     * Replaces an unresolved parent with the parent's own expression. Any
     * resolved flows into the parent get copied and modified to become resolved
     * into the child. Unresolved flows into the parent become unresolved flows
     * into the child (with the child's modifiers added too).
     */
    expandParent(parentExpr) {
        assert(this.unresolvedFlows.has(parentExpr.edge), `Can't substitute parent edge, it's not an unresolved parent.`);
        // Remove unresolved parent, and replace with unresolved grandparents.
        const modifierSet = this.unresolvedFlows.get(parentExpr.edge);
        this.unresolvedFlows.delete(parentExpr.edge);
        for (const modifier of modifierSet) {
            // Copy flows from parent (and apply modifiers).
            const newFlows = parentExpr.resolvedFlows.copyAndModify(modifier);
            this.resolvedFlows.addAll(newFlows);
            // Copy any unresolved grandparents (and apply modifiers).
            for (const [edge, parentModifierSet] of parentExpr.unresolvedFlows) {
                for (const parentModifier of parentModifierSet) {
                    // Combine modifiers, applying parent's modifiers first.
                    const combinedModifier = parentModifier.copyAndModify(modifier);
                    this.inheritFromEdge(edge, combinedModifier);
                }
            }
        }
        this.removeSelfReference();
    }
    /** Add a new unresolved flow, consisting of the given edge and a modifier for it. */
    inheritFromEdge(edge, modifier) {
        if (this.unresolvedFlows.has(edge)) {
            this.unresolvedFlows.get(edge).add(modifier);
        }
        else {
            this.unresolvedFlows.set(edge, new FlowModifierSet(modifier));
        }
    }
    removeSelfReference() {
        const selfModifierSet = this.unresolvedFlows.get(this.edge);
        if (!selfModifierSet) {
            return;
        }
        // Delete the self-reference.
        this.unresolvedFlows.delete(this.edge);
        // Apply each self-modifier to a copy of each parent modifier.
        for (const parentModifierSet of this.unresolvedFlows.values()) {
            const newModifiers = new FlowModifierSet();
            for (const selfModifier of selfModifierSet) {
                newModifiers.addAll(parentModifierSet.copyAndModify(selfModifier));
            }
            parentModifierSet.addAll(newModifiers);
        }
        // Make a copy of all existing resolved flows, with each set of flow
        // modifiers applied to them.
        const newFlows = new FlowSet();
        for (const selfModifier of selfModifierSet) {
            newFlows.addAll(this.resolvedFlows.copyAndModify(selfModifier));
        }
        this.resolvedFlows.addAll(newFlows);
    }
    toString() {
        const result = [`EdgeExpression(${this.edge.edgeId}) {`];
        for (const flow of this.resolvedFlows) {
            result.push('  ' + flow.toUniqueString());
        }
        for (const [edge, modifierSets] of this.unresolvedFlows) {
            for (const modifiers of modifierSets) {
                result.push(`  EdgeExpression(${edge.edgeId}) + ${modifiers.toUniqueString()}`);
            }
        }
        result.push('}');
        return result.join('\n');
    }
}
class Solver {
    constructor(edges) {
        /** Maps from an edge to a "expression" for it. */
        this.edgeExpressions = new Map();
        this._isResolved = false;
        this.edges = edges;
        // Fill dependentEdges map with empty sets.
        this.dependentExpressions = new Map();
        for (const edge of edges) {
            this.dependentExpressions.set(edge, new Set());
        }
    }
    /** Returns true if every edge in the graph has been fully resolved to a FlowSet. */
    get isResolved() {
        return this._isResolved;
    }
    /**
     * Runs through every check on an edge in the graph, and validates it against
     * the resolved flows into that edge.
     */
    validateAllChecks() {
        assert(this._isResolved, 'Graph must be resolved before checks can be validated.');
        const finalResult = new ValidationResult();
        for (const edge of this.edges) {
            if (edge.check) {
                const result = this.validateCheckOnEdge(edge);
                finalResult.addAllFailures(result);
            }
        }
        return finalResult;
    }
    validateCheckOnEdge(edge) {
        assert(this._isResolved, 'Graph must be resolved before checks can be validated.');
        assert(edge.check, 'Edge does not have any check conditions.');
        const check = edge.check;
        const finalResult = new ValidationResult();
        const edgeExpression = this.edgeExpressions.get(edge);
        const flows = edgeExpression.resolvedFlows;
        if (flows.size === 0) {
            // There is no ingress into this edge, so there's nothing to check.
            finalResult.addIngressFailure(check.originalCheck.toManifestString());
            return finalResult;
        }
        for (const flow of flows) {
            if (!flow.evaluateCheck(check)) {
                finalResult.addCheckFailure(check.originalCheck.toManifestString(), flow);
            }
        }
        return finalResult;
    }
    /**
     * Fully resolves the graph. All edges will have a fully resolved edge
     * expression at the end of this function.
     */
    resolve() {
        if (this._isResolved) {
            return;
        }
        for (const edge of this.edges) {
            this.processEdge(edge);
        }
        // Verify that all edges are fully resolved.
        const numEdges = this.edges.length;
        assert(this.edgeExpressions.size === numEdges);
        assert(this.dependentExpressions.size === numEdges);
        for (const edgeExpression of this.edgeExpressions.values()) {
            assert(edgeExpression.isResolved, `Unresolved edge expression: ${edgeExpression.toString()}`);
        }
        this._isResolved = true;
    }
    /**
     * Constructs a new EdgeExpression for the given edge, and tries to expand as
     * many of its unresolved parents as is possible. The edge expression might
     * still not be fully resolved at the end of this function.
     */
    processEdge(edge) {
        let edgeExpression = this.edgeExpressions.get(edge);
        if (edgeExpression) {
            // Edge has already been processed.
            return edgeExpression;
        }
        edgeExpression = new EdgeExpression(edge);
        this.edgeExpressions.set(edge, edgeExpression);
        // Try to expand all of the parents we already know about.
        for (const parent of edgeExpression.parents) {
            // Indicate that edge depends on parent.
            this.dependentExpressions.get(parent).add(edgeExpression);
            this.tryExpandParent(edgeExpression, parent);
        }
        // Now go through and expand this edge in the edges which depend on it.
        for (const dependentExpression of this.dependentExpressions.get(edge)) {
            this.tryExpandParent(dependentExpression, edge);
        }
        return edgeExpression;
    }
    /**
     * Takes an edge expression with an unresolved parent edge, and tries to
     * expand out that parent edge using the parent edge's own expression.
     */
    tryExpandParent(expression, parentEdge) {
        if (!expression.unresolvedFlows.has(parentEdge)) {
            return;
        }
        const parentExpression = this.edgeExpressions.get(parentEdge);
        if (parentExpression) {
            this.dependentExpressions.get(parentEdge).delete(expression);
            expression.expandParent(parentExpression);
            // Note down new dependencies from the grandparents to this edge.
            parentExpression.parents.forEach(grandparent => this.dependentExpressions.get(grandparent).add(expression));
        }
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class InitialRecipe extends Strategy {
    constructor(recipe) {
        super();
        this.recipe = recipe;
    }
    async generate({ generation }) {
        if (generation !== 0) {
            return [];
        }
        return [{
                result: this.recipe,
                score: 1,
                derivation: [{ strategy: this, parent: undefined }],
                hash: this.recipe.digest(),
                valid: Object.isFrozen(this.recipe),
            }];
    }
}
class ArcPlannerInvoker {
    constructor(arc, arcDevtoolsChannel) {
        this.arc = arc;
        arcDevtoolsChannel.listen('fetch-strategies', async () => arcDevtoolsChannel.send({
            messageType: 'fetch-strategies-result',
            messageBody: Planner.AllStrategies.map(s => s.name)
        }));
        arcDevtoolsChannel.listen('invoke-planner', async (msg) => arcDevtoolsChannel.send({
            messageType: 'invoke-planner-result',
            messageBody: await this.invokePlanner(msg.messageBody.manifest, msg.messageBody.method),
            requestId: msg.requestId
        }));
    }
    async invokePlanner(manifestString, method) {
        if (!this.recipeIndex) {
            this.recipeIndex = RecipeIndex.create(this.arc);
            await this.recipeIndex.ready;
        }
        let manifest;
        try {
            manifest = await Manifest.parse(manifestString, { loader: this.arc._loader, fileName: 'manifest.manifest' });
        }
        catch (error) {
            return this.processManifestError(error);
        }
        if (manifest.recipes.length === 0)
            return { results: [] };
        if (manifest.recipes.length > 1)
            return { error: { message: `More than 1 recipe present, found ${manifest.recipes.length}.` } };
        const recipe = manifest.recipes[0];
        recipe.normalize();
        if (method === 'arc' || method === 'arc_coalesce') {
            return this.multiStrategyRun(recipe, method);
        }
        else {
            return this.singleStrategyRun(recipe, method);
        }
    }
    async multiStrategyRun(recipe, method) {
        const strategies = method === 'arc_coalesce' ? Planner.ResolutionStrategies
            : Planner.ResolutionStrategies.filter(s => s !== CoalesceRecipes);
        const strategizer = new Strategizer([new InitialRecipe(recipe), ...strategies.map(S => this.instantiate(S))], [], Empty);
        const terminal = [];
        do {
            await strategizer.generate();
            terminal.push(...strategizer.terminal);
        } while (strategizer.generated.length + strategizer.terminal.length > 0);
        return this.processStrategyOutput(terminal);
    }
    async singleStrategyRun(recipe, strategyName) {
        const strategy = Planner.AllStrategies.find(s => s.name === strategyName);
        if (!strategy)
            return { error: { message: `Strategy ${strategyName} not found` } };
        return this.processStrategyOutput(await this.instantiate(strategy).generate({
            generation: 0,
            generated: [{ result: recipe, score: 1 }],
            population: [{ result: recipe, score: 1 }],
            terminal: [{ result: recipe, score: 1 }]
        }));
    }
    instantiate(strategyClass) {
        // TODO: Strategies should have access to the context that is a combination of arc context and
        //       the entered manifest. Right now strategies only see arc context, which means that
        //       various strategies will not see particles defined in the manifest entered in the
        //       editor. This may bite us with verb substitution, hosted particle resolution etc.
        return new strategyClass(this.arc, { recipeIndex: this.recipeIndex });
    }
    processStrategyOutput(inputs) {
        return { results: inputs.map(result => {
                const recipe = result.result;
                const errors = new Map();
                if (!Object.isFrozen(recipe)) {
                    recipe.normalize({ errors });
                }
                let recipeString = '';
                try {
                    recipeString = recipe.toString({ showUnresolved: true });
                }
                catch (e) {
                    console.warn(e);
                }
                let dataflow;
                try {
                    const manifest = this.arc.context;
                    const [graph, flowResult] = analyseDataflow(recipe, manifest);
                    if (flowResult.isValid) {
                        dataflow = { success: true, message: 'Success!' };
                    }
                    else {
                        dataflow = { success: false, message: 'Failed: ' + flowResult.getFailureMessages(graph).join('\n') };
                    }
                }
                catch (e) {
                    dataflow = { success: false, message: e.toString() };
                }
                return {
                    recipe: recipeString,
                    derivation: this.extractDerivation(result),
                    dataflow,
                    errors: [...errors.values()].map(error => ({ error })),
                };
            }) };
    }
    extractDerivation(result) {
        const found = [];
        for (const deriv of result.derivation || []) {
            if (!deriv.parent && deriv.strategy.constructor !== InitialRecipe) {
                found.push(deriv.strategy.constructor.name);
            }
            else if (deriv.parent) {
                const childDerivs = this.extractDerivation(deriv.parent);
                for (const childDeriv of childDerivs) {
                    found.push(childDeriv
                        ? `${childDeriv} -> ${deriv.strategy.constructor.name}`
                        : deriv.strategy.constructor.name);
                }
                if (childDerivs.length === 0)
                    found.push(deriv.strategy.constructor.name);
            }
        }
        return found;
    }
    processManifestError(error) {
        let suggestion = null;
        const errorTypes = [{
                // TODO: Switch to declaring errors in a structured way in the error object, instead of message parsing.
                pattern: /could not find particle ([A-Z][A-Za-z0-9_]*)\n/,
                predicate: extracted => manifest => !!(manifest.particles.find(p => p.name === extracted))
            }, {
                pattern: /Could not resolve type reference to type name '([A-Z][A-Za-z0-9_]*)'\n/,
                predicate: extracted => manifest => !!(manifest.schemas[extracted])
            }];
        for (const { pattern, predicate } of errorTypes) {
            const match = pattern.exec(error.message);
            if (match) {
                const [_, extracted] = match;
                const fileNames = this.findManifestNames(this.arc.context, predicate(extracted));
                if (fileNames.length > 0)
                    suggestion = { action: 'import', fileNames };
            }
        }
        return { suggestion, error: ((({ location, message }) => ({ location, message }))(error)) };
    }
    findManifestNames(manifest, predicate) {
        const map = new Map();
        this.findManifestNamesRecursive(manifest, predicate, map);
        return [...map.entries()].sort(([a, depthA], [b, depthB]) => (depthA - depthB)).map(v => v[0]);
    }
    findManifestNamesRecursive(manifest, predicate, fileNames) {
        let depth = predicate(manifest) ? 0 : Number.MAX_SAFE_INTEGER;
        for (const child of manifest.imports) {
            depth = Math.min(depth, this.findManifestNamesRecursive(child, predicate, fileNames) + 1);
        }
        // http check to avoid listing shell created 'in-memory manifest'.
        if (depth < Number.MAX_SAFE_INTEGER && manifest.fileName.startsWith('http')) {
            fileNames.set(manifest.fileName, depth);
        }
        return depth;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
let streamingToDevtools = false;
function enableTracingAdapter(devtoolsChannel) {
    if (!streamingToDevtools) {
        Tracing.enable();
        devtoolsChannel.send({
            messageType: 'trace-time-sync',
            messageBody: {
                traceTime: Tracing.now(),
                localTime: Date.now()
            }
        });
        Tracing.stream(trace => devtoolsChannel.send({
            messageType: 'trace',
            messageBody: trace
        }), trace => trace.ov // Overview events only.
        );
        streamingToDevtools = true;
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Listens to particle reload events for all particles instantiated in an arc and reloads the particles
 * when their source files change
 */
class HotCodeReloader {
    constructor(arc, arcDevtoolsChannel) {
        this.arc = arc;
        this.arcDevtoolsChannel = arcDevtoolsChannel;
        arcDevtoolsChannel.listen('particle-reload', (msg) => void this._reload(msg.messageBody));
    }
    _reload(filepath) {
        const arcs = [this.arc];
        arcs.push(...this.arc.innerArcs);
        for (const arc of arcs) {
            const particles = [];
            for (const particle of arc.pec.particles) {
                if (particle.spec.implFile === filepath) {
                    particles.push(particle);
                }
            }
            arc.pec.reload(particles);
        }
    }
    updateParticleSet(particles) {
        const particleSources = [];
        particles.forEach(particle => {
            particleSources.push(particle.spec.implFile);
        });
        this.arcDevtoolsChannel.send({
            messageType: 'watch-particle-sources',
            messageBody: particleSources
        });
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Arc-independent handlers for devtools logic.
void DevtoolsConnection.onceConnected.then(devtoolsChannel => {
    enableTracingAdapter(devtoolsChannel);
});
const devtoolsArcInspectorFactory = {
    create(arc) {
        return new DevtoolsArcInspector(arc);
    }
};
class DevtoolsArcInspector {
    constructor(arc) {
        this.arcDevtoolsChannel = null;
        this.onceActiveResolve = null;
        this.onceActive = null;
        if (arc.isStub)
            return;
        this.arc = arc;
        this.onceActive = new Promise(resolve => this.onceActiveResolve = resolve);
        const connectedOnInstantiate = DevtoolsConnection.isConnected;
        void DevtoolsConnection.onceConnected.then(devtoolsChannel => {
            if (!connectedOnInstantiate) {
                devtoolsChannel.send({
                    messageType: 'warning',
                    messageBody: 'pre-existing-arc'
                });
            }
            this.arcDevtoolsChannel = devtoolsChannel.forArc(arc);
            this.storesFetcher = new ArcStoresFetcher(arc, this.arcDevtoolsChannel);
            const unused1 = new ArcPlannerInvoker(arc, this.arcDevtoolsChannel);
            this.hotCodeReloader = new HotCodeReloader(arc, this.arcDevtoolsChannel);
            this.arcDevtoolsChannel.send({
                messageType: 'arc-available',
                messageBody: {
                    speculative: arc.isSpeculative,
                    inner: arc.isInnerArc
                }
            });
            this.sendEnvironmentMessage(arc);
            this.onceActiveResolve();
        });
    }
    recipeInstantiated(particles, activeRecipe) {
        if (!DevtoolsConnection.isConnected)
            return;
        this.storesFetcher.onRecipeInstantiated();
        const truncate = ({ id, name }) => ({ id, name });
        const slotConnections = [];
        particles.forEach(p => p.getSlotConnections().forEach(cs => {
            if (cs.targetSlot) {
                slotConnections.push({
                    particleId: cs.particle.id.toString(),
                    consumed: truncate(cs.targetSlot),
                    provided: Object.values(cs.providedSlots).map(slot => truncate(slot)),
                });
            }
        }));
        this.arcDevtoolsChannel.send({
            messageType: 'recipe-instantiated',
            messageBody: { slotConnections, activeRecipe }
        });
        if (!this.arc.isSpeculative)
            this.hotCodeReloader.updateParticleSet(particles);
    }
    pecMessage(name, pecMsgBody, pecMsgCount, stackString) {
        if (!DevtoolsConnection.isConnected)
            return;
        const stack = this._extractStackFrames(stackString);
        this.arcDevtoolsChannel.send({
            messageType: 'PecLog',
            messageBody: { name, pecMsgBody, pecMsgCount, timestamp: Date.now(), stack },
        });
    }
    _extractStackFrames(stackString) {
        const stack = [];
        if (!stackString)
            return stack;
        // File refs should appear only in stack traces generated by tests run with
        // --explore set.
        if (stackString.includes('(file:///')) {
            // The slice discards the 'Error' text and the the stack frame
            // corresponding to the API channel function, which is already being
            // displayed in the log entry.
            for (const frameString of stackString.split('\n    at ').slice(2)) {
                const match = frameString.match(/^(.*) \((.*)\)$/);
                const method = match ? match[1] : '<unknown>';
                let location = match ? match[2] : frameString;
                location = location.replace(/:[0-9]+$/, '');
                if (location.startsWith('file')) {
                    // 'file:///<path>/arcs.*/runtime/file.js:84'
                    // -> location: 'runtime/file.js:150'
                    location = location.replace(/^.*\/arcs[^/]*\//, '');
                }
                stack.push({ method, location, target: null, targetClass: 'noLink' });
            }
            return stack;
        }
        // The slice discards the stack frame corresponding to the API channel
        // function, which is already being displayed in the log entry.
        if (mapStackTrace) {
            mapStackTrace(stackString, (mapped) => mapped.slice(1).map(frameString => {
                // Each frame has the form '    at function (source:line:column)'.
                // Extract the function name and source:line:column text, then set up
                // a frame object with the following fields:
                //   location: text to display as the source in devtools Arcs panel
                //   target: URL to open in devtools Sources panel
                //   targetClass: CSS class specifier to attach to the location text
                const match = frameString.match(/^ {4}at (.*) \((.*)\)$/);
                const method = match ? match[1] : '<unknown>';
                let source = match ? match[2] : frameString.replace(/^ *at */, '');
                const frame = { method };
                source = match[2].replace(/:[0-9]+$/, '');
                if (source.startsWith('http')) {
                    // 'http://<url>/arcs.*/shell/file.js:150'
                    // -> location: 'shell/file.js:150', target: same as source
                    frame.location = source.replace(/^.*\/arcs[^/]*\//, '');
                    frame.target = source;
                    frame.targetClass = 'link';
                }
                else if (source.startsWith('webpack')) {
                    // 'webpack:///runtime/sub/file.js:18'
                    // -> location: 'runtime/sub/file.js:18', target: 'webpack:///./runtime/sub/file.js:18'
                    frame.location = source.slice(11);
                    frame.target = `webpack:///./${frame.location}`;
                    frame.targetClass = 'link';
                }
                else {
                    // '<anonymous>' (or similar)
                    frame.location = source;
                    frame.target = null;
                    frame.targetClass = 'noLink';
                }
                stack.push(frame);
            }));
        }
        return stack;
    }
    isActive() {
        return DevtoolsConnection.isConnected;
    }
    sendEnvironmentMessage(arc) {
        const allManifests = [];
        (function traverse(manifest) {
            allManifests.push(manifest);
            manifest.imports.forEach(traverse);
        })(arc.context);
        this.arcDevtoolsChannel.send({
            messageType: 'arc-environment',
            messageBody: {
                recipes: arc.context.allRecipes.map(r => ({
                    name: r.name,
                    text: r.toString(),
                    file: allManifests.find(m => m.recipes.includes(r)).fileName
                })),
                particles: arc.context.allParticles.map(p => ({
                    name: p.name,
                    spec: p.toString(),
                    file: allManifests.find(m => m.particles.includes(p)).fileName
                }))
            }
        });
    }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const log$1 = console.log.bind(console);
const warn = console.warn.bind(console);
const env = {};

const createPathMap = root => ({
  'https://$arcs/': `${root}/`,
  'https://$shells/': `${root}/shells/`,
  'https://$build/': `${root}/shells/lib/build/`,
  'https://$particles/': `${root}/particles/`,
});

const init$1 = (root, urls) => {
  const map = Object.assign(Utils.createPathMap(root), urls);
  env.loader = new PlatformLoader(map);
  env.pecFactory = pecIndustry(env.loader);
  return env;
};

const parse$1 = async (content, options) => {
  const id = `in-memory-${Math.floor((Math.random()+1)*1e6)}.manifest`;
  const localOptions = {
    id,
    fileName: `./${id}`,
    loader: env.loader
  };
  if (options) {
    Object.assign(localOptions, options);
  }
  return Manifest.parse(content, localOptions);
};

const resolve = async (arc, recipe) =>{
  if (normalize(recipe)) {
    let plan = recipe;
    if (!plan.isResolved()) {
      const resolver = new RecipeResolver(arc);
      //const errors = new Map();
      plan = await resolver.resolve(recipe); //, {errors});
      //console.warn(errors);
      //if (plan) {
      //  normalize(plan);
      //}
      if (!plan || !plan.isResolved()) {
        warn('failed to resolve:\n', (plan || recipe).toString({showUnresolved: true}));
        //log(arc.context, arc, arc.context.storeTags);
        plan = null;
      }
    }
    return plan;
  }
};

const normalize = async (recipe) =>{
  const errors = new Map();
  if (isNormalized(recipe) || recipe.normalize({errors})) {
    return true;
  }
  warn('failed to normalize:\n', errors, recipe.toString());
  //warn('failed to normalize:\n', recipe.toString());
  return false;
};

const isNormalized = recipe => {
  return Object.isFrozen(recipe);
};

const spawn = async ({id, serialization, context, composer, storage, portFactories}) => {
  const arcId = IdGenerator.newSession().newArcId(id);
  const params = {
    id: arcId,
    fileName: './serialized.manifest',
    serialization,
    context,
    storageKey: storage || 'volatile',
    slotComposer: composer,
    pecFactories: [].concat([env.pecFactory], portFactories || []),
    loader: env.loader,
    inspectorFactory: devtoolsArcInspectorFactory,
  };
  Object.assign(params, env.params);
  return serialization ? Arc.deserialize(params) : new Arc(params);
};

const Utils = {
  createPathMap,
  init: init$1,
  env,
  parse: parse$1,
  resolve,
  spawn
};

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class SyntheticStores {
  static get providerFactory() {
    return SyntheticStores._providerFactory || (SyntheticStores._providerFactory = new StorageProviderFactory('shell'));
  }
  static async getArcsStore(storage, arcid) {
    const handleStore = await SyntheticStores.getStore(storage, arcid);
    if (handleStore) {
      const handles = await handleStore.toList();
      const handle = handles[0];
      if (handle) {
        return await SyntheticStores.getHandleStore(handle);
      }
    }
  }
  static async getStore(storage, arcid) {
    return await SyntheticStores.connectToKind('handles', storage, arcid);
  }
  static async connectToKind(kind, storage, arcid) {
    // delimiter problems
    if (storage[storage.length-1] === '/') {
      storage = storage.slice(0, -1);
    }
    return SyntheticStores.storeConnect(null, `synthetic://arc/${kind}/${storage}/${arcid}`);
  }
  static async getHandleStore(handle) {
    return await SyntheticStores.storeConnect(handle.type, handle.storageKey);
  }
  static async storeConnect(type, storageKey) {
    return SyntheticStores.providerFactory.connect(SyntheticStores.makeId(), type, storageKey);
  }
  static makeId() {
    return `id${Math.random()}`;
  }
  static snarfId(key) {
    return key.split('/').pop();
  }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const {log: log$2, warn: warn$1, error: error$1} = logsFactory('ArcHost', '#cade57');

class ArcHost {
  constructor(context, storage, composer, portFactories) {
    this.context = context;
    this.storage = storage;
    this.composer = composer;
    this.portFactories = portFactories;
  }
  disposeArc() {
    if (this.arc) {
      this.arc.dispose();
    }
    this.arc = null;
  }
  // config = {id, [serialization], [manifest]}
  async spawn(config) {
    log$2('spawning arc', config);
    this.config = config;
    const context = this.context || await Utils.parse(``);
    const storage = config.storage || this.storage;
    this.serialization = await this.computeSerialization(config, storage);
    this.arc = await this._spawn(context, this.composer, storage, config.id, this.serialization, this.portFactories);
    if (config.manifest && !this.serialization) {
      await this.instantiateDefaultRecipe(this.arc, config.manifest);
    }
    if (this.pendingPlan) {
      const plan = this.pendingPlan;
      this.pendingPlan = null;
      await this.instantiatePlan(this.arc, plan);
    }
    return this.arc;
  }
  set manifest(manifest) {
    this.instantiateDefaultRecipe(this.arc, manifest);
  }
  set plan(plan) {
    if (this.arc) {
      this.instantiatePlan(this.arc, plan);
    } else {
      this.pendingPlan = plan;
    }
  }
  async computeSerialization(config, storage) {
    let serialization;
    if (config.serialization != null) {
      serialization = config.serialization;
    }
    if (serialization == null) {
      if (storage.includes('volatile')) {
        serialization = '';
      } else {
        serialization = await this.fetchSerialization(storage, config.id) || '';
      }
    }
    return serialization;
  }
  async _spawn(context, composer, storage, id, serialization, portFactories) {
    return await Utils.spawn({id, context, composer, serialization, storage: `${storage}/${id}`, portFactories});
  }
  async instantiateDefaultRecipe(arc, manifest) {
    log$2('instantiateDefaultRecipe');
    try {
      manifest = await Utils.parse(manifest);
      const recipe = manifest.allRecipes[0];
      const plan = await Utils.resolve(arc, recipe);
      if (plan) {
        await this.instantiatePlan(arc, plan);
      }
    } catch (x) {
      error$1(x);
    }
  }
  async instantiatePlan(arc, plan) {
    log$2('instantiatePlan');
    // TODO(sjmiles): pass suggestion all the way from web-shell
    // and call suggestion.instantiate(arc).
    if (!plan.isResolved()) {
      log$2(`plan ${plan.toString({showUnresolved: true})} is not resolved.`);
    }
    try {
      await arc.instantiate(plan);
    } catch (x) {
      error$1(x);
      //console.error(plan.toString());
    }
    await this.persistSerialization(arc);
  }
  async fetchSerialization(storage, arcid) {
    const key = `${storage}/${arcid}/arc-info`;
    const store = await SyntheticStores.providerFactory.connect('id', new ArcType(), key);
    if (store) {
      log$2('loading stored serialization');
      const info = await store.get();
      return info && info.serialization;
    }
  }
  async persistSerialization(arc) {
    const {id, storageKey} = arc;
    if (!storageKey.includes('volatile')) {
      log$2(`compiling serialization for [${id}]...`);
      const serialization = await arc.serialize();
      log$2(`persisting serialization to [${id}/serialization]...`);
      await arc.persistSerialization(serialization);
    }
  }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class RamSlotComposer extends SlotComposer {
  constructor(options = {}) {
    super({
      rootContainer: options.rootContainer || {'root': 'root-context'},
      modalityName: options.modalityName,
      modalityHandler: ModalityHandler.createHeadlessHandler()
    });
  }
  sendEvent(particleName, slotName, event, data) {
    const particles = this.consumers.filter(s => s.consumeConn.particle.name == particleName).map(s => s.consumeConn.particle);
    this.pec.sendEvent(particles[0], slotName, {handler: event, data});
  }
  renderSlot(particle, slotName, content) {
    super.renderSlot(particle, slotName, content);
    const slotConsumer = this.getSlotConsumer(particle, slotName);
    if (slotConsumer) {
      slotConsumer.updateProvidedContexts();
    }
  }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const version = '0_7_0';
const firebase = `firebase://arcs-storage.firebaseio.com/AIzaSyBme42moeI-2k8WgXh-6YK_wYyjEXo4Oz8/${version}`;
const pouchdb = `pouchdb://local/arcs/${version}`;
const volatile = 'volatile://';
const prefix = `arcs-${version}`;

const Const = {
  version,
  DEFAULT: {
    userId: 'user',
    firebaseStorageKey: firebase,
    pouchdbStorageKey: pouchdb,
    volatileStorageKey: volatile,
    storageKey: pouchdb, //firebase,
    plannerStorageKey: 'volatile',
    manifest: `https://$particles/canonical.arcs`,
    launcherId: 'arc-launcher'
  },
  LOCALSTORAGE: {
    user: `${prefix}-user`,
    storage: `${prefix}-storage`,
    plannerStorage: `${prefix}-plannerStorage`,
    userHistory: `${prefix}-userHistory`
  },
  SHARE: {
    private: 1,
    self: 2,
    friends: 3
  },
  STORES: {
    boxed: 'BOXED',
    my: 'PROFILE',
    shared: 'FRIEND'
  }
};

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const log$3 = logFactory('UserArcs', '#4f0433');
const warn$2 = logFactory('UserArcs', '#4f0433', 'warn');

class UserArcs {
  constructor(storage, userid) {
    SyntheticStores.init();
    this.values = [];
    this.listeners = [];
    this.contextWait = 3000;
    this.updateArcsStore(storage, userid);
  }
  async subscribe(listener) {
    if (this.listeners.indexOf(listener) < 0) {
      await this.publishInitialChanges([listener]);
      this.listeners.push(listener);
      this.publish(this.values, [listener]);
    }
  }
  publish(changes, listeners) {
    // convert {add:[], remove:[]} to [{add, remove}]
    if (changes.add) {
      changes.add.forEach(add => this._publish({add: add.value}, listeners));
    }
    if (changes.remove) {
      changes.remove.forEach(remove => this._publish({remove: remove.value}, listeners));
    }
  }
  async publishInitialChanges(listeners) {
    const changes = {add: []};
    if (this.store) {
      const values = await this.store.toList();
      values.forEach(value => this._publish({add: value}, listeners));
    }
    return changes;
  }
  _publish(change, listeners) {
    if (!change.add || !change.add.rawData.deleted) {
      listeners.forEach(listener => listener(change));
    }
  }
  async updateArcsStore(storage, userid) {
    // attempt to marshal arcs-store for this user
    this.store = await this.fetchArcsStore(storage, userid);
    if (this.store) {
      // TODO(sjmiles): plop arcsStore into state early for updateUserContext, usage is weird
      this.foundArcsStore(this.store);
    } else {
      // retry after a bit
      setTimeout(() => this.updateArcsStore(storage, userid), this.contextWait);
    }
  }
  async fetchArcsStore(storage, userid) {
    // TODO(sjmiles): marshalling of arcs-store arc id from userid should be elsewhere
    const store = await SyntheticStores.getArcsStore(storage, Const.DEFAULT.launcherId);
    if (store) {
      log$3(`marshalled arcsStore for [${userid}]`);
      return store;
    }
    warn$2(`failed to marshal arcsStore for [${userid}][${storage}]`);
  }
  async foundArcsStore(store) {
    log$3('foundArcsStore', Boolean(store));
    await this.publishInitialChanges(this.listeners);
    store.on('change', changes => this.arcsStoreChange(changes), this);
  }
  arcsStoreChange(changes) {
    this.publish(changes, this.listeners);
  }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const log$4 = logFactory('SingleUserContext', '#f2ce14');
const warn$3 = logFactory('SingleUserContext', '#f2ce14', 'warn');
const error$2 = logFactory('SingleUserContext', '#f2ce14', 'error');

// SoloContext (?)
const SingleUserContext = class {
  constructor(storage, context, userid, arcstore, isProfile) {
    this.storage = storage;
    this.context = context;
    this.userid = userid;
    this.arcstore = arcstore;
    this.isProfile = isProfile;
    // we observe `arcid`s and `storageKey`s
    this.observers = {};
    // when we remove an arc from consideration, we have to unobserve storageKeys from that arc
    // `handles` maps an arcid to an array of storageKeys to unobserve
    this.handles = {};
    // promises for async store marshaling
    this.pendingStores = [];
    if (arcstore) {
      this.attachArcStore(storage, arcstore);
    }
  }
  async attachArcStore(storage, arcstore) {
    this.observeStore(arcstore, arcstore.id, info => {
      log$4('arcstore::observer', info);
      if (info.add) {
        info.add.forEach(({value}) => this._addArc(storage, value.rawData));
      } else if (info.remove) {
        info.remove.forEach(({value}) => {
          // TODO(sjmiles): value should contain `rawData.key`, but sometimes there is no `rawData`
          this.removeArc(value.id);
        });
      } else {
        log$4('arcstore::observer info type not supported: ', info);
      }
    });
  }
  async dispose() {
    // chuck all observers
    Object.values(this.observers).forEach(({key}) => this.unobserve(key));
    // chuck all data
    await this.removeUserEntities(this.context, this.userid, this.isProfile);
  }
  removeArc(arcid) {
    this.unobserve(arcid);
    const handles = this.handles[arcid];
    if (handles) {
      handles.forEach(({storageKey}) => this.unobserve(storageKey));
      this.handles[arcid] = null;
    }
  }
  async _addArc(storage, arcmeta) {
    const {deleted, key} = arcmeta;
    if (!deleted) {
      const store = await SyntheticStores.getStore(storage, key);
      if (store) {
        await this.observeStore(store, key, info => this.onArcStoreChanged(key, info));
      }
    }
  }
  async addArc(key) {
    //if (!deleted) {
      const store = await SyntheticStores.getStore(this.storage, key);
      if (store) {
        await this.observeStore(store, key, info => this.onArcStoreChanged(key, info));
      } else {
        warn$3(`failed to get SyntheticStore for arc at [${this.storage}, ${key}]\nhttps://github.com/PolymerLabs/arcs/issues/2304`);
      }
    //}
  }
  unobserve(key) {
    const observer = this.observers[key];
    if (observer) {
      this.observers[key] = null;
      //log(`UNobserving [${key}]`);
      observer.store.off('change', observer.cb);
    }
  }
  async observeStore(store, key, cb) {
   if (!store) {
      console.warn(`observeStore: store is null for [${key}]`);
    } else {
      if (!this.observers[key]) {
        log$4(`observing [${key}]`);
        // TODO(sjmiles): create synthetic store `change` records from the initial state
        // SyntheticCollection has `toList` but is `!type.isCollection`,
        if (store.toList) {
          const data = await store.toList();
          if (data && data.length) {
            const add = data.map(value => ({value}));
            cb({add});
          } else log$4('...store is empty collection');
        } else if (store.type.isEntity) {
          const data = await store.get();
          if (data) {
            cb({data});
          }
        }
        this.observers[key] = {key, store, cb: store.on('change', cb, this)};
      }
    }
  }
   onArcStoreChanged(arcid, info) {
    log$4('Synthetic-store change event (onArcStoreChanged):', info);
    // TODO(sjmiles): synthesize add/remove records from data record
    //   this._patchArcDataInfo(arcid, info);
    // process add/remove stream
    if (info.add) {
      info.add.forEach(async add => {
        let handle = add.value;
        if (!handle) {
          error$2('`add` record has no `value`, applying workaround', add);
          handle = add;
        }
        if (handle) { //} && handle.tags.length) {
          //handle.tags.length && log('observing handle', handle.tags);
          //log('fetching handle store', handle);
          const store = await SyntheticStores.getHandleStore(handle);
          await this.observeStore(store, handle.storageKey, info => this.updateHandle(arcid, handle, info));
        }
      });
    }
    if (info.remove) {
      info.remove.forEach(async remove => {
        const handle = remove.value;
        if (handle) {
          //log('UNobserving handle', handle);
          this.unobserve(handle.storageKey);
        }
      });
    }
  }
  async updateHandle(arcid, handle, info) {
    const {context, userid, isProfile} = this;
    const tags = handle.tags ? handle.tags.join('-') : '';
    if (tags) {
      log$4('updateHandle', tags/*, info*/);
      const type = handle.type.isCollection ? handle.type : handle.type.collectionOf();
      const id = SyntheticStores.snarfId(handle.storageKey);
      //
      const shareid = `${tags}|${id}|from|${userid}|${arcid}`;
      const shortid = `${(isProfile ? `PROFILE` : `FRIEND`)}_${tags}`;
      const storeName = shortid;
      const storeId = isProfile ? shortid : shareid;
      log$4('share id:', storeId);
      const store = await this.getShareStore(context, type, storeName, storeId, ['shared']); //handle.tags);
      //
      const boxStoreId = `BOXED_${tags}`;
      const boxDataId = `${userid}|${arcid}`;
      //const boxId = `${tags}|${boxDataId}`;
      log$4('box ids:', boxStoreId, boxDataId/*, boxId*/);
      const boxStore = await this.getShareStore(context, type, boxStoreId, boxStoreId, ['shared']); //[boxStoreId]);
      //
      // TODO(sjmiles): no mutation
      if (handle.type.isEntity) {
        if (info.data) {
          // TODO(sjmiles): in the absence of data mutation, when an entity changes
          // it gets an entirely new id, so we cannot use ids to track entities
          // in boxed stores. However as this entity is a Highlander for this
          // user and arc (by virtue of not being in a Collection) we can synthesize
          // a stable id.
          info.data.id = boxDataId;
          this.unshareEntities(userid, store, boxStore, info.data);
          this.shareEntities(userid, store, boxStore, info.data);
        }
      } else if (info.add || info.remove) {
        info.remove && info.remove.forEach(remove => this.unshareEntities(userid, store, boxStore, [remove.value]));
        info.add && info.add.forEach(add => this.shareEntities(userid, store, boxStore, [add.value]));
      } else if (info.data) {
        this.shareEntities(userid, store, boxStore, info.data);
      }
    }
  }
  async getShareStore(context, type, name, id, tags) {
    // TODO(sjmiles): cache and return promises in case of re-entrancy
    let promise = this.pendingStores[id];
    if (!promise) {
      promise = (async () => {
        let store = context.findStoreById(id);
        if (!store) {
          store = await context.createStore(type, name, id, tags);
        }
        return store;
      })();
      this.pendingStores[id] = promise;
    }
    return promise;
  }
  async shareEntities(userid, shareStore, boxStore, data) {
    if (data) {
      this.storeEntitiesWithUid(shareStore, data, userid);
      boxStore.idMap = this.storeEntitiesWithUid(boxStore, data, userid);
    }
  }
  async unshareEntities(userid, shareStore, boxStore, data) {
    if (data) {
      this.removeEntitiesWithUid(shareStore, data, userid);
      this.removeEntitiesWithUid(boxStore, data, userid);
    }
  }
  storeEntitiesWithUid(store, data, uid) {
    const ids = [];
    const storeDecoratedEntity = ({id, rawData}, uid) => {
      const decoratedId = `${id}:uid:${uid}`;
      ids.push({id: decoratedId, rawData});
      //console.log('pushing data to store');
      if (store.type.isCollection) {
        // FIXME: store.generateID may not be safe (session scoped)?
        store.store({id: decoratedId, rawData}, [store.generateID()]);
      } else {
        store.set({id: decoratedId, rawData});
      }
    };
    if (data && data.id) {
      storeDecoratedEntity(data, uid);
    } else {
      Object.values(data).forEach(entity => entity && storeDecoratedEntity(entity, uid));
    }
    return ids;
  }
  removeEntitiesWithUid(store, data, uid) {
    const removeDecoratedEntity = ({id, rawData}, uid) => {
      const decoratedId = `${id}:uid:${uid}`;
      if (store.type.isCollection) {
        store.remove(decoratedId);
      }
    };
    if (store.type.isCollection) {
      if (Array.isArray(data)) {
        data.forEach(entity => entity && removeDecoratedEntity(entity, uid));
      } else if (data && data.id) {
        removeDecoratedEntity(data, uid);
      }
    } else {
      store.clear();
    }
  }
  async removeEntities(context) {
    this.removeUserEntities(context, 'all', true);
  }
  async removeUserEntities(context, userid, isProfile) {
    log$4(`removing entities for [${userid}]`);
    const jobs = [];
    for (let i=0, store; (store=context.stores[i]); i++) {
      jobs.push(this.removeUserStoreEntities(userid, store, isProfile));
    }
    await Promise.all(jobs);
  }
  async removeUserStoreEntities(userid, store, isProfile) {
   if (!store) {
      console.warn(`removeUserStoreEntities: store is null for [${userid}]`);
    } else {
      log$4(`scanning [${userid}] [${store.id}] (${store.toList ? 'collection' : 'singleton'})`);
      //const tags = context.findStoreTags(store);
      if (store.toList) {
        const entities = await store.toList();
        entities.forEach(entity => {
          const uid = entity.id.split('uid:').pop().split('|').shift();
          if (isProfile || uid === userid) {
            log$4(`  REMOVE `, entity.id);
            // TODO(sjmiles): _removeUserStoreEntities is strangely re-entering
            //  (1) `remove` fires synchronous change events
            //  (2) looks like there are double `remove` events in the queue. Bug?
            // In general, to avoid interleaving we'll probably need to
            // use a stack to process changes async to receiving them.
            // Parallel processing works as of now ... feature?
            store.remove(entity.id);
          }
        });
      }
      else {
        const uid = store.id.split('|').slice(-2, -1).pop();
        if (isProfile || uid === userid) {
          log$4(`  CLEAR store`);
          store.clear();
        }
      }
    }
  }
};

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const log$5 = logFactory('UserContext', '#4f0433');
const warn$4 = logFactory('UserContext', '#4f0433', 'warn');

class UserContext {
  constructor() {
  }
  async init(storage, userid, context) {
    await this.disposeUserContext(this.userContext);
    const isProfile = true;
    this.userContext = new SingleUserContext(storage, context, userid, null, isProfile);
  }
  async disposeUserContext(userContext) {
    if (userContext) {
      try {
        await userContext.dispose();
      } catch (x) {
        //
      }
    }
  }
  onArc({add, remove}) {
    if (add) {
      this.userContext.addArc(add.id);
    }
    if (remove) {
      this.userContext.removeArc(remove.id);
    }
  }
  // _getInitialState() {
  //   return {
  //     // ms to wait until we think there is probably some context
  //     contextWait: 3000,
  //     // maps userid to SingleUserContext for friends
  //     friends: {},
  //     // TODO(sjmiles): workaround for missing data in `remove` records
  //     // maps entityids to userids for friends
  //     friendEntityIds: {},
  //     // snapshot of BOXED_avatar for use by shell
  //     avatars: {},
  //   };
  // }
  // update(props, state) {
  //   if (!state.env && props.env) {
  //     state.env = props.env;
  //     SyntheticStores.init(props.env);
  //   }
  //   if (props.context && state.context !== props.context) {
  //     state.context = props.context;
  //     this.updateFriends(props, state);
  //   }
  //   if (props.storage && props.context && props.userid !== state.userid) {
  //     state.userid = props.userid;
  //     this.awaitState('arcsStore', () => this.updateArcsStore(props, state));
  //   }
  // }
  // async updateArcsStore(props, state) {
  //   const {storage, userid} = props;
  //   const arcsStore = await this.fetchArcsStore(storage, userid);
  //   if (arcsStore) {
  //     // TODO(sjmiles): plop arcsStore into state early for updateUserContext, usage is weird
  //     state.arcsStore = arcsStore;
  //     // TODO(sjmiles): props and state are suspect after await
  //     await this.updateUserContext(props, state);
  //   } else {
  //     // retry after a bit
  //     setTimeout(() => this.state = {userid: null}, state.contextWait);
  //   }
  //   // signal when user-decorated context is `ready`
  //   // TODO(sjmiles): ideally we have a better signal than a timeout
  //   setTimeout(() => this.fire('context', props.context), state.contextWait);
  //   return arcsStore;
  // }
  // async fetchArcsStore(storage, userid) {
  //   const store = await SyntheticStores.getArcsStore(storage, `${userid}${Const.DEFAULT.launcherSuffix}`);
  //   if (store) {
  //     log(`marshalled arcsStore for [${userid}]`); //[${storage}]`, store);
  //     return store;
  //   }
  //   warn(`failed to marshal arcsStore for [${userid}][${storage}]`);
  // }
  // async updateSystemUser({userid, context}) {
  //   const store = await context.findStoreById('SYSTEM_user');
  //   if (store) {
  //     const user = {
  //       id: store.generateID(),
  //       rawData: {
  //         id: userid,
  //       }
  //     };
  //     store.set(user);
  //     log('installed SYSTEM_user');
  //   }
  // }
  // async updateUserContext({storage, userid, context}, {userContext, arcsStore}) {
  //   await this.disposeUserContext(userContext);
  //   // do not operate on stale userid
  //   if (!this.state.userContext && userid === this.state.userid) {
  //     const isProfile = true;
  //     this.state = {
  //       userContext: new SingleUserContext(storage, context, userid, arcsStore, isProfile)
  //     };
  //   }
  // }
  // async disposeUserContext(userContext) {
  //   if (userContext) {
  //     this.state = {userContext: null};
  //     try {
  //       await userContext.dispose();
  //     } catch (x) {
  //       //
  //     }
  //   }
  // }
  // async updateFriends({storage, userid, context}, state) {
  //   if (state.friendsStore) {
  //     log('discarding old PROFILE_friends');
  //     state.friendsStore.off('change', state.friendsStoreCb);
  //     state.friendsStore = null;
  //   }
  //   const friendsStore = await context.findStoreById('PROFILE_friends');
  //   if (friendsStore) {
  //     log('found PROFILE_friends');
  //     const friendsStoreCb = info => this.onFriendsChange(storage, context, info);
  //     // get current data
  //     const friends = await friendsStore.toList();
  //     // listen for changes
  //     friendsStore.on('change', friendsStoreCb, this);
  //     // process friends already in store
  //     this.onFriendsChange(storage, context, {add: friends.map(f => ({value: f}))});
  //     this.state = {friendsStore, friendsStoreCb};
  //   } else {
  //     warn('PROFILE_friends missing');
  //   }
  // }
  // onFriendsChange(storage, context, info) {
  //   const {friends, friendEntityIds} = this._state;
  //   if (info.add) {
  //     info.add.forEach(({value}) => {
  //       const entityId = value.id;
  //       const friendId = value.rawData.id;
  //       // TODO(sjmiles): friendEntityIds is a hack to workaround missing rawData in removal records
  //       friendEntityIds[entityId] = friendId;
  //       this.addFriend(storage, context, friends, friendId);
  //     });
  //   }
  //   if (info.remove) {
  //     info.remove.forEach(remove => this.removeFriend(friends, friendEntityIds[remove.value.id]));
  //   }
  // }
  // async addFriend(storage, context, friends, friendId, attempts) {
  //   log(`trying to addFriend [${friendId}]`);
  //   if (!friends[friendId]) {
  //     friends[friendId] = true;
  //     const arcsStore = await this.fetchArcsStore(storage, friendId);
  //     if (arcsStore) {
  //       friends[friendId] = new SingleUserContext(storage, context, friendId, arcsStore, false);
  //     } else {
  //       friends[friendId] = null;
  //       // retry a bit
  //       attempts = (attempts || 0) + 1;
  //       if (attempts < 11) {
  //         const timeout = 1000*Math.pow(2.9076, attempts);
  //         console.warn(`retry [${attempts}/10] to addFriend [${friendId}] in ${(timeout/1000/60).toFixed(2)}m`);
  //         setTimeout(() => this.addFriend(storage, context, friends, friendId, attempts), timeout);
  //       }
  //     }
  //   }
  // }
  // removeFriend(friends, friendId) {
  //   log('removeFriend', friendId);
  //   const friend = friends[friendId];
  //   if (friend) {
  //     friend.dispose && friend.dispose();
  //     friends[friendId] = null;
  //   }
  // }
  //async _boxedAvatarChanged(store) {
  //   const avatars = await store.toList();
  //   this._fire('avatars', avatars);
  //   avatars.get = id => {
  //     const avatar = avatars.find(avatar => {
  //       const uid = avatar.id.split(':uid:').pop();
  //       return uid === id;
  //     });
  //     return avatar && avatar.rawData;
  //   };
  // }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * @fileoverview
 * Preconditions
 *
 * Convenience functions that check whether values are as expected and
 * also help make Typescript code less nullable/undefined.
 */
/**
 * Returns a given value if it is not undefined and not null.
 *
 * @param value Value to check.
 * @param message Used for the thrown error.
 * @throws when value is undefined or null.
 */
function checkDefined(value, customMessage) {
    if (value === undefined || value === null) {
        throw new Error(customMessage || 'undefined or null');
    }
    return value;
}

class SuggestionComposer {
    constructor(arc, slotComposer) {
        this._suggestions = [];
        // used in tests
        this._suggestConsumers = [];
        this._container = slotComposer.findContainerByName('suggestions');
        this._slotComposer = slotComposer;
        this.arc = arc;
    }
    get modalityHandler() { return this._slotComposer.modalityHandler; }
    clear() {
        if (this._container) {
            this.modalityHandler.slotConsumerClass.clear(this._container);
        }
        this._suggestConsumers.forEach(consumer => consumer.dispose());
        this._suggestConsumers.length = 0;
    }
    setSuggestions(suggestions) {
        this.clear();
        this._suggestions = suggestions.sort(Suggestion.compare);
        for (const suggestion of this._suggestions) {
            if (this._container) {
                if (!this.modalityHandler.suggestionConsumerClass.render(this.arc, this._container, suggestion)) {
                    throw new Error(`Couldn't render suggestion for ${suggestion.hash}`);
                }
            }
            this._addInlineSuggestion(suggestion);
        }
    }
    _addInlineSuggestion(suggestion) {
        const remoteSlots = suggestion.plan.slots.filter(s => !!s.id);
        if (remoteSlots.length !== 1) {
            return;
        }
        const remoteSlot = remoteSlots[0];
        const context = this._slotComposer.findContextById(remoteSlot.id);
        if (!context) {
            throw new Error('Missing context for ' + remoteSlot.id);
        }
        if (context.spec.isSet) {
            // TODO: Inline suggestion in a set slot is not supported yet. Implement!
            return;
        }
        // Don't put suggestions in context that either (1) is a root context, (2) doesn't have
        // an actual container or (3) is not restricted to specific handles.
        if (!context.sourceSlotConsumer) {
            return;
        }
        if (context.spec.handles.length === 0) {
            return;
        }
        const handleIds = context.spec.handles.map(handleName => context.sourceSlotConsumer.consumeConn.particle.connections[handleName].handle.id);
        if (!handleIds.find(handleId => suggestion.plan.handles.some(handle => handle.id === handleId))) {
            // the suggestion doesn't use any of the handles that the context is restricted to.
            return;
        }
        const suggestConsumer = new this.modalityHandler.suggestionConsumerClass(this.arc, this._slotComposer.containerKind, suggestion, (eventlet) => {
            const suggestion = this._suggestions.find(s => s.hash === eventlet.data.key);
            suggestConsumer.dispose();
            if (suggestion) {
                const index = this._suggestConsumers.findIndex(consumer => consumer === suggestConsumer);
                if (index < 0) {
                    throw new Error('cannot find suggest slot context');
                }
                this._suggestConsumers.splice(index, 1);
                suggestion.instantiate(this.arc).catch(e => console.error(e));
            }
        });
        context.addSlotConsumer(suggestConsumer);
        this._suggestConsumers.push(suggestConsumer);
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SuggestFilter {
    constructor(showAll, search) {
        this.showAll = showAll;
        this.search = search;
        assert(!(showAll && search), `Cannot set search string for 'show-all' filter`);
    }
    isEquivalent(showAll, search) {
        return (this.showAll === showAll) && (this.search === search);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class PlanConsumer {
    constructor(arc, result, inspector) {
        this.suggestFilter = new SuggestFilter(false);
        // Callback is triggered when planning results have changed.
        this.suggestionsChangeCallbacks = [];
        // Callback is triggered when suggestions visible to the user have changed.
        this.visibleSuggestionsChangeCallbacks = [];
        this.suggestionComposer = null;
        this.currentSuggestions = [];
        assert(arc, 'arc cannot be null');
        assert(result, 'result cannot be null');
        this.arc = arc;
        this.result = result;
        this.suggestionsChangeCallbacks = [];
        this.visibleSuggestionsChangeCallbacks = [];
        this.inspector = inspector;
        this._initSuggestionComposer();
        this.result.registerChangeCallback(() => this.onSuggestionsChanged());
        this._maybeUpdateStrategyExplorer();
    }
    registerSuggestionsChangedCallback(callback) {
        this.suggestionsChangeCallbacks.push(callback);
    }
    registerVisibleSuggestionsChangedCallback(callback) {
        this.visibleSuggestionsChangeCallbacks.push(callback);
    }
    setSuggestFilter(showAll, search) {
        assert(!showAll || !search);
        if (this.suggestFilter.isEquivalent(showAll, search)) {
            return;
        }
        this.suggestFilter = new SuggestFilter(showAll, search);
        this._onMaybeSuggestionsChanged();
    }
    onSuggestionsChanged() {
        this._onSuggestionsChanged();
        this._onMaybeSuggestionsChanged();
        this._maybeUpdateStrategyExplorer();
    }
    getCurrentSuggestions(options) {
        return this.result.suggestions.filter(suggestion => {
            const suggestOption = options && options.reasons ? { reasons: [] } : undefined;
            const isVisible = suggestion.isVisible(this.arc, this.suggestFilter, suggestOption);
            if (options && options.reasons) {
                options.reasons.set(suggestion.hash, suggestOption);
            }
            return isVisible;
        });
    }
    dispose() {
        this.suggestionsChangeCallbacks = [];
        this.visibleSuggestionsChangeCallbacks = [];
        if (this.suggestionComposer) {
            this.suggestionComposer.clear();
        }
    }
    _onSuggestionsChanged() {
        this.suggestionsChangeCallbacks.forEach(callback => callback({ suggestions: this.result.suggestions }));
        if (this.inspector) {
            this.inspector.updatePlanningResults(this.result, {});
            this.inspector.updateVisibleSuggestions(this.result.suggestions, { reasons: new Map() });
        }
    }
    _onMaybeSuggestionsChanged() {
        const options = this.inspector ? { reasons: new Map() } : undefined;
        const suggestions = this.getCurrentSuggestions(options);
        if (!PlanningResult.isEquivalent(this.currentSuggestions, suggestions)) {
            this.visibleSuggestionsChangeCallbacks.forEach(callback => callback(suggestions));
            this.currentSuggestions = suggestions;
            if (this.inspector) {
                this.inspector.updateVisibleSuggestions(this.currentSuggestions, options);
            }
        }
    }
    _initSuggestionComposer() {
        const composer = this.arc.pec.slotComposer;
        if (composer && composer.findContextById('rootslotid-suggestions')) {
            this.suggestionComposer = new SuggestionComposer(this.arc, composer);
            this.registerVisibleSuggestionsChangedCallback((suggestions) => this.suggestionComposer.setSuggestions(suggestions));
        }
    }
    _maybeUpdateStrategyExplorer() {
        if (this.result.generations.length && this.inspector) {
            this.inspector.strategizingRecord(this.result.generations, { label: 'Plan Consumer', keep: true });
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Speculator {
    constructor() {
        this.speculativeArcs = [];
    }
    async speculate(arc, plan, hash) {
        assert(plan.isResolved(), `Cannot speculate on an unresolved plan: ${plan.toString({ showUnresolved: true })}`);
        const speculativeArc = await arc.cloneForSpeculativeExecution();
        this.speculativeArcs.push(speculativeArc);
        const relevance = Relevance.create(arc, plan);
        await speculativeArc.instantiate(plan);
        await this.awaitCompletion(relevance, speculativeArc);
        if (!relevance.isRelevant(plan)) {
            return null;
        }
        return { speculativeArc, relevance };
    }
    async awaitCompletion(relevance, speculativeArc) {
        const messageCount = speculativeArc.pec.messageCount;
        relevance.apply(await speculativeArc.pec.idle);
        // We expect two messages here, one requesting the idle status, and one answering it.
        if (speculativeArc.pec.messageCount !== messageCount + 2) {
            return this.awaitCompletion(relevance, speculativeArc);
        }
        else {
            speculativeArc.dispose();
            this.speculativeArcs.splice(this.speculativeArcs.indexOf(speculativeArc, 1));
            return relevance;
        }
    }
    dispose() {
        for (const arc of this.speculativeArcs) {
            arc.dispose();
        }
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const defaultTimeoutMs = 5000;
const log$6 = logFactory('PlanProducer', '#ff0090', 'log');
const error$3 = logFactory('PlanProducer', '#ff0090', 'error');
var Trigger;
(function (Trigger) {
    Trigger["Init"] = "init";
    Trigger["Search"] = "search";
    Trigger["PlanInstantiated"] = "plan-instantiated";
    Trigger["DataChanged"] = "data-changed";
    Trigger["Forced"] = "forced";
})(Trigger || (Trigger = {}));
class PlanProducer {
    constructor(arc, result, searchStore, inspector, { debug = false, noSpecEx = false } = {}) {
        this.planner = null;
        this.needReplan = false;
        this.replanOptions = {};
        this._isPlanning = false;
        this.stateChangedCallbacks = [];
        assert(result, 'result cannot be null');
        assert(arc, 'arc cannot be null');
        this.arc = arc;
        this.result = result;
        this.recipeIndex = RecipeIndex.create(this.arc);
        this.speculator = new Speculator();
        this.searchStore = searchStore;
        this.inspector = inspector;
        if (this.searchStore) {
            this.searchStoreCallback = () => this.onSearchChanged();
            this.searchStore.on('change', this.searchStoreCallback, this);
        }
        this.debug = debug;
        this.noSpecEx = noSpecEx;
    }
    get isPlanning() { return this._isPlanning; }
    set isPlanning(isPlanning) {
        if (this.isPlanning === isPlanning) {
            return;
        }
        this._isPlanning = isPlanning;
        this.stateChangedCallbacks.forEach(callback => callback(this.isPlanning));
    }
    registerStateChangedCallback(callback) {
        this.stateChangedCallbacks.push(callback);
    }
    async onSearchChanged() {
        const values = await this.searchStore.get() || [];
        const arcId = this.arc.id.idTreeAsString();
        const value = values.find(value => value.arc === arcId);
        if (!value) {
            return;
        }
        if (value.search === this.search) {
            return;
        }
        this.search = value.search;
        if (!this.search) {
            // search string turned empty, no need to replan, going back to contextual suggestions.
            return;
        }
        const options = {
            // If we're searching but currently only have contextual suggestions,
            // we need get non-contextual suggestions as well.
            contextual: !this.result.contextual,
            metadata: { trigger: Trigger.Search, search: this.search }
        };
        if (this.search !== '*') { // Search for ALL (including non-contextual) suggestions.
            // Search by search term.
            options.cancelOngoingPlanning = this.result.suggestions.length > 0;
            options.search = this.search;
            if (options.contextual) {
                // If search changed and we already how all suggestions (i.e. including
                // non-contextual ones) then it's enough to initialize with InitSearch
                // with a new search phrase.
                options.strategies = [InitSearch, ...Planner.ResolutionStrategies];
            }
        }
        await this.produceSuggestions(options);
    }
    dispose() {
        if (this.searchStore) {
            this.searchStore.off('change', this.searchStoreCallback);
        }
    }
    async produceSuggestions(options = {}) {
        if (options.cancelOngoingPlanning && this.isPlanning) {
            this._cancelPlanning();
        }
        this.needReplan = true;
        this.replanOptions = options;
        if (this.isPlanning) {
            return;
        }
        this.isPlanning = true;
        const time = now();
        let suggestions = [];
        let generations = [];
        while (this.needReplan) {
            this.needReplan = false;
            generations = [];
            suggestions = await this.runPlanner(this.replanOptions, generations);
        }
        const timestr = ((now() - time) / 1000).toFixed(2);
        if (suggestions) {
            log$6(`[${this.arc.id.idTreeAsString()}] Produced ${suggestions.length} suggestions [elapsed=${timestr}s].`);
            this.isPlanning = false;
            const serializedGenerations = this.debug ? PlanningResult.formatSerializableGenerations(generations) : [];
            if (this.result.merge({
                suggestions,
                generations: serializedGenerations,
                contextual: this.replanOptions.contextual
            }, this.arc)) {
                // Store suggestions to store.
                await this.result.flush();
                if (this.inspector)
                    this.inspector.updatePlanningResults(this.result, options.metadata);
            }
            else {
                // Add skipped result to devtools.
                if (this.inspector) {
                    this.inspector.updatePlanningAttempt(suggestions, options.metadata);
                    if (this.debug)
                        this.inspector.strategizingRecord(serializedGenerations, { label: 'Plan Producer', keep: true });
                }
            }
        }
        else { // Suggestions are null, if planning was cancelled.
            // Add cancelled attempt to devtools.
            if (this.inspector)
                this.inspector.updatePlanningAttempt(null, options.metadata);
        }
    }
    async runPlanner(options, generations) {
        let suggestions = [];
        assert(!this.planner, 'Planner must be null');
        this.planner = new Planner();
        this.planner.init(this.arc, {
            strategies: options.strategies,
            strategyArgs: {
                contextual: options.contextual,
                search: options.search,
                recipeIndex: this.recipeIndex
            },
            speculator: this.speculator,
            noSpecEx: this.noSpecEx
        });
        suggestions = await this.planner.suggest(options.timeout || defaultTimeoutMs, generations);
        if (this.planner) {
            this.planner = null;
            return suggestions;
        }
        // Planning was cancelled.
        return null;
    }
    _cancelPlanning() {
        if (this.planner) {
            this.planner = null;
        }
        this.speculator.dispose();
        this.needReplan = false;
        this.isPlanning = false; // using the setter method to trigger callbacks.
        log$6(`Cancel planning`);
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const defaultReplanDelayMs = 300;
class ReplanQueue {
    constructor(planProducer, options = {}) {
        this.options = {};
        this.planProducer = planProducer;
        this.options = options;
        this.options.replanDelayMs = this.options.replanDelayMs || defaultReplanDelayMs;
        this.changes = [];
        this.replanTimer = null;
        this.planProducer.registerStateChangedCallback(this._onPlanningStateChanged.bind(this));
    }
    addChange() {
        this.changes.push(now());
        if (this.isReplanningScheduled()) {
            this._postponeReplan();
        }
        else if (!this.planProducer.isPlanning) {
            this._scheduleReplan(this.options.replanDelayMs);
        }
    }
    _onPlanningStateChanged(isPlanning) {
        if (isPlanning) {
            // Cancel scheduled planning.
            this._cancelReplanIfScheduled();
            this.changes = [];
        }
        else if (this.changes.length > 0) {
            // Schedule delayed planning.
            const timeNow = now();
            this.changes.forEach((_ch, i) => this.changes[i] = timeNow);
            this._scheduleReplan(this.options.replanDelayMs);
        }
    }
    isReplanningScheduled() {
        return this.replanTimer !== null;
    }
    _scheduleReplan(intervalMs) {
        this._cancelReplanIfScheduled();
        this.replanTimer = setTimeout(() => this.planProducer.produceSuggestions({
            contextual: this.planProducer.result.contextual,
            metadata: { trigger: Trigger.DataChanged }
        }), intervalMs);
    }
    _cancelReplanIfScheduled() {
        if (this.isReplanningScheduled()) {
            clearTimeout(this.replanTimer);
            this.replanTimer = null;
        }
    }
    _postponeReplan() {
        if (this.changes.length <= 1) {
            return;
        }
        const now = this.changes[this.changes.length - 1];
        const sinceFirstChangeMs = now - this.changes[0];
        if (this._canPostponeReplan(sinceFirstChangeMs)) {
            this._cancelReplanIfScheduled();
            let nextReplanDelayMs = this.options.replanDelayMs;
            if (this.options.maxNoReplanMs) {
                nextReplanDelayMs = Math.min(nextReplanDelayMs, this.options.maxNoReplanMs - sinceFirstChangeMs);
            }
            this._scheduleReplan(nextReplanDelayMs);
        }
    }
    _canPostponeReplan(changesInterval) {
        return !this.options.maxNoReplanMs || changesInterval < this.options.maxNoReplanMs;
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const planificatorId = 'plans';
class Planificator {
    constructor(arc, result, searchStore, onlyConsumer = false, debug = false, inspectorFactory, noSpecEx = false) {
        this.search = null;
        this.arc = arc;
        this.searchStore = searchStore;
        this.noSpecEx = noSpecEx;
        if (inspectorFactory) {
            this.inspector = inspectorFactory.create(this);
        }
        this.result = checkDefined(result, 'Result cannot be null');
        if (!onlyConsumer) {
            this.producer = new PlanProducer(this.arc, this.result, searchStore, this.inspector, { debug, noSpecEx });
            this.replanQueue = new ReplanQueue(this.producer);
            this.dataChangeCallback = () => this.replanQueue.addChange();
            this._listenToArcStores();
        }
        this.consumer = new PlanConsumer(this.arc, this.result, this.inspector);
    }
    static async create(arc, { storageKeyBase, onlyConsumer, debug = false, inspectorFactory, noSpecEx }) {
        debug = debug || (Boolean(storageKeyBase) && storageKeyBase.startsWith('volatile'));
        const store = await Planificator._initSuggestStore(arc, storageKeyBase);
        const searchStore = await Planificator._initSearchStore(arc);
        const result = new PlanningResult({ context: arc.context, loader: arc.loader }, store);
        await result.load();
        const planificator = new Planificator(arc, result, searchStore, onlyConsumer, debug, inspectorFactory, noSpecEx);
        await planificator._storeSearch(); // Reset search value for the current arc.
        await planificator.requestPlanning({ contextual: true, metadata: { trigger: Trigger.Init } });
        return planificator;
    }
    async forceReplan() {
        this.consumer.result.suggestions = [];
        this.consumer.result.generations = [];
        await this.consumer.result.flush();
        await this.requestPlanning({ metadata: { trigger: Trigger.Forced } });
        await this.loadSuggestions();
    }
    async requestPlanning(options = {}) {
        if (!this.consumerOnly && this.producer) {
            await this.producer.produceSuggestions(options);
        }
    }
    get consumerOnly() { return !this.producer; }
    async loadSuggestions() {
        return this.result.load();
    }
    async setSearch(search) {
        search = search ? search.toLowerCase().trim() : null;
        search = (search !== '') ? search : null;
        if (this.search !== search) {
            this.search = search;
            await this._storeSearch();
            const showAll = this.search === '*';
            const filter = showAll ? null : this.search;
            this.consumer.setSuggestFilter(showAll, filter);
        }
    }
    registerSuggestionsChangedCallback(callback) {
        this.consumer.registerSuggestionsChangedCallback(callback);
    }
    registerVisibleSuggestionsChangedCallback(callback) {
        this.consumer.registerVisibleSuggestionsChangedCallback(callback);
    }
    dispose() {
        if (!this.consumerOnly) {
            this._unlistenToArcStores();
            if (this.producer) {
                this.producer.dispose();
            }
        }
        this.consumer.dispose();
        this.result.dispose();
    }
    async deleteAll() {
        if (this.producer) {
            await this.producer.result.clear();
        }
        await this.setSearch(null);
    }
    _listenToArcStores() {
        this.arc.onDataChange(this.dataChangeCallback, this);
        this.arc.context.allStores.forEach(store => {
            if (store instanceof StorageProviderBase) {
                store.on('change', this.dataChangeCallback, this);
            }
        });
    }
    _unlistenToArcStores() {
        this.arc.clearDataChange(this);
        this.arc.context.allStores.forEach(store => {
            if (store instanceof StorageProviderBase) {
                store.off('change', this.dataChangeCallback);
            }
        });
    }
    static constructSuggestionKey(arc, storageKeyBase) {
        const arcStorageKey = arc.storageProviderFactory.parseStringAsKey(arc.storageKey);
        const keybase = arc.storageProviderFactory.parseStringAsKey(storageKeyBase || arcStorageKey.base());
        return keybase.childKeyForSuggestions(planificatorId, arcStorageKey.arcId);
    }
    static constructSearchKey(arc) {
        const arcStorageKey = arc.storageProviderFactory.parseStringAsKey(arc.storageKey);
        const keybase = arc.storageProviderFactory.parseStringAsKey(arcStorageKey.base());
        return keybase.childKeyForSearch(planificatorId);
    }
    static async _initSuggestStore(arc, storageKeyBase) {
        const storageKey = Planificator.constructSuggestionKey(arc, storageKeyBase);
        return Planificator._initStore(arc, 'suggestions-id', EntityType.make(['Suggestions'], { current: 'Object' }), storageKey);
    }
    static async _initSearchStore(arc) {
        const storageKey = Planificator.constructSearchKey(arc);
        return Planificator._initStore(arc, 'search-id', EntityType.make(['Search'], { current: 'Object' }), storageKey);
    }
    static async _initStore(arc, id, type, storageKey) {
        const store = await arc.storageProviderFactory.connectOrConstruct(id, type, storageKey.toString());
        assert(store, `Failed initializing '${storageKey.toString()}' store.`);
        store.referenceMode = false;
        return store;
    }
    async _storeSearch() {
        const values = await this.searchStore.get() || [];
        const arcKey = this.arc.id.idTreeAsString();
        const newValues = [];
        for (const { arc, search } of values) {
            if (arc === arcKey) {
                if (search === this.search) {
                    return; // Unchanged search value for the current arc.
                }
            }
            else {
                newValues.push({ arc, search });
            }
        }
        if (this.search) {
            newValues.push({ search: this.search, arc: arcKey });
        }
        return this.searchStore.set(newValues);
    }
}

/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const devtoolsPlannerInspectorFactory = {
    create(planner) {
        return new DevtoolsPlannerInspector(planner);
    }
};
class DevtoolsPlannerInspector {
    constructor(planner) {
        this.arcDevtoolsChannel = null;
        void DevtoolsConnection.onceConnected.then(devtoolsChannel => {
            this.arcDevtoolsChannel = devtoolsChannel.forArc(planner.arc);
            if (planner.forceReplan) {
                this.arcDevtoolsChannel.listen('force-replan', () => void planner.forceReplan());
            }
        });
    }
    strategizingRecord(generations, options = {}) {
        if (!this.arcDevtoolsChannel)
            return;
        this.arcDevtoolsChannel.send({
            messageType: 'generations',
            messageBody: { results: generations, options }
        });
    }
    updatePlanningResults(result, metadata) {
        if (!this.arcDevtoolsChannel)
            return;
        this.arcDevtoolsChannel.send({
            messageType: 'suggestions-changed',
            messageBody: {
                suggestions: this.formatSuggestions(result.suggestions),
                lastUpdated: result.lastUpdated.getTime(),
                metadata
            }
        });
    }
    updateVisibleSuggestions(visibleSuggestions, options) {
        if (!this.arcDevtoolsChannel)
            return;
        this.arcDevtoolsChannel.send({
            messageType: 'visible-suggestions-changed',
            messageBody: {
                visibleSuggestionHashes: visibleSuggestions.map(s => s.hash),
                visibilityReasons: options ? [...options.reasons.entries()].map(e => ({ hash: e[0], ...e[1] })) : undefined
            }
        });
    }
    updatePlanningAttempt(suggestions, metadata) {
        if (!this.arcDevtoolsChannel)
            return;
        this.arcDevtoolsChannel.send({
            messageType: 'planning-attempt',
            messageBody: {
                suggestions: suggestions ? this.formatSuggestions(suggestions) : null,
                metadata
            }
        });
    }
    formatSuggestions(suggestions) {
        return suggestions.map(s => {
            const suggestionCopy = { ...s };
            suggestionCopy['particles'] = s.plan.particles.map(p => ({ name: p.name }));
            delete suggestionCopy.plan;
            return suggestionCopy;
        });
    }
}

/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const log$7 = logFactory('UserPlanner', '#4f0433');
const warn$5 = logFactory('UserPlanner', '#4f0433', 'warn');

class UserPlanner {
  constructor(userid, hostFactory, options) {
    this.runners = [];
    this.userid = userid;
    this.hostFactory = hostFactory;
    this.options = options;
  }
  onArc({add, remove}) {
    //log(add, remove);
    if (add) {
      this.addArc(add.id);
    }
    if (remove) {
      this.removeArc(remove.id);
    }
  }
  async addArc(key) {
    if (this.runners[key]) {
      warn$5(`marshalArc: already marshaled [${key}]`);
      return;
    }
    this.runners[key] = true;
    // TODO(sjmiles): we'll need a queue to handle change notifications that arrive while we are 'await'ing
    log$7(`marshalArc [${key}]`);
    try {
      const host = await this.hostFactory();
      const arc = await host.spawn({id: key});
      const planificator = await this.createPlanificator(this.userid, key, arc);
      this.runners[key] = {host, arc, planificator};
    } catch (x) {
      warn$5(`marshalArc [${key}] failed: `, x);
      //
    }
  }
  removeArc(key) {
    const runner = this.runners[key];
    if (runner) {
      runner.arc && runner.arc.dispose();
      if (runner.planificator) {
        runner.planificator.dispose();
        runner.planificator.deleteAll();
      }
      this.runners[key] = null;
    }
  }
  async createPlanificator(userid, key, arc) {
    log$7(`createPlanificator for [${key}]`);
    const options = {
      storageKeyBase: this.options.plannerStorage,
      //onlyConsumer: config.plannerOnlyConsumer,
      debug: this.options.debug,
      userid,
      inspectorFactory: devtoolsPlannerInspectorFactory
    };
    const planificator = await Planificator.create(arc, options);
    planificator.setSearch('*');
    planificator.registerSuggestionsChangedCallback(suggestions => this.suggestionsChanged(key, suggestions));
    planificator.registerVisibleSuggestionsChangedCallback(suggestions => this.visibleSuggestionsChanged(key, suggestions));
    return planificator;
  }
  suggestionsChanged(key, {suggestions}) {
    log$7(`${suggestions.length} suggestions [${key}]: ${suggestions.map(({plan}) => `[${plan.name}]`).join(', ')}`);
  }

  visibleSuggestionsChanged(key, suggestions) {
    log$7(`${suggestions.length} visible suggestions [${key}]:`);
    suggestions.forEach(({descriptionByModality, plan: {name}}) => log$7(`\t\t[${name}]: ${descriptionByModality.text}`));
  }
}

/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const contextManifest = `
  import 'https://$particles/canonical.arcs'
  import 'https://$particles/Profile/Sharing.recipe'
`;

const rootContainer = {
  root: 'root-context',
  toproot: 'toproot-context',
  modal: 'modal-context'
};

class PlannerShellInterface {
  /**
   * Starts a continuous shell planning import.
   *
   * @param assetsPath a path (relative or absolute) to locate planning assets.
   * @param userid the User Id to do planning for.
   * @param storageKeyBase Plans will be stored in a key that begins with this prefix.
   *   If not specified use a key based on the Launcher Arc.
   */
  static async start(assetsPath, storage, userid, options) {
    if (!assetsPath || !userid || !storage) {
      throw new Error('assetsPath, userid, and storage required');
    }
    // connect to DevTools if running with --explore
    await maybeConnectToDevTools();
    // create an arcs environment
    Utils.init(assetsPath);
    // observe user's arc list
    const userArcs = new UserArcs(storage, userid);
    // base context (particles & recipes) from static manifest
    const context = await Utils.parse(contextManifest);
    // userContext continually updates context based on user's arcs
    const userContext = new UserContext();
    // wait for context to spin up
    await userContext.init(storage, userid, context);
    // subscribe context to changes in user arcs
    userArcs.subscribe(change => userContext.onArc(change));
    // wait for context to bloom before planning
    let userPlanner;
    setTimeout(() => {
      // visualize context
      visualizeContext(context);
      // define a host factory
      const hostFactory = () => {
        const composer = new RamSlotComposer({rootContainer});
        const host = new ArcHost(context, storage, composer);
        return host;
      };
      // instantiate planner
      userPlanner = new UserPlanner(userid, hostFactory, options);
      // subscribe planner to changes in user arcs
      userArcs.subscribe(change => userPlanner.onArc(change));
    }, 4000);
  }
}

// These are sample users for testing.
PlannerShellInterface.DEFAULT_USER_ID = Const.DEFAULT.userId;
PlannerShellInterface.DEFAULT_STORAGE = Const.DEFAULT.storageKey;
PlannerShellInterface.DEFAULT_MANIFEST = Const.DEFAULT.manifest;

const visualizeContext = context => {
  console.log('== context ===========================');
  console.log('recipes:');
  console.log(context.allRecipes.map(recipe => recipe._name));
  console.log('stores:');
  console.log(context.allStores.map(store => store.name));
  console.log('======================================');
};

const maybeConnectToDevTools = async () => {
  if (process.argv.includes('--explore')) {
    console.log('Waiting for Arcs Explorer');
    DevtoolsConnection.ensure();
    await DevtoolsConnection.onceConnected;
  }
};

export { KeyManager, PlannerShellInterface, Runtime };
//# sourceMappingURL=index.es.js.map
