!function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=8)}([function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("assert")},function(e,t){e.exports=require("node-fetch")},function(e,t){e.exports=require("vm")},function(e,t){e.exports=require("minimist")},function(e,t){e.exports=require("jszip")},function(e,t){e.exports=require("crypto")},function(e,t,n){"use strict";n.r(t);var s=n(5),i=n.n(s),r=n(0),o=n.n(r),a=n(1),c=n.n(a),l=n(6),h=n.n(l),u=n(2),d=n.n(u),p=n(3),f=n.n(p),m=n(4),g=n.n(m);
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const y=["Text","URL","Number","Boolean"];class _{static convert(e,t){const n=JSON.parse(e),s={},i={};n["@graph"]||(n["@graph"]=[n]);for(const e of n["@graph"])"rdf:Property"===e["@type"]?i[e["@id"]]=e:"rdfs:Class"===e["@type"]&&(s[e["@id"]]=e,e.subclasses=[],e.superclass=null);for(const e of Object.values(s))if(void 0!==e["rdfs:subClassOf"]){null==e["rdfs:subClassOf"].length&&(e["rdfs:subClassOf"]=[e["rdfs:subClassOf"]]);for(const t of e["rdfs:subClassOf"]){const n=t["@id"];null==e.superclass&&(e.superclass=[]),s[n]?(s[n].subclasses.push(e),e.superclass.push(s[n])):e.superclass.push({"@id":n})}}for(const e of Object.values(s))0===e.subclasses.length&&null==t&&(t=e);const r=[];for(const e of Object.values(i)){let n=e["schema:domainIncludes"];if(n||(n={"@id":t["@id"]}),n.length||(n=[n]),(n=n.map(e=>e["@id"])).includes(t["@id"])){const t=e["@id"].split(":")[1];let n=e["schema:rangeIncludes"];n||console.log(e),n.length||(n=[n]),(n=(n=n.map(e=>e["@id"].split(":")[1])).filter(e=>y.includes(e))).length>0&&r.push({name:t,type:n})}}const o=t["@id"].split(":")[1],a=t&&t.superclass?t.superclass.map(e=>e["@id"].split(":")[1]):[];let c="";for(const e of a)c+=`import 'https://schema.org/${e}'\n\n`;if(c+=`schema ${o}`,a.length>0&&(c+=` extends ${a.join(", ")}`),r.length>0)for(const e of r){let t;c+=`\n  ${t=e.type.length>1?"("+e.type.join(" or ")+")":e.type[0]} ${e.name}`}return c+="\n"}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const v=()=>Object.create(null),S=e=>(class extends e{constructor(){super(),this._pendingProps=v(),this._props=this._getInitialProps()||v(),this._lastProps=v(),this._state=this._getInitialState()||v(),this._lastState=v()}_getInitialProps(){}_getInitialState(){}_getProperty(e){return this._pendingProps[e]||this._props[e]}_setProperty(e,t){(this._validator||this._wouldChangeProp(e,t))&&(this._pendingProps[e]=t,this._invalidateProps())}_wouldChangeValue(e,t,n){return e[t]!==n}_wouldChangeProp(e,t){return this._wouldChangeValue(this._props,e,t)}_wouldChangeState(e,t){return this._wouldChangeValue(this._state,e,t)}_setProps(e){Object.assign(this._pendingProps,e),this._invalidateProps()}_invalidateProps(){this._propsInvalid=!0,this._invalidate()}_setImmutableState(e,t){"object"==typeof e&&(console.warn("Xen:: _setImmutableState takes name and value args for a single property, dictionaries not supported."),t=Object.values(e)[0],e=Object.names(e)[0]),"object"==typeof t&&(t=Object.assign(Object.create(null),t)),this._state[e]=t,this._invalidate()}_setState(e){let t=!1;const n=this._state;for(const s in e){const i=e[s];this._wouldChangeState(s,i)&&(t=!0,n[s]=i)}if(t)return this._invalidate(),!0}_async(e){return Promise.resolve().then(e.bind(this))}_invalidate(){this._validator||(this._validator=this._async(this._validate))}_getStateArgs(){return[this._props,this._state,this._lastProps,this._lastState]}_validate(){const e=this._getStateArgs();try{Object.assign(this._props,this._pendingProps),this._propsInvalid&&(this._willReceiveProps(...e),this._propsInvalid=!1),this._shouldUpdate(...e)&&(this._ensureMount(),this._doUpdate(...e))}catch(e){console.error(e)}this._validator=null,this._lastProps=Object.assign(v(),this._props),this._lastState=Object.assign(v(),this._state)}_doUpdate(...e){this._update(...e),this._didUpdate(...e)}_ensureMount(){}_willReceiveProps(){}_shouldUpdate(){return!0}_update(){}_didUpdate(){}_debounce(e,t,n){e=`_debounce_${e}`,this._state[e]=((e,t,n)=>{if(e&&clearTimeout(e),t&&n)return setTimeout(t,n)})(this._state[e],t,null!=n?n:16)}});class b extends Error{constructor(e,t,n,s){super(),this.cause=e,this.method=t,this.particleId=n,this.particleName=s,this.stack+=`\nCaused by: ${this.cause.stack}`}toLiteral(){return{exceptionType:this.constructor.name,cause:{name:this.cause.name,message:this.cause.message,stack:this.cause.stack},method:this.method,particleId:this.particleId,particleName:this.particleName,stack:this.stack}}static fromLiteral(e){const t=e.cause;let n;switch(e.exceptionType){case w.name:n=new w(t,e.method,e.particleId,e.particleName);break;case C.name:n=new C(t,e.method,e.particleId,e.particleName);break;default:throw new Error(`Unknown exception type: ${e.exceptionType}`)}return n.stack=e.stack,n}}class w extends b{get message(){const e=this.particleName?this.particleName:this.particleId;return`SystemException: exception ${this.cause.name} raised when invoking system function ${this.method} on behalf of particle ${e}: ${this.cause.message}`}}class C extends b{get message(){const e=this.particleName?this.particleName:this.particleId;return`UserException: exception ${this.cause.name} raised when invoking function ${this.method} on particle ${e}: ${this.cause.message}`}}const T=[];var $,k;$=(e=>{throw console.log(e.method,e.particleName),e}),T.includes($)||T.push($),function(e){e.Dom="dom",e.DomTouch="dom-touch",e.Vr="vr",e.Voice="voice"}(k||(k={}));class R{constructor(e){this.names=e}static create(e){return d()(e.every(e=>R.all.names.includes(e)),`Unsupported modality in: ${e}`),new R(e)}intersection(e){return new R(this.names.filter(t=>e.names.includes(t)))}isResolved(){return this.names.length>0}isCompatible(e){return this.intersection(R.create(e)).isResolved()}static get Name(){return k}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function E(e){return ee.fromLiteral(e)}function I(e){return"object"==typeof e?E(e):e}function N({type:e,name:t,direction:n}){return{type:e?E(e):void 0,name:t?I(t):void 0,direction:n}}function M({name:e,direction:t,isRequired:n,isSet:s}){return{name:e?I(e):void 0,direction:t,isRequired:n,isSet:s}}function x(e){return e instanceof ne?e.toLiteral():e}function A({type:e,name:t,direction:n}){return{type:e?e.toLiteral():void 0,name:t?x(t):void 0,direction:n}}function j({name:e,direction:t,isRequired:n,isSet:s}){return{name:e?x(e):void 0,direction:t,isRequired:n,isSet:s}}R.all=new R([R.Name.Dom,R.Name.DomTouch,R.Name.Vr,R.Name.Voice]),R.dom=new R([R.Name.Dom]),R.domTouch=new R([R.Name.DomTouch]),R.voice=new R([R.Name.Voice]),R.vr=new R([R.Name.Vr]);const O=["type","name","direction"],P=["name","direction","isRequired","isSet"];class F{constructor(e,t,n){d()(e),d()(void 0!==t),d()(void 0!==n),this.name=e,this.handles=t,this.slots=n,this.typeVars=[];for(const e of t)for(const t of O)F.isTypeVar(e[t])&&this.typeVars.push({object:e,field:t});for(const e of n)for(const t of P)F.isTypeVar(e[t])&&this.typeVars.push({object:e,field:t})}toPrettyString(){return"InterfaceInfo"}mergeTypeVariablesByName(e){this.typeVars.map(({object:t,field:n})=>t[n]=t[n].mergeTypeVariablesByName(e))}get canReadSubset(){return this._cloneAndUpdate(e=>e.canReadSubset)}get canWriteSuperset(){return this._cloneAndUpdate(e=>e.canWriteSuperset)}isMoreSpecificThan(e){if(this.handles.length!==e.handles.length||this.slots.length!==e.slots.length)return!1;for(let t=0;t<this.typeVars.length;t++){const n=this.typeVars[t],s=e.typeVars[t];if(!n.object[n.field].isMoreSpecificThan(s.object[s.field]))return!1}return!0}_applyExistenceTypeTest(e){for(const t of this.typeVars)if(e(t.object[t.field]))return!0;return!1}_handlesToManifestString(){return this.handles.map(e=>`  ${e.direction?e.direction+" ":""}${e.type.toString()} ${e.name?e.name:"*"}`).join("\n")}_slotsToManifestString(){return this.slots.map(e=>`  ${e.direction} ${e.isSet?"set of ":""}${e.name?e.name+" ":""}`).join("\n")}toString(){return`interface ${this.name}\n${this._handlesToManifestString()}\n${this._slotsToManifestString()}`}static fromLiteral(e){const t=e.handles.map(N),n=e.slots.map(M);return new F(e.name,t,n)}toLiteral(){const e=this.handles.map(A),t=this.slots.map(j);return{name:this.name,handles:e,slots:t}}clone(e){const t=this.handles.map(({name:t,direction:n,type:s})=>({name:t,direction:n,type:s?s.clone(e):void 0})),n=this.slots.map(({name:e,direction:t,isRequired:n,isSet:s})=>({name:e,direction:t,isRequired:n,isSet:s}));return new F(this.name,t,n)}cloneWithResolutions(e){return this._cloneWithResolutions(e)}_cloneWithResolutions(e){const t=this.handles.map(({name:t,direction:n,type:s})=>({name:t,direction:n,type:s?s._cloneWithResolutions(e):void 0})),n=this.slots.map(({name:e,direction:t,isRequired:n,isSet:s})=>({name:e,direction:t,isRequired:n,isSet:s}));return new F(this.name,t,n)}canEnsureResolved(){for(const e of this.typeVars)if(!e.object[e.field].canEnsureResolved())return!1;return!0}maybeEnsureResolved(){for(const e of this.typeVars){let t=e.object[e.field];if(!(t=t.clone(new Map)).maybeEnsureResolved())return!1}for(const e of this.typeVars)e.object[e.field].maybeEnsureResolved();return!0}tryMergeTypeVariablesWith(e){if(!this._equalItems(e.slots,this.slots,this._equalSlot))return null;if(e.handles.length!==this.handles.length)return null;const t=new Set(this.handles),n=new Set(e.handles),s=new Map;let i=t.size;for(;t.size>0;){const e=[...t.values()].map(e=>({handle:e,match:[...n.values()].filter(t=>this._equalHandle(e,t))}));for(const i of e){if(0===i.match.length)return null;1===i.match.length&&(s.set(i.handle,i.match[0]),n.delete(i.match[0]),t.delete(i.handle))}if(t.size===i)return null;i=t.size}const r=[];for(const e of this.handles){const t=s.get(e);let n;if(e.type.hasVariable||t.type.hasVariable){if(!(n=ue._tryMergeTypeVariable(e.type,t.type)))return null}else n=e.type||t.type;r.push({name:e.name||t.name,direction:e.direction||t.direction,type:n})}const o=this.slots.map(({name:e,direction:t,isRequired:n,isSet:s})=>({name:e,direction:t,isRequired:n,isSet:s}));return new F(this.name,r,o)}resolvedType(){return this._cloneAndUpdate(e=>e.resolvedType())}equals(e){return this.handles.length===e.handles.length&&(!!this._equalItems(e.handles,this.handles,this._equalHandle)&&!!this._equalItems(e.slots,this.slots,this._equalSlot))}_equalHandle(e,t){return e.name===t.name&&e.direction===t.direction&&e.type.equals(t.type)}_equalSlot(e,t){return e.name===t.name&&e.direction===t.direction&&e.isRequired===t.isRequired&&e.isSet===t.isSet}_equalItems(e,t,n){for(const s of e){let e=!1;for(const i of t)if(n(i,s)){e=!0;break}if(!e)return!1}return!0}_cloneAndUpdate(e){const t=this.clone(new Map);return t.typeVars.forEach(t=>F._updateTypeVar(t,e)),t}static _updateTypeVar(e,t){e.object[e.field]=t(e.object[e.field])}static isTypeVar(e){return e instanceof ne||e instanceof ee&&e.hasVariable}static mustMatch(e){return!(null==e||F.isTypeVar(e))}static handlesMatch(e,t){if(F.mustMatch(e.name)&&e.name!==t.name)return!1;if(F.mustMatch(e.direction)&&e.direction!==t.direction)return!1;if(null==e.type)return!0;const[n,s]=ee.unwrapPair(e.type,t.type);return n instanceof ne?[{var:n,value:s,direction:e.direction}]:n.equals(s)}static slotsMatch(e,t){return(!F.mustMatch(e.name)||e.name===t.name)&&((!F.mustMatch(e.direction)||e.direction===t.direction)&&((!F.mustMatch(e.isRequired)||e.isRequired===t.isRequired)&&(!F.mustMatch(e.isSet)||e.isSet===t.isSet)))}particleMatches(e){return!1!==this.cloneWithResolutions(new Map).restrictType(e)}restrictType(e){return this._restrictThis(e)}_restrictThis(e){const t=this.handles.map(t=>e.handleConnections.map(e=>({match:e,result:F.handlesMatch(t,e)})).filter(e=>!1!==e.result)),n=[];e.slotConnections.forEach(e=>{n.push({name:e.name,direction:"consume",isRequired:e.isRequired,isSet:e.isSet}),e.provideSlotConnections.forEach(e=>{n.push({name:e.name,direction:"provide",isRequired:!1,isSet:e.isSet})})});const s=this.slots.map(e=>n.filter(t=>F.slotsMatch(e,t))).map(e=>e.map(e=>({match:e,result:!0})));function i(e,t){if(0===e.length)return[];const n=e.pop();for(const s of n){if(t.includes(s.match))continue;const n=t.slice();n.push(s.match);const r=i(e,n);if(!1!==r)return"boolean"==typeof s.result?r:r.concat(s.result)}return!1}const r=i(t,[]),o=i(s,[]);if(!1===r||!1===o)return!1;for(const e of r)if(e.var.variable.resolution){if(e.var.variable.resolution instanceof ne){if(!ue.processTypeList(e.var,[{type:e.value,direction:e.direction}]))return!1}else if(!e.var.variable.resolution.equals(e.value))return!1}else e.var.variable.resolution=e.value;return!0}}
// @license
const L={identifier:Symbol("id")};
/** @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */var H;!function(e){e[e.Unstored=0]="Unstored",e[e.Stored=1]="Stored"}(H||(H={}));class B{constructor(e,t,n){this.entity=null,this.storageProxy=null,this.handle=null,this.id=e.id,this.storageKey=e.storageKey,this.context=n,this.type=t}async ensureStorageProxy(){null==this.storageProxy&&(this.storageProxy=await this.context.getStorageProxy(this.storageKey,this.type.referredType),this.handle=function(e,t,n=null,s="",i=!0,r=!0){let o;o=e.type instanceof se?new ke(e,t,n,s,i,r):e.type instanceof ie?new Ie(e,t,n,s,i,r):new Re(e,t,n,s,i,r);const a=e.type.getContainedType()||e.type;a instanceof te&&(o.entityClass=a.entitySchema.entityClass(e.pec));return o}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */(this.storageProxy,this.context.idGenerator),this.storageKey?d()(this.storageKey===this.storageProxy.storageKey):this.storageKey=this.storageProxy.storageKey)}async dereference(){return d()(this.context,"Must have context to dereference"),this.entity?this.entity:(await this.ensureStorageProxy(),this.entity=await this.handle.get(this.id),this.entity)}dataClone(){return{storageKey:this.storageKey,id:this.id}}serialize(){return{id:this.id,rawData:this.dataClone()}}}class q extends B{constructor(e,t){super({id:e.id,storageKey:null},new ce(e.entityClass.type),t),this.mode=H.Unstored,this.entity=e,this.stored=new Promise(async(t,n)=>{await this.storeReference(e),t()})}async storeReference(e){await this.ensureStorageProxy(),await this.handle.store(e),this.mode=H.Stored}async dereference(){return this.mode===H.Unstored?null:super.dereference()}isIdentified(){return this.entity.isIdentified()}static newClientReference(e){return class extends q{constructor(t){super(t,e)}}}}
// @license
class V{constructor(e,t,n,s){this._mutable=!0,d()(!s||-1===s.indexOf(":"),"user IDs must not contain the ':' character"),J(this,void 0),this.userIDComponent=s,this.schema=t,this.context=n,d()(e,"can't construct entity with null data"),this.rawData=K(e,t,n)}get mutable(){return this._mutable}set mutable(e){if(!this.mutable&&e)throw new Error("You cannot make an immutable entity mutable again.");this._mutable=e}mutate(e){if(!this.mutable)throw new Error("Entity is immutable.");let t;"function"==typeof e?e(t=this.dataClone()):t=e,this.rawData=K(t,this.schema,this.context)}getUserID(){return this.userIDComponent}isIdentified(){return void 0!==U(this)}get id(){return d()(!!this.isIdentified()),U(this)}identify(e){d()(!this.isIdentified()),J(this,e);const t=e.split(":"),n=t.lastIndexOf("uid");this.userIDComponent=n>0?t.slice(n+1).join(":"):""}createIdentity(e,t){let n;d()(!this.isIdentified()),J(this,n=this.userIDComponent?`${e.toString()}:uid:${this.userIDComponent}`:t.newChildId(e).toString())}toLiteral(){return this.rawData}toJSON(){return this.rawData}dataClone(){const e={},t=this.schema.fields;for(const n of Object.keys(t))void 0!==this.rawData[n]&&(t[n]&&"schema-reference"===t[n].kind?this.rawData[n]&&(e[n]=this.rawData[n].dataClone()):t[n]&&"schema-collection"===t[n].kind?this.rawData[n]&&(e[n]=[...this.rawData[n]].map(e=>e.dataClone())):e[n]=this.rawData[n]);return e}serialize(){return{id:U(this),rawData:this.dataClone()}}static createEntityClass(e,t){const n=class extends V{constructor(n,s){super(n,e,t,s)}get entityClass(){return n}static get type(){return new te(e)}static get key(){return{tag:"entity",schema:e}}static get schema(){return e}};Object.defineProperty(n,"name",{value:e.name});for(const t of Object.keys(e.fields))Object.defineProperty(n.prototype,t,{get(){return this.rawData[t]},set(e){this.rawData[t]=e}});return n}}function W(e,t){switch(e.type){case"Text":case"URL":return"string";case"Number":return"number";case"Boolean":return"boolean";case"Bytes":return"Uint8Array";case"Object":return"object";default:throw new Error(`Unknown field type ${e.type} in schema ${t}`)}}function z({op:e,name:t,value:n,schema:s,fieldType:i}){if(void 0===(i=i||s.fields[t]))throw new Error(`Can't ${e} field ${t}; not in schema ${s.name}`);if(null!=n)switch(i.kind){case"schema-primitive":if(("Uint8Array"===n.constructor.name?"Uint8Array":typeof n)!==W(i,s.name))throw new TypeError(`Type mismatch ${e}ting field ${t} (type ${i.type}); `+`value '${n}' is type ${typeof n}`);break;case"schema-union":for(const e of i.types)if(typeof n===W(e,s.name))return;throw new TypeError(`Type mismatch ${e}ting field ${t} (union [${i.types}]); `+`value '${n}' is type ${typeof n}`);case"schema-tuple":if(!Array.isArray(n))throw new TypeError(`Cannot ${e} tuple ${t} with non-array value '${n}'`);if(n.length!==i.types.length)throw new TypeError(`Length mismatch ${e}ting tuple ${t} `+`[${i.types}] with value '${n}'`);i.types.map((r,o)=>{if(void 0!==n[o]&&null!==n[o]&&typeof n[o]!==W(r,s.name))throw new TypeError(`Type mismatch ${e}ting field ${t} (tuple [${i.types}]); `+`value '${n}' has type ${typeof n[o]} at index ${o}`)});break;case"schema-reference":if(!(n instanceof B))throw new TypeError(`Cannot ${e} reference ${t} with non-reference '${n}'`);if(!ue.compareTypes({type:n.type},{type:new ce(i.schema.model)}))throw new TypeError(`Cannot ${e} reference ${t} with value '${n}' of mismatched type`);break;case"schema-collection":if("Set"!==n.constructor.name)throw new TypeError(`Cannot ${e} collection ${t} with non-Set '${n}'`);for(const r of n)z({op:e,name:t,value:r,schema:s,fieldType:i.schema});break;default:throw new Error(`Unknown kind ${i.kind} in schema ${s.name}`)}}function D(e,t,n,s){if(!e)return t;if("schema-reference"===e.kind&&t){if(t instanceof B)return t;if(t.id&&t.storageKey)return new B(t,new ce(e.schema.model),s);throw new TypeError(`Cannot set reference ${n} with non-reference '${t}'`)}if("schema-collection"===e.kind&&t){if("Set"===t.constructor.name)return t;if(t.length&&t instanceof Object)return new Set(t.map(t=>D(e.schema,t,n,s)));throw new TypeError(`Cannot set collection ${n} with non-collection '${t}'`)}return t}function K(e,t,n){const s=["toJSON","prototype","toString","inspect"],i=function(e,t,n){const s={};for(const[i,r]of Object.entries(e)){const e=D(t.fields[i],r,i,n);z({op:"set",name:i,value:e,schema:t}),s[i]=e}return s}(e,t,n);return new Proxy(i,{get:(e,n)=>{if(s.includes(n)||n.constructor===Symbol)return;const i=e[n];return z({op:"get",name:n,value:i,schema:t}),i},set:(e,t,n)=>{throw new Error(`Tried to modify entity field '${t}'. Use the mutate method instead.`)}})}function U(e){return e[L.identifier]}function J(e,t){e[L.identifier]=t}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class Z{constructor(e,t,n){this.description={},this.names=e,this.fields={};for(const[e,n]of Object.entries(t))this.fields[e]="string"==typeof n?{kind:"schema-primitive",type:n}:n;n&&n.description.forEach(e=>this.description[e.name]=e.pattern||e.patterns[0])}toLiteral(){const e={},t=e=>{if("schema-reference"===e.kind){const t=e.schema;return{kind:"schema-reference",schema:{kind:t.kind,model:t.model.toLiteral()}}}return"schema-collection"===e.kind?{kind:"schema-collection",schema:t(e.schema)}:e};for(const n of Object.keys(this.fields))e[n]=t(this.fields[n]);return{names:this.names,fields:e,description:this.description}}static fromLiteral(e={fields:{},names:[],description:{}}){const t={},n=e=>{if("schema-reference"===e.kind){const t=e.schema;return{kind:"schema-reference",schema:{kind:t.kind,model:ee.fromLiteral(t.model)}}}return"schema-collection"===e.kind?{kind:"schema-collection",schema:n(e.schema)}:e};for(const s of Object.keys(e.fields))t[s]=n(e.fields[s]);const s=new Z(e.names,t);return s.description=e.description||{},s}get name(){return this.names[0]}static typesEqual(e,t){return Z._typeString(e)===Z._typeString(t)}static _typeString(e){switch(e.kind){case"schema-primitive":return e.type;case"schema-union":return`(${e.types.map(e=>e.type).join(" or ")})`;case"schema-tuple":return`(${e.types.map(e=>e.type).join(", ")})`;case"schema-reference":return`Reference<${Z._typeString(e.schema)}>`;case"type-name":case"schema-inline":return e.model.entitySchema.toInlineSchemaString();case"schema-collection":return`[${Z._typeString(e.schema)}]`;default:throw new Error(`Unknown type kind ${e.kind} in schema ${this.name}`)}}static union(e,t){const n=[...new Set([...e.names,...t.names])],s={};for(const[n,i]of[...Object.entries(e.fields),...Object.entries(t.fields)])if(s[n]){if(!Z.typesEqual(s[n],i))return null}else s[n]=i;return new Z(n,s)}static intersect(e,t){const n=[...e.names].filter(e=>t.names.includes(e)),s={};for(const[n,i]of Object.entries(e.fields)){const e=t.fields[n];e&&Z.typesEqual(i,e)&&(s[n]=i)}return new Z(n,s)}equals(e){return this===e||this.name===e.name&&this.isMoreSpecificThan(e)&&e.isMoreSpecificThan(this)}isMoreSpecificThan(e){const t=new Set(this.names);for(const n of e.names)if(!t.has(n))return!1;const n={};for(const[e,t]of Object.entries(this.fields))n[e]=t;for(const[t,s]of Object.entries(e.fields)){if(null==n[t])return!1;if(!Z.typesEqual(n[t],s))return!1}return!0}get type(){return new te(this)}entityClass(e=null){return V.createEntityClass(this,e)}toInlineSchemaString(e){const t=this.names.join(" ")||"*",n=Object.entries(this.fields).map(([e,t])=>`${Z._typeString(t)} ${e}`).join(", ");return`${t} {${n.length>0&&e&&e.hideFields?"...":n}}`}toManifestString(){const e=[];if(e.push(`schema ${this.names.join(" ")}`),e.push(...Object.entries(this.fields).map(([e,t])=>`  ${Z._typeString(t)} ${e}`)),Object.keys(this.description).length>0){e.push(`  description \`${this.description.pattern}\``);for(const t of Object.keys(this.description))"pattern"!==t&&e.push(`    ${t} \`${this.description[t]}\``)}return e.join("\n")}}
// @license
class G{constructor(e,t){this.formFactor=e,this.handle=t}toLiteral(){return this}static fromLiteral({formFactor:e,handle:t}){return new G(e,t)}}
// @license
class Q{constructor(e,t){this.id=e.toString(),this.serialization=t.replace(/\bimport .*\n/g,"")}static extractSerialization(e){return e.serialization.replace(/\bimport .*\n/g,"")}}class X{constructor(e,t,n,s){this.id=e,this.storageKey=t,this.type=n,this.tags=s}}
// @license
class Y{constructor(e,t,n){this.name=e,this._canWriteSuperset=t,this._canReadSubset=n,this._resolution=null}maybeMergeConstraints(e){return!!this.maybeMergeCanReadSubset(e.canReadSubset)&&this.maybeMergeCanWriteSuperset(e.canWriteSuperset)}maybeMergeCanReadSubset(e){if(null==e)return!0;if(null==this.canReadSubset)return this.canReadSubset=e,!0;if(this.canReadSubset instanceof ae&&e instanceof ae)return!0;if(this.canReadSubset instanceof te&&e instanceof te){const t=Z.intersect(this.canReadSubset.entitySchema,e.entitySchema);return!!t&&(this.canReadSubset=new te(t),!0)}return!1}maybeMergeCanWriteSuperset(e){if(null==e)return!0;if(null==this.canWriteSuperset)return this.canWriteSuperset=e,!0;if(this.canWriteSuperset instanceof ae&&e instanceof ae)return!0;if(this.canWriteSuperset instanceof te&&e instanceof te){const t=Z.union(this.canWriteSuperset.entitySchema,e.entitySchema);return!!t&&(this.canWriteSuperset=new te(t),!0)}return!1}isSatisfiedBy(e){const t=this._canWriteSuperset;if(!t)return!0;if(!(t instanceof te&&e instanceof te))throw new Error(`constraint checking not implemented for ${this} and ${e}`);return e.getEntitySchema().isMoreSpecificThan(t.getEntitySchema())}get resolution(){return this._resolution?this._resolution.resolvedType():null}isValidResolutionCandidate(e){const t=e.resolvedType().getContainedType();return t instanceof ne&&t.variable===this?{result:!1,detail:"variable cannot resolve to collection of itself"}:{result:!0}}set resolution(e){d()(!this._resolution);const t=this.isValidResolutionCandidate(e);d()(t.result,t.detail);let n=e;for(;n&&n instanceof ne;){if(n.variable===this)return;n=n.variable.resolution}this._resolution=e,this._canWriteSuperset=null,this._canReadSubset=null}get canWriteSuperset(){return this._resolution?(d()(!this._canWriteSuperset),this._resolution instanceof ne?this._resolution.variable.canWriteSuperset:null):this._canWriteSuperset}set canWriteSuperset(e){d()(!this._resolution),this._canWriteSuperset=e}get canReadSubset(){return this._resolution?(d()(!this._canReadSubset),this._resolution instanceof ne?this._resolution.variable.canReadSubset:null):this._canReadSubset}set canReadSubset(e){d()(!this._resolution),this._canReadSubset=e}get hasConstraint(){return null!==this._canReadSubset||null!==this._canWriteSuperset}canEnsureResolved(){return this._resolution?this._resolution.canEnsureResolved():!(!this._canWriteSuperset&&!this._canReadSubset)}maybeEnsureResolved(){return this._resolution?this._resolution.maybeEnsureResolved():this._canWriteSuperset?(this.resolution=this._canWriteSuperset,!0):!!this._canReadSubset&&(this.resolution=this._canReadSubset,!0)}toLiteral(){return d()(null==this.resolution),this.toLiteralIgnoringResolutions()}toLiteralIgnoringResolutions(){return{name:this.name,canWriteSuperset:this._canWriteSuperset&&this._canWriteSuperset.toLiteral(),canReadSubset:this._canReadSubset&&this._canReadSubset.toLiteral()}}static fromLiteral(e){return new Y(e.name,e.canWriteSuperset?ee.fromLiteral(e.canWriteSuperset):null,e.canReadSubset?ee.fromLiteral(e.canReadSubset):null)}isResolved(){return this._resolution&&this._resolution.isResolved()}}
// @license
class ee{constructor(e){this.tag=e}static fromLiteral(e){switch(e.tag){case"Entity":return new te(Z.fromLiteral(e.data));case"TypeVariable":return new ne(Y.fromLiteral(e.data));case"Collection":return new se(ee.fromLiteral(e.data));case"BigCollection":return new ie(ee.fromLiteral(e.data));case"Relation":return new re(e.data.map(e=>ee.fromLiteral(e)));case"Interface":return new oe(F.fromLiteral(e.data));case"Slot":return new ae(G.fromLiteral(e.data));case"Reference":return new ce(ee.fromLiteral(e.data));case"Arc":return new le;case"Handle":return new he;default:throw new Error(`fromLiteral: unknown type ${e}`)}}static unwrapPair(e,t){if(e.tag===t.tag){const n=e.getContainedType();if(null!==n)return ee.unwrapPair(n,t.getContainedType())}return[e,t]}static canMergeConstraints(e,t){return ee._canMergeCanReadSubset(e,t)&&ee._canMergeCanWriteSuperset(e,t)}static _canMergeCanReadSubset(e,t){if(e.canReadSubset&&t.canReadSubset){if(e.canReadSubset.tag!==t.canReadSubset.tag)return!1;if(e.canReadSubset instanceof te)return null!==Z.intersect(e.canReadSubset.entitySchema,t.canReadSubset.entitySchema);throw new Error(`_canMergeCanReadSubset not implemented for types tagged with ${e.canReadSubset.tag}`)}return!0}static _canMergeCanWriteSuperset(e,t){if(e.canWriteSuperset&&t.canWriteSuperset){if(e.canWriteSuperset.tag!==t.canWriteSuperset.tag)return!1;if(e.canWriteSuperset instanceof te)return null!==Z.union(e.canWriteSuperset.entitySchema,t.canWriteSuperset.entitySchema)}return!0}isCollectionType(){return this instanceof se}isBigCollectionType(){return this instanceof ie}equals(e){return ue.compareTypes({type:this},{type:e})}isResolved(){return!this.hasUnresolvedVariable}mergeTypeVariablesByName(e){return this}_applyExistenceTypeTest(e){return e(this)}get hasVariable(){return this._applyExistenceTypeTest(e=>e instanceof ne)}get hasUnresolvedVariable(){return this._applyExistenceTypeTest(e=>e instanceof ne&&!e.variable.isResolved())}getContainedType(){return null}isTypeContainer(){return!1}collectionOf(){return new se(this)}bigCollectionOf(){return new ie(this)}resolvedType(){return this}canEnsureResolved(){return this.isResolved()||this._canEnsureResolved()}_canEnsureResolved(){return!0}maybeEnsureResolved(){return!0}get canWriteSuperset(){throw new Error(`canWriteSuperset not implemented for ${this}`)}get canReadSubset(){throw new Error(`canReadSubset not implemented for ${this}`)}isMoreSpecificThan(e){return this.tag===e.tag&&this._isMoreSpecificThan(e)}_isMoreSpecificThan(e){throw new Error(`isMoreSpecificThan not implemented for ${this}`)}clone(e){return this.resolvedType()._clone(e)}_clone(e){return ee.fromLiteral(this.toLiteral())}_cloneWithResolutions(e){return ee.fromLiteral(this.toLiteral())}hasProperty(e){return e(this)||this._hasProperty(e)}_hasProperty(e){return!1}toString(e){return this.tag}getEntitySchema(){return null}toPrettyString(){return null}}class te extends ee{constructor(e){super("Entity"),this.entitySchema=e}static make(e,t,n){return new te(new Z(e,t,n))}get isEntity(){return!0}get canWriteSuperset(){return this}get canReadSubset(){return this}_isMoreSpecificThan(e){return this.entitySchema.isMoreSpecificThan(e.entitySchema)}toLiteral(){return{tag:this.tag,data:this.entitySchema.toLiteral()}}toString(e){return this.entitySchema.toInlineSchemaString(e)}getEntitySchema(){return this.entitySchema}_cloneWithResolutions(e){if(e.has(this.entitySchema))return e.get(this.entitySchema);const t=new te(this.entitySchema);return e.set(this.entitySchema,t),t}toPrettyString(){return this.entitySchema.description.pattern?this.entitySchema.description.pattern:this.entitySchema.name?this.entitySchema.name.replace(/([^A-Z])([A-Z])/g,"$1 $2").replace(/([A-Z][^A-Z])/g," $1").replace(/[\s]+/g," ").trim():JSON.stringify(this.entitySchema.toLiteral())}}class ne extends ee{constructor(e){super("TypeVariable"),this.variable=e}static make(e,t,n){return new ne(new Y(e,t,n))}get isVariable(){return!0}mergeTypeVariablesByName(e){const t=this.variable.name;let n=e.get(t);if(n){if(n instanceof ne&&(n.variable.hasConstraint||this.variable.hasConstraint)){if(!n.variable.maybeMergeConstraints(this.variable))throw new Error("could not merge type variables")}}else n=this,e.set(t,this);return n}resolvedType(){return this.variable.resolution||this}_canEnsureResolved(){return this.variable.canEnsureResolved()}maybeEnsureResolved(){return this.variable.maybeEnsureResolved()}get canWriteSuperset(){return this.variable.canWriteSuperset}get canReadSubset(){return this.variable.canReadSubset}_clone(e){const t=this.variable.name;if(e.has(t))return new ne(e.get(t));{const n=Y.fromLiteral(this.variable.toLiteral());return e.set(t,n),new ne(n)}}_cloneWithResolutions(e){if(e.has(this.variable))return new ne(e.get(this.variable));{const t=Y.fromLiteral(this.variable.toLiteralIgnoringResolutions());return this.variable.resolution&&(t._resolution=this.variable._resolution._cloneWithResolutions(e)),this.variable._canReadSubset&&(t.canReadSubset=this.variable.canReadSubset._cloneWithResolutions(e)),this.variable._canWriteSuperset&&(t.canWriteSuperset=this.variable.canWriteSuperset._cloneWithResolutions(e)),e.set(this.variable,t),new ne(t)}}toLiteral(){return this.variable.resolution?this.variable.resolution.toLiteral():{tag:this.tag,data:this.variable.toLiteral()}}toString(e){return`~${this.variable.name}`}getEntitySchema(){return this.variable.isResolved()?this.resolvedType().getEntitySchema():null}toPrettyString(){return this.variable.isResolved()?this.resolvedType().toPrettyString():`[~${this.variable.name}]`}}class se extends ee{constructor(e){super("Collection"),this.collectionType=e}get isCollection(){return!0}mergeTypeVariablesByName(e){const t=this.collectionType,n=t.mergeTypeVariablesByName(e);return n===t?this:n.collectionOf()}_applyExistenceTypeTest(e){return this.collectionType._applyExistenceTypeTest(e)}getContainedType(){return this.collectionType}isTypeContainer(){return!0}resolvedType(){const e=this.collectionType,t=e.resolvedType();return e!==t?t.collectionOf():this}_canEnsureResolved(){return this.collectionType.canEnsureResolved()}maybeEnsureResolved(){return this.collectionType.maybeEnsureResolved()}_clone(e){const t=this.collectionType.clone(e).toLiteral();return ee.fromLiteral({tag:this.tag,data:t})}_cloneWithResolutions(e){return new se(this.collectionType._cloneWithResolutions(e))}toLiteral(){return{tag:this.tag,data:this.collectionType.toLiteral()}}_hasProperty(e){return this.collectionType.hasProperty(e)}toString(e){return`[${this.collectionType.toString(e)}]`}getEntitySchema(){return this.collectionType.getEntitySchema()}toPrettyString(){const e=this.getEntitySchema();return e&&e.description.plural?e.description.plural:`${this.collectionType.toPrettyString()} List`}}class ie extends ee{constructor(e){super("BigCollection"),this.bigCollectionType=e}get isBigCollection(){return!0}mergeTypeVariablesByName(e){const t=this.bigCollectionType,n=t.mergeTypeVariablesByName(e);return n===t?this:n.bigCollectionOf()}_applyExistenceTypeTest(e){return this.bigCollectionType._applyExistenceTypeTest(e)}getContainedType(){return this.bigCollectionType}isTypeContainer(){return!0}resolvedType(){const e=this.bigCollectionType,t=e.resolvedType();return e!==t?t.bigCollectionOf():this}_canEnsureResolved(){return this.bigCollectionType.canEnsureResolved()}maybeEnsureResolved(){return this.bigCollectionType.maybeEnsureResolved()}_clone(e){const t=this.bigCollectionType.clone(e).toLiteral();return ee.fromLiteral({tag:this.tag,data:t})}_cloneWithResolutions(e){return new ie(this.bigCollectionType._cloneWithResolutions(e))}toLiteral(){return{tag:this.tag,data:this.bigCollectionType.toLiteral()}}_hasProperty(e){return this.bigCollectionType.hasProperty(e)}toString(e){return`BigCollection<${this.bigCollectionType.toString(e)}>`}getEntitySchema(){return this.bigCollectionType.getEntitySchema()}toPrettyString(){const e=this.getEntitySchema();return e&&e.description.plural?e.description.plural:`Collection of ${this.bigCollectionType.toPrettyString()}`}}class re extends ee{constructor(e){super("Relation"),this.relationEntities=e}get isRelation(){return!0}toLiteral(){return{tag:this.tag,data:this.relationEntities.map(e=>e.toLiteral())}}toPrettyString(){return JSON.stringify(this.relationEntities)}}class oe extends ee{constructor(e){super("Interface"),this.interfaceInfo=e}static make(e,t,n){return new oe(new F(e,t,n))}get isInterface(){return!0}mergeTypeVariablesByName(e){const t=this.interfaceInfo.clone(new Map);return t.mergeTypeVariablesByName(e),new oe(t)}_applyExistenceTypeTest(e){return this.interfaceInfo._applyExistenceTypeTest(e)}resolvedType(){return new oe(this.interfaceInfo.resolvedType())}_canEnsureResolved(){return this.interfaceInfo.canEnsureResolved()}maybeEnsureResolved(){return this.interfaceInfo.maybeEnsureResolved()}get canWriteSuperset(){return new oe(this.interfaceInfo.canWriteSuperset)}get canReadSubset(){return new oe(this.interfaceInfo.canReadSubset)}_isMoreSpecificThan(e){return this.interfaceInfo.isMoreSpecificThan(e.interfaceInfo)}_clone(e){const t=this.interfaceInfo.clone(e).toLiteral();return ee.fromLiteral({tag:this.tag,data:t})}_cloneWithResolutions(e){return new oe(this.interfaceInfo._cloneWithResolutions(e))}toLiteral(){return{tag:this.tag,data:this.interfaceInfo.toLiteral()}}toString(e){return this.interfaceInfo.name}toPrettyString(){return this.interfaceInfo.toPrettyString()}}class ae extends ee{constructor(e){super("Slot"),this.slot=e}static make(e,t){return new ae(new G(e,t))}get isSlot(){return!0}get canWriteSuperset(){return this}get canReadSubset(){return this}_isMoreSpecificThan(e){return!0}toLiteral(){return{tag:this.tag,data:this.slot.toLiteral()}}toString(e){const t=[];for(const e of Object.keys(this.slot))void 0!==this.slot[e]&&t.push(`${e}:${this.slot[e]}`);let n="";return 0!==t.length&&(n=` {${t.join(", ")}}`),`Slot${n}`}toPrettyString(){const e=[];for(const t of Object.keys(this.slot))void 0!==this.slot[t]&&e.push(`${t}:${this.slot[t]}`);let t="";return 0!==e.length&&(t=` {${e.join(", ")}}`),`Slot${t}`}}class ce extends ee{constructor(e){super("Reference"),this.referredType=e}get isReference(){return!0}getContainedType(){return this.referredType}isTypeContainer(){return!0}resolvedType(){const e=this.referredType,t=e.resolvedType();return e!==t?new ce(t):this}_canEnsureResolved(){return this.referredType.canEnsureResolved()}maybeEnsureResolved(){return this.referredType.maybeEnsureResolved()}get canReadSubset(){return this.referredType.canReadSubset}_clone(e){const t=this.referredType.clone(e).toLiteral();return ee.fromLiteral({tag:this.tag,data:t})}_cloneWithResolutions(e){return new ce(this.referredType._cloneWithResolutions(e))}toLiteral(){return{tag:this.tag,data:this.referredType.toLiteral()}}toString(e){return"Reference<"+this.referredType.toString()+">"}}class le extends ee{constructor(){super("Arc")}get isArc(){return!0}newInstance(e,t){return new Q(e,t)}toLiteral(){return{tag:this.tag}}}class he extends ee{constructor(){super("Handle")}get isHandle(){return!0}toLiteral(){return{tag:this.tag}}}class ue{static processTypeList(e,t){const n=ne.make("",null,null);e&&(n.variable.resolution=e),e=n;const s=[];for(const n of t)if(n.type.resolvedType().hasVariable){if(null==(e=ue._tryMergeTypeVariable(e,n.type)))return null}else s.push(n);for(const t of s)if(!ue._tryMergeConstraints(e,t))return null;const i=e=>e instanceof ne?null==e.canReadSubset||null==e.canWriteSuperset?e:e.canReadSubset.isMoreSpecificThan(e.canWriteSuperset)?(e.canWriteSuperset.isMoreSpecificThan(e.canReadSubset)&&(e.variable.resolution=e.canReadSubset),e):null:e,r=e.resolvedType();if(r.isCollectionType()){const e=i(r.collectionType);return null!==e?e.collectionOf():null}if(r.isBigCollectionType()){const e=i(r.bigCollectionType);return null!==e?e.bigCollectionOf():null}return i(r)}static _tryMergeTypeVariable(e,t){const[n,s]=ee.unwrapPair(e.resolvedType(),t.resolvedType());if(n instanceof ne){if(s instanceof ne){if(!1===n.variable.maybeMergeConstraints(s.variable))return null;s.variable.resolution=n}else{if(!n.variable.isValidResolutionCandidate(s).result)return null;n.variable.resolution=s}return e}if(s instanceof ne)return s.variable.isValidResolutionCandidate(n).result?(s.variable.resolution=n,t):null;if(n instanceof oe&&s instanceof oe){const e=n.interfaceInfo.tryMergeTypeVariablesWith(s.interfaceInfo);return null==e?null:new oe(e)}if(n.isTypeContainer()&&n.hasVariable||s.isTypeContainer()&&s.hasVariable)return null;throw new Error("tryMergeTypeVariable shouldn't be called on two types without any type variables")}static _tryMergeConstraints(e,{type:t,direction:n}){let[s,i]=ee.unwrapPair(e.resolvedType(),t.resolvedType());if(s instanceof ne){for(;i.isTypeContainer();){if(null!=s.variable.resolution||null!=s.variable.canReadSubset||null!=s.variable.canWriteSuperset)return!1;const e=ne.make("a",null,null);s.variable.resolution=i instanceof se?new se(e):i instanceof ie?new ie(e):new ce(e);const t=ee.unwrapPair(s.resolvedType(),i);if([s,i]=t,!(s instanceof ne))throw new TypeError("unwrapping a wrapped TypeVariable somehow didn't become a TypeVariable")}if(("out"===n||"inout"===n||"`provide"===n)&&!s.variable.maybeMergeCanReadSubset(i.canWriteSuperset))return!1;if(("in"===n||"inout"===n||"`consume"===n)&&!s.variable.maybeMergeCanWriteSuperset(i.canReadSubset))return!1}else{if(i.tag!==s.tag)return!1;if(("out"===n||"inout"===n)&&!ue._writeConstraintsApply(s,i))return!1;if(("in"===n||"inout"===n)&&!ue._readConstraintsApply(s,i))return!1}return!0}static _writeConstraintsApply(e,t){const n=t.canWriteSuperset;return null==n||null==e.canReadSubset||!!n.isMoreSpecificThan(e.canReadSubset)}static _readConstraintsApply(e,t){const n=t.canReadSubset;return null==n||null==e.canWriteSuperset||!!e.canWriteSuperset.isMoreSpecificThan(n)}static compareTypes(e,t){const n=e.type.resolvedType(),s=t.type.resolvedType(),[i,r]=ee.unwrapPair(n,s);if(i instanceof ne&&r.isTypeContainer())return!(i.variable.canReadSubset||i.variable.canWriteSuperset);if(r instanceof ne&&i.isTypeContainer())return!(r.variable.canReadSubset||r.variable.canWriteSuperset);if(i instanceof ne||r instanceof ne)return ee.canMergeConstraints(i,r);if(void 0===i!=(void 0===r))return!1;if(i===r)return!0;if(i.tag!==r.tag)return!1;if(i instanceof ae)return!0;if(i instanceof oe&&r instanceof oe&&i.interfaceInfo.equals(r.interfaceInfo))return!0;if(!(i instanceof te&&r instanceof te))return!1;const o=i.entitySchema.isMoreSpecificThan(r.entitySchema),a=r.entitySchema.isMoreSpecificThan(i.entitySchema);if(a&&o)return!0;if(!a&&!o)return!1;const[c,l]=a?[e,t]:[t,e],h=c.direction||(c.connection?c.connection.direction:"inout"),u=l.direction||(l.connection?l.connection.direction:"inout");return"in"===h||"out"===u}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */function de(e){return e instanceof ee?e:ee.fromLiteral(e)}function pe(e){return e instanceof ee?e.toLiteral():e}class fe{constructor(e,t){this.parentConnection=null,this.rawData=e,this.direction=e.direction,this.name=e.name,this.type=de(e.type).mergeTypeVariablesByName(t),this.isOptional=e.isOptional,this.tags=e.tags||[],this.dependentConnections=[]}instantiateDependentConnections(e,t){for(const n of this.rawData.dependentConnections){const s=e.createConnection(n,t);s.parentConnection=this,this.dependentConnections.push(s)}}get isInput(){return"in"===this.direction||"inout"===this.direction||"host"===this.direction}get isOutput(){return"out"===this.direction||"inout"===this.direction}isCompatibleType(e){return ue.compareTypes({type:e},{type:this.type,direction:this.direction})}}class me{constructor(e){this.name=e.name,this.isRequired=e.isRequired||!1,this.isSet=e.isSet||!1,this.tags=e.tags||[],this.formFactor=e.formFactor,this.handles=e.handles||[],this.provideSlotConnections=[],e.provideSlotConnections&&e.provideSlotConnections.forEach(e=>{this.provideSlotConnections.push(new ge(e))})}get isOptional(){return!this.isRequired}get direction(){return"`consume"}get type(){return ae.make(this.formFactor,null)}get dependentConnections(){return this.provideSlotConnections}}class ge extends me{}class ye{constructor(e){this.model=e,this.name=e.name,this.verbs=e.verbs;const t=new Map;this.handleConnectionMap=new Map,e.args.forEach(e=>this.createConnection(e,t)),e.description=e.description||{},this.validateDescription(e.description),this.pattern=e.description.pattern,this.handleConnectionMap.forEach((t,n)=>{t.pattern=e.description[n]}),this.implFile=e.implFile,this.implBlobUrl=e.implBlobUrl,this.modality=R.create(e.modality||[]),this.slotConnections=new Map,e.slotConnections&&e.slotConnections.forEach(e=>this.slotConnections.set(e.name,new me(e))),this.slotConnections.forEach(e=>{e.provideSlotConnections.forEach(e=>{e.handles.forEach(e=>d()(this.handleConnectionMap.has(e),"Cannot provide slot for nonexistent handle constraint "+e))})})}createConnection(e,t){const n=new fe(e,t);return this.handleConnectionMap.set(n.name,n),n.instantiateDependentConnections(this,t),n}get handleConnections(){return this.connections}get connections(){return[...this.handleConnectionMap.values()]}get inputs(){return this.connections.filter(e=>e.isInput)}get outputs(){return this.connections.filter(e=>e.isOutput)}isInput(e){const t=this.handleConnectionMap.get(e);return t&&t.isInput}isOutput(e){const t=this.handleConnectionMap.get(e);return t&&t.isOutput}getConnectionByName(e){return this.handleConnectionMap.get(e)}getSlotSpec(e){return this.slotConnections.get(e)}get primaryVerb(){return this.verbs.length>0?this.verbs[0]:void 0}isCompatible(e){return 0===this.slotConnections.size||this.modality.intersection(e).isResolved()}setImplBlobUrl(e){this.model.implBlobUrl=this.implBlobUrl=e}toLiteral(){const{args:e,name:t,verbs:n,description:s,implFile:i,implBlobUrl:r,modality:o,slotConnections:a}=this.model,c=({type:e,direction:t,name:n,isOptional:s,dependentConnections:i})=>({type:pe(e),direction:t,name:n,isOptional:s,dependentConnections:i.map(c)});return{args:e.map(e=>c(e)),name:t,verbs:n,description:s,implFile:i,implBlobUrl:r,modality:o,slotConnections:a}}static fromLiteral(e){let{args:t,name:n,verbs:s,description:i,implFile:r,implBlobUrl:o,modality:a,slotConnections:c}=e;const l=({type:e,direction:t,name:n,isOptional:s,dependentConnections:i})=>({type:de(e),direction:t,name:n,isOptional:s,dependentConnections:i?i.map(l):[]});return t=t.map(l),new ye({args:t,name:n,verbs:s||[],description:i,implFile:r,implBlobUrl:o,modality:a,slotConnections:c})}clone(){return ye.fromLiteral(this.toLiteral())}cloneWithResolutions(e){const t=this.clone();return this.handleConnectionMap.forEach((n,s)=>{t.handleConnectionMap.get(s).type=n.type._cloneWithResolutions(e)}),t}equals(e){return JSON.stringify(this.toLiteral())===JSON.stringify(e.toLiteral())}validateDescription(e){Object.keys(e||[]).forEach(e=>{d()(["kind","location","pattern"].includes(e)||this.handleConnectionMap.has(e),`Unexpected description for ${e}`)})}toInterface(){d()(!this.slotConnections.size,"please implement slots toInterface");const e=this.model.args.map(({type:e,name:t,direction:n})=>({type:de(e),name:t,direction:n}));return oe.make(this.name,e,[])}toString(){const e=[];let t="";this.verbs.length>0&&(t=" "+this.verbs.map(e=>`&${e}`).join(" ")),e.push(`particle ${this.name}${t} in '${this.implFile}'`.trim());const n=(t,s)=>{const i=t.tags.map(e=>` #${e}`).join("");e.push(`${s}${t.direction}${t.isOptional?"?":""} ${t.type.toString()} ${t.name}${i}`);for(const e of t.dependentConnections)n(e,s+"  ")};for(const e of this.handleConnections)e.parentConnection||n(e,"  ");return this.modality.names.forEach(t=>e.push(`  modality ${t}`)),this.slotConnections.forEach(t=>{const n=[];t.isRequired&&n.push("must"),n.push("consume"),t.isSet&&n.push("set of"),n.push(t.name),t.tags.length>0&&n.push(t.tags.map(e=>`#${e}`).join(" ")),e.push(`  ${n.join(" ")}`),t.formFactor&&e.push(`    formFactor ${t.formFactor}`),t.provideSlotConnections.forEach(t=>{const n=[];t.isRequired&&n.push("must"),n.push("provide"),t.isSet&&n.push("set of"),n.push(t.name),t.tags.length>0&&n.push(t.tags.map(e=>`#${e}`).join(" ")),e.push(`    ${n.join(" ")}`),t.formFactor&&e.push(`      formFactor ${t.formFactor}`),t.handles.forEach(t=>e.push(`      handle ${t}`))})}),this.pattern&&(e.push(`  description \`${this.pattern}\``),this.handleConnectionMap.forEach(t=>{t.pattern&&e.push(`    ${t.name} \`${t.pattern}\``)})),e.join("\n")}toManifestString(){return this.toString()}}
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class _e{}const ve=new class extends _e{next(){return Math.random()}};class Se{static next(){return ve.next()}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class be{constructor(e){this._nextComponentId=0,this._currentSessionId=e}static newSession(){const e=Math.floor(Se.next()*Math.pow(2,50))+"";return new be(e)}static createWithSessionIdForTesting(e){return new be(e)}newArcId(e){return Ce._newArcIdInternal(this._currentSessionId,e)}newChildId(e,t=""){return t+=this._nextComponentId++,we._newIdInternal(this._currentSessionId,[...e.idTree,t])}get currentSessionIdForTesting(){return this._currentSessionId}}class we{constructor(e,t=[]){this.idTree=[],this.root=e,this.idTree=t}static _newIdInternal(e,t=[]){return new we(e,t)}static fromString(e){const t=e.split(":");if(t[0].startsWith("!")){const e=t[0].slice(1),n=t.slice(1).filter(e=>e.length>0);return new we(e,n)}return new we("",t)}toString(){return`!${this.root}:${this.idTree.join(":")}`}idTreeAsString(){return this.idTree.join(":")}equal(e){if(e.root!==this.root||e.idTree.length!==this.idTree.length)return!1;for(let t=0;t<e.idTree.length;t++)if(e.idTree[t]!==this.idTree[t])return!1;return!0}}class Ce extends we{static _newArcIdInternal(e,t){return new Ce(e,[t])}static newForTest(e){return be.newSession().newArcId(e)}}
/** @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */function Te(e,t){d()(t,"Handles need entity classes for deserialization");const{id:n,rawData:s}=e,i=new t(s);return e.id&&i.identify(e.id),i}class $e{constructor(e,t,n,s,i,r){d()(!(e instanceof $e)),this.storage=e,this.idGenerator=t,this.name=n||this.storage.name,this.canRead=i,this.canWrite=r,this._particleId=s,this.options={keepSynced:!0,notifySync:!0,notifyUpdate:!0,notifyDesync:!1}}reportUserExceptionInHost(e,t,n){this.storage.reportExceptionInHost(new C(e,n,this._particleId,t.spec.name))}reportSystemExceptionInHost(e,t){this.storage.reportExceptionInHost(new w(e,t,this._particleId))}configure(e){d()(this.canRead,"configure can only be called on readable Handles");try{const t=Object.keys(this.options),n=Object.keys(e).filter(e=>!t.includes(e));if(n.length>0)throw new Error(`Invalid option in Handle.configure(): ${n}`);Object.assign(this.options,e)}catch(e){throw this.reportSystemExceptionInHost(e,"Handle::configure"),e}}_serialize(e){return d()(e,"can't serialize a null entity"),e instanceof V&&(e.isIdentified()||e.createIdentity(we.fromString(this._id),this.idGenerator)),e.serialize()}get type(){return this.storage.type}get _id(){return this.storage.id}toManifestString(){return`'${this._id}'`}generateKey(){return this.idGenerator.newChildId(we.fromString(this._id),"key").toString()}}class ke extends $e{_notify(e,t,n){switch(d()(this.canRead,"_notify should not be called for non-readable handles"),e){case"sync":try{t.onHandleSync(this,this._restore(n))}catch(e){this.reportUserExceptionInHost(e,t,"onHandleSync")}return;case"update":{const e={};return"add"in n&&(e.added=this._restore(n.add)),"remove"in n&&(e.removed=this._restore(n.remove)),e.originator=n.originatorId===this._particleId,void t.onHandleUpdate(this,e)}case"desync":return void t.onHandleDesync(this);default:throw new Error("unsupported")}}async get(e){if(!this.canRead)throw new Error("Handle not readable");return this._restore([await this.storage.get(e)])[0]}async toList(){if(!this.canRead)throw new Error("Handle not readable");return this._restore(await this.storage.toList())}_restore(e){return null!==e?e.map(e=>Te(e,this.entityClass)):null}async store(e){if(!this.canWrite)throw new Error("Handle not writeable");const t=this._serialize(e),n=[this.generateKey()];return this.storage.store(t,n,this._particleId)}async clear(){if(!this.canWrite)throw new Error("Handle not writeable");if(this.storage.clear)return this.storage.clear(this._particleId);throw new Error("clear not implemented by storage")}async remove(e){if(!this.canWrite)throw new Error("Handle not writeable");const t=this._serialize(e);this.storage.remove(t.id,[],this._particleId)}}class Re extends $e{async _notify(e,t,n){switch(d()(this.canRead,"_notify should not be called for non-readable handles"),e){case"sync":try{await t.onHandleSync(this,this._restore(n))}catch(e){this.reportUserExceptionInHost(e,t,"onHandleSync")}return;case"update":try{const e=this._restore(n.data),s=this._restore(n.oldData);await t.onHandleUpdate(this,{data:e,oldData:s})}catch(e){this.reportUserExceptionInHost(e,t,"onHandleUpdate")}return;case"desync":try{await t.onHandleDesync(this)}catch(e){this.reportUserExceptionInHost(e,t,"onHandleDesync")}return;default:throw new Error("unsupported")}}async get(){if(!this.canRead)throw new Error("Handle not readable");const e=await this.storage.get();return this._restore(e)}_restore(e){if(null==e)return null;if(this.type instanceof te)return Te(e,this.entityClass);if(this.type instanceof oe)return ye.fromLiteral(e);if(this.type instanceof ce)return new B(e,this.type,this.storage.pec);throw new Error(`Don't know how to deliver handle data of type ${this.type}`)}async set(e){try{if(!this.canWrite)throw new Error("Handle not writeable");const t=this._serialize(e);return this.storage.set(t,this._particleId)}catch(e){throw this.reportSystemExceptionInHost(e,"Handle::set"),e}}async clear(){if(!this.canWrite)throw new Error("Handle not writeable");return this.storage.clear(this._particleId)}}class Ee{constructor(e,t){this._parent=e,this._cursorId=t}async next(){const e=await this._parent.storage.cursorNext(this._cursorId);return e.done||(e.value=e.value.map(e=>Te(e,this._parent.entityClass))),e}close(){this._parent.storage.cursorClose(this._cursorId)}}class Ie extends $e{configure(e){throw new Error("BigCollections do not support sync/update configuration")}async _notify(e,t,n){d()(this.canRead,"_notify should not be called for non-readable handles"),d()("sync"===e,"BigCollection._notify only supports sync events"),await t.onHandleSync(this,[])}async store(e){if(!this.canWrite)throw new Error("Handle not writeable");const t=this._serialize(e),n=[this.generateKey()];return this.storage.store(t,n,this._particleId)}async remove(e){if(!this.canWrite)throw new Error("Handle not writeable");const t=this._serialize(e);this.storage.remove(t.id,[],this._particleId)}async stream({pageSize:e,forward:t=!0}){if(!this.canRead)throw new Error("Handle not readable");if(isNaN(e)||e<1)throw new Error("Streamed reads require a positive pageSize");const n=await this.storage.stream(e,t);return new Ee(this,n)}}class Ne{constructor(){this.relevances=[],this._idle=Promise.resolve(),this._busy=0,this.slotProxiesByName=new Map,this.spec=this.constructor.spec,0===this.spec.inputs.length&&(this.extraData=!0)}setCapabilities(e){if(this.capabilities)throw new Error("capabilities should only be set once");this.capabilities=e||{}}async setHandles(e){}onHandleSync(e,t){}async onHandleUpdate(e,t){}async onHandleDesync(e){}async constructInnerArc(){if(!this.capabilities.constructInnerArc)throw new Error("This particle is not allowed to construct inner arcs");return this.capabilities.constructInnerArc(this)}get busy(){return this._busy>0}get idle(){return this._idle}set relevance(e){this.relevances.push(e)}startBusy(){0===this._busy&&(this._idle=new Promise(e=>this._idleResolver=e)),this._busy++}doneBusy(){this._busy--,0===this._busy&&this._idleResolver()}inputs(){return this.spec.inputs}outputs(){return this.spec.outputs}hasSlotProxy(e){return this.slotProxiesByName.has(e)}addSlotProxy(e){this.slotProxiesByName.set(e.slotName,e)}removeSlotProxy(e){this.slotProxiesByName.delete(e)}async service(e){return this.capabilities.serviceRequest?new Promise(t=>{this.capabilities.serviceRequest(this,e,e=>t(e))}):(console.warn(`${this.spec.name} has no service support.`),null)}getSlot(e){return this.slotProxiesByName.get(e)}static buildManifest(e,...t){const n=[];for(let s=0;s<t.length;s++){const i=e[s],r=/ *$/.exec(i)[0];let o;o=(o="string"==typeof t[s]?t[s]:t[s].toManifestString()).replace(/(\n)/g,"$1"+r),n.push(i),n.push(o)}return e.length>t.length&&n.push(e[e.length-1]),n.join("")}setParticleDescription(e){return this.setDescriptionPattern("pattern",e)}setDescriptionPattern(e,t){const n=this.handles.get("descriptions");if(n){const s=n.entityClass;return(n instanceof ke||n instanceof Ie)&&n.store(new s({key:e,value:t},this.spec.name+"-"+e)),!0}throw new Error("A particle needs a description handle to set a decription pattern")}renderSlot(e,t){}renderHostedSlot(e,t,n){}fireEvent(e,t){}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class Me extends Ne{get template(){return""}getTemplate(e){return this.template}getTemplateName(e){return"default"}shouldRender(e){return!0}render(e){return{}}renderSlot(e,t){const n=this._getStateArgs(),s=this.getSlot(e);if(s){if(this.currentSlotName=e,t.forEach(e=>s.requestedContentTypes.add(e)),this.shouldRender(...n)){const e={};if(s.requestedContentTypes.has("template")&&(e.template=this.getTemplate(s.slotName)),s.requestedContentTypes.has("model")&&(e.model=this.render(...n)),e.templateName=this.getTemplateName(s.slotName),s.providedSlots.size>0&&(e.template&&("string"==typeof e.template?e.template=this.slotNamesToModelReferences(s,e.template):e.template=Object.entries(e.template).reduce((e,[t,n])=>(e[t]=this.slotNamesToModelReferences(s,n),e),{})),e.model)){const t={};s.providedSlots.forEach((e,n)=>t[`$${n}`]=e),e.model=this.enhanceModelWithSlotIDs(e.model,t)}s.render(e)}else s.isRendered&&s.render({});this.currentSlotName=void 0}}slotNamesToModelReferences(e,t){return e.providedSlots.forEach((e,n)=>{t=t.replace(new RegExp(`slotid="${n}"`,"gi"),`slotname="${n}" slotid$="{{$${n}}}"`)}),t}enhanceModelWithSlotIDs(e={},t,n=!0){n&&(e=Object.assign({},t,e)),e.hasOwnProperty("$template")&&e.hasOwnProperty("models")&&Array.isArray(e.models)&&(e.models=e.models.map(e=>this.enhanceModelWithSlotIDs(e,t)));for(const[n,s]of Object.entries(e))s&&"object"==typeof s&&(e[n]=this.enhanceModelWithSlotIDs(s,t,!1));return e}_getStateArgs(){return[]}forceRenderTemplate(e=""){this.slotProxiesByName.forEach((t,n)=>{e&&n!==e||t.requestedContentTypes.add("template")})}fireEvent(e,{handler:t,data:n}){this[t]&&this[t]({data:n})}setParticleDescription(e){if("string"==typeof e)return super.setParticleDescription(e);if(e.template&&e.model)return super.setDescriptionPattern("_template_",e.template),void super.setDescriptionPattern("_model_",JSON.stringify(e.model));throw new Error("Description pattern must either be string or have template and model")}async clearHandle(e){const t=this.handles.get(e);if(!(t instanceof Re||t instanceof ke))throw new Error("Variable/Collection required");t.clear()}async mergeEntitiesToHandle(e,t){const n={},s=this.handles.get(e);if(!(s instanceof ke))throw new Error("Collection required");(await s.toList()).forEach(e=>n[e.id]=e);for(const e of t)n[e.id]||s.store(e)}async appendEntitiesToHandle(e,t){const n=this.handles.get(e);if(n){if(!(n instanceof ke||n instanceof Ie))throw new Error("Collection required");Promise.all(t.map(e=>n.store(e)))}}async appendRawDataToHandle(e,t){const n=this.handles.get(e);if(n&&n.entityClass){if(!(n instanceof ke||n instanceof Ie))throw new Error("Collection required");{const e=n.entityClass;Promise.all(t.map(t=>n.store(new e(t))))}}}updateVariable(e,t){const n=this.handles.get(e);if(n&&n.entityClass){if(n instanceof Re){const e=new(0,n.entityClass)(t);return n.set(e),e}throw new Error("Variable required")}}async updateSet(e,t){const n=this.handles.get(e);if(n){if(!(n instanceof ke||n instanceof Ie))throw new Error("Collection required");await n.remove(t),await n.store(t)}}boxQuery(e,t){return e&&e.filter(e=>t===e.getUserID().split("|")[0])}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class xe extends(S(Me)){constructor(){super(),this.state=this._state,this.props=this._props}willReceiveProps(...e){}update(...e){}shouldRender(...e){return!0}render(...e){return{}}setState(e){return this._setState(e)}configureHandles(e){}get config(){return{handleNames:this.spec.inputs.map(e=>e.name),slotNames:[...this.spec.slotConnections.values()].map(e=>e.name)}}_willReceiveProps(...e){this.willReceiveProps(...e)}_update(...e){this.update(...e),this.shouldRender(...e)&&(this.relevance=1),this.config.slotNames.forEach(e=>this.renderSlot(e,["model"]))}get _views(){return console.warn(`Particle ${this.spec.name} uses deprecated _views getter.`),this.handles}async setHandles(e){this.configureHandles(e),this.handles=e,this._handlesToSync=new Set;for(const t of this.config.handleNames){const n=e.get(t);n&&n.options.keepSynced&&n.options.notifySync&&this._handlesToSync.add(t)}this._handlesToSync.length||this._invalidate()}async onHandleSync(e,t){this._handlesToSync.delete(e.name),0===this._handlesToSync.size&&await this._handlesToProps()}async onHandleUpdate(e,t){this._debounce("handleUpdateDebounce",()=>{this._handlesToProps()},300)}async _handlesToProps(){const e=Object.create(null),{handleNames:t}=this.config;await Promise.all(t.map(t=>this._addNamedHandleData(e,t))),this._setProps(e)}async _addNamedHandleData(e,t){const n=this.handles.get(t);n&&(e[t]=await this._getHandleData(n))}async _getHandleData(e){return e instanceof ke?await e.toList():e instanceof Re?await e.get():e}fireEvent(e,{handler:t,data:n}){this[t]&&this[t]({data:n},this._state)}_debounce(e,t,n){const s=`_debounce_${e}`;this._state[s]||this.startBusy();super._debounce(e,()=>{this.doneBusy(),t(),this._state[s]=null},n)}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class Ae extends xe{getTemplate(e){return this._state.template}getTemplateName(e){return this._state.templateName}render(e,t){return t.renderModel}shouldRender(e,t){return Boolean((t.template||t.templateName)&&t.renderModel)}renderHostedSlot(e,t,n){this.combineHostedTemplate(e,t,n),this.combineHostedModel(e,t,n)}combineHostedTemplate(e,t,n){}combineHostedModel(e,t,n){}static propsToItems(e){return e?e.map(({rawData:e,id:t})=>Object.assign({},e,{subId:t})):[]}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class je extends Ae{constructor(){super(...arguments),this._itemSubIdByHostedSlotId=new Map,this._connByHostedConn=new Map}async _mapParticleConnections(e,t,n,s,i){const r=[],o=[];let a=2;const c=[e,t];for(const[e,t]of s){if(c.includes(e))continue;let s;s=t.storage,r.push(`use '${await i.mapHandle(s)}' as v${a}`);const l=n.handleConnections.find(e=>e.isCompatibleType(t.type));l&&(o.push(`${l.name} = v${a++}`),this._connByHostedConn.set(l.name,e))}return[r,o]}async setHandles(e){this.handleIds={};const t=await this.constructInnerArc(),n=e.get("hostedParticle");let s=null,i=[],r=[];n&&(s=await n.get())&&([i,r]=await this._mapParticleConnections("list","hostedParticle",s,e,t)),this.setState({arc:t,type:e.get("list").type,hostedParticle:s,otherMappedHandles:i,otherConnections:r}),await super.setHandles(e)}async willReceiveProps({list:e},{arc:t,type:n,hostedParticle:s,otherMappedHandles:i,otherConnections:r}){e.length>0&&(this.relevance=.1);for(const[o,a]of this.getListEntries(e)){let e=s;if(this.handleIds[a.id]){(await this.handleIds[a.id]).set(a);continue}const c=t.createHandle(n.getContainedType(),`item${o}`);this.handleIds[a.id]=c;const l=await c;if(!e){if(!a.renderParticleSpec)continue;e=ye.fromLiteral(JSON.parse(a.renderParticleSpec));const n="list",s="renderParticle";[i,r]=await this._mapParticleConnections(n,s,e,this.handles,t)}const h=[...e.slotConnections.keys()][0],u=[...this.spec.slotConnections.values()][0].name,d=await t.createSlot(this,u,l._id);if(d){this._itemSubIdByHostedSlotId.set(d,a.id);try{const n=this.constructInnerRecipe(e,a,l,{name:h,id:d},{connections:r,handles:i});await t.loadRecipe(n),l.set(a)}catch(e){console.log(e)}}}}combineHostedModel(e,t,n){const s=this._itemSubIdByHostedSlotId.get(t);if(!s)return;const i=this._state.renderModel?this._state.renderModel.items:[],r=i.findIndex(e=>e.subId===s),o=Object.assign({},n.model,{subId:s});r>=0&&r<i.length?i[r]=o:i.push(o),this._setState({renderModel:{items:i}})}combineHostedTemplate(e,t,n){const s=this._itemSubIdByHostedSlotId.get(t);if(!s)return;d()(n.templateName,`Template name is missing for slot '${e}' (hosted slot ID: '${t}')`);const i=Object.assign({},this._state.templateName,{[s]:`${n.templateName}`});if(this._setState({templateName:i}),n.template){let e=n.template;e=e.replace(new RegExp('slotid="[a-z]+"',"gi"),'$& subid$="{{subId}}"'),this._connByHostedConn.forEach((t,n)=>{e=e.replace(new RegExp(`{{${n}.description}}`,"g"),`{{${t}.description}}`)}),this._setState({template:Object.assign({},this._state.template,{[n.templateName]:e})}),this.forceRenderTemplate()}}getListEntries(e){return e.entries()}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const Oe=(e,...t)=>(e[0]+t.map((t,n)=>t+e[n+1]).join("")).trim();class Pe{path(e){return e.replace(/[\/][^\/]+$/,"/")}join(e,t){return/^https?:\/\//.test(t)?t:"/"===t[0]||":"===t[1]?t:(e=this.path(e),t=this.normalizeDots(`${e}${t}`))}normalizeDots(e){const t=e=>e.replace(/(?:^|\/)[^.\/]*\/\.\./g,"");for(let n=t(e=(e=e.replace(/\\/g,"/")).replace(/\/\.\//g,"/"));n!==e;n=t(e=n));return e}async loadResource(e){return/^https?:\/\//.test(e)?this._loadURL(e):this._loadFile(e,"utf-8")}async loadBinary(e){return/^https?:\/\//.test(e)?f()(e).then(e=>e.arrayBuffer()):this._loadFile(e,null)}async _loadFile(e,t){return new Promise((n,s)=>{o.a.readFile(e,{encoding:t},(e,i)=>{e?s(e):n(t?i:i.buffer)})})}async _loadURL(e){return/\/\/schema.org\//.test(e)?e.endsWith("/Thing")?f()("https://schema.org/Product.jsonld").then(e=>e.text()).then(e=>_.convert(e,{"@id":"schema:Thing"})):f()(e+".jsonld").then(e=>e.text()).then(e=>_.convert(e)):f()(e).then(e=>e.text())}async loadParticleClass(e){const t=await this.requireParticle(e.implFile);return t.spec=e,t}async requireParticle(e){null===e&&(e="");const t=await this.loadResource(e),n=new g.a.Script(t,{filename:e,displayErrors:!0}),s=[],i={defineParticle(e){s.push(e)},console:console,fetch:f.a,setTimeout:setTimeout,importScripts:e=>null};return n.runInNewContext(i,{filename:e,displayErrors:!0}),d()(s.length>0&&"function"==typeof s[0],`Error while instantiating particle implementation from ${e}`),this.unwrapParticle(s[0])}setParticleExecutionContext(e){this.pec=e}unwrapParticle(e){return d()(this.pec),e({Particle:Ne,DomParticle:xe,TransformationDomParticle:Ae,MultiplexerDomParticle:je,Reference:q.newClientReference(this.pec),html:Oe})}}class Fe extends Error{static buildMessage(e,t){function n(e){return e.charCodeAt(0).toString(16).toUpperCase()}function s(e){return e.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,e=>"\\x0"+n(e)).replace(/[\x10-\x1F\x7F-\x9F]/g,e=>"\\x"+n(e))}function i(e){return e.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,e=>"\\x0"+n(e)).replace(/[\x10-\x1F\x7F-\x9F]/g,e=>"\\x"+n(e))}function r(e){switch(e.type){case"literal":return'"'+s(e.text)+'"';case"class":const t=e.parts.map(e=>Array.isArray(e)?i(e[0])+"-"+i(e[1]):i(e));return"["+(e.inverted?"^":"")+t+"]";case"any":return"any character";case"end":return"end of input";case"other":return e.description}}return"Expected "+function(e){const t=e.map(r);let n,s;if(t.sort(),t.length>0){for(n=1,s=1;n<t.length;n++)t[n-1]!==t[n]&&(t[s]=t[n],s++);t.length=s}switch(t.length){case 1:return t[0];case 2:return t[0]+" or "+t[1];default:return t.slice(0,-1).join(", ")+", or "+t[t.length-1]}}(e)+" but "+((o=t)?'"'+s(o)+'"':"end of input")+" found.";var o}constructor(e,t,n,s){super(),this.message=e,this.expected=t,this.found=n,this.location=s,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,Fe)}}const Le=function(e,t){t=void 0!==t?t:{};const n={},s={Manifest:nr};let i=nr;const r=function(e){const t=e.map(e=>{const t=e[2];return t.annotation=io(e[0],e=>e[1],null),t});return function e(t){if(!["string","number","boolean"].includes(typeof t)&&null!==t){if(void 0===t)throw new Fe("result was undefined",[],"",Ui());if(Array.isArray(t))for(const n of t)e(n);else{if(t.model)throw new Fe(`unexpected 'model' in ${JSON.stringify(t)}`,[],"",Ui());if(!t.location)throw new Fe(`no 'location' in ${JSON.stringify(t)}`,[],"",Ui());if(!t.kind)throw new Fe(`no 'kind' in ${JSON.stringify(t)}`,[],"",Ui());for(const n of Object.keys(t))["location","kind"].includes(n)||e(t[n])}}}(t),t},o=Qi("an annotation (e.g. @foo)"),a="@",c=Zi("@",!1),l=function(e){return e},h="resource",u=Zi("resource",!1),d=function(e,t){return{kind:"resource",name:e,data:t,location:Ui()}},p="start",f=Zi("start",!1),m=function(){to=eo},g=function(e){return e.map(e=>e[0].substring(to.length)+e[1]).join("")},y=/^[^\n]/,_=Gi(["\n"],!0,!1),v=function(){return Ki()},S="store",b=Zi("store",!1),w="of",C=Zi("of",!1),T="!!",$=Zi("!!",!1),k=function(e,t,n,s,i,r,o,a){return a=io(a,so,[]),{kind:"store",location:Ui(),name:e,type:t,id:io(n,e=>e[1],null),originalId:io(s,e=>e[1],null),version:io(i,e=>e[1],null),tags:io(r,e=>e[1],null),source:o.source,origin:o.origin,description:a.length>0?a[0][2]:null}},R="in",E=Zi("in",!1),I=function(e){return{origin:"file",source:e}},N=function(e){return{origin:"resource",source:e}},M="at",x=Zi("at",!1),A=function(e){return{origin:"storage",source:e}},j="description",O=Zi("description",!1),P="import",F=Zi("import",!1),L=function(e){return{kind:"import",location:Ui(),path:e}},H=Qi("an interface"),B="interface",q=Zi("interface",!1),V="<",W=Zi("<",!1),z=">",D=Zi(">",!1),K=function(e,t,n){return{kind:"interface",location:Ui(),name:e,args:io(n,so,[]).filter(e=>"interface-argument"===e.kind),slots:io(n,so,[]).filter(e=>"interface-slot"===e.kind)}},U="*",J=Zi("*",!1),Z=function(e,t,n){return"host"===(e=io(e,e=>e[0],null))&&Ji("Interface cannot have arguments with a 'host' direction."),{kind:"interface-argument",location:Ui(),direction:e,type:io(t,e=>e[0],null),name:n}},G="must",Q=Zi("must",!1),X="consume",Y=Zi("consume",!1),ee="provide",te=Zi("provide",!1),ne="set of",se=Zi("set of",!1),ie=function(e,t,n,s){return{kind:"interface-slot",location:Ui(),name:io(s,e=>s[1],null),isRequired:io(e,e=>"must"===e[0],!1),direction:t,isSet:!!n}},re="meta",oe=Zi("meta",!1),ae=function(e){return{kind:"meta",items:e=e?so(e):[],location:Ui()}},ce="name",le=Zi("name",!1),he=":",ue=Zi(":",!1),de=function(e){return{key:"name",value:e,location:Ui(),kind:"name"}},pe="storageKey",fe=Zi("storageKey",!1),me=function(e){return{key:"storageKey",value:e,location:Ui(),kind:"storageKey"}},ge="particle",ye=Zi("particle",!1),_e=function(e,t,n,s){let i=[];const r=[],o=[];let a=null,c=!1;return t=io(t,e=>e[1],[]),(s=io(s,so,[])).forEach(n=>{"particle-interface"===n.kind?(/[A-Z]/.test(n.verb[0])&&n.verb!==e&&Ji(`Verb ${n.verb} must start with a lower case character or be same as particle name.`),t.push(n.verb),i=n.args,c=!0):"particle-argument"===n.kind?i.push(n):"particle-slot"===n.kind?o.push(n):"description"===n.kind?(a={kind:"description",location:Ui()},n.description.forEach(e=>a[e.name]=e.pattern||e.patterns[0])):n.modality?r.push(n.modality):Ji(`Particle ${e} contains an unknown element: ${n.name}`)}),0===r.length&&r.push("dom"),{kind:"particle",location:Ui(),name:e,implFile:io(n,e=>e[3],null),verbs:t,args:i,modality:r,slotConnections:o,description:a,hasParticleArgument:c}},ve=Qi("a particle item"),Se=function(e,t){return t=io(t,so,[]),e.dependentConnections=t,e},be="?",we=Zi("?",!1),Ce=function(e,t,n,s){return{kind:"particle-argument",location:Ui(),direction:e,type:n,isOptional:!!t,dependentConnections:[],name:s.name,tags:s.tags}},Te=Qi("a direction (e.g. inout, in, out, host, `consume, `provide)"),$e="inout",ke=Zi("inout",!1),Re="out",Ee=Zi("out",!1),Ie="host",Ne=Zi("host",!1),Me="`consume",xe=Zi("`consume",!1),Ae="`provide",je=Zi("`provide",!1),Oe=function(){return Ki()},Pe="[",Le=Zi("[",!1),He="]",Be=Zi("]",!1),qe=function(e){return{kind:"collection-type",location:Ui(),type:e}},Ve="BigCollection<",We=Zi("BigCollection<",!1),ze=function(e){return{kind:"big-collection-type",location:Ui(),type:e}},De="Reference<",Ke=Zi("Reference<",!1),Ue=function(e){return{kind:"reference-type",location:Ui(),type:e}},Je=Qi("a type variable (e.g. ~foo)"),Ze="~",Ge=Zi("~",!1),Qe="with",Xe=Zi("with",!1),Ye=function(e,t){return{kind:"variable-type",location:Ui(),name:e,constraint:io(t,e=>e[3],null)}},et="Slot",tt=Zi("Slot",!1),nt="{",st=Zi("{",!1),it=",",rt=Zi(",",!1),ot="}",at=Zi("}",!1),ct=function(e){return e=io(e,e=>{const t=e[2];return[t[0]].concat(t[1].map(e=>e[2]))},[]),{kind:"slot-type",location:Ui(),fields:e}},lt=function(e,t){return{kind:"slot-field",location:Ui(),name:e,value:t}},ht=function(e){return{kind:"type-name",location:Ui(),name:e}},ut=function(e,t){return[e,...t.map(e=>e[2])]},dt="modality",pt=Zi("modality",!1),ft=function(e){return{kind:"particle-modality",location:Ui(),modality:e}},mt="dom-touch",gt=Zi("dom-touch",!1),yt="dom",_t=Zi("dom",!1),vt="vr",St=Zi("vr",!1),bt="voice",wt=Zi("voice",!1),Ct="mock-dom-touch",Tt=Zi("mock-dom-touch",!1),$t="mock-dom",kt=Zi("mock-dom",!1),Rt="mock-vr",Et=Zi("mock-vr",!1),It="mock-voice",Nt=Zi("mock-voice",!1),Mt=function(e,t,n,s,i){let r=null;const o=[];return(i=io(i,so,[])).forEach(e=>{"provided-slot"===e.kind?o.push(e):"form-factor"===e.kind?(r&&Ji("duplicate form factor for a slot"),r=e.formFactor):Ji("Unsupported particle slot item ",e)}),{kind:"particle-slot",location:Ui(),name:n,tags:io(s,e=>e[1],[]),isRequired:io(e,e=>"must"===e[0],!1),isSet:!!t,formFactor:r,provideSlotConnections:o}},xt="formFactor",At=Zi("formFactor",!1),jt="fullscreen",Ot=Zi("fullscreen",!1),Pt="big",Ft=Zi("big",!1),Lt="medium",Ht=Zi("medium",!1),Bt="small",qt=Zi("small",!1),Vt=function(e){return{kind:"form-factor",location:Ui(),formFactor:e}},Wt=function(e,t,n,s,i){let r=null;const o=[];return(i=i?so(i):[]).forEach(e=>{"form-factor"===e.kind?(r&&Ji("duplicate form factor for a slot"),r=e.formFactor):o.push(e.handle)}),{kind:"provided-slot",location:Ui(),name:n,tags:io(s,e=>e[1],[]),isRequired:io(e,e=>"must"===e[0],!1),isSet:!!t,formFactor:r,handles:o}},zt="handle",Dt=Zi("handle",!1),Kt=function(e){return{kind:"particle-provided-slot-handle",location:Ui(),handle:e}},Ut=function(e,t){t=io(t,so,[]);const n=[];return e&&n.push(e),t.filter(e=>"pattern"===e.name).forEach(e=>n.push(e)),t=t.filter(e=>"pattern"!==e.name),{kind:"description",location:Ui(),description:[{kind:"default-description?",location:Ui(),name:"pattern",patterns:n},...t]}},Jt=function(e,t){return{kind:"handle-description",location:Ui(),name:e,pattern:t}},Zt="recipe",Gt=Zi("recipe",!1),Qt=function(e,t,n){return t=io(t,e=>e[1],[]),{kind:"recipe",location:Ui(),name:io(e,e=>e[1],null),verbs:t,items:io(n,so,[])}},Xt="as",Yt=Zi("as",!1),en=function(e){return e},tn=function(e,t,n){const s=[],i=[];if(n){n=so(n);for(const e of n)"handle-connection"===e.kind?s.push(e):i.push(e)}return{kind:"particle",location:Ui(),name:io(t,e=>e[1],null),ref:e,connections:s,slotConnections:i}},nn=function(e,t,n,s){return{kind:"handle-connection",location:Ui(),param:e,dir:t,target:io(n,e=>e[1],null),dependentConnections:io(s,so,[])}},sn=function(e,t){let n=null,s=null;return(e=io(e,e=>e,null))&&(e[0].toUpperCase()===e[0]?s=e:n=e),{kind:"handle-connection-components",location:Ui(),name:n,particle:s,tags:io(t,e=>e,[])}},rn=function(e,t,n,s){return{kind:"slot-connection",location:Ui(),direction:e,param:t.param,tags:t.tags,name:io(n,e=>e[1],null),dependentSlotConnections:io(s,so,[])}},on=function(e,t){return{kind:"slot-connection-ref",location:Ui(),param:e,tags:t}},an=function(e,t,n){return{kind:"connection",location:Ui(),direction:t,from:e,to:n}},cn="search",ln=Zi("search",!1),hn="tokens",un=Zi("tokens",!1),dn=function(e,t){return{kind:"search",location:Ui(),phrase:e,tokens:io(t,e=>e[1][2].map(e=>e[1]),null)}},pn="<-",fn=Zi("<-",!1),mn="->",gn=Zi("->",!1),yn="=",_n=Zi("=",!1),vn=function(e,t){const{param:n,tags:s}=io(t,e=>e,{param:null,tags:[]});return{kind:"connection-target",location:Ui(),targetType:"verb",verbs:e,param:n,tags:s}},Sn=function(e){return{kind:"connection-target",location:Ui(),targetType:"tag",tags:e}},bn=function(e,t){const{param:n,tags:s}=io(t,e=>e,{param:null,tags:[]});return{kind:"connection-target",targetType:"localName",location:Ui(),name:e,param:n,tags:s}},wn=function(e,t){const{param:n,tags:s}=io(t,e=>e,{param:null,tags:[]});return{kind:"connection-target",targetType:"particle",location:Ui(),particle:e,param:n,tags:s}},Cn=".",Tn=Zi(".",!1),$n=function(e,t){return{param:io(e,e=>e,null),tags:io(t,e=>e[1],[])}},kn="use",Rn=Zi("use",!1),En="map",In=Zi("map",!1),Nn="create",Mn=Zi("create",!1),xn="copy",An=Zi("copy",!1),jn="`slot",On=Zi("`slot",!1),Pn=function(e,t,n){return{kind:"handle",location:Ui(),name:io(n,e=>e[1],null),ref:io(t,e=>e[1],null),fate:e}},Fn="require",Ln=Zi("require",!1),Hn=function(e){return{kind:"require",location:Ui(),items:so(e)}},Bn=function(e,t){return{kind:"requireHandle",location:Ui(),name:io(e,e=>e[1],null),ref:io(t,e=>e[1],null)}},qn="#",Vn=Zi("#",!1),Wn=/^[a-zA-Z]/,zn=Gi([["a","z"],["A","Z"]],!1,!1),Dn=/^[a-zA-Z0-9_]/,Kn=Gi([["a","z"],["A","Z"],["0","9"],"_"],!1,!1),Un=function(){return Ki().substring(1)},Jn=function(e,t){return[e,...t&&t[1]||[]]},Zn=Qi("a verb (e.g. &Verb)"),Gn="&",Qn=Zi("&",!1),Xn=function(e){return e},Yn=function(e,t){return{name:e,tags:t=io(t,e=>e[1],[])}},es=function(e){return{name:e,tags:[]}},ts=function(e){return{name:e[0],tags:e}},ns=function(e){return{kind:"particle-ref",location:Ui(),name:e,verbs:[]}},ss=function(e){return{kind:"particle-ref",location:Ui(),verbs:[e]}},is=function(e,t){return{kind:"handle-ref",location:Ui(),id:e,tags:t||[]}},rs=function(e,t){return{kind:"handle-ref",location:Ui(),name:e,tags:t||[]}},os=function(e){return{kind:"handle-ref",location:Ui(),tags:e}},as="slot",cs=Zi("slot",!1),ls=function(e,t){return{kind:"slot",location:Ui(),ref:io(e,e=>e[1],null),name:io(t,e=>e[1],"")}},hs=function(e,t){return{kind:"schema-inline",location:Ui(),names:io(e,e=>e.map(e=>e[0]).filter(e=>"*"!==e),[]),fields:io(t,e=>[e[0],...e[1].map(e=>e[2])],[])}},us=function(e,t){return{kind:"schema-inline-field",location:Ui(),name:t,type:io(e,e=>e[0],null)}},ds="schema",ps=Zi("schema",!1),fs=function(e,t){return{names:e.map(e=>e[1]).filter(e=>"*"!==e),parents:io(t,e=>e,[])}},ms="alias",gs=Zi("alias",!1),ys=function(e,t,n){return Object.assign({kind:"schema",location:Ui(),items:io(n,so,[]),alias:t},e)},_s=function(e,t){return Object.assign({kind:"schema",location:Ui(),items:io(t,so,[])},e)},vs="extends",Ss=Zi("extends",!1),bs=function(e,t){return[e,...t.map(e=>e[3])]},ws=function(e,t){return{kind:"schema-field",location:Ui(),type:e,name:t}},Cs=function(e){return{kind:"schema-collection",location:Ui(),schema:e}},Ts=function(e){return{kind:"schema-reference",location:Ui(),schema:e}},$s="Text",ks=Zi("Text",!1),Rs="URL",Es=Zi("URL",!1),Is="Number",Ns=Zi("Number",!1),Ms="Boolean",xs=Zi("Boolean",!1),As="Bytes",js=Zi("Bytes",!1),Os="Object",Ps=Zi("Object",!1),Fs=function(e){return{kind:"schema-primitive",location:Ui(),type:e}},Ls="(",Hs=Zi("(",!1),Bs="or",qs=Zi("or",!1),Vs=")",Ws=Zi(")",!1),zs=function(e,t){const n=[e];for(const e of t)n.push(e[3]);return{kind:"schema-union",location:Ui(),types:n}},Ds=function(e,t){const n=[e];for(const e of t)n.push(e[3]);return{kind:"schema-tuple",location:Ui(),types:n}},Ks=Qi("a version number (e.g. @012)"),Us=/^[0-9]/,Js=Gi([["0","9"]],!1,!1),Zs=function(e){return Number(e.join(""))},Gs=Qi("indentation"),Qs=" ",Xs=Zi(" ",!1),Ys=function(e){return(e=e.join("")).length>eo.length&&(no.push(eo),eo=e,!0)},ei=Qi("same indentation"),ti=function(e){return(e=e.join("")).length===eo.length||e.length<eo.length&&(eo=no.pop(),!1)},ni=Qi("same or more indentation"),si=function(e){return(e=e.join("")).length>=eo.length||(e.length<eo.length?(eo=no.pop(),!1):void 0)},ii=/^[^a-zA-Z0-9_]/,ri=Gi([["a","z"],["A","Z"],["0","9"],"_"],!0,!1),oi={type:"any"},ai=function(e){throw new Fe(`Expected identifier but keyword, '${e}' found.`,[],"",Ui())},ci=Qi("a `backquoted string`"),li="`",hi=Zi("`",!1),ui=/^[^`]/,di=Gi(["`"],!0,!1),pi=function(e){return e.join("")},fi=Qi("an identifier (e.g. 'id')"),mi="'",gi=Zi("'",!1),yi=/^[^']/,_i=Gi(["'"],!0,!1),vi=function(e){return e.join("")},Si=Qi("an uppercase identifier (e.g. Foo)"),bi=/^[A-Z]/,wi=Gi([["A","Z"]],!1,!1),Ci=/^[a-z0-9_]/i,Ti=Gi([["a","z"],["0","9"],"_"],!1,!0),$i=Qi("a lowercase identifier (e.g. foo)"),ki=/^[a-z]/,Ri=Gi([["a","z"]],!1,!1),Ei=Qi("a field name (e.g. foo9)"),Ii=Qi("one or more whitespace characters"),Ni=Qi("a new line"),Mi=/^[ ]/,xi=Gi([" "],!1,!1),Ai="//",ji=Zi("//",!1),Oi="\r",Pi=Zi("\r",!1),Fi="\n",Li=Zi("\n",!1);let Hi=0,Bi=0;const qi=[{line:1,column:1}];let Vi,Wi=0,zi=[],Di=0;if(void 0!==t.startRule){if(!(t.startRule in s))throw new Error("Can't start parsing from rule \""+t.startRule+'".');i=s[t.startRule]}function Ki(){return e.substring(Bi,Hi)}function Ui(){return Yi(Bi,Hi)}function Ji(e,t){throw function(e,t){return new Fe(e,[],"",t)}(e,t=void 0!==t?t:Yi(Bi,Hi))}function Zi(e,t){return{type:"literal",text:e,ignoreCase:t}}function Gi(e,t,n){return{type:"class",parts:e,inverted:t,ignoreCase:n}}function Qi(e){return{type:"other",description:e}}function Xi(t){let n,s=qi[t];if(s)return s;for(n=t-1;!qi[n];)n--;for(s={line:(s=qi[n]).line,column:s.column};n<t;)10===e.charCodeAt(n)?(s.line++,s.column=1):s.column++,n++;return qi[t]=s,s}function Yi(e,t){const n=Xi(e),s=Xi(t);return{start:{offset:e,line:n.line,column:n.column},end:{offset:t,line:s.line,column:s.column}}}function er(e){Hi<Wi||(Hi>Wi&&(Wi=Hi,zi=[]),zi.push(e))}function tr(e,t,n){return new Fe(Fe.buildMessage(e,t),e,t,n)}function nr(){let e,t,s,i,o,a,c,l,h;if(e=Hi,(t=Xr())===n&&(t=null),t!==n)if((s=Wr())===n&&(s=null),s!==n){for(i=[],o=Hi,a=Hi,(c=zr())!==n&&(l=ir())!==n&&(h=Xr())!==n?a=c=[c,l,h]:(Hi=a,a=n),a===n&&(a=null),a!==n&&(c=zr())!==n&&(l=sr())!==n?o=a=[a,c,l]:(Hi=o,o=n);o!==n;)i.push(o),o=Hi,a=Hi,(c=zr())!==n&&(l=ir())!==n&&(h=Xr())!==n?a=c=[c,l,h]:(Hi=a,a=n),a===n&&(a=null),a!==n&&(c=zr())!==n&&(l=sr())!==n?o=a=[a,c,l]:(Hi=o,o=n);i!==n?(Bi=e,e=t=r(i)):(Hi=e,e=n)}else Hi=e,e=n;else Hi=e,e=n;return e}function sr(){let t;return(t=function(){let t,s,i,r,o,a,c,l,h,u,d;if(t=Hi,e.substr(Hi,6)===Zt?(s=Zt,Hi+=6):(s=n,0===Di&&er(Gt)),s!==n)if(i=Hi,(r=Qr())!==n&&(o=Jr())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n)if(r=Hi,(o=Qr())!==n&&(a=Ar())!==n?r=o=[o,a]:(Hi=r,r=n),r===n&&(r=null),r!==n)if((o=Xr())!==n){if(a=Hi,(c=Wr())!==n){for(l=[],h=Hi,(u=zr())!==n&&(d=wr())!==n?h=u=[u,d]:(Hi=h,h=n);h!==n;)l.push(h),h=Hi,(u=zr())!==n&&(d=wr())!==n?h=u=[u,d]:(Hi=h,h=n);l!==n?a=c=[c,l]:(Hi=a,a=n)}else Hi=a,a=n;a===n&&(a=null),a!==n?(Bi=t,s=Qt(i,r,a),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p,f;if(t=Hi,e.substr(Hi,8)===ge?(s=ge,Hi+=8):(s=n,0===Di&&er(ye)),s!==n)if((i=Qr())!==n)if((r=Jr())!==n)if(o=Hi,(a=Qr())!==n&&(c=Ar())!==n?o=a=[a,c]:(Hi=o,o=n),o===n&&(o=null),o!==n)if(a=Hi,(c=Qr())!==n?(e.substr(Hi,2)===R?(l=R,Hi+=2):(l=n,0===Di&&er(E)),l!==n&&(h=Qr())!==n&&(u=Ur())!==n?a=c=[c,l,h,u]:(Hi=a,a=n)):(Hi=a,a=n),a===n&&(a=null),a!==n)if((c=Xr())!==n){if(l=Hi,(h=Wr())!==n){for(u=[],d=Hi,(p=zr())!==n&&(f=lr())!==n?d=p=[p,f]:(Hi=d,d=n);d!==n;)u.push(d),d=Hi,(p=zr())!==n&&(f=lr())!==n?d=p=[p,f]:(Hi=d,d=n);u!==n?l=h=[h,u]:(Hi=l,l=n)}else Hi=l,l=n;l===n&&(l=null),l!==n?((h=Xr())===n&&(h=null),h!==n?(Bi=t,s=_e(r,o,a,l),t=s):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o;return t=Hi,e.substr(Hi,6)===P?(s=P,Hi+=6):(s=n,0===Di&&er(F)),s!==n&&(i=Qr())!==n&&(r=Ur())!==n&&(o=Xr())!==n?(Bi=t,s=L(r),t=s):(Hi=t,t=n),t}())===n&&(t=function(){let e,t,s,i,r,o,a,c,l;if(e=Hi,(t=Hr())!==n)if((s=Xr())!==n){if(i=Hi,(r=Wr())!==n){for(o=[],a=Hi,(c=zr())!==n&&(l=Br())!==n?a=c=[c,l]:(Hi=a,a=n);a!==n;)o.push(a),a=Hi,(c=zr())!==n&&(l=Br())!==n?a=c=[c,l]:(Hi=a,a=n);o!==n?i=r=[r,o]:(Hi=i,i=n)}else Hi=i,i=n;i===n&&(i=null),i!==n?(Bi=e,t=_s(t,i),e=t):(Hi=e,e=n)}else Hi=e,e=n;else Hi=e,e=n;return e}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p,f;if(t=Hi,e.substr(Hi,5)===ms?(s=ms,Hi+=5):(s=n,0===Di&&er(gs)),s!==n)if((i=Qr())!==n)if((r=Hr())!==n)if((o=Qr())!==n)if((a=function(){let t,s,i,r;return t=Hi,e.substr(Hi,2)===Xt?(s=Xt,Hi+=2):(s=n,0===Di&&er(Yt)),s!==n&&(i=Qr())!==n&&(r=Jr())!==n?(Bi=t,s=en(r),t=s):(Hi=t,t=n),t}())!==n)if((c=Xr())!==n){if(l=Hi,(h=Wr())!==n){for(u=[],d=Hi,(p=zr())!==n&&(f=Br())!==n?d=p=[p,f]:(Hi=d,d=n);d!==n;)u.push(d),d=Hi,(p=zr())!==n&&(f=Br())!==n?d=p=[p,f]:(Hi=d,d=n);u!==n?l=h=[h,u]:(Hi=l,l=n)}else Hi=l,l=n;l===n&&(l=null),l!==n?(Bi=t,s=ys(r,a,l),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o,l,h,u,d,p,f,m,g,y,_,v,j,O,P,F,L;if(t=Hi,e.substr(Hi,5)===S?(s=S,Hi+=5):(s=n,0===Di&&er(b)),s!==n)if((i=Qr())!==n)if((r=Jr())!==n)if((o=Qr())!==n)if(e.substr(Hi,2)===w?(l=w,Hi+=2):(l=n,0===Di&&er(C)),l!==n)if((h=Qr())!==n)if((u=function(){let e;return(e=Fr())===n&&(e=dr())===n&&(e=pr())===n&&(e=gr()),e}())!==n)if(d=Hi,(p=Qr())!==n&&(f=Ur())!==n?d=p=[p,f]:(Hi=d,d=n),d===n&&(d=null),d!==n)if(p=Hi,e.substr(Hi,2)===T?(f=T,Hi+=2):(f=n,0===Di&&er($)),f!==n&&(m=Ur())!==n?p=f=[f,m]:(Hi=p,p=n),p===n&&(p=null),p!==n)if(f=Hi,(m=Qr())!==n&&(g=function(){let t,s,i,r;if(Di++,t=Hi,64===e.charCodeAt(Hi)?(s=a,Hi++):(s=n,0===Di&&er(c)),s!==n){if(i=[],Us.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(Js)),r!==n)for(;r!==n;)i.push(r),Us.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(Js));else i=n;i!==n?(Bi=t,s=Zs(i),t=s):(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(Ks)),t}())!==n?f=m=[m,g]:(Hi=f,f=n),f===n&&(f=null),f!==n)if(m=Hi,(g=Qr())!==n&&(y=Mr())!==n?m=g=[g,y]:(Hi=m,m=n),m===n&&(m=null),m!==n)if((g=Qr())!==n)if((y=function(){let t;return(t=function(){let t,s,i,r;return t=Hi,e.substr(Hi,2)===R?(s=R,Hi+=2):(s=n,0===Di&&er(E)),s!==n&&(i=Qr())!==n&&(r=Ur())!==n?(Bi=t,s=I(r),t=s):(Hi=t,t=n),t}())===n&&(t=function(){let t,s,i,r;return t=Hi,e.substr(Hi,2)===R?(s=R,Hi+=2):(s=n,0===Di&&er(E)),s!==n&&(i=Qr())!==n&&(r=Jr())!==n?(Bi=t,s=N(r),t=s):(Hi=t,t=n),t}())===n&&(t=function(){let t,s,i,r;return t=Hi,e.substr(Hi,2)===M?(s=M,Hi+=2):(s=n,0===Di&&er(x)),s!==n&&(i=Qr())!==n&&(r=Ur())!==n?(Bi=t,s=A(r),t=s):(Hi=t,t=n),t}()),t}())!==n)if((_=Xr())!==n){if(v=Hi,(j=Wr())!==n){if(O=[],P=Hi,(F=zr())!==n&&(L=or())!==n?P=F=[F,L]:(Hi=P,P=n),P!==n)for(;P!==n;)O.push(P),P=Hi,(F=zr())!==n&&(L=or())!==n?P=F=[F,L]:(Hi=P,P=n);else O=n;O!==n?v=j=[j,O]:(Hi=v,v=n)}else Hi=v,v=n;v===n&&(v=null),v!==n?(Bi=t,s=k(r,u,d,p,f,m,y,v),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p;if(Di++,t=Hi,e.substr(Hi,9)===B?(s=B,Hi+=9):(s=n,0===Di&&er(q)),s!==n)if((i=Qr())!==n)if((r=Jr())!==n)if(o=Hi,(a=Qr())===n&&(a=null),a!==n?(60===e.charCodeAt(Hi)?(c=V,Hi++):(c=n,0===Di&&er(W)),c!==n?((l=Qr())===n&&(l=null),l!==n&&(h=function(){let t,s,i,r,o,a,c;if(t=Hi,(s=fr())!==n){for(i=[],r=Hi,44===e.charCodeAt(Hi)?(o=it,Hi++):(o=n,0===Di&&er(rt)),o!==n&&(a=Qr())!==n&&(c=fr())!==n?r=o=[o,a,c]:(Hi=r,r=n);r!==n;)i.push(r),r=Hi,44===e.charCodeAt(Hi)?(o=it,Hi++):(o=n,0===Di&&er(rt)),o!==n&&(a=Qr())!==n&&(c=fr())!==n?r=o=[o,a,c]:(Hi=r,r=n);i!==n?(Bi=t,s=ut(s,i),t=s):(Hi=t,t=n)}else Hi=t,t=n;return t}())!==n?((u=Qr())===n&&(u=null),u!==n?(62===e.charCodeAt(Hi)?(d=z,Hi++):(d=n,0===Di&&er(D)),d!==n?o=a=[a,c,l,h,u,d]:(Hi=o,o=n)):(Hi=o,o=n)):(Hi=o,o=n)):(Hi=o,o=n)):(Hi=o,o=n),o===n&&(o=null),o!==n)if((a=Xr())!==n){if(c=Hi,(l=Wr())!==n){for(h=[],u=Hi,(d=zr())!==n&&(p=ar())!==n?u=d=[d,p]:(Hi=u,u=n);u!==n;)h.push(u),u=Hi,(d=zr())!==n&&(p=ar())!==n?u=d=[d,p]:(Hi=u,u=n);h!==n?c=l=[l,h]:(Hi=c,c=n)}else Hi=c,c=n;c===n&&(c=null),c!==n?((l=Xr())===n&&(l=null),l!==n?(Bi=t,s=K(r,o,c),t=s):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(H)),t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h;if(t=Hi,e.substr(Hi,4)===re?(s=re,Hi+=4):(s=n,0===Di&&er(oe)),s!==n)if((i=Xr())!==n){if(r=Hi,(o=Wr())!==n){for(a=[],c=Hi,(l=zr())!==n&&(h=cr())!==n?c=l=[l,h]:(Hi=c,c=n);c!==n;)a.push(c),c=Hi,(l=zr())!==n&&(h=cr())!==n?c=l=[l,h]:(Hi=c,c=n);a!==n?r=o=[o,a]:(Hi=r,r=n)}else Hi=r,r=n;r===n&&(r=null),r!==n?((o=Xr())===n&&(o=null),o!==n?(Bi=t,s=ae(r),t=s):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,y,_;return t=Hi,e.substr(Hi,8)===h?(s=h,Hi+=8):(s=n,0===Di&&er(u)),s!==n&&(i=Qr())!==n&&(r=Jr())!==n&&(o=Xr())!==n&&(a=Wr())!==n&&(c=zr())!==n&&(l=function(){let t,s,i;return t=Hi,e.substr(Hi,5)===p?(s=p,Hi+=5):(s=n,0===Di&&er(f)),s!==n&&(i=Xr())!==n?(Bi=t,s=m(),t=s):(Hi=t,t=n),t}())!==n&&(y=function(){let e,t,s,i,r;if(e=Hi,t=[],s=Hi,(i=Dr())!==n&&(r=rr())!==n?s=i=[i,r]:(Hi=s,s=n),s!==n)for(;s!==n;)t.push(s),s=Hi,(i=Dr())!==n&&(r=rr())!==n?s=i=[i,r]:(Hi=s,s=n);else t=n;return t!==n&&(Bi=e,t=g(t)),e=t}())!==n?((_=Xr())===n&&(_=null),_!==n?(Bi=t,s=d(r,y),t=s):(Hi=t,t=n)):(Hi=t,t=n),t}()),t}function ir(){let t,s,i;return Di++,t=Hi,64===e.charCodeAt(Hi)?(s=a,Hi++):(s=n,0===Di&&er(c)),s!==n&&(i=Zr())!==n?(Bi=t,t=s=l(i)):(Hi=t,t=n),Di--,t===n&&(s=n,0===Di&&er(o)),t}function rr(){let t,s,i;for(t=Hi,s=[],y.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(_));i!==n;)s.push(i),y.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(_));return s!==n&&(i=Yr())!==n?(Bi=t,t=s=v()):(Hi=t,t=n),t}function or(){let t,s,i,r,o;return t=Hi,e.substr(Hi,11)===j?(s=j,Hi+=11):(s=n,0===Di&&er(O)),s!==n&&(i=Qr())!==n&&(r=Kr())!==n&&(o=Xr())!==n?t=s=[s,i,r,o]:(Hi=t,t=n),t}function ar(){let t;return(t=function(){let t,s,i,r,o,a,c;return t=Hi,s=Hi,e.substr(Hi,4)===G?(i=G,Hi+=4):(i=n,0===Di&&er(Q)),i!==n&&(r=Qr())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n?(e.substr(Hi,7)===X?(i=X,Hi+=7):(i=n,0===Di&&er(Y)),i===n&&(e.substr(Hi,7)===ee?(i=ee,Hi+=7):(i=n,0===Di&&er(te))),i!==n?(r=Hi,(o=Qr())!==n?(e.substr(Hi,6)===ne?(a=ne,Hi+=6):(a=n,0===Di&&er(se)),a!==n?r=o=[o,a]:(Hi=r,r=n)):(Hi=r,r=n),r===n&&(r=null),r!==n?(o=Hi,(a=Qr())!==n&&(c=Zr())!==n?o=a=[a,c]:(Hi=o,o=n),o===n&&(o=null),o!==n&&(a=Xr())!==n?(Bi=t,s=ie(s,i,r,o),t=s):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}())===n&&(t=function(){let t,s,i,r,o;return t=Hi,s=Hi,(i=hr())!==n&&(r=Qr())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n?(i=Hi,(r=ur())!==n&&(o=Qr())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n?((r=Zr())===n&&(42===e.charCodeAt(Hi)?(r=U,Hi++):(r=n,0===Di&&er(J))),r!==n&&(o=Xr())!==n?(Bi=t,s=Z(s,i,r),t=s):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}()),t}function cr(){let t;return(t=function(){let t,s,i,r,o,a,c;return t=Hi,e.substr(Hi,10)===pe?(s=pe,Hi+=10):(s=n,0===Di&&er(fe)),s!==n?((i=Qr())===n&&(i=null),i!==n?(58===e.charCodeAt(Hi)?(r=he,Hi++):(r=n,0===Di&&er(ue)),r!==n?((o=Qr())===n&&(o=null),o!==n&&(a=Ur())!==n&&(c=Xr())!==n?(Bi=t,s=me(a),t=s):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}())===n&&(t=function(){let t,s,i,r,o,a,c;return t=Hi,e.substr(Hi,4)===ce?(s=ce,Hi+=4):(s=n,0===Di&&er(le)),s!==n?((i=Qr())===n&&(i=null),i!==n?(58===e.charCodeAt(Hi)?(r=he,Hi++):(r=n,0===Di&&er(ue)),r!==n?((o=Qr())===n&&(o=null),o!==n&&(a=Ur())!==n&&(c=Xr())!==n?(Bi=t,s=de(a),t=s):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}()),t}function lr(){let t,s;return Di++,(t=function(){let t,s,i,r,o;return t=Hi,e.substr(Hi,8)===dt?(s=dt,Hi+=8):(s=n,0===Di&&er(pt)),s!==n&&(i=Qr())!==n&&(r=function(){let t;return e.substr(Hi,9)===mt?(t=mt,Hi+=9):(t=n,0===Di&&er(gt)),t===n&&(e.substr(Hi,3)===yt?(t=yt,Hi+=3):(t=n,0===Di&&er(_t)),t===n&&(e.substr(Hi,2)===vt?(t=vt,Hi+=2):(t=n,0===Di&&er(St)),t===n&&(e.substr(Hi,5)===bt?(t=bt,Hi+=5):(t=n,0===Di&&er(wt)),t===n&&(e.substr(Hi,14)===Ct?(t=Ct,Hi+=14):(t=n,0===Di&&er(Tt)),t===n&&(e.substr(Hi,8)===$t?(t=$t,Hi+=8):(t=n,0===Di&&er(kt)),t===n&&(e.substr(Hi,7)===Rt?(t=Rt,Hi+=7):(t=n,0===Di&&er(Et)),t===n&&(e.substr(Hi,10)===It?(t=It,Hi+=10):(t=n,0===Di&&er(Nt))))))))),t}())!==n&&(o=Xr())!==n?(Bi=t,s=ft(r),t=s):(Hi=t,t=n),t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p,f,m;if(t=Hi,s=Hi,e.substr(Hi,4)===G?(i=G,Hi+=4):(i=n,0===Di&&er(Q)),i!==n&&(r=Qr())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n)if(e.substr(Hi,7)===X?(i=X,Hi+=7):(i=n,0===Di&&er(Y)),i!==n)if((r=Qr())!==n)if(o=Hi,e.substr(Hi,6)===ne?(a=ne,Hi+=6):(a=n,0===Di&&er(se)),a!==n&&(c=Qr())!==n?o=a=[a,c]:(Hi=o,o=n),o===n&&(o=null),o!==n)if((a=Zr())!==n)if(c=Hi,(l=Qr())!==n&&(h=Mr())!==n?c=l=[l,h]:(Hi=c,c=n),c===n&&(c=null),c!==n)if((l=Xr())!==n){if(h=Hi,(u=Wr())!==n){for(d=[],p=Hi,(f=zr())!==n&&(m=yr())!==n?p=f=[f,m]:(Hi=p,p=n);p!==n;)d.push(p),p=Hi,(f=zr())!==n&&(m=yr())!==n?p=f=[f,m]:(Hi=p,p=n);d!==n?h=u=[u,d]:(Hi=h,h=n)}else Hi=h,h=n;h===n&&(h=null),h!==n?(Bi=t,s=Mt(s,o,a,c,h),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=Sr())===n&&(t=function t(){let s,i,r,o,a,c,l,h,u;if(s=Hi,(i=function(){let t,s,i,r,o,a,c;return t=Hi,(s=hr())!==n?(63===e.charCodeAt(Hi)?(i=be,Hi++):(i=n,0===Di&&er(we)),i===n&&(i=null),i!==n&&(r=Qr())!==n&&(o=ur())!==n&&(a=Qr())!==n&&(c=function(){let e,t,s,i,r;return e=Hi,(t=Zr())!==n?(s=Hi,(i=Qr())!==n&&(r=Mr())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n?(Bi=e,t=Yn(t,s),e=t):(Hi=e,e=n)):(Hi=e,e=n),e===n&&(e=Hi,(t=Qr())!==n&&(s=Zr())!==n?(Bi=e,t=es(s),e=t):(Hi=e,e=n),e===n&&(e=Hi,(t=Qr())!==n&&(s=Mr())!==n?(Bi=e,t=ts(s),e=t):(Hi=e,e=n))),e}())!==n?(Bi=t,s=Ce(s,i,o,c),t=s):(Hi=t,t=n)):(Hi=t,t=n),t}())!==n)if((r=Xr())!==n){if(o=Hi,(a=Wr())!==n){for(c=[],l=Hi,(h=zr())!==n&&(u=t())!==n?l=h=[h,u]:(Hi=l,l=n);l!==n;)c.push(l),l=Hi,(h=zr())!==n&&(u=t())!==n?l=h=[h,u]:(Hi=l,l=n);c!==n?o=a=[a,c]:(Hi=o,o=n)}else Hi=o,o=n;o===n&&(o=null),o!==n?(Bi=s,i=Se(i,o),s=i):(Hi=s,s=n)}else Hi=s,s=n;else Hi=s,s=n;return s}()),Di--,t===n&&(s=n,0===Di&&er(ve)),t}function hr(){let t,s;return Di++,e.substr(Hi,5)===$e?(t=$e,Hi+=5):(t=n,0===Di&&er(ke)),t===n&&(e.substr(Hi,2)===R?(t=R,Hi+=2):(t=n,0===Di&&er(E)),t===n&&(e.substr(Hi,3)===Re?(t=Re,Hi+=3):(t=n,0===Di&&er(Ee)),t===n&&(e.substr(Hi,4)===Ie?(t=Ie,Hi+=4):(t=n,0===Di&&er(Ne)),t===n&&(e.substr(Hi,8)===Me?(t=Me,Hi+=8):(t=n,0===Di&&er(xe)),t===n&&(t=Hi,e.substr(Hi,8)===Ae?(s=Ae,Hi+=8):(s=n,0===Di&&er(je)),s!==n&&(Bi=t,s=Oe()),t=s))))),Di--,t===n&&(s=n,0===Di&&er(Te)),t}function ur(){let t;return(t=fr())===n&&(t=dr())===n&&(t=pr())===n&&(t=function(){let t,s,i,r;return t=Hi,e.substr(Hi,10)===De?(s=De,Hi+=10):(s=n,0===Di&&er(Ke)),s!==n&&(i=ur())!==n?(62===e.charCodeAt(Hi)?(r=z,Hi++):(r=n,0===Di&&er(D)),r!==n?(Bi=t,s=Ue(i),t=s):(Hi=t,t=n)):(Hi=t,t=n),t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p;if(t=Hi,e.substr(Hi,4)===et?(s=et,Hi+=4):(s=n,0===Di&&er(tt)),s!==n){if(i=Hi,(r=Qr())!==n)if(123===e.charCodeAt(Hi)?(o=nt,Hi++):(o=n,0===Di&&er(st)),o!==n){if(a=Hi,(c=mr())!==n){for(l=[],h=Hi,44===e.charCodeAt(Hi)?(u=it,Hi++):(u=n,0===Di&&er(rt)),u!==n&&(d=Qr())!==n&&(p=mr())!==n?h=u=[u,d,p]:(Hi=h,h=n);h!==n;)l.push(h),h=Hi,44===e.charCodeAt(Hi)?(u=it,Hi++):(u=n,0===Di&&er(rt)),u!==n&&(d=Qr())!==n&&(p=mr())!==n?h=u=[u,d,p]:(Hi=h,h=n);l!==n?a=c=[c,l]:(Hi=a,a=n)}else Hi=a,a=n;a===n&&(a=null),a!==n?(125===e.charCodeAt(Hi)?(c=ot,Hi++):(c=n,0===Di&&er(at)),c!==n?i=r=[r,o,a,c]:(Hi=i,i=n)):(Hi=i,i=n)}else Hi=i,i=n;else Hi=i,i=n;i===n&&(i=null),i!==n?(Bi=t,s=ct(i),t=s):(Hi=t,t=n)}else Hi=t,t=n;return t}())===n&&(t=Fr())===n&&(t=gr()),t}function dr(){let t,s,i,r;return t=Hi,91===e.charCodeAt(Hi)?(s=Pe,Hi++):(s=n,0===Di&&er(Le)),s!==n&&(i=ur())!==n?(93===e.charCodeAt(Hi)?(r=He,Hi++):(r=n,0===Di&&er(Be)),r!==n?(Bi=t,t=s=qe(i)):(Hi=t,t=n)):(Hi=t,t=n),t}function pr(){let t,s,i,r;return t=Hi,e.substr(Hi,14)===Ve?(s=Ve,Hi+=14):(s=n,0===Di&&er(We)),s!==n&&(i=ur())!==n?(62===e.charCodeAt(Hi)?(r=z,Hi++):(r=n,0===Di&&er(D)),r!==n?(Bi=t,t=s=ze(i)):(Hi=t,t=n)):(Hi=t,t=n),t}function fr(){let t,s,i,r,o,a,c,l;return Di++,t=Hi,126===e.charCodeAt(Hi)?(s=Ze,Hi++):(s=n,0===Di&&er(Ge)),s!==n&&(i=Zr())!==n?(r=Hi,(o=Qr())!==n?(e.substr(Hi,4)===Qe?(a=Qe,Hi+=4):(a=n,0===Di&&er(Xe)),a!==n&&(c=Qr())!==n&&(l=ur())!==n?r=o=[o,a,c,l]:(Hi=r,r=n)):(Hi=r,r=n),r===n&&(r=null),r!==n?(Bi=t,t=s=Ye(i,r)):(Hi=t,t=n)):(Hi=t,t=n),Di--,t===n&&(s=n,0===Di&&er(Je)),t}function mr(){let t,s,i,r,o,a;return t=Hi,(s=Gr())!==n?((i=Qr())===n&&(i=null),i!==n?(58===e.charCodeAt(Hi)?(r=he,Hi++):(r=n,0===Di&&er(ue)),r!==n?((o=Qr())===n&&(o=null),o!==n&&(a=Zr())!==n?(Bi=t,t=s=lt(s,a)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}function gr(){let e,t;return e=Hi,(t=Jr())!==n&&(Bi=e,t=ht(t)),e=t}function yr(){let t;return(t=_r())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p,f,m;if(t=Hi,s=Hi,e.substr(Hi,4)===G?(i=G,Hi+=4):(i=n,0===Di&&er(Q)),i!==n&&(r=Qr())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n)if(e.substr(Hi,7)===ee?(i=ee,Hi+=7):(i=n,0===Di&&er(te)),i!==n)if((r=Qr())!==n)if(o=Hi,e.substr(Hi,6)===ne?(a=ne,Hi+=6):(a=n,0===Di&&er(se)),a!==n&&(c=Qr())!==n?o=a=[a,c]:(Hi=o,o=n),o===n&&(o=null),o!==n)if((a=Zr())!==n)if(c=Hi,(l=Qr())!==n&&(h=Mr())!==n?c=l=[l,h]:(Hi=c,c=n),c===n&&(c=null),c!==n)if((l=Xr())!==n){if(h=Hi,(u=Wr())!==n){for(d=[],p=Hi,(f=zr())!==n&&(m=vr())!==n?p=f=[f,m]:(Hi=p,p=n);p!==n;)d.push(p),p=Hi,(f=zr())!==n&&(m=vr())!==n?p=f=[f,m]:(Hi=p,p=n);d!==n?h=u=[u,d]:(Hi=h,h=n)}else Hi=h,h=n;h===n&&(h=null),h!==n?(Bi=t,s=Wt(s,o,a,c,h),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}()),t}function _r(){let t,s,i,r,o;return t=Hi,e.substr(Hi,10)===xt?(s=xt,Hi+=10):(s=n,0===Di&&er(At)),s!==n&&(i=Qr())!==n?(e.substr(Hi,10)===jt?(r=jt,Hi+=10):(r=n,0===Di&&er(Ot)),r===n&&(e.substr(Hi,3)===Pt?(r=Pt,Hi+=3):(r=n,0===Di&&er(Ft)),r===n&&(e.substr(Hi,6)===Lt?(r=Lt,Hi+=6):(r=n,0===Di&&er(Ht)),r===n&&(e.substr(Hi,5)===Bt?(r=Bt,Hi+=5):(r=n,0===Di&&er(qt))))),r!==n&&(o=Xr())!==n?(Bi=t,t=s=Vt(r)):(Hi=t,t=n)):(Hi=t,t=n),t}function vr(){let t;return(t=_r())===n&&(t=function(){let t,s,i,r,o;return t=Hi,e.substr(Hi,6)===zt?(s=zt,Hi+=6):(s=n,0===Di&&er(Dt)),s!==n&&(i=Qr())!==n&&(r=Zr())!==n&&(o=Xr())!==n?(Bi=t,s=Kt(r),t=s):(Hi=t,t=n),t}()),t}function Sr(){let t,s,i,r,o,a,c,l,h,u,d;if(t=Hi,e.substr(Hi,11)===j?(s=j,Hi+=11):(s=n,0===Di&&er(O)),s!==n)if((i=Qr())!==n)if((r=Kr())!==n)if((o=Xr())!==n){if(a=Hi,(c=Wr())!==n){if(l=[],h=Hi,(u=zr())!==n&&(d=br())!==n?h=u=[u,d]:(Hi=h,h=n),h!==n)for(;h!==n;)l.push(h),h=Hi,(u=zr())!==n&&(d=br())!==n?h=u=[u,d]:(Hi=h,h=n);else l=n;l!==n?a=c=[c,l]:(Hi=a,a=n)}else Hi=a,a=n;a===n&&(a=null),a!==n?(Bi=t,t=s=Ut(r,a)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}function br(){let e,t,s,i,r;return e=Hi,(t=Zr())!==n&&(s=Qr())!==n&&(i=Kr())!==n&&(r=Xr())!==n?(Bi=e,e=t=Jt(t,i)):(Hi=e,e=n),e}function wr(){let t;return(t=Tr())===n&&(t=function(){let e,t,s,i,r,o;return e=Hi,(t=Ir())!==n?(s=Hi,(i=Qr())!==n&&(r=Or())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n?(i=Hi,(r=Qr())!==n&&(o=Cr())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n&&(r=Xr())!==n?(Bi=e,t=Pn(t,s,i),e=t):(Hi=e,e=n)):(Hi=e,e=n)):(Hi=e,e=n),e}())===n&&(t=Nr())===n&&(t=function(){let t,s,i,r,o,a,c,l,h;if(t=Hi,e.substr(Hi,7)===Fn?(s=Fn,Hi+=7):(s=n,0===Di&&er(Ln)),s!==n)if((i=Xr())!==n){if(r=Hi,(o=Wr())!==n){for(a=[],c=Hi,(l=zr())!==n?((h=Tr())===n&&(h=Nr())===n&&(h=Pr()),h!==n?c=l=[l,h]:(Hi=c,c=n)):(Hi=c,c=n);c!==n;)a.push(c),c=Hi,(l=zr())!==n?((h=Tr())===n&&(h=Nr())===n&&(h=Pr()),h!==n?c=l=[l,h]:(Hi=c,c=n)):(Hi=c,c=n);a!==n?r=o=[o,a]:(Hi=r,r=n)}else Hi=r,r=n;r===n&&(r=null),r!==n?(Bi=t,s=Hn(r),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=Pr())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u,d,p,f,m;if(t=Hi,e.substr(Hi,6)===cn?(s=cn,Hi+=6):(s=n,0===Di&&er(ln)),s!==n)if((i=Qr())!==n)if((r=Kr())!==n)if((o=Xr())!==n){if(a=Hi,(c=Wr())!==n){if(l=Hi,(h=zr())!==n)if(e.substr(Hi,6)===hn?(u=hn,Hi+=6):(u=n,0===Di&&er(un)),u!==n){if(d=[],p=Hi,(f=Qr())!==n&&(m=Kr())!==n?p=f=[f,m]:(Hi=p,p=n),p!==n)for(;p!==n;)d.push(p),p=Hi,(f=Qr())!==n&&(m=Kr())!==n?p=f=[f,m]:(Hi=p,p=n);else d=n;d!==n&&(p=Xr())!==n?l=h=[h,u,d,p]:(Hi=l,l=n)}else Hi=l,l=n;else Hi=l,l=n;l!==n?a=c=[c,l]:(Hi=a,a=n)}else Hi=a,a=n;a===n&&(a=null),a!==n?(Bi=t,s=dn(r,a),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let e,t,s,i,r,o,a;return e=Hi,(t=Rr())!==n&&(s=Qr())!==n&&(i=kr())!==n&&(r=Qr())!==n&&(o=Rr())!==n&&(a=Xr())!==n?(Bi=e,t=an(t,i,o),e=t):(Hi=e,e=n),e}())===n&&(t=Sr()),t}function Cr(){let t,s,i,r;return t=Hi,e.substr(Hi,2)===Xt?(s=Xt,Hi+=2):(s=n,0===Di&&er(Yt)),s!==n&&(i=Qr())!==n&&(r=Zr())!==n?(Bi=t,t=s=en(r)):(Hi=t,t=n),t}function Tr(){let t,s,i,r,o,a,c,l,h,u;if(t=Hi,(s=function(){let e,t;return e=Hi,(t=Jr())!==n&&(Bi=e,t=ns(t)),(e=t)===n&&(e=Hi,(t=xr())!==n&&(Bi=e,t=ss(t)),e=t),e}())===n&&(42===e.charCodeAt(Hi)?(s=U,Hi++):(s=n,0===Di&&er(J))),s!==n)if(i=Hi,(r=Qr())!==n&&(o=Cr())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n)if((r=Xr())!==n){if(o=Hi,(a=Wr())!==n){for(c=[],l=Hi,(h=zr())!==n&&(u=$r())!==n?l=h=[h,u]:(Hi=l,l=n);l!==n;)c.push(l),l=Hi,(h=zr())!==n&&(u=$r())!==n?l=h=[h,u]:(Hi=l,l=n);c!==n?o=a=[a,c]:(Hi=o,o=n)}else Hi=o,o=n;o===n&&(o=null),o!==n?(Bi=t,t=s=tn(s,i,o)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}function $r(){let t;return(t=function t(){let s,i,r,o,a,c,l,h,u,d,p,f;if(s=Hi,(i=function(){let t;return e.substr(Hi,7)===ee?(t=ee,Hi+=7):(t=n,0===Di&&er(te)),t===n&&(e.substr(Hi,7)===X?(t=X,Hi+=7):(t=n,0===Di&&er(Y))),t}())!==n)if((r=Qr())!==n)if((o=function(){let e,t,s;return e=Hi,(t=Zr())!==n?((s=jr())===n&&(s=null),s!==n?(Bi=e,t=on(t,s),e=t):(Hi=e,e=n)):(Hi=e,e=n),e}())!==n)if(a=Hi,(c=Qr())!==n&&(l=Cr())!==n?a=c=[c,l]:(Hi=a,a=n),a===n&&(a=null),a!==n)if((c=Xr())!==n){if(l=Hi,(h=Wr())!==n){for(u=[],d=Hi,(p=zr())!==n&&(f=t())!==n?d=p=[p,f]:(Hi=d,d=n);d!==n;)u.push(d),d=Hi,(p=zr())!==n&&(f=t())!==n?d=p=[p,f]:(Hi=d,d=n);u!==n?l=h=[h,u]:(Hi=l,l=n)}else Hi=l,l=n;l===n&&(l=null),l!==n?(Bi=s,i=rn(i,o,a,l),s=i):(Hi=s,s=n)}else Hi=s,s=n;else Hi=s,s=n;else Hi=s,s=n;else Hi=s,s=n;else Hi=s,s=n;return s}())===n&&(t=function t(){let s,i,r,o,a,c,l,h,u,d,p,f;if(s=Hi,(i=Zr())===n&&(42===e.charCodeAt(Hi)?(i=U,Hi++):(i=n,0===Di&&er(J))),i!==n)if((r=Qr())!==n)if((o=kr())!==n)if(a=Hi,(c=Qr())!==n&&(l=function(){let e,t,s,i;return e=Hi,(t=Jr())===n&&(t=Zr()),t===n&&(t=null),t!==n?((s=Qr())===n&&(s=null),s!==n?((i=Mr())===n&&(i=null),i!==n?(Bi=e,t=sn(t,i),e=t):(Hi=e,e=n)):(Hi=e,e=n)):(Hi=e,e=n),e}())!==n?a=c=[c,l]:(Hi=a,a=n),a===n&&(a=null),a!==n)if((c=Xr())!==n){if(l=Hi,(h=Wr())!==n){for(u=[],d=Hi,(p=zr())!==n&&(f=t())!==n?d=p=[p,f]:(Hi=d,d=n);d!==n;)u.push(d),d=Hi,(p=zr())!==n&&(f=t())!==n?d=p=[p,f]:(Hi=d,d=n);u!==n?l=h=[h,u]:(Hi=l,l=n)}else Hi=l,l=n;l===n&&(l=null),l!==n?(Bi=s,i=nn(i,o,a,l),s=i):(Hi=s,s=n)}else Hi=s,s=n;else Hi=s,s=n;else Hi=s,s=n;else Hi=s,s=n;else Hi=s,s=n;return s}()),t}function kr(){let t;return e.substr(Hi,2)===pn?(t=pn,Hi+=2):(t=n,0===Di&&er(fn)),t===n&&(e.substr(Hi,2)===mn?(t=mn,Hi+=2):(t=n,0===Di&&er(gn)),t===n&&(61===e.charCodeAt(Hi)?(t=yn,Hi++):(t=n,0===Di&&er(_n)),t===n&&(e.substr(Hi,7)===X?(t=X,Hi+=7):(t=n,0===Di&&er(Y)),t===n&&(e.substr(Hi,7)===ee?(t=ee,Hi+=7):(t=n,0===Di&&er(te)))))),t}function Rr(){let e;return(e=function(){let e,t,s;return e=Hi,(t=Ar())!==n?((s=Er())===n&&(s=null),s!==n?(Bi=e,t=vn(t,s),e=t):(Hi=e,e=n)):(Hi=e,e=n),e}())===n&&(e=function(){let e,t;return e=Hi,(t=Mr())!==n&&(Bi=e,t=Sn(t)),e=t}())===n&&(e=function(){let e,t,s;return e=Hi,(t=Jr())!==n?((s=Er())===n&&(s=null),s!==n?(Bi=e,t=wn(t,s),e=t):(Hi=e,e=n)):(Hi=e,e=n),e}())===n&&(e=function(){let e,t,s;return e=Hi,(t=Zr())!==n?((s=Er())===n&&(s=null),s!==n?(Bi=e,t=bn(t,s),e=t):(Hi=e,e=n)):(Hi=e,e=n),e}()),e}function Er(){let t,s,i,r,o,a;return t=Hi,46===e.charCodeAt(Hi)?(s=Cn,Hi++):(s=n,0===Di&&er(Tn)),s!==n?((i=Zr())===n&&(i=null),i!==n?(r=Hi,(o=Qr())===n&&(o=null),o!==n&&(a=Mr())!==n?r=o=[o,a]:(Hi=r,r=n),r===n&&(r=null),r!==n?(Bi=t,t=s=$n(i,r)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}function Ir(){let t;return 63===e.charCodeAt(Hi)?(t=be,Hi++):(t=n,0===Di&&er(we)),t===n&&(e.substr(Hi,3)===kn?(t=kn,Hi+=3):(t=n,0===Di&&er(Rn)),t===n&&(e.substr(Hi,3)===En?(t=En,Hi+=3):(t=n,0===Di&&er(In)),t===n&&(e.substr(Hi,6)===Nn?(t=Nn,Hi+=6):(t=n,0===Di&&er(Mn)),t===n&&(e.substr(Hi,4)===xn?(t=xn,Hi+=4):(t=n,0===Di&&er(An)),t===n&&(e.substr(Hi,5)===jn?(t=jn,Hi+=5):(t=n,0===Di&&er(On))))))),t}function Nr(){let t,s,i,r,o,a;return t=Hi,e.substr(Hi,6)===zt?(s=zt,Hi+=6):(s=n,0===Di&&er(Dt)),s!==n?(i=Hi,(r=Qr())!==n&&(o=Cr())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n?(r=Hi,(o=Qr())!==n&&(a=Or())!==n?r=o=[o,a]:(Hi=r,r=n),r===n&&(r=null),r!==n&&(o=Xr())!==n?(Bi=t,t=s=Bn(i,r)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}function Mr(){let t,s,i,r,o;return t=Hi,(s=function(){let t,s,i,r,o;if(t=Hi,35===e.charCodeAt(Hi)?(s=qn,Hi++):(s=n,0===Di&&er(Vn)),s!==n)if(Wn.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(zn)),i!==n){for(r=[],Dn.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(Kn));o!==n;)r.push(o),Dn.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(Kn));r!==n?(Bi=t,t=s=Un()):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;return t}())!==n?(i=Hi,(r=Qr())!==n&&(o=Mr())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n?(Bi=t,t=s=Jn(s,i)):(Hi=t,t=n)):(Hi=t,t=n),t}function xr(){let t,s,i,r,o;if(Di++,t=Hi,38===e.charCodeAt(Hi)?(s=Gn,Hi++):(s=n,0===Di&&er(Qn)),s!==n)if(Wn.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(zn)),i!==n){for(r=[],Dn.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(Kn));o!==n;)r.push(o),Dn.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(Kn));r!==n?(Bi=t,t=s=Un()):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(Zn)),t}function Ar(){let e,t,s,i,r;return e=Hi,(t=xr())!==n?(s=Hi,(i=Qr())!==n&&(r=Ar())!==n?s=i=[i,r]:(Hi=s,s=n),s===n&&(s=null),s!==n?(Bi=e,e=t=Jn(t,s)):(Hi=e,e=n)):(Hi=e,e=n),e}function jr(){let e,t,s;return e=Hi,(t=Qr())!==n&&(s=Mr())!==n?(Bi=e,e=t=Xn(s)):(Hi=e,e=n),e}function Or(){let e,t,s;return e=Hi,(t=Ur())!==n?((s=jr())===n&&(s=null),s!==n?(Bi=e,e=t=is(t,s)):(Hi=e,e=n)):(Hi=e,e=n),e===n&&(e=Hi,(t=Jr())!==n?((s=jr())===n&&(s=null),s!==n?(Bi=e,e=t=rs(t,s)):(Hi=e,e=n)):(Hi=e,e=n),e===n&&(e=Hi,(t=Mr())!==n&&(Bi=e,t=os(t)),e=t)),e}function Pr(){let t,s,i,r,o,a;return t=Hi,e.substr(Hi,4)===as?(s=as,Hi+=4):(s=n,0===Di&&er(cs)),s!==n?(i=Hi,(r=Qr())!==n&&(o=Or())!==n?i=r=[r,o]:(Hi=i,i=n),i===n&&(i=null),i!==n?(r=Hi,(o=Qr())!==n&&(a=Cr())!==n?r=o=[o,a]:(Hi=r,r=n),r===n&&(r=null),r!==n&&(o=Xr())!==n?(Bi=t,t=s=ls(i,r)):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),t}function Fr(){let t,s,i,r,o,a,c,l,h,u;if(t=Hi,s=[],i=Hi,(r=Jr())===n&&(42===e.charCodeAt(Hi)?(r=U,Hi++):(r=n,0===Di&&er(J))),r!==n&&(o=Qr())!==n?i=r=[r,o]:(Hi=i,i=n),i!==n)for(;i!==n;)s.push(i),i=Hi,(r=Jr())===n&&(42===e.charCodeAt(Hi)?(r=U,Hi++):(r=n,0===Di&&er(J))),r!==n&&(o=Qr())!==n?i=r=[r,o]:(Hi=i,i=n);else s=n;if(s!==n)if(123===e.charCodeAt(Hi)?(i=nt,Hi++):(i=n,0===Di&&er(st)),i!==n){if(r=Hi,(o=Lr())!==n){for(a=[],c=Hi,44===e.charCodeAt(Hi)?(l=it,Hi++):(l=n,0===Di&&er(rt)),l!==n&&(h=Qr())!==n&&(u=Lr())!==n?c=l=[l,h,u]:(Hi=c,c=n);c!==n;)a.push(c),c=Hi,44===e.charCodeAt(Hi)?(l=it,Hi++):(l=n,0===Di&&er(rt)),l!==n&&(h=Qr())!==n&&(u=Lr())!==n?c=l=[l,h,u]:(Hi=c,c=n);a!==n?r=o=[o,a]:(Hi=r,r=n)}else Hi=r,r=n;r===n&&(r=null),r!==n?(125===e.charCodeAt(Hi)?(o=ot,Hi++):(o=n,0===Di&&er(at)),o!==n?(Bi=t,t=s=hs(s,r)):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;return t}function Lr(){let e,t,s,i;return e=Hi,t=Hi,(s=qr())!==n&&(i=Qr())!==n?t=s=[s,i]:(Hi=t,t=n),t===n&&(t=null),t!==n&&(s=Gr())!==n?(Bi=e,e=t=us(t,s)):(Hi=e,e=n),e}function Hr(){let t,s,i,r,o,a;if(t=Hi,e.substr(Hi,6)===ds?(s=ds,Hi+=6):(s=n,0===Di&&er(ps)),s!==n){if(i=[],r=Hi,(o=Qr())!==n?(42===e.charCodeAt(Hi)?(a=U,Hi++):(a=n,0===Di&&er(J)),a===n&&(a=Jr()),a!==n?r=o=[o,a]:(Hi=r,r=n)):(Hi=r,r=n),r!==n)for(;r!==n;)i.push(r),r=Hi,(o=Qr())!==n?(42===e.charCodeAt(Hi)?(a=U,Hi++):(a=n,0===Di&&er(J)),a===n&&(a=Jr()),a!==n?r=o=[o,a]:(Hi=r,r=n)):(Hi=r,r=n);else i=n;i!==n?((r=function(){let t,s,i,r,o,a,c,l,h,u,d;if(t=Hi,(s=Qr())!==n)if(e.substr(Hi,7)===vs?(i=vs,Hi+=7):(i=n,0===Di&&er(Ss)),i!==n)if((r=Qr())!==n)if((o=Jr())!==n){for(a=[],c=Hi,(l=Qr())===n&&(l=null),l!==n?(44===e.charCodeAt(Hi)?(h=it,Hi++):(h=n,0===Di&&er(rt)),h!==n&&(u=Qr())!==n&&(d=Jr())!==n?c=l=[l,h,u,d]:(Hi=c,c=n)):(Hi=c,c=n);c!==n;)a.push(c),c=Hi,(l=Qr())===n&&(l=null),l!==n?(44===e.charCodeAt(Hi)?(h=it,Hi++):(h=n,0===Di&&er(rt)),h!==n&&(u=Qr())!==n&&(d=Jr())!==n?c=l=[l,h,u,d]:(Hi=c,c=n)):(Hi=c,c=n);a!==n?(Bi=t,s=bs(o,a),t=s):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(r=null),r!==n?(Bi=t,t=s=fs(i,r)):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;return t}function Br(){let e;return(e=function(){let e,t,s,i,r;return e=Hi,(t=qr())!==n&&(s=Qr())!==n&&(i=Gr())!==n&&(r=Xr())!==n?(Bi=e,t=ws(t,i),e=t):(Hi=e,e=n),e}())===n&&(e=Sr()),e}function qr(){let t;return(t=function(){let t,s,i,r,o,a;if(t=Hi,e.substr(Hi,10)===De?(s=De,Hi+=10):(s=n,0===Di&&er(Ke)),s!==n){for(i=[],r=Qr();r!==n;)i.push(r),r=Qr();if(i!==n)if((r=Fr())===n&&(r=gr()),r!==n){for(o=[],a=Qr();a!==n;)o.push(a),a=Qr();o!==n?(62===e.charCodeAt(Hi)?(a=z,Hi++):(a=n,0===Di&&er(D)),a!==n?(Bi=t,s=Ts(r),t=s):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n}else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o,a;if(t=Hi,91===e.charCodeAt(Hi)?(s=Pe,Hi++):(s=n,0===Di&&er(Le)),s!==n){for(i=[],r=Qr();r!==n;)i.push(r),r=Qr();if(i!==n)if((r=qr())!==n){for(o=[],a=Qr();a!==n;)o.push(a),a=Qr();o!==n?(93===e.charCodeAt(Hi)?(a=He,Hi++):(a=n,0===Di&&er(Be)),a!==n?(Bi=t,s=Cs(r),t=s):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n}else Hi=t,t=n;return t}())===n&&(t=Vr())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u;if(t=Hi,40===e.charCodeAt(Hi)?(s=Ls,Hi++):(s=n,0===Di&&er(Hs)),s!==n)if((i=Qr())===n&&(i=null),i!==n)if((r=Vr())!==n){if(o=[],a=Hi,(c=Qr())!==n?(e.substr(Hi,2)===Bs?(l=Bs,Hi+=2):(l=n,0===Di&&er(qs)),l!==n&&(h=Qr())!==n&&(u=Vr())!==n?a=c=[c,l,h,u]:(Hi=a,a=n)):(Hi=a,a=n),a!==n)for(;a!==n;)o.push(a),a=Hi,(c=Qr())!==n?(e.substr(Hi,2)===Bs?(l=Bs,Hi+=2):(l=n,0===Di&&er(qs)),l!==n&&(h=Qr())!==n&&(u=Vr())!==n?a=c=[c,l,h,u]:(Hi=a,a=n)):(Hi=a,a=n);else o=n;o!==n?((a=Qr())===n&&(a=null),a!==n?(41===e.charCodeAt(Hi)?(c=Vs,Hi++):(c=n,0===Di&&er(Ws)),c!==n?(Bi=t,s=zs(r,o),t=s):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}())===n&&(t=function(){let t,s,i,r,o,a,c,l,h,u;if(t=Hi,40===e.charCodeAt(Hi)?(s=Ls,Hi++):(s=n,0===Di&&er(Hs)),s!==n)if((i=Qr())===n&&(i=null),i!==n)if((r=Vr())!==n){for(o=[],a=Hi,(c=Qr())===n&&(c=null),c!==n?(44===e.charCodeAt(Hi)?(l=it,Hi++):(l=n,0===Di&&er(rt)),l!==n?((h=Qr())===n&&(h=null),h!==n&&(u=Vr())!==n?a=c=[c,l,h,u]:(Hi=a,a=n)):(Hi=a,a=n)):(Hi=a,a=n);a!==n;)o.push(a),a=Hi,(c=Qr())===n&&(c=null),c!==n?(44===e.charCodeAt(Hi)?(l=it,Hi++):(l=n,0===Di&&er(rt)),l!==n?((h=Qr())===n&&(h=null),h!==n&&(u=Vr())!==n?a=c=[c,l,h,u]:(Hi=a,a=n)):(Hi=a,a=n)):(Hi=a,a=n);o!==n?((a=Qr())===n&&(a=null),a!==n?(41===e.charCodeAt(Hi)?(c=Vs,Hi++):(c=n,0===Di&&er(Ws)),c!==n?(Bi=t,s=Ds(r,o),t=s):(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;else Hi=t,t=n;return t}()),t}function Vr(){let t,s;return t=Hi,e.substr(Hi,4)===$s?(s=$s,Hi+=4):(s=n,0===Di&&er(ks)),s===n&&(e.substr(Hi,3)===Rs?(s=Rs,Hi+=3):(s=n,0===Di&&er(Es)),s===n&&(e.substr(Hi,6)===Is?(s=Is,Hi+=6):(s=n,0===Di&&er(Ns)),s===n&&(e.substr(Hi,7)===Ms?(s=Ms,Hi+=7):(s=n,0===Di&&er(xs)),s===n&&(e.substr(Hi,5)===As?(s=As,Hi+=5):(s=n,0===Di&&er(js)),s===n&&(e.substr(Hi,6)===Os?(s=Os,Hi+=6):(s=n,0===Di&&er(Ps))))))),s!==n&&(Bi=t,s=Fs(s)),t=s}function Wr(){let t,s,i,r;if(Di++,t=Hi,Di++,s=Hi,i=[],32===e.charCodeAt(Hi)?(r=Qs,Hi++):(r=n,0===Di&&er(Xs)),r!==n)for(;r!==n;)i.push(r),32===e.charCodeAt(Hi)?(r=Qs,Hi++):(r=n,0===Di&&er(Xs));else i=n;return i!==n?(Bi=Hi,(r=(r=Ys(i))?void 0:n)!==n?s=i=[i,r]:(Hi=s,s=n)):(Hi=s,s=n),Di--,s!==n?(Hi=t,t=void 0):t=n,Di--,t===n&&(s=n,0===Di&&er(Gs)),t}function zr(){let t,s,i,r,o;for(Di++,t=Hi,s=Hi,Di++,i=Hi,r=[],32===e.charCodeAt(Hi)?(o=Qs,Hi++):(o=n,0===Di&&er(Xs));o!==n;)r.push(o),32===e.charCodeAt(Hi)?(o=Qs,Hi++):(o=n,0===Di&&er(Xs));if(r!==n?(Bi=Hi,(o=(o=ti(r))?void 0:n)!==n?i=r=[r,o]:(Hi=i,i=n)):(Hi=i,i=n),Di--,i!==n?(Hi=s,s=void 0):s=n,s!==n){for(i=[],32===e.charCodeAt(Hi)?(r=Qs,Hi++):(r=n,0===Di&&er(Xs));r!==n;)i.push(r),32===e.charCodeAt(Hi)?(r=Qs,Hi++):(r=n,0===Di&&er(Xs));i!==n?t=s=[s,i]:(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(ei)),t}function Dr(){let t,s,i,r,o;for(Di++,t=Hi,s=Hi,Di++,i=Hi,r=[],32===e.charCodeAt(Hi)?(o=Qs,Hi++):(o=n,0===Di&&er(Xs));o!==n;)r.push(o),32===e.charCodeAt(Hi)?(o=Qs,Hi++):(o=n,0===Di&&er(Xs));if(r!==n?(Bi=Hi,(o=(o=si(r))?void 0:n)!==n?i=r=[r,o]:(Hi=i,i=n)):(Hi=i,i=n),Di--,i!==n?(Hi=s,s=void 0):s=n,s!==n){for(i=[],32===e.charCodeAt(Hi)?(r=Qs,Hi++):(r=n,0===Di&&er(Xs));r!==n;)i.push(r),32===e.charCodeAt(Hi)?(r=Qs,Hi++):(r=n,0===Di&&er(Xs));i!==n?(Bi=t,t=s=v()):(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(ni)),t}function Kr(){let t,s,i,r;if(Di++,t=Hi,96===e.charCodeAt(Hi)?(s=li,Hi++):(s=n,0===Di&&er(hi)),s!==n){if(i=[],ui.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(di)),r!==n)for(;r!==n;)i.push(r),ui.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(di));else i=n;i!==n?(96===e.charCodeAt(Hi)?(r=li,Hi++):(r=n,0===Di&&er(hi)),r!==n?(Bi=t,t=s=pi(i)):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(ci)),t}function Ur(){let t,s,i,r;if(Di++,t=Hi,39===e.charCodeAt(Hi)?(s=mi,Hi++):(s=n,0===Di&&er(gi)),s!==n){if(i=[],yi.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(_i)),r!==n)for(;r!==n;)i.push(r),yi.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(_i));else i=n;i!==n?(39===e.charCodeAt(Hi)?(r=mi,Hi++):(r=n,0===Di&&er(gi)),r!==n?(Bi=t,t=s=vi(i)):(Hi=t,t=n)):(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(fi)),t}function Jr(){let t,s,i,r;if(Di++,t=Hi,bi.test(e.charAt(Hi))?(s=e.charAt(Hi),Hi++):(s=n,0===Di&&er(wi)),s!==n){for(i=[],Ci.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(Ti));r!==n;)i.push(r),Ci.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(Ti));i!==n?(Bi=t,t=s=v()):(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(Si)),t}function Zr(){let t,s,i,r,o;if(Di++,t=Hi,s=Hi,Di++,i=function(){let t,s,i,r;return t=Hi,(s=kr())===n&&(s=hr())===n&&(s=Ir())===n&&(e.substr(Hi,8)===ge?(s=ge,Hi+=8):(s=n,0===Di&&er(ye)),s===n&&(e.substr(Hi,6)===Zt?(s=Zt,Hi+=6):(s=n,0===Di&&er(Gt)),s===n&&(e.substr(Hi,6)===P?(s=P,Hi+=6):(s=n,0===Di&&er(F)),s===n&&(e.substr(Hi,9)===B?(s=B,Hi+=9):(s=n,0===Di&&er(q)),s===n&&(e.substr(Hi,6)===ds?(s=ds,Hi+=6):(s=n,0===Di&&er(ps)),s===n&&(e.substr(Hi,7)===Fn?(s=Fn,Hi+=7):(s=n,0===Di&&er(Ln)),s===n&&(e.substr(Hi,6)===zt?(s=zt,Hi+=6):(s=n,0===Di&&er(Dt))))))))),s!==n?(ii.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(ri)),i===n&&(i=Hi,Di++,e.length>Hi?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(oi)),Di--,r===n?i=void 0:(Hi=i,i=n)),i!==n?(Bi=t,t=s=ai(s)):(Hi=t,t=n)):(Hi=t,t=n),t}(),Di--,i===n?s=void 0:(Hi=s,s=n),s!==n)if(ki.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(Ri)),i!==n){for(r=[],Ci.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(Ti));o!==n;)r.push(o),Ci.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(Ti));r!==n?(Bi=t,t=s=v()):(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er($i)),t}function Gr(){let t,s,i,r;if(Di++,t=Hi,ki.test(e.charAt(Hi))?(s=e.charAt(Hi),Hi++):(s=n,0===Di&&er(Ri)),s!==n){for(i=[],Ci.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(Ti));r!==n;)i.push(r),Ci.test(e.charAt(Hi))?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(Ti));i!==n?(Bi=t,t=s=v()):(Hi=t,t=n)}else Hi=t,t=n;return Di--,t===n&&(s=n,0===Di&&er(Ei)),t}function Qr(){let t,s;if(Di++,t=[],32===e.charCodeAt(Hi)?(s=Qs,Hi++):(s=n,0===Di&&er(Xs)),s!==n)for(;s!==n;)t.push(s),32===e.charCodeAt(Hi)?(s=Qs,Hi++):(s=n,0===Di&&er(Xs));else t=n;return Di--,t===n&&(s=n,0===Di&&er(Ii)),t}function Xr(){let t,s,i,r,o;for(Di++,t=Hi,s=[],Mi.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(xi));i!==n;)s.push(i),Mi.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(xi));if(s!==n?(i=Hi,Di++,e.length>Hi?(r=e.charAt(Hi),Hi++):(r=n,0===Di&&er(oi)),Di--,r===n?i=void 0:(Hi=i,i=n),i!==n?t=s=[s,i]:(Hi=t,t=n)):(Hi=t,t=n),t===n){for(t=Hi,s=[],Mi.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(xi));i!==n;)s.push(i),Mi.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(xi));if(s!==n)if(e.substr(Hi,2)===Ai?(i=Ai,Hi+=2):(i=n,0===Di&&er(ji)),i!==n){for(r=[],y.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(_));o!==n;)r.push(o),y.test(e.charAt(Hi))?(o=e.charAt(Hi),Hi++):(o=n,0===Di&&er(_));r!==n&&(o=Xr())!==n?t=s=[s,i,r,o]:(Hi=t,t=n)}else Hi=t,t=n;else Hi=t,t=n;if(t===n){for(t=Hi,s=[],Mi.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(xi));i!==n;)s.push(i),Mi.test(e.charAt(Hi))?(i=e.charAt(Hi),Hi++):(i=n,0===Di&&er(xi));s!==n&&(i=Yr())!==n?((r=Xr())===n&&(r=null),r!==n?t=s=[s,i,r]:(Hi=t,t=n)):(Hi=t,t=n)}}return Di--,t===n&&(s=n,0===Di&&er(Ni)),t}function Yr(){let t,s,i,r;return Di++,t=Hi,13===e.charCodeAt(Hi)?(s=Oi,Hi++):(s=n,0===Di&&er(Pi)),s===n&&(s=null),s!==n?(10===e.charCodeAt(Hi)?(i=Fi,Hi++):(i=n,0===Di&&er(Li)),i!==n?(13===e.charCodeAt(Hi)?(r=Oi,Hi++):(r=n,0===Di&&er(Pi)),r===n&&(r=null),r!==n?t=s=[s,i,r]:(Hi=t,t=n)):(Hi=t,t=n)):(Hi=t,t=n),Di--,t===n&&(s=n,0===Di&&er(Ni)),t}let eo="",to="";const no=[];function so(e){return e[1].map(e=>e[1])}function io(e,t,n){if(null!==e){const n=t(e);if(null!==n)return n}return null===n?null:n}if((Vi=i())!==n&&Hi===e.length)return Vi;throw Vi!==n&&Hi<e.length&&er({type:"end"}),tr(zi,Wi<e.length?e.charAt(Wi):null,Wi<e.length?Yi(Wi,Wi+1):Yi(Wi,Wi))};var He,Be=n(7),qe=n.n(Be);async function Ve(e){const t=qe.a.createHash("sha1");return t.update(e),Promise.resolve().then(()=>t.digest("hex"))}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class We{constructor(){this.storageKey=null,this.name=null}apply(e){e.forEach(e=>{this[e.key]=e.value})}}function ze(e,t){return e===t?0:null===e?-1:1}function De(e,t){return null==e||null==t?ze(e,t):e.localeCompare(t)}function Ke(e,t){return null==e||null==t?ze(e,t):e-t}function Ue(e,t,n){if(d()(null!=e),d()(null!=t),e.length!==t.length)return Ke(e.length,t.length);for(let s=0;s<e.length;s++){let i;if(0!==(i=n(e[s],t[s])))return i}return 0}function Je(e,t){return null==e||null==t?ze(e,t):e._compareTo(t)}class Ze{}class Ge extends Ze{constructor(e,t){super(),this.particle=e,this.connection=t}_clone(e){return new Ge(this.particle,this.connection)}_compareTo(e){let t;return 0!==(t=De(this.particle.name,e.particle.name))?t:0!==(t=De(this.connection,e.connection))?t:0}toString(e){return this.connection?`${this.particle.name}.${this.connection}`:`${this.particle.name}`}}class Qe extends Ze{constructor(e,t){super(),d()(e),this.instance=e,this.connection=t}_clone(e){return new Qe(e.get(this.instance),this.connection)}_compareTo(e){let t;return 0!==(t=Je(this.instance,e.instance))?t:0!==(t=De(this.connection,e.connection))?t:0}toString(e){return this.connection?`${e.get(this.instance)}.${this.connection}`:`${e.get(this.instance)}`}}class Xe extends Ze{constructor(e){super(),this.handle=e}_clone(e){return new Xe(this.handle)}_compareTo(e){let t;return 0!==(t=De(this.handle.localName,e.handle.localName))?t:0}toString(e){return`${this.handle.localName}`}}class Ye extends Ze{constructor(e){super(),this.tags=e}_clone(e){return new Ye(this.tags)}_compareTo(e){let t;return 0!==(t=Ue(this.tags,e.tags,De))?t:0}toString(e){return this.tags.map(e=>`#${e}`).join(" ")}}class et{constructor(e,t,n,s){d()(n),d()(s),this.from=e,this.to=t,this.direction=n,this.type=s,Object.freeze(this)}_copyInto(e,t){if("constraint"===this.type){if(!(this.from instanceof Qe||this.to instanceof Qe))return e.newConnectionConstraint(this.from._clone(),this.to._clone(),this.direction);d()(!1)}return e.newObligation(this.from._clone(t),this.to._clone(t),this.direction)}_compareTo(e){let t;return 0!==(t=this.from._compareTo(e.from))?t:0!==(t=this.to._compareTo(e.to))?t:0!==(t=De(this.direction,e.direction))?t:0}toString(e,t){let n="";return t&&!0===t.showUnresolved&&"obligation"===this.type&&(n=" // unresolved obligation"),`${this.from.toString(e)} ${this.direction} ${this.to.toString(e)}${n}`}}class tt{constructor(e){this._id=null,this._localName=void 0,this._tags=[],this._type=void 0,this._fate=null,this._originalFate=null,this._originalId=null,this._connections=[],this._mappedType=void 0,this._storageKey=void 0,this._pattern=void 0,this._immediateValue=void 0,d()(e),this._recipe=e}_copyInto(e,t,n){let s=void 0;return null!==this._id&&["map","use","copy"].includes(this.fate)&&(s=e.findHandle(this._id)),null==s&&((s=e.newHandle())._id=this._id,s._tags=[...this._tags],s._type=this._type?this._type._cloneWithResolutions(n):void 0,s._fate=this._fate,s._originalFate=this._originalFate,s._originalId=this._originalId,s._mappedType=this._mappedType,s._storageKey=this._storageKey,s._immediateValue=this._immediateValue,s._connections=[],s._pattern=this._pattern),s}mergeInto(e){for(d()(this.recipe===e.recipe,"Cannot merge handles from different recipes.");this.connections.length>0;){const[t]=this.connections;t.disconnectHandle(),t.connectToHandle(e)}e._immediateValue=this._immediateValue,e.tags=e.tags.concat(this.tags),e.recipe.removeHandle(this),e.fate=this._mergedFate([this.fate,e.fate])}_mergedFate(e){return d()(e.length>0,"Cannot merge empty fates list"),d()(!e.includes("map")&&!e.includes("copy"),"Merging map/copy not supported yet"),e.every(e=>"use"===e)?"use":"create"}_startNormalize(){this._localName=null,this._tags.sort()}_finishNormalize(){for(const e of this._connections)d()(Object.isFrozen(e),`Handle connection '${e.name}' is not frozen.`);this._connections.sort(Je),Object.freeze(this)}_compareTo(e){let t;return 0!==(t=De(this._id,e._id))?t:0!==(t=De(this._localName,e._localName))?t:0!==(t=Ue(this._tags,e._tags,De))?t:0!==(t=De(this.fate,e.fate))?t:0!==(t=De(this._immediateValue&&this._immediateValue.toString()||"",e._immediateValue&&e._immediateValue.toString()||""))?t:0}get fate(){return this._fate||"?"}set fate(e){null==this._originalFate&&(this._originalFate=this._fate),this._fate=e}get originalFate(){return this._originalFate||"?"}get originalId(){return this._originalId}get recipe(){return this._recipe}get tags(){return this._tags}set tags(e){this._tags=e}get type(){return this._type}get id(){return this._id}set id(e){this._originalId||(this._originalId=this._id),this._id=e}mapToStorage(e){if(!e)throw new Error("Cannot map to undefined storage");this._id=e.id,this._originalId=e.originalId,this._type=void 0,this._mappedType=e.type,this._storageKey=e.storageKey}get localName(){return this._localName}set localName(e){this._localName=e}get connections(){return this._connections}get storageKey(){return this._storageKey}set storageKey(e){this._storageKey=e}get pattern(){return this._pattern}set pattern(e){this._pattern=e}get mappedType(){return this._mappedType}set mappedType(e){this._mappedType=e}get immediateValue(){return this._immediateValue}set immediateValue(e){this._immediateValue=e}static effectiveType(e,t){const n=new Map,s=t.filter(e=>null!=e.type).map(e=>({type:e.type._cloneWithResolutions(n),direction:e.direction}));return ue.processTypeList(e?e._cloneWithResolutions(n):null,s)}static resolveEffectiveType(e,t){const n=t.filter(e=>null!=e.type).map(e=>({type:e.type,direction:e.direction}));return ue.processTypeList(e,n)}_isValid(e){const t=new Set;for(const n of this._connections){if("map"===this.fate&&["out","inout"].includes(n.direction))return e&&e.errors&&e.errors.set(this,`Invalid fate '${this.fate}' for handle '${this}'; it is used for '${n.direction}' ${n.getQualifiedName()} connection`),!1;n.tags.forEach(e=>t.add(e))}const n=tt.resolveEffectiveType(this._mappedType,this._connections);return n?(this._type=n,this._tags.forEach(e=>t.add(e)),this._tags=[...t],!0):(e&&e.errors&&e.errors.set(this,`Type validations failed for handle '${this}'`),!1)}isResolved(e){d()(Object.isFrozen(this));let t=!0;if(this.type){let n=!0;"create"!==this.fate&&"`slot"!==this.fate||(n=!1),(n&&!this.type.isResolved()||!this.type.canEnsureResolved())&&(e&&e.details.push("unresolved type"),t=!1)}else e&&e.details.push("missing type"),t=!1;switch(this.fate){case"?":e&&e.details.push("missing fate"),t=!1;break;case"copy":case"map":case"use":e&&null===this.id&&e.details.push("missing id"),t=t&&null!==this.id;break;case"`slot":case"create":break;default:throw e&&e.details.push(`invalid fate ${this.fate}`),new Error(`Unexpected fate: ${this.fate}`)}return t}toString(e,t){if(this._immediateValue)return;t=t||{};const n=[];if(n.push(this.fate),this.id&&n.push(`'${this.id}'`),n.push(...this.tags.map(e=>`#${e}`)),n.push(`as ${e&&e.get(this)||this.localName}`),this.type)if(n.push("//"),this.type.isResolved())n.push(this.type.resolvedType().toString({hideFields:null==t.hideFields||t.hideFields}));else if(n.push(this.type.toString()),t.showUnresolved&&this.type.canEnsureResolved()){const e=ee.fromLiteral(this.type.toLiteral());e.maybeEnsureResolved(),n.push("//"),n.push(e.resolvedType().toString({hideFields:null==t.hideFields||t.hideFields}))}if(t.showUnresolved){const e={details:[]};this.isResolved(e)||n.push(` // unresolved handle: ${e.details.join(", ")}`)}return n.join(" ")}findConnectionByDirection(e){return this._connections.find(t=>t.direction===e)}}class nt{constructor(e,t){this._tags=[],this.resolvedType=void 0,this._direction=void 0,this._handle=void 0,d()(t),d()(t.recipe),this._recipe=t.recipe,this._name=e,this._particle=t}_clone(e,t){if(t.has(this))return t.get(this);const n=new nt(this._name,e);return n._tags=[...this._tags],n.resolvedType=this.resolvedType,n._direction=this._direction,null!=this._handle&&(n._handle=t.get(this._handle),d()(void 0!==n._handle),n._handle.connections.push(n)),t.set(this,n),n}cloneTypeWithResolutions(e){this.resolvedType&&(this.resolvedType=this.resolvedType._cloneWithResolutions(e))}_normalize(){this._tags.sort(),Object.freeze(this)}_compareTo(e){let t;return 0!==(t=Je(this._particle,e._particle))?t:0!==(t=De(this._name,e._name))?t:0!==(t=Ue(this._tags,e._tags,De))?t:0!==(t=Je(this._handle,e._handle))?t:0!==(t=De(this._direction,e._direction))?t:0}get recipe(){return this._recipe}get name(){return this._name}getQualifiedName(){return`${this.particle.name}::${this.name}`}get tags(){return this._tags}get type(){if(this.resolvedType)return this.resolvedType;const e=this.spec;return e?e.type:null}get direction(){if(this._direction)return this._direction;const e=this.spec;return e?e.direction:null}get isInput(){return"in"===this.direction||"inout"===this.direction}get isOutput(){return"out"===this.direction||"inout"===this.direction}get handle(){return this._handle}get particle(){return this._particle}set tags(e){this._tags=e}set type(e){this.resolvedType=e,this._resetHandleType()}set direction(e){this._direction=e,this._resetHandleType()}get spec(){return null==this.particle.spec?null:this.particle.spec.handleConnectionMap.get(this.name)}get isOptional(){return null!=this.spec&&this.spec.isOptional}_isValid(e){if(this.direction&&!["in","out","inout","host","`consume","`provide"].includes(this.direction))return e&&e.errors&&e.errors.set(this,`Invalid direction '${this.direction}' for handle connection '${this.getQualifiedName()}'`),!1;if(this.particle.spec&&this.name){const t=this.spec;if(!t)return e&&e.errors&&e.errors.set(this,`Connection ${this.name} is not defined by ${this.particle.name}.`),!1;if(this.direction!==t.direction&&(!["in","out"].includes(this.direction)||"inout"!==t.direction))return e&&e.errors&&e.errors.set(this,`Direction '${this.direction}' for handle connection '${this.getQualifiedName()}' doesn't match particle spec's direction '${t.direction}'`),!1;if(this.resolvedType){if(!t.isCompatibleType(this.resolvedType))return e&&e.errors&&e.errors.set(this,`Type '${this.resolvedType.toString()} for handle connection '${this.getQualifiedName()}' doesn't match particle spec's type '${t.type.toString()}'`),!1}else this.resolvedType=t.type}return!0}isResolved(e){let t;return d()(Object.isFrozen(this)),!this.spec||!this.spec.parentConnection||(t=this.particle.connections[this.spec.parentConnection.name])&&t.handle?this.handle?this.direction?!!this.type||(e&&(e.details="missing type"),!1):(e&&(e.details="missing direction"),!1):!!this.isOptional||(e&&(e.details="missing handle"),!1):(e&&(e.details="parent connection missing handle"),!1)}_resetHandleType(){this._handle&&(this._handle._type=void 0)}connectToHandle(e){d()(e.recipe===this.recipe),this._handle=e,this._resetHandleType(),this._handle.connections.push(this)}disconnectHandle(){const e=this._handle.connections.indexOf(this);d()(e>=0),this._handle.connections.splice(e,1),this._handle=void 0}toString(e,t){const n=[];return n.push(this.name||"*"),n.push({in:"<-",out:"->",inout:"=",host:"=","`consume":"<-","`provide":"->"}[this.direction]||this.direction||"="),this.handle&&(this.handle.immediateValue?n.push(this.handle.immediateValue.name):n.push(`${e&&e.get(this.handle)||this.handle.localName}`)),n.push(...this.tags.map(e=>`#${e}`)),t&&t.showUnresolved&&(this.isResolved(t)||n.push(`// unresolved handle-connection: ${t.details}`)),n.join(" ")}findSpecsForUnnamedHandles(){return this.particle.spec.handleConnections.filter(e=>!e.isOptional&&this.handle.type.equals(e.type)&&!this.particle.getConnectionByName(e.name))}}class st{constructor(e,t){this._targetSlot=void 0,this._providedSlots={},this._tags=[],d()(t),d()(t.recipe),d()(e),this._recipe=t.recipe,this._particle=t,this._name=e}remove(){this._particle.removeSlotConnection(this)}get recipe(){return this._recipe}get particle(){return this._particle}get name(){return this._name}getQualifiedName(){return`${this.particle.name}::${this.name}`}get targetSlot(){return this._targetSlot}set targetSlot(e){this._targetSlot=e}get providedSlots(){return this._providedSlots}get tags(){return this._tags}set tags(e){this._tags=e}getSlotSpec(){return this.particle.spec&&this.particle.spec.getSlotSpec(this.name)}connectToSlot(e){d()(e),d()(!this.targetSlot),d()(this.recipe instanceof ct||this.recipe===e.recipe,"Cannot connect to slot from different recipe"),this._targetSlot=e,e.consumeConnections.push(this)}disconnectFromSlot(){this._targetSlot&&(this._targetSlot.removeConsumeConnection(this),this._targetSlot=void 0)}_clone(e,t){if(t.has(this))return t.get(this);const n=e.addSlotConnectionAsCopy(this.name);return n.tags=this.tags,t.set(this,n),n}_normalize(){const e={};for(const t of Object.keys(this._providedSlots).sort())e[t]=this._providedSlots[t];this._providedSlots=e,Object.freeze(this)}_compareTo(e){let t;return 0!==(t=De(this.name,e.name))?t:0!==(t=Je(this._targetSlot,e._targetSlot))?t:0!==(t=Je(this._particle,e._particle))?t:0}_isValid(e){return!this._targetSlot||!this._targetSlot.sourceConnection||this._targetSlot===this._targetSlot.sourceConnection.providedSlots[this._targetSlot.name]||(e&&e.errors&&e.errors.set(this,`Invalid target slot '${this._targetSlot.name}' for slot connection '${this.name}' of particle ${this.particle.name}`),!1)}isResolved(e){return d()(Object.isFrozen(this)),this.name?this.particle?null!=this.getSlotSpec()&&!this.getSlotSpec().isRequired||this.targetSlot&&(this.targetSlot.id||this.targetSlot.sourceConnection.isConnected())?!this.targetSlot||(null==this.getSlotSpec()||this.getSlotSpec().provideSlotConnections.every(t=>!t.isRequired||0!==this.providedSlots[t.name].consumeConnections.length||(e&&(e.details="missing consuming slot"),!1))):(e&&(e.details="missing target-slot"),!1):(e&&(e.details="missing particle"),!1):(e&&(e.details="missing name"),!1)}isConnectedToInternalSlot(){return this.targetSlot&&!!this.targetSlot.sourceConnection}isConnectedToRemoteSlot(){return this.targetSlot&&!!this.targetSlot.id}isConnected(){return this.isConnectedToInternalSlot()||this.isConnectedToRemoteSlot()}toString(e,t){const n=[];n.push("consume"),n.push(`${this.name}`),this.targetSlot&&n.push(`as ${e&&e.get(this.targetSlot)||this.targetSlot.localName}`),t&&t.showUnresolved&&(this.isResolved(t)||n.push(`// unresolved slot-connection: ${t.details}`));const s=[];return s.push(n.join(" ")),Object.keys(this.providedSlots).forEach(t=>{const n=this.providedSlots[t],i=[];if(i.push("  provide"),this.getSlotSpec()){const e=this.particle.getSlotSpecByName(t);d()(e,`Cannot find providedSlotSpec for ${t}`)}i.push(`${t} as ${e&&e.get(n)||n}`),s.push(i.join(" "))}),s.join("\n")}}class it{constructor(e,t){this._id=void 0,this._localName=void 0,this.spec=void 0,this._verbs=[],this._connections={},this._unnamedConnections=[],this._consumedSlotConnections={},d()(e),this._recipe=e,this._name=t}_copyInto(e,t,n){const s=e.newParticle(this._name);s._id=this._id,s._verbs=[...this._verbs],s.spec=this.spec?this.spec.cloneWithResolutions(n):void 0,Object.keys(this._connections).forEach(e=>{s._connections[e]=this._connections[e]._clone(s,t)}),s._unnamedConnections=this._unnamedConnections.map(e=>e._clone(s,t)),s._cloneConnectionRawTypes(n);for(const[n,i]of Object.entries(this.consumedSlotConnections)){s.consumedSlotConnections[n]=i._clone(s,t),t.has(i.targetSlot)&&(d()(e instanceof ct),s.consumedSlotConnections[n].connectToSlot(t.get(i.targetSlot)),-1===s.recipe.slots.indexOf(t.get(i.targetSlot))&&s.recipe.slots.push(t.get(i.targetSlot)));for(const[r,o]of Object.entries(i.providedSlots))if(t.has(o)){d()(e instanceof ct);const i=t.get(o);i.sourceConnection=s.consumedSlotConnections[n],s.consumedSlotConnections[n].providedSlots[r]=i,-1===s.recipe.slots.indexOf(i)&&s.recipe.slots.push(i)}}return s}_cloneConnectionRawTypes(e){for(const t of Object.values(this._connections))t.cloneTypeWithResolutions(e);for(const t of this._unnamedConnections)t.cloneTypeWithResolutions(e)}_startNormalize(){this._localName=null,this._verbs.sort();const e={};for(const t of Object.keys(this._connections).sort())e[t]=this._connections[t];this._connections=e;const t={};for(const e of Object.keys(this._consumedSlotConnections).sort())t[e]=this._consumedSlotConnections[e];this._consumedSlotConnections=t}_finishNormalize(){this._unnamedConnections.sort(Je),Object.freeze(this)}_compareTo(e){let t;return 0!==(t=De(this._id?this._id.toString():"",e._id?e._id.toString():""))?t:0!==(t=De(this._name,e._name))?t:0!==(t=De(this._localName,e._localName))?t:0!==(t=Ue(this._verbs,e._verbs,De))?t:0}matches(e){if(this.name&&e.name&&this.name!==e.name)return!1;for(const[t,n]of Object.entries(this.consumedSlotConnections)){if(null==e.consumedSlotConnections[t]||null==e.consumedSlotConnections[t].targetSlot)return!1;if(n.targetSlot&&n.targetSlot.id&&n.targetSlot.id!==e.consumedSlotConnections[t].targetSlot.id)return!1;for(const s of Object.keys(n.providedSlots)){const i=n.providedSlots[s],r=e.consumedSlotConnections[t].providedSlots[s];if(null==r||i.id&&r.id&&i.id!==r.id)return!1}}return!0}_isValid(e){return!this.spec||(!(!this.name&&!this.primaryVerb)||(e&&e.errors&&e.errors.set(this,"Particle has no name and no verb"),!1))}isResolved(e){if(d()(Object.isFrozen(this)),!this.spec)return e&&e.showUnresolved&&(e.details="missing spec"),!1;if(this.spec.slotConnections.size>0){if(0===Object.values(this.consumedSlotConnections).filter(e=>void 0!==e.targetSlot).length)return e&&e.showUnresolved&&(e.details="unfullfilled slot connections"),!1}if(!this.spec)return e&&e.showUnresolved&&(e.details="missing spec"),!1;const t=this.getUnboundConnections().filter(e=>{let t=e.parentConnection;for(;null!==t;){if(!this.connections[t.name])return!1;t=t.parentConnection}return!0});return t.length>0?(e&&e.showUnresolved&&(e.details=`unresolved connections: ${t.map(e=>e.name).join(", ")}`),!1):0===this.unnamedConnections.length||(e&&e.showUnresolved&&(e.details=`${this.unnamedConnections.length} unnamed connections`),!1)}get recipe(){return this._recipe}get localName(){return this._localName}set localName(e){this._localName=e}get id(){return this._id}set id(e){d()(!this._id,"Particle ID can only be set once."),this._id=e}get name(){return this._name}set name(e){this._name=e}get connections(){return this._connections}get unnamedConnections(){return this._unnamedConnections}get consumedSlotConnections(){return this._consumedSlotConnections}get primaryVerb(){return this._verbs.length>0?this._verbs[0]:void 0}set verbs(e){this._verbs=e}addUnnamedConnection(){const e=new nt(void 0,this);return this._unnamedConnections.push(e),e}addConnectionName(e){return d()(e,"Cannot create connection with no name"),d()(null==this._connections[e]),this._connections[e]=new nt(e,this),this._connections[e]}allConnections(){return Object.values(this._connections).concat(this._unnamedConnections)}ensureConnectionName(e){return this._connections[e]||this.addConnectionName(e)}getConnectionByName(e){return this._connections[e]}nameConnection(e,t){d()(!this._connections[t],`Connection "${t}" already has a handle`);const n=this._unnamedConnections.indexOf(e);d()(n>=0,`Cannot name '${t}' nonexistent unnamed connection.`),e._name=t;const s=this.spec.getConnectionByName(t);e.type=s.type,e.direction!==s.direction&&(d()("inout"===e.direction,`Unnamed connection cannot adjust direction ${e.direction} to ${t}'s direction ${s.direction}`),e.direction=s.direction),this._connections[t]=e,this._unnamedConnections.splice(n,1)}getUnboundConnections(e){return this.spec.handleConnections.filter(t=>!t.isOptional&&!this.getConnectionByName(t.name)&&(!e||e.equals(t.type)))}addSlotConnection(e){d()(!(e in this._consumedSlotConnections),"slot connection already exists"),d()(!this.spec||this.spec.slotConnections.has(e),"slot connection not in particle spec");const t=new st(e,this);this._consumedSlotConnections[e]=t;const n=this.getSlotSpecByName(e);return n&&n.provideSlotConnections.forEach(e=>{const n=this.recipe.newSlot(e.name);n.sourceConnection=t,t.providedSlots[e.name]=n}),t}addSlotConnectionAsCopy(e){const t=new st(e,this);return this._consumedSlotConnections[e]=t,t}removeSlotConnection(e){this._consumedSlotConnections[e.name]=null,e.disconnectFromSlot()}remove(){this.recipe.removeParticle(this)}getSlotConnectionBySpec(e){return Object.values(this._consumedSlotConnections).find(t=>t.getSlotSpec()===e)}getSlotSpecByName(e){if(!this.spec)return;const t=this.spec.slotConnections.get(e);if(t)return t;for(const t of this.spec.slotConnections.values())for(const n of t.provideSlotConnections)if(n.name===e)return n}getSlotConnectionByName(e){return this._consumedSlotConnections[e]}getProvidedSlotByName(e,t){return this.consumedSlotConnections[e]&&this.consumedSlotConnections[e].providedSlots[t]}getSlotSpecs(){return this.spec?this.spec.slotConnections:new Map}toString(e,t){let n=[];this.name?(n.push(this.name),n.push(`as ${e&&e.get(this)||this.localName}`),this.primaryVerb&&this.primaryVerb!==this.name&&n.push(`// verb=${this.primaryVerb}`)):n.push(`&${this.primaryVerb}`),t&&t.showUnresolved&&(this.isResolved(t)||n.push(`// unresolved particle: ${t.details}`)),n=[n.join(" ")];for(const s of this.unnamedConnections)n.push(s.toString(e,t).replace(/^|(\n)/g,"$1  "));for(const s of Object.values(this.connections))n.push(s.toString(e,t).replace(/^|(\n)/g,"$1  "));for(const s of Object.values(this._consumedSlotConnections))n.push(s.toString(e,t).replace(/^|(\n)/g,"$1  "));return n.join("\n")}}class rt{constructor(e,t){d()(e),this._phrase=e;const n=this.phrase.toLowerCase().split(/[^a-z0-9]/g);this._unresolvedTokens=[],(t||n).forEach(e=>this._unresolvedTokens.push(e)),this._resolvedTokens=n.slice();for(const e of this.unresolvedTokens){const t=this._resolvedTokens.indexOf(e);t>=0&&this._resolvedTokens.splice(t,1)}d()(n.length===this.unresolvedTokens.length+this.resolvedTokens.length)}_append(e,t,n){this._phrase.length>0&&(this._phrase=this.phrase.concat(" ")),this._phrase=this._phrase.concat(e),n.forEach(e=>this._resolvedTokens.push(e)),t.forEach(e=>this._unresolvedTokens.push(e))}get phrase(){return this._phrase}get unresolvedTokens(){return this._unresolvedTokens}get resolvedTokens(){return this._resolvedTokens}resolveToken(e){const t=this.unresolvedTokens.indexOf(e.toLowerCase());d()(t>=0,`Cannot resolved nonexistent token ${e}`),this._unresolvedTokens.splice(t,1),this._resolvedTokens.push(e.toLowerCase())}isValid(){return this._unresolvedTokens.length>0||this._resolvedTokens.length>0}isResolved(){return d()(Object.isFrozen(this)),this._resolvedTokens.length>0}_normalize(){this._unresolvedTokens.sort(),this._resolvedTokens.sort(),Object.freeze(this)}_copyInto(e){return e.search?e.search._append(this.phrase,this.unresolvedTokens,this.resolvedTokens):(e.search=new rt(this.phrase,this.unresolvedTokens),d()(e.search.resolvedTokens.length===this.resolvedTokens.length,`${e.search.resolvedTokens} is not same as ${this.resolvedTokens}`)),d()(this.resolvedTokens.every(t=>e.search.resolvedTokens.indexOf(t)>=0)&&this.unresolvedTokens.every(t=>e.search.unresolvedTokens.indexOf(t)>=0)),e.search}toString(e){const t=[];t.push(`search \`${this.phrase}\``);const n=[];return n.push("  tokens"),this.unresolvedTokens.length>0&&n.push(this.unresolvedTokens.map(e=>`\`${e}\``).join(" ")),this.resolvedTokens.length>0&&n.push(`// ${this.resolvedTokens.map(e=>`\`${e}\``).join(" ")}`),e&&e.showUnresolved&&this.unresolvedTokens.length>0&&n.push("// unresolved search tokens"),t.push(n.join(" ")),t.join("\n")}}class ot{constructor(e,t){this._id=void 0,this._localName=void 0,this._tags=[],this._sourceConnection=void 0,this._formFactor=void 0,this._consumeConnections=[],d()(e),this._recipe=e,this._name=t}get recipe(){return this._recipe}get id(){return this._id}set id(e){this._id=e}get localName(){return this._localName}set localName(e){this._localName=e}get name(){return this._name}set name(e){this._name=e}get tags(){return this._tags}set tags(e){this._tags=e}get formFactor(){return this._formFactor}set formFactor(e){this._formFactor=e}get sourceConnection(){return this._sourceConnection}set sourceConnection(e){this._sourceConnection=e}get consumeConnections(){return this._consumeConnections}get spec(){return this.sourceConnection&&this.sourceConnection.getSlotSpec()?this.sourceConnection.particle.getSlotSpecByName(this.name):{isSet:!1,tags:[]}}get handles(){const e=[];if(this.sourceConnection&&this.sourceConnection.getSlotSpec())for(const t of this.sourceConnection.particle.getSlotSpecByName(this.name).handles){const n=this.sourceConnection.particle.connections[t];(n||n.handle)&&e.push(n.handle)}return e}_copyInto(e,t){let n=void 0;return t.has(this)?t.get(this):(!this.sourceConnection&&this.id&&(n=e.findSlot(this.id)),null==n&&((n=e.newSlot(this.name))._id=this.id,n._formFactor=this.formFactor,n._localName=this._localName,n._tags=[...this._tags],n._sourceConnection=t.get(this._sourceConnection),n.sourceConnection&&(n.sourceConnection._providedSlots[n.name]=n)),this._consumeConnections.forEach(e=>{t.get(e)&&null==t.get(e).targetSlot&&t.get(e).connectToSlot(n)}),n)}_startNormalize(){this.localName=null,this._tags.sort()}_finishNormalize(){this._consumeConnections.forEach(e=>d()(Object.isFrozen(e))),this._consumeConnections.sort(Je),Object.freeze(this)}_compareTo(e){let t;return 0!==(t=De(this.id,e.id))?t:0!==(t=De(this.localName,e.localName))?t:0!==(t=De(this.formFactor,e.formFactor))?t:0!==(t=Ue(this._tags,e._tags,De))?t:0}findHandleByID(e){return this.handles.find(t=>t.id===e)}removeConsumeConnection(e){const t=this._consumeConnections.indexOf(e);d()(t>-1),this._consumeConnections.splice(t,1),0===this._consumeConnections.length&&this.remove()}remove(){this._recipe.removeSlot(this)}isResolved(e){return d()(Object.isFrozen(this)),e&&e.showUnresolved&&(e.details=[],this._sourceConnection||e.details.push("missing source-connection"),this.id||e.details.push("missing id"),e.details=e.details.join("; ")),Boolean(this._sourceConnection||this.id)}_isValid(e){return!0}toString(e,t){const n=[];n.push("slot"),this.id&&n.push(`'${this.id}'`),this.tags.length>0&&n.push(this.tags.map(e=>`#${e}`).join(" ")),n.push(`as ${e&&e.get(this)||this.localName}`);const s=t&&t.showUnresolved&&!this.isResolved(t);return s&&n.push(`// unresolved slot: ${t.details}`),this.id||s?n.join(" "):""}}class at{constructor(e){this._requires=[],this._particles=[],this._handles=[],this._slots=[],this._localName=void 0,this.annotation=void 0,this._connectionConstraints=[],this._obligations=[],this._verbs=[],this._search=null,this._patterns=[],this._name=e}newConnectionConstraint(e,t,n){const s=new et(e,t,n,"constraint");return this._connectionConstraints.push(s),s}newObligation(e,t,n){const s=new et(e,t,n,"obligation");return this._obligations.push(s),s}removeObligation(e){const t=this._obligations.indexOf(e);d()(t>-1),this._obligations.splice(t,1)}removeConstraint(e){const t=this._connectionConstraints.indexOf(e);d()(t>=0),this._connectionConstraints.splice(t,1)}clearConnectionConstraints(){this._connectionConstraints.length=0}newRequireSection(){const e=new ct(this);return this._requires.push(e),e}newParticle(e){const t=new it(this,e);return this._particles.push(t),t}removeParticle(e){const t=this._particles.indexOf(e);d()(t>-1),this._particles.splice(t,1);for(const t of Object.values(e._consumedSlotConnections))t.remove()}newHandle(){const e=new tt(this);return this._handles.push(e),e}removeHandle(e){d()(0===e.connections.length);const t=this._handles.indexOf(e);d()(t>-1),this._handles.splice(t,1)}newSlot(e){const t=new ot(this,e);return this._slots.push(t),t}addSlot(e){-1===this.slots.indexOf(e)&&this.slots.push(e)}removeSlot(e){d()(0===e.consumeConnections.length);let t=this._slots.indexOf(e);d()(t>-1),this._slots.splice(t,1);for(const n of this.requires)-1!==(t=n.slots.indexOf(e))&&n.slots.splice(t,1)}isResolved(){return d()(Object.isFrozen(this),"Recipe must be normalized to be resolved."),!(this._obligations.length>0)&&(0===this._connectionConstraints.length&&this.requires.every(e=>e.isEmpty())&&(null===this._search||this._search.isResolved())&&this._handles.every(e=>e.isResolved())&&this._particles.every(e=>e.isResolved())&&this.modality.isResolved()&&this.allRequiredSlotsPresent()&&this._slots.every(e=>e.isResolved())&&this.handleConnections.every(e=>e.isResolved())&&this.slotConnections.every(e=>e.isResolved()))}isCompatible(e){return this.particles.every(t=>!t.spec||t.spec.isCompatible(e))}get modality(){return this.particles.filter(e=>Boolean(e.spec&&e.spec.slotConnections.size>0)).map(e=>e.spec.modality).reduce((e,t)=>e.intersection(t),R.all)}allRequiredSlotsPresent(){for(const e of this.particles){if(0===e.spec.slotConnections.size)continue;let t=!1;for(const[n,s]of e.spec.slotConnections){if(s.isRequired&&!e.consumedSlotConnections[n])return!1;if(e.consumedSlotConnections[n])for(const t of s.provideSlotConnections)if(t.isRequired&&!e.getProvidedSlotByName(n,t.name))return!1;e.consumedSlotConnections[n]&&(t=!0)}if(!t)return!1}return!0}_findDuplicate(e,t){const n=new Set,s=e.find(e=>{if(e.id){if(n.has(e.id))return e;n.add(e.id)}});return s&&t&&t.errors&&t.errors.set(s,`Has Duplicate ${s instanceof tt?"Handle":"Slot"} '${s.id}'`),s}_isValid(e){return!this._findDuplicate(this._handles,e)&&!this._findDuplicate(this._slots,e)&&this._handles.every(t=>t._isValid(e))&&this._particles.every(t=>t._isValid(e))&&this._slots.every(t=>t._isValid(e))&&this.handleConnections.every(t=>t._isValid(e))&&this.slotConnections.every(t=>t._isValid(e))&&(!this.search||this.search.isValid())}get requires(){return this._requires}get name(){return this._name}set name(e){this._name=e}get localName(){return this._localName}set localName(e){this._localName=e}get particles(){return this._particles}set particles(e){this._particles=e}get handles(){return this._handles}set handles(e){this._handles=e}get slots(){return this._slots}set slots(e){this._slots=e}get connectionConstraints(){return this._connectionConstraints}get obligations(){return this._obligations}get verbs(){return this._verbs}set verbs(e){this._verbs=e}get search(){return this._search}set search(e){this._search=e}setSearchPhrase(e){d()(!this._search,"Cannot override search phrase"),e&&(this._search=new rt(e))}get slotConnections(){const e=[];return this._particles.forEach(t=>{e.push(...Object.values(t.consumedSlotConnections))}),e}get handleConnections(){const e=[];return this._particles.forEach(t=>{e.push(...Object.values(t.connections)),e.push(...t._unnamedConnections)}),e}isEmpty(){return 0===this.particles.length&&0===this.handles.length&&0===this.slots.length&&0===this._connectionConstraints.length}findHandle(e){for(const t of this.handles)if(t.id===e)return t;return null}findSlot(e){for(const t of this.slots)if(t.id===e)return t;return null}get patterns(){return this._patterns}set patterns(e){this._patterns=e}set description(e){const t=e.find(e=>"pattern"===e.name);t&&t.patterns.forEach(e=>this._patterns.push(e)),e.forEach(e=>{if("pattern"!==e.name){const t=this.handles.find(t=>t.localName===e.name);d()(t,`Cannot set description pattern for nonexistent handle ${e.name}.`),t.pattern=e.pattern}})}async digest(){return Ve(this.toString())}normalize(e){if(Object.isFrozen(this))return e&&e.errors&&e.errors.set(this,"already normalized"),!1;if(!this._isValid()){this._findDuplicate(this._handles,e),this._findDuplicate(this._slots,e);const t=t=>t.forEach(t=>!t._isValid(e));return t(this._handles),t(this._particles),t(this._slots),t(this.handleConnections),t(this.slotConnections),!1}for(const e of this._particles)e._startNormalize();for(const e of this._handles)e._startNormalize();for(const e of this._slots)e._startNormalize();const t=this.handleConnections;for(const e of t)e._normalize();t.sort(Je);const n=this.slotConnections;for(const e of n)e._normalize();n.sort(Je),this.search&&this.search._normalize();for(const e of this.requires)e.normalize();for(const e of this._particles)e._finishNormalize();for(const e of this._handles)e._finishNormalize();for(const e of this._slots)e._finishNormalize();const s=new Set,i=new Set,r=new Set,o=[],a=[],c=[];let l=t.filter(e=>!(e.type&&e.type instanceof oe));l=l.concat(t.filter(e=>!!e.type&&!!(e.type instanceof oe)));for(const e of l)i.has(e.particle)||(o.push(e.particle),i.add(e.particle)),e.handle&&!s.has(e.handle)&&(a.push(e.handle),s.add(e.handle));for(const e of n)e.targetSlot&&!r.has(e.targetSlot)&&(c.push(e.targetSlot),r.add(e.targetSlot)),Object.values(e.providedSlots).forEach(e=>{r.has(e)||(c.push(e),r.add(e))});const h=this._handles.filter(e=>!s.has(e));h.sort(Je),a.push(...h);const u=this._particles.filter(e=>!i.has(e));u.sort(Je),o.push(...u);const d=this._slots.filter(e=>!r.has(e));return d.sort(Je),c.push(...d),this._particles=o,this._handles=a,this._slots=c,this._connectionConstraints.sort(Je),this._verbs.sort(),this._patterns.sort(),Object.freeze(this._particles),Object.freeze(this._handles),Object.freeze(this._slots),Object.freeze(this._connectionConstraints),Object.freeze(this),!0}clone(e){const t=new at(this.name);return null==e&&(e=new Map),this._copyInto(t,e),t._cloneMap=e,t}mergeInto(e){const t=new Map,n=e._handles.length,s=e._particles.length,i=e._slots.length;return this._copyInto(e,t),{handles:e._handles.slice(n),particles:e._particles.slice(s),slots:e._slots.slice(i),cloneMap:t}}_copyInto(e,t){const n=new Map;function s(s){const i=s._copyInto(e,t,n);t.set(s,i)}e._name=this.name,e._verbs=e._verbs.concat(...this._verbs),this._handles.forEach(s),this._particles.forEach(s),this._slots.forEach(s),this._connectionConstraints.forEach(s),this._obligations.forEach(s),e.verbs=e.verbs.slice(),this.search&&this.search._copyInto(e);for(const n of this.requires){const s=e.newRequireSection();n._copyInto(s,t),s._cloneMap=t}e.patterns=e.patterns.concat(this.patterns)}updateToClone(e){const t={};return Object.keys(e).forEach(n=>t[n]=this._cloneMap.get(e[n])),t}_makeLocalNameMap(){const e=new Set;for(const t of this.particles)e.add(t.localName);for(const t of this.handles)e.add(t.localName);for(const t of this.slots)e.add(t.localName);const t=new Map;let n=0;for(const s of this.particles){let i=s.localName;if(!i)do{i=`particle${n++}`}while(e.has(i));t.set(s,i)}n=0;for(const s of this.handles){let i=s.localName;if(!i)do{i=`handle${n++}`}while(e.has(i));t.set(s,i)}n=0;for(const s of this.slots){let i=s.localName;if(!i)do{i=`slot${n++}`}while(e.has(i));t.set(s,i)}return t}toString(e){const t=this._makeLocalNameMap(),n=[],s=this.verbs.length>0?` ${this.verbs.map(e=>`&${e}`).join(" ")}`:"";n.push(`recipe${this.name?` ${this.name}`:""}${s}`),e&&e.showUnresolved&&this.search&&n.push(this.search.toString(e).replace(/^|(\n)/g,"$1  "));for(const t of this._connectionConstraints){let s=t.toString().replace(/^|(\n)/g,"$1  ");e&&e.showUnresolved&&(s=s.concat(" // unresolved connection-constraint")),n.push(s)}n.push(...this.handles.map(n=>n.toString(t,e)).filter(e=>e).map(e=>e.replace(/^|(\n)/g,"$1  ")));for(const s of this.slots){const i=s.toString(t,e);i&&n.push(i.replace(/^|(\n)/g,"$1  "))}for(const s of this.requires)s.isEmpty()||n.push(s.toString(t,e).replace(/^|(\n)/g,"$1  "));for(const s of this.particles)n.push(s.toString(t,e).replace(/^|(\n)/g,"$1  "));if(this.patterns.length>0||this.handles.find(e=>void 0!==e.pattern)){n.push(`  description \`${this.patterns[0]}\``);for(let e=1;e<this.patterns.length;++e)n.push(`    pattern \`${this.patterns[e]}\``);this.handles.forEach(e=>{e.pattern&&n.push(`    ${e.localName} \`${e.pattern}\``)})}if(this._obligations.length>0){n.push("  obligations");for(const s of this._obligations){const i=s.toString(t,e).replace(/^|(\n)/g,"$1    ");n.push(i)}}return n.join("\n")}getFreeHandles(){return this.handles.filter(e=>0===e.connections.length)}get allSpecifiedConnections(){return[].concat(...this.particles.filter(e=>e.spec&&e.spec.connections).map(e=>e.spec.connections.map(t=>({particle:e,connSpec:t}))))}getFreeConnections(e){return this.allSpecifiedConnections.filter(({particle:t,connSpec:n})=>!n.isOptional&&"descriptions"!==n.name&&"host"!==n.direction&&!t.connections[n.name]&&(!e||e.equals(n.type)))}findHandleByID(e){return this.handles.find(t=>t.id===e)}getUnnamedUntypedConnections(){return this.handleConnections.find(e=>!e.type||!e.name||e.isOptional)}getParticlesByImplFile(e){return this.particles.filter(t=>t.spec&&e.has(t.spec.implFile))}findSlotByID(e){let t=this.slots.find(t=>t.id===e);if(null==t)if(this instanceof ct)t=this.parent.slots.find(t=>t.id===e);else for(const n of this.requires)if(void 0!==(t=n.slots.find(t=>t.id===e)))break;return t}}class ct extends at{constructor(e,t){super(t),this.parent=e}toString(e,t){null==e&&(e=this._makeLocalNameMap());const n=[];n.push("require"),t&&t.showUnresolved&&this.search&&n.push(this.search.toString(t).replace(/^|(\n)/g,"$1  "));for(const e of this.connectionConstraints){let s=e.toString().replace(/^|(\n)/g,"$1  ");t&&t.showUnresolved&&(s=s.concat(" // unresolved connection-constraint")),n.push(s)}n.push(...this.handles.map(n=>n.toString(e,t)).filter(e=>e).map(e=>e.replace(/^|(\n)/g,"$1  ")));for(const s of this.slots){const i=s.toString(e,t);i&&n.push(i.replace(/^|(\n)/g,"$1  "))}for(const s of this.particles)n.push(s.toString(e,t).replace(/^|(\n)/g,"$1  "));if(this.patterns.length>0||this.handles.find(e=>void 0!==e.pattern)){n.push(`  description \`${this.patterns[0]}\``);for(let e=1;e<this.patterns.length;++e)n.push(`    pattern \`${this.patterns[e]}\``);this.handles.forEach(e=>{e.pattern&&n.push(`    ${e.localName} \`${e.pattern}\``)})}if(this.obligations.length>0){n.push("  obligations");for(const s of this.obligations){const i=s.toString(e,t).replace(/^|(\n)/g,"$1    ");n.push(i)}}return n.join("\n")}}class lt{constructor(e,t,n,s){this.recipe=e,this.particles=t,this.handles=n,this.reverse=new Map;for(const e of Object.keys(t))this.reverse.set(t[e],e);for(const e of n.keys())this.reverse.set(n.get(e),e);for(const e of Object.keys(s))this.reverse.set(s[e],e)}}class ht{static makeShape(e,t,n,s){s=s||new at;const i={},r=new Map,o={};return e.forEach(e=>i[e]=s.newParticle(e)),t.forEach(e=>r.set(e,s.newHandle())),Object.keys(n).forEach(e=>{Object.keys(n[e]).forEach(t=>{const s=n[e][t];let a="=";s.direction&&(a={"->":"out","<-":"in","=":"="}[s.direction]);const c=s.tags||[];s.localName&&(r.get(s.handle).localName=s.localName);const l=i[e].addConnectionName(t);l.direction=a,r.get(s.handle).tags=c,l.connectToHandle(r.get(s.handle)),o[e+":"+t]=i[e].connections[t]})}),new lt(s,i,r,o)}static recipeToShape(e){const t={};let n=0;e.particles.forEach(e=>t[e.name]=e);const s=new Map;e.handles.forEach(e=>s.set("h"+n++,e));const i={};return e.handleConnections.forEach(e=>i[e.particle.name+":"+e.name]=e),new lt(e,t,s,i)}static find(e,t){function n(e,t,n,i){const{forward:r,reverse:o,score:a}=n;let c=!1;for(const n of e.particles)if(n.spec)for(const e of n.spec.handleConnections){if(o.has(e))continue;if(n.name!==t.particle.name)continue;if(t.name&&t.name!==e.name)continue;const s={in:["in","inout"],out:["out","inout"],"=":["in","out","inout"],inout:["inout"],host:["host"]};if(e.direction&&(d()(Object.keys(s).includes(t.direction),`${t.direction} not in ${Object.keys(s)}`),!s[t.direction].includes(e.direction)))continue;const l=n.connections[e.name];if(t.handle&&l&&l.handle&&t.handle.localName&&t.handle.localName!==l.handle.localName)continue;if(o.has(n)){if(o.get(n)!==t.particle)continue}else if(r.has(t.particle))continue;if(t.handle&&l&&l.handle){if(o.has(l.handle)){if(o.get(l.handle)!==t.handle)continue}else if(r.has(t.handle)&&null!==r.get(t.handle))continue;if("create"!==t.handle.fate||"create"!==l.handle.fate&&"create"!==l.handle.originalFate){if(Boolean(t.handle.immediateValue)!==Boolean(l.handle.immediateValue))continue;if(l.handle.immediateValue){if(!l.handle.immediateValue.equals(t.handle.immediateValue))continue}else if(t.handle.id!==l.handle.id&&t.handle.id!==l.handle.originalId)continue}}const h={forward:new Map(r),reverse:new Map(o),score:a};d()(!h.reverse.has(n)||h.reverse.get(n)===t.particle),d()(!h.forward.has(t.particle)||h.forward.get(t.particle)===n),h.forward.set(t.particle,n),h.reverse.set(n,t.particle),t.handle&&(l&&l.handle?(h.forward.set(t.handle,l.handle),h.reverse.set(l.handle,t.handle)):h.forward.has(t.handle)||(h.forward.set(t.handle,null),h.score-=2)),h.forward.set(t,e),h.reverse.set(e,t),i.push(h),c=!0}if(!1===c){if(n.forward.get(t.particle))return;const r=[];s(e,t.particle,n,r),r.forEach(e=>{t.handle&&!e.forward.has(t.handle)&&(e.forward.set(t.handle,null),e.score-=2),e.forward.set(t,null),e.score-=1,i.push(e)})}}function s(e,t,n,s){const{forward:i,reverse:r,score:o}=n;let a=!1;for(const n of e.particles){if(r.has(n))continue;if(n.name!==t.name)continue;let e=!0;for(const s of Object.keys(n.connections)){const i=n.connections[s];if(!i.handle)continue;const r=t.connections[s];if(r&&r.handle&&r.handle.localName&&r.handle.localName!==i.handle.localName){e=!1;break}}if(!e)continue;const c={forward:new Map(i),reverse:new Map(r),score:o};d()(!c.forward.has(t)||c.forward.get(t)===n),d()(!c.reverse.has(n)||c.reverse.get(n)===t),c.forward.set(t,n),c.reverse.set(n,t),s.push(c),a=!0}if(!1===a){const e={forward:new Map,reverse:new Map,score:0};i.forEach((t,n)=>{d()(!e.forward.has(n)||e.forward.get(n)===t),e.forward.set(n,t)}),r.forEach((t,n)=>{d()(!e.reverse.has(n)||e.reverse.get(n)===t),e.reverse.set(n,t)}),e.forward.has(t)||(e.forward.set(t,null),e.score=n.score-1),s.push(e)}}function i(e,n,s){if(1===n.length){const t=[],{forward:i,reverse:r,score:o}=e;for(const e of s){let s=!0;for(const t of e.tags)if(!n[0].tags.includes(t)){s=!1;break}if(!s)continue;const a={forward:new Map(i),reverse:new Map(r),score:o+1};a.forward.set(e,n[0]),a.reverse.set(n[0],e),t.push(a)}return t}const r=n.pop(),o=i(e,n,s);let a=[];for(const e of o){const n=[...t.handles.values()].filter(t=>null===e.forward.get(t));n.length>0?a=a.concat(i(e,[r],n)):a.concat(e)}return a}let r=[{forward:new Map,reverse:new Map,score:0}];for(const s of t.recipe.handleConnections){const t=[];for(const i of r)n(e,s,i,t);r=t}for(const n of t.recipe.particles){if(Object.keys(n.connections).length>0)continue;if(n.unnamedConnections.length>0)continue;const t=[];for(const i of r)s(e,n,i,t);r=t}const o=e.handles.filter(e=>0===e.connections.length);if(o.length>0){let e=[];for(const n of r){const s=[...t.handles.values()].filter(e=>null===n.forward.get(e));e=s.length>0?e.concat(i(n,o,s)):e.concat(n)}r=e}return r.map(({forward:e,score:n})=>{const s={};return e.forEach((e,n)=>s[t.reverse.get(n)]=e),{match:s,score:n}})}static constructImmediateValueHandle(e,t,n){if(d()(e.type instanceof oe),!(e.type instanceof oe&&e.type.interfaceInfo.restrictType(t)))return null;const s=e.type.clone(new Map);s.maybeEnsureResolved();const i=e.recipe.newHandle();return i.id=n.toString(),i.mappedType=s,i.fate="copy",i.immediateValue=t,i}static directionCounts(e){const t={in:0,out:0,inout:0,unknown:0};for(const n of e.connections){let e=n.direction;void 0===t[e]&&(e="unknown"),t[e]++}return t.in+=t.inout,t.out+=t.inout,t}static matchesRecipe(e,t){const n=ht.recipeToShape(t);return ht.find(e,n).some(e=>0===e.score)}}
// @license
class ut{constructor(e){if(this.items=new Map,e)for(let{id:t,value:n,keys:s}of e)s||(s=[]),this.items.set(t,{value:n,keys:new Set(s)})}add(e,t,n){d()(n.length>0&&"object"==typeof n,"add requires a list of keys");let s=this.items.get(e),i=!1;if(s){let e=!1;for(const t of n)s.keys.has(t)||(e=!0),s.keys.add(t);this._equals(s.value,t)||(d()(e,"cannot add without new keys. incoming="+n.join(",")+" existing="+[...s.keys].join(",")),s.value=t,i=!0)}else s={value:t,keys:new Set(n)},this.items.set(e,s),i=!0;return i}_equals(e,t){if(Boolean(e)!==Boolean(t))return!1;if(!e)return!0;const n=typeof e;if(n!==typeof t)return!1;if("object"===n){const n=Object.keys(e);return n.length===Object.keys(t).length&&n.every(n=>this._equals(e[n],t[n]))}return JSON.stringify(e)===JSON.stringify(t)}remove(e,t){const n=this.items.get(e);if(!n)return!1;for(const e of t)n.keys.delete(e);const s=0===n.keys.size;return s&&this.items.delete(e),s}toLiteral(){const e=[];for(const[t,{value:n,keys:s}]of this.items.entries())e.push({id:t,value:n,keys:[...s]});return e}toList(){return[...this.items.values()].map(e=>e.value)}has(e){return this.items.has(e)}getKeys(e){const t=this.items.get(e);return t?[...t.keys]:[]}getValue(e){const t=this.items.get(e);return t?t.value:null}get size(){return this.items.size}}class dt{}!function(e){e.change="Change"}(He||(He={}));class pt{constructor(e){this.arcId=e,this._debug=!1,d()(void 0!==e,"Arcs with storage must have ids")}set debug(e){this._debug=e}async shutdown(){}}class ft{constructor(e){Object.assign(this,e)}}class mt{constructor(e,t,n,s){this.referenceMode=!1,d()(n,"id must be provided when constructing StorageProviders"),d()(!e.hasUnresolvedVariable,"Storage types must be concrete"),this._type=e,this.listeners=new Map,this.name=t,this.version=0,this.id=n,this.source=null,this._storageKey=s,this.nextLocalID=0}enableReferenceMode(){this.referenceMode=!0}get storageKey(){return this._storageKey}get type(){return this._type}reportExceptionInHost(e){throw e}on(e,t,n){d()(void 0!==n,"must provide a target to register a storage event handler");const s=He[e],i=this.listeners.get(s)||new Map;i.set(t,{target:n}),this.listeners.set(s,i)}off(e,t){const n=He[e],s=this.listeners.get(n);s&&s.delete(t)}async _fire(e,t){const n=He[e],s=this.listeners.get(n);if(!s||0===s.size)return;const i=[];for(const[e]of s.entries())i.push(e);await 0;for(const e of i)e(t)}_compareTo(e){let t;return 0!==(t=De(this.name,e.name))?t:0!==(t=Ke(this.version,e.version))?t:0!==(t=De(this.source,e.source))?t:0!==(t=De(this.id,e.id))?t:0}toString(e){const t=[],n=[];return n.push("store"),this.name&&n.push(`${this.name}`),n.push(`of ${this.type.toString()}`),this.id&&n.push(`'${this.id}'`),e&&e.length&&n.push(`${e.join(" ")}`),this.source&&n.push(`in '${this.source}'`),t.push(n.join(" ")),this.description&&t.push(`  description \`${this.description}\``),t.join("\n")}get apiChannelMappingId(){return this.id}dispose(){}async modelForSynchronization(){return this.toLiteral()}}class gt extends dt{constructor(e){super();let t=e.split("://");this.protocol=t[0],d()("volatile"===this.protocol,`can't construct volatile key for protocol ${this.protocol} (input key ${e})`),t=t[1]?t.slice(1).join("://").split("^^"):[],this.arcId=t[0],this.location=t[1],d()(this.toString()===e,`Expected ${e}, but got ${this.toString()} volatile key base.`)}base(){return"volatile"}get arcId(){return this._arcId}set arcId(e){this._arcId=e}childKeyForHandle(e){return new gt("volatile")}childKeyForArcInfo(){return new gt(`${this.protocol}://${this.arcId}^^arc-info`)}childKeyForSuggestions(e,t){return new gt(`${this.protocol}://${this.arcId}^^${e}/suggestions/${t}`)}childKeyForSearch(e){return new gt(`${this.protocol}://${this.arcId}^^${e}/search`)}toString(){return void 0!==this.location&&void 0!==this.arcId?`${this.protocol}://${this.arcId}^^${this.location}`:void 0!==this.arcId?`${this.protocol}://${this.arcId}`:`${this.protocol}`}}const yt={};class _t extends mt{constructor(){super(...arguments),this.backingStore=null,this.pendingBackingStore=null}static newProvider(e,t,n,s,i){return e instanceof se?new vt(e,t,n,s,i):e instanceof ie?new wt(e,t,n,s,i):new St(e,t,n,s,i)}async ensureBackingStore(){if(this.backingStore)return this.backingStore;if(!this.pendingBackingStore){const e=this.storageEngine.baseStorageKey(this.backingType());this.pendingBackingStore=this.storageEngine.baseStorageFor(this.backingType(),e),this.pendingBackingStore.then(e=>this.backingStore=e)}return this.pendingBackingStore}}class vt extends _t{constructor(e,t,n,s,i){super(e,n,s,i),this._model=new ut,this.storageEngine=t,d()(null!==this.version)}backingType(){return this.type.getContainedType()}clone(){const e=new vt(this.type,this.storageEngine,this.name,this.id,null);return e.cloneFrom(this),e}async cloneFrom(e){this.referenceMode=e.referenceMode;const t=await e.toLiteral();if(this.referenceMode&&t.model.length>0){await Promise.all([this.ensureBackingStore(),e.ensureBackingStore()]),t.model=t.model.map(({id:e,value:t})=>({id:e,value:{id:t.id,storageKey:this.backingStore.storageKey}}));const n=await e.backingStore.getMultiple(t.model.map(({id:e})=>e));await this.backingStore.storeMultiple(n,[this.storageKey])}this.fromLiteral(t)}async modelForSynchronization(){const e=await this._toList();return{version:this.version,model:e}}async toLiteral(){return{version:this.version,model:this._model.toLiteral()}}fromLiteral({version:e,model:t}){this.version=e,this._model=new ut(t)}async _toList(){if(this.referenceMode){const e=(await this.toLiteral()).model;if(0===e.length)return[];const t=new Set;e.forEach(e=>t.add(e.value.storageKey)),d()(1===t.size,"multiple storageKeys in reference set of collection not yet supported.");t.values().next().value;await this.ensureBackingStore();const n=e.map(e=>e.value.id),s=await this.backingStore.getMultiple(n),i=[];for(let t=0;t<s.length;t++)i.push({id:n[t],value:s[t],keys:e[t].keys});return i}return(await this.toLiteral()).model}async toList(){return(await this._toList()).map(e=>e.value)}async getMultiple(e){return d()(!this.referenceMode,"getMultiple not implemented for referenceMode stores"),e.map(e=>this._model.getValue(e))}async storeMultiple(e,t,n=null){d()(!this.referenceMode,"storeMultiple not implemented for referenceMode stores"),e.map(e=>this._model.add(e.id,e,t)),this.version++}async get(e){if(this.referenceMode){const t=this._model.getValue(e);return null==t?null:(await this.ensureBackingStore(),await this.backingStore.get(t.id))}return this._model.getValue(e)}traceInfo(){return{items:this._model.size}}async store(e,t,n=null){d()(null!=t&&t.length>0,"keys required");const s={value:e,keys:t,effective:void 0};if(this.referenceMode){const n=this.type.getContainedType(),i=this.backingStore?this.backingStore.storageKey:this.storageEngine.baseStorageKey(n);s.effective=this._model.add(e.id,{id:e.id,storageKey:i},t),await this.ensureBackingStore(),await this.backingStore.store(e,t)}else s.effective=this._model.add(e.id,e,t);this.version++,await this._fire("change",new ft({add:[s],version:this.version,originatorId:n}))}async removeMultiple(e,t=null){0===e.length&&(e=this._model.toList().map(e=>({id:e.id,keys:[]}))),e.forEach(e=>{0===e.keys.length&&(e.keys=this._model.getKeys(e.id)),e.value=this._model.getValue(e.id),null!==e.value&&(e.effective=this._model.remove(e.id,e.keys))}),this.version++,this._fire("change",new ft({remove:e,version:this.version,originatorId:t}))}async remove(e,t=[],n=null){0===t.length&&(t=this._model.getKeys(e));const s=this._model.getValue(e);if(null!==s){const i=this._model.remove(e,t);this.version++,await this._fire("change",new ft({remove:[{value:s,keys:t,effective:i}],version:this.version,originatorId:n}))}}clearItemsForTesting(){this._model=new ut}}class St extends _t{constructor(e,t,n,s,i){super(e,n,s,i),this.localKeyId=0,this.storageEngine=t,this._stored=null,this.backingStore=null}backingType(){return this.type}clone(){const e=new St(this.type,this.storageEngine,this.name,this.id,null);return e.cloneFrom(this),e}async cloneFrom(e){this.referenceMode=e.referenceMode,e.referenceMode&&e.localModified&&await e._persistChanges();const t=await e.toLiteral();if(this.referenceMode&&t.model.length>0){await Promise.all([this.ensureBackingStore(),e.ensureBackingStore()]),t.model=t.model.map(({id:e,value:t})=>({id:e,value:{id:t.id,storageKey:this.backingStore.storageKey}}));const n=await e.backingStore.getMultiple(t.model.map(({id:e})=>e));await this.backingStore.storeMultiple(n,[this.storageKey])}await this.fromLiteral(t)}async modelForSynchronization(){if(this.referenceMode&&null!==this._stored){const e=this._stored;await this.ensureBackingStore();const t=await this.backingStore.get(e.id);return{version:this.version,model:[{id:e.id,value:t}]}}return super.modelForSynchronization()}async toLiteral(){const e=this._stored,t=null!=e?[{id:e.id,value:e,keys:[]}]:[];return{version:this.version,model:t}}fromLiteral({version:e,model:t}){const n=0===t.length?null:t[0].value;this.referenceMode&&n&&n.rawData&&d()(!1,`shouldn't have rawData ${JSON.stringify(n.rawData)} here`),d()(void 0!==n),this._stored=n,this.version=e}traceInfo(){return{stored:null!==this._stored}}async get(){if(this.referenceMode&&this._stored){const e=this._stored;return await this.ensureBackingStore(),await this.backingStore.get(e.id)}return this._stored}async set(e,t=null,n=null){if(d()(void 0!==e),this.referenceMode&&e){const t=this.type,n=this.backingStore?this.backingStore.storageKey:this.storageEngine.baseStorageKey(t);this._stored={id:e.id,storageKey:n},await this.ensureBackingStore(),await this.backingStore.store(e,[this.storageKey+this.localKeyId++])}else{if(JSON.stringify(this._stored)===JSON.stringify(e)&&null==n)return;this._stored=e}this.version++;const s=this.referenceMode?e:this._stored;await this._fire("change",new ft({data:s,version:this.version,originatorId:t,barrier:n}))}async clear(e=null,t=null){await this.set(null,e,t)}}class bt{constructor(e,t,n,s){this.version=e,this.pageSize=n;const i=[...t];i.sort((e,t)=>e.index-t.index),this.data=i.map(e=>e.value),s||this.data.reverse()}async next(){return 0===this.data.length?{done:!0}:{value:this.data.splice(0,this.pageSize),done:!1}}close(){this.data=[]}}class wt extends _t{constructor(e,t,n,s,i){super(e,n,s,i),this.items=new Map,this.cursors=new Map,this.cursorIndex=0}enableReferenceMode(){d()(!1,"referenceMode is not supported for BigCollection")}backingType(){return this.type.getContainedType()}async get(e){const t=this.items.get(e);return void 0!==t?t.value:null}async store(e,t,n){d()(null!=t&&t.length>0,"keys required"),this.version++,this.items.has(e.id)||this.items.set(e.id,{index:null,value:null,keys:{}});const s=this.items.get(e.id);s.index=this.version,s.value=e,t.forEach(e=>s.keys[e]=this.version)}async remove(e,t,n){this.version++,this.items.delete(e)}async stream(e,t=!0){d()(!isNaN(e)&&e>0),this.cursorIndex++;const n=new bt(this.version,this.items.values(),e,t);return this.cursors.set(this.cursorIndex,n),this.cursorIndex}async cursorNext(e){const t=this.cursors.get(e);if(!t)return{done:!0};const n=await t.next();return n.done&&this.cursors.delete(e),n}async cursorClose(e){const t=this.cursors.get(e);t&&(this.cursors.delete(e),t.close())}cursorVersion(e){const t=this.cursors.get(e);return t?t.version:null}async cloneFrom(e){e.items&&this.fromLiteral(e.toLiteral())}async toLiteral(){const e=[];for(const[t,{index:n,value:s,keys:i}]of this.items.entries())e.push({id:t,index:n,value:s,keys:Object.keys(i)});return{version:this.version,model:e}}fromLiteral({version:e,model:t}){this.version=e,this.items.clear();for(const{id:e,index:n,value:s,keys:i}of t){const t={};for(const e of i)t[e]=n;this.items.set(e,{index:n,value:s,keys:t})}}clearItemsForTesting(){this.items.clear()}}
// @license
// @license
var Ct,Tt;!function(e){e[e.arc=1]="arc"}(Ct||(Ct={})),function(e){e[e.handles=1]="handles"}(Tt||(Tt={}));class $t extends dt{constructor(e,t){super();const n=e.match(/^synthetic:\/\/([^\/]+)\/([^\/]+)\/(.+)$/);if(null===n||4!==n.length)throw new Error(`invalid synthetic key: ${e}`);if(this.scope=Ct[n[1]],this.category=Tt[n[2]],this.scope!==Ct.arc)throw new Error(`invalid scope '${n[1]}' for synthetic key: ${e}`);{this.targetType=new le;const e=t.parseStringAsKey(n[3]).childKeyForArcInfo();this.targetKey=e.toString()}if(this.category!==Tt.handles)throw new Error(`invalid category '${n[2]}' for synthetic key: ${e}`);this.syntheticType=new he}get protocol(){return"synthetic"}base(){return d()(!1,"base not supported for synthetic keys"),null}get arcId(){return d()(!1,"arcId not supported for synthetic keys"),null}childKeyForHandle(e){return d()(!1,"childKeyForHandle not supported for synthetic keys"),null}childKeyForArcInfo(){return d()(!1,"childKeyForArcInfo not supported for synthetic keys"),null}childKeyForSuggestions(e,t){return d()(!1,"childKeyForSuggestions not supported for synthetic keys"),null}childKeyForSearch(e){return d()(!1,"childKeyForSearch not supported for synthetic keys"),null}toString(){return`${this.protocol}://${Ct[this.scope]}/${Tt[this.category]}/${this.targetKey}`}}class kt extends mt{constructor(e,t,n,s,i){let r;super(e,void 0,t,n),this.model=[],this.backingStore=void 0,this.targetStore=s,this.storageFactory=i,this.initialized=new Promise(e=>r=e);const o=async e=>{await this.process(e,!1),r(),s.on("change",e=>this.process(e.data,!0),this)};s.get().then(e=>o(e))}async process(e,t){let n;try{if(e){const t=await At.parse(Q.extractSerialization(e),{});n=t.activeRecipe&&t.activeRecipe.handles}}catch(e){console.warn(`Error parsing manifest at ${this.storageKey}:\n${e.message}`)}const s=this.model;this.model=[];for(const e of n||[])this.storageFactory.isPersistent(e.storageKey)&&this.model.push(new X(e.id,e.storageKey,e.mappedType,e.tags));if(t){const e=function(e,t,n){const s={add:[],remove:[]},i=new Map,r=new Map,o=new Map;for(const t of e){const e=n(t);i.set(e,t),r.set(e,t)}for(const e of t){const t=n(e);i.set(t,e),o.set(t,e)}for(const[e,t]of i)if(r.has(e)){if(o.has(e))continue;s.remove.push(t)}else d()(o.has(e)),s.add.push(t);return s}(s,this.model,JSON.stringify),t=e.add.map(e=>({value:e})),n=e.remove.map(e=>({value:e}));this._fire("change",new ft({add:t,remove:n}))}}async toList(){return await this.initialized,this.model}async toLiteral(){throw new Error("unimplemented")}async cloneFrom(){throw new Error("cloneFrom should never be called on SyntheticCollection!")}async ensureBackingStore(){throw new Error("ensureBackingStore should never be called on SyntheticCollection!")}async getMultiple(e){throw new Error("unimplemented")}async storeMultiple(e,t,n){throw new Error("unimplemented")}async removeMultiple(e,t){throw new Error("unimplemented")}async get(e){throw new Error("unimplemented")}remove(e,t,n){throw new Error("unimplemented")}store(e,t,n){throw new Error("unimplemented")}}const Rt={volatile:{storage:class extends pt{constructor(e){super(e),this._memoryMap={},this._typeMap={},this.localIDBase=0,this.typePromiseMap={},yt[this.arcId.toString()]=this}async construct(e,t,n){const s=await this._construct(e,t,n);return t instanceof ce||t instanceof ie?s:t.isTypeContainer()&&t.getContainedType()instanceof ce?s:(s.enableReferenceMode(),s)}async _construct(e,t,n){const s=new gt(n);void 0===s.arcId&&(s.arcId=this.arcId.toString()),void 0===s.location&&(s.location="volatile-"+this.localIDBase++);const i=_t.newProvider(t,this,void 0,e,s.toString());return void 0!==this._memoryMap[s.toString()]?null:(this._memoryMap[s.toString()]=i,i)}async connect(e,t,n){const s=new gt(n);return s.arcId!==this.arcId.toString()?null==yt[s.arcId]?null:yt[s.arcId].connect(e,t,n):void 0===this._memoryMap[n]?null:this._memoryMap[n]}baseStorageKey(e){const t=new gt("volatile");return t.arcId=this.arcId.toString(),t.location="volatile-"+e.toString(),t.toString()}async baseStorageFor(e,t){if(this._typeMap[t])return this._typeMap[t];if(this.typePromiseMap[t])return this.typePromiseMap[t];const n=this._construct(e.toString(),e.collectionOf(),t);this.typePromiseMap[t]=n;const s=await n;return d()(s,`could not construct baseStorage for key ${t}`),this._typeMap[t]=s,s}parseStringAsKey(e){const t=new gt(e);return void 0===t.arcId&&(t.arcId=this.arcId.toString()),t}},isPersistent:!1},synthetic:{storage:class extends pt{constructor(e,t){super(e),this.storageFactory=t}async construct(e,t,n){throw new Error("cannot construct SyntheticStorage providers; use connect")}async connect(e,t,n){d()(null===t,"SyntheticStorage does not accept a type parameter");const s=new $t(n,this.storageFactory),i=await this.storageFactory.connect(e,s.targetType,s.targetKey);return null===i?null:new kt(s.syntheticType,e,n,i,this.storageFactory)}async baseStorageFor(e,t){throw new Error("baseStorageFor not implemented for SyntheticStorage")}baseStorageKey(e,t){throw new Error("baseStorageKey not implemented for SyntheticStorage")}parseStringAsKey(e){return new $t(e,this.storageFactory)}},isPersistent:!1}};class Et{constructor(e){this.arcId=e,this._storageInstances={},Object.keys(Rt).forEach(t=>{const{storage:n,isPersistent:s}=Rt[t];this._storageInstances[t]={storage:new n(e,this),isPersistent:s}})}static register(e,t){Rt[e]=t}getInstance(e){const t=this._storageInstances[e.split(":")[0]];if(!t)throw new Error(`unknown storage protocol: ${e}`);return t}_storageForKey(e){if(!e)throw new Error("key is required");return this.getInstance(e).storage}isPersistent(e){return e&&this.getInstance(e).isPersistent}async construct(e,t,n){return await this._storageForKey(n).construct(e,t,n)}async connect(e,t,n){return await this._storageForKey(n).connect(e,t,n)}async connectOrConstruct(e,t,n){const s=this._storageForKey(n);let i=await s.connect(e,t,n);return null==i&&(i=await s.construct(e,t,n)),i}async baseStorageFor(e,t){return await this._storageForKey(t).baseStorageFor(e,t)}baseStorageKey(e,t){return this._storageForKey(t).baseStorageKey(e,t)}parseStringAsKey(e){return this._storageForKey(e).parseStringAsKey(e)}newKey(e,t){}async shutdown(){for(const e of Object.values(this._storageInstances))await e.storage.shutdown()}}
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class It extends Error{constructor(e,t){super(t),this.location=e}}class Nt{constructor(e,t,n,s,i,r){this.referenceMode=!1,this.type=e,this.id=t,this.name=n,this.storageKey=s,this.storageProviderFactory=i,this.originalId=r}get version(){}get description(){}async inflate(){const e=await this.storageProviderFactory.connect(this.id,this.type,this.storageKey);return d()(null!=e,"inflating missing storageKey "+this.storageKey),e.originalId=this.originalId,e}toLiteral(){}toString(e){const t=[],n=[];return n.push("store"),this.name&&n.push(`${this.name}`),n.push(`of ${this.type.toString()}`),this.id&&n.push(`'${this.id}'`),e&&e.length&&n.push(`${e.join(" ")}`),t.push(n.join(" ")),this.description&&t.push(`  description \`${this.description}\``),t.join("\n")}_compareTo(e){let t;return 0!==(t=De(this.name,e.name))?t:0!==(t=De(this.id,e.id))?t:0}}class Mt{traverse(e){if(["string","number","boolean"].includes(typeof e)||null===e)return;if(e instanceof Array){for(const t of e)this.traverse(t);return}d()(e.location,"expected manifest node to have `location`"),d()(e.kind,"expected manifest node to have `kind`");let t=!1;const n=()=>{if(!t){t=!0;for(const t of Object.keys(e))["location","kind","model"].includes(t)||this.traverse(e[t])}};this.visit(e,n),n()}visit(e,t){}}const xt=new Set;class At{constructor({id:e}){if(this._recipes=[],this._imports=[],this._particles={},this._schemas={},this._stores=[],this._interfaces=[],this.storeTags=new Map,this._fileName=null,this._idGenerator=be.newSession(),this._storageProviderFactory=void 0,this._meta=new We,this._resources={},this.storeManifestUrls=new Map,this.errors=[],d()(e instanceof we||"string"==typeof e),e instanceof we)this._id=e;else{const t=e.split(":");this._id=we._newIdInternal(t[0],t.slice(1))}}get id(){return this._meta.name?we.fromString(this._meta.name):this._id}get storageProviderFactory(){return null==this._storageProviderFactory&&(this._storageProviderFactory=new Et(this.id)),this._storageProviderFactory}get recipes(){return this._recipes}get allRecipes(){return[...new Set(this._findAll(e=>e._recipes))]}get activeRecipe(){return this._recipes.find(e=>"active"===e.annotation)}get particles(){return Object.values(this._particles)}get allParticles(){return[...new Set(this._findAll(e=>Object.values(e._particles)))]}get imports(){return this._imports}get schemas(){return this._schemas}get fileName(){return this._fileName}get stores(){return this._stores}get allStores(){return[...this._findAll(e=>e._stores)]}get interfaces(){return this._interfaces}get meta(){return this._meta}get resources(){return this._resources}applyMeta(e){void 0!==this._storageProviderFactory&&d()(e.name===this._meta.name||null==e.name,"can't change manifest ID after storage is constructed"),this._meta.apply(e)}async createStore(e,t,n,s,i){const r=await this.storageProviderFactory.construct(n,e,i||`volatile://${this.id}`);return d()(null!==r.version),r.name=t,this.storeManifestUrls.set(r.id,this.fileName),this._addStore(r,s)}_addStore(e,t){return this._stores.push(e),this.storeTags.set(e,t||[]),e}newStorageStub(e,t,n,s,i,r){return this._addStore(new Nt(e,n,t,s,this.storageProviderFactory,r),i)}_find(e){let t=e(this);if(!t)for(const n of this._imports)if(t=n._find(e))break;return t}*_findAll(e){yield*e(this);for(const t of this._imports)yield*t._findAll(e)}findSchemaByName(e){return this._find(t=>t._schemas[e])}findTypeByName(e){const t=this.findSchemaByName(e);if(t)return new te(t);const n=this.findInterfaceByName(e);return n?new oe(n):void 0}findParticleByName(e){return this._find(t=>t._particles[e])}findParticlesByVerb(e){return[...this._findAll(t=>Object.values(t._particles).filter(t=>t.primaryVerb===e))]}findStoreByName(e){return this._find(t=>t._stores.find(t=>t.name===e))}findStoreById(e){return this._find(t=>t._stores.find(t=>t.id===e))}findStoreTags(e){return this._find(t=>t.storeTags.get(e))}findManifestUrlForHandleId(e){return this._find(t=>t.storeManifestUrls.get(e))}findStoresByType(e,t={tags:[],subtype:!1}){const n=t.tags||[],s=t.subtype||!1;return[...this._findAll(t=>t._stores.filter(i=>(function(t){const n=e.resolvedType();if(!n.isResolved())return e instanceof se==t.type instanceof se&&e instanceof ie==t.type instanceof ie;if(s){const[e,s]=ee.unwrapPair(t.type,n);return e instanceof te&&s instanceof te&&e.entitySchema.isMoreSpecificThan(s.entitySchema)}return t.type.equals(e)})(i)&&function(e,t){return 0===n.filter(n=>!e.storeTags.get(t).includes(n)).length}(t,i)))].filter(t=>!!tt.effectiveType(e,[{type:t.type,direction:t.type instanceof oe?"host":"inout"}]))}findInterfaceByName(e){return this._find(t=>t._interfaces.find(t=>t.name===e))}findRecipesByVerb(e){return[...this._findAll(t=>t._recipes.filter(t=>t.verbs.includes(e)))]}generateID(){return this._idGenerator.newChildId(this.id)}static async load(e,t,n){n=n||{};let{registry:s,id:i}=n;return(s=s||{})&&s[e]?await s[e]:(s[e]=(async()=>{const n=await t.loadResource(e);return d()(void 0!==n,`${e} unable to be loaded by Manifest parser`),await At.parse(n,{id:i,fileName:e,loader:t,registry:s})})(),await s[e])}static async parse(e,t){t=t||{};let{session_id:n,fileName:s,loader:i,registry:r,context:o,throwImportErrors:a}=t;r=r||{};const c=`manifest:${s}:`;function l(e){for(const t of e.errors){if(t.key){if(xt.has(t.key))continue;xt.add(t.key)}console.warn(h(t).message)}}function h(t,n){if(!(t instanceof It||t.location))return t;const i=e.split("\n")[t.location.start.line-1];let r=t.message||"";if(i){let e=1;e=t.location.end.line===t.location.start.line?t.location.end.column-t.location.start.column:i.length-t.location.start.column,e=Math.max(1,e);let o,a="";for(let e=0;e<t.location.start.column-1;e++)a+=" ";for(let t=0;t<e;t++)a+="^";r=`${o=n?"Parse error in":"Post-parse processing error caused by"} '${s}' line ${t.location.start.line}.\n${t.message}\n  ${i}\n  ${a}`}const o=new It(t.location,r);return n||(o.stack=t.stack),o}let u=[];try{u=Le(e)}catch(e){throw h(e,!0)}const d=new At({id:c});d._fileName=s,o&&d._imports.push(o);try{await Promise.all(u.map(async e=>{if("import"===e.kind){const t=i.path(d.fileName),n=i.join(t,e.path);try{d._imports.push(await At.load(n,i,{registry:r}))}catch(t){d.errors.push(t),d.errors.push(new It(e.location,`Error importing '${n}'`))}}}));const e=async(e,t)=>{for(const n of u)n.kind===e&&(At._augmentAstWithTypes(d,n),await t(n))};await e("meta",e=>d.applyMeta(e.items)),await e("resource",e=>this._processResource(d,e)),await e("schema",e=>this._processSchema(d,e)),await e("interface",e=>this._processInterface(d,e)),await e("particle",e=>this._processParticle(d,e,i)),await e("store",e=>this._processStore(d,e,i)),await e("recipe",e=>this._processRecipe(d,e,i))}catch(e){throw l(d),h(e,!1)}if(l(d),t.throwImportErrors&&d.errors.length>0)throw d.errors[0];return d}static _augmentAstWithTypes(e,t){(new class extends Mt{constructor(){super()}visit(t,n){switch(n(),t.kind){case"schema-inline":{const n=[],s=[],i=[];for(const r of t.names){const t=e.resolveTypeName(r);t&&t.schema&&t.schema.isAlias?s.push(t.schema):i.push(r),t&&t.schema&&n.push(t.schema)}const r={};for(let{name:e,type:s}of t.fields){for(const i of n)if(s){const n=i.fields[e];if(n&&!Z.typesEqual(n,s))throw new It(t.location,`Type of '${e}' does not match schema (${s} vs ${n})`)}else s=i.fields[e];if(!s)throw new It(t.location,`Could not infer type of '${e}' field`);r[e]=s}let o=new Z(i,r);for(const e of s)if(!(o=Z.union(e,o)))throw new It(t.location,"Could not merge schema aliases");return void(t.model=new te(o))}case"variable-type":{const e=t.constraint&&t.constraint.model;return void(t.model=ne.make(t.name,e,null))}case"slot-type":{const e={};for(const n of Object.keys(t.fields)){const s=t.fields[n];e[s.name]=s.value}return void(t.model=ae.make(e.formFactor,e.handle))}case"type-name":{const n=e.resolveTypeName(t.name);if(!n)throw new It(t.location,`Could not resolve type reference to type name '${t.name}'`);if(n.schema)t.model=new te(n.schema);else{if(!n.iface)throw new It(t.location,"Expected {iface} or {schema}");t.model=new oe(n.iface)}return}case"collection-type":return void(t.model=new se(t.type.model));case"big-collection-type":return void(t.model=new ie(t.type.model));case"reference-type":return void(t.model=new ce(t.type.model));default:return}}}).traverse(t)}static _processSchema(e,t){let n;const s={};let i=[...t.names];for(const e of t.items)switch(e.kind){case"schema-field":{const t=e;if(s[t.name])throw new It(t.location,`Duplicate definition of field '${t.name}'`);s[t.name]=t.type;break}case"description":if(n)throw new It(e.location,"Duplicate schema description");n=e;break;default:throw new It(e.location,`unknown parser artifact ${e.kind} while processing schema`)}for(const n of t.parents){const r=e.findSchemaByName(n);if(!r)throw new It(t.location,`Could not find parent schema '${n}'`);for(const[e,i]of Object.entries(r.fields))if(s[e]&&!Z.typesEqual(s[e],i))throw new It(t.location,`'${n}' defines incompatible type for field '${e}'`);Object.assign(s,r.fields),i.push(...r.names)}i=[i[0],...i.filter(e=>e!==i[0])];const r=t.alias||i[0];if(!r)throw new It(t.location,"Schema defined without name or alias");const o=new Z(i,s,n);t.alias&&(o.isAlias=!0),e._schemas[r]=o}static _processResource(e,t){e._resources[t.name]=t.data}static _processParticle(e,t,n){if(d()(null==t.implFile||null!==t.args,"no valid body defined for this particle"),t.args||(t.args=[]),t.hasParticleArgument){const n=new It(t.location,"Particle uses deprecated argument body");n.key="hasParticleArgument",e._warnings.push(n)}t.implFile&&n&&(t.implFile=n.join(e.fileName,t.implFile));const s=e=>{for(const t of e)t.type=t.type.model,s(t.dependentConnections)};s(t.args),e._particles[t.name]=new ye(t)}static _processInterface(e,t){const n=[];for(const e of t.args){const t={name:void 0,type:void 0,direction:e.direction};"*"!==e.name&&(t.name=e.name),e.type&&(t.type=e.type.model),n.push(t)}const s=[];for(const e of t.slots)s.push({direction:e.direction,name:e.name,isRequired:e.isRequired,isSet:e.isSet});const i=new F(t.name,n,s);e._interfaces.push(i)}static _processRecipe(e,t,n){const s=e._newRecipe(t.name);this._buildRecipe(e,s,t)}static _buildRecipe(e,t,n){n.annotation&&(t.annotation=n.annotation),n.verbs&&(t.verbs=n.verbs);const s={require:n.items.filter(e=>"require"===e.kind),handles:n.items.filter(e=>"handle"===e.kind),byHandle:new Map,requireHandles:n.items.filter(e=>"requireHandle"===e.kind),byRequireHandle:new Map,particles:n.items.filter(e=>"particle"===e.kind),byParticle:new Map,slots:n.items.filter(e=>"slot"===e.kind),bySlot:new Map,byName:new Map,connections:n.items.filter(e=>"connection"===e.kind),search:n.items.find(e=>"search"===e.kind),description:n.items.find(e=>"description"===e.kind)};d()(!(s.handles.length>0&&s.requireHandles.length>0),"Inconsistent handle definitions");const i=s.handles.length>0?s.handles:s.requireHandles;for(const n of i){const i=t.newHandle(),r=n.ref||{tags:[]};if(r.id){i.id=r.id;const t=e.findStoreById(i.id);t&&i.mapToStorage(t)}else if(r.name){const t=e.findStoreByName(r.name);d()(t,`Could not find handle ${r.name}`),i.mapToStorage(t)}i.tags=r.tags,n.name&&(d()(!s.byName.has(n.name),`duplicate handle name: ${n.name}`),i.localName=n.name,s.byName.set(n.name,{item:n,handle:i})),i.fate=n.fate?n.fate:null,s.byHandle.set(i,n)}const r=(t,n)=>{switch(n.targetType){case"particle":{const s=e.findParticleByName(n.particle);if(!s)throw new It(t.location,`could not find particle '${n.particle}'`);if(null!==n.param&&!s.handleConnectionMap.has(n.param))throw new It(t.location,`param '${n.param}' is not defined by '${n.particle}'`);return new Ge(s,n.param)}case"localName":if(!s.byName.has(n.name))throw new It(t.location,`local name '${n.name}' does not exist in recipe`);if(null==n.param&&0===n.tags.length&&s.byName.get(n.name).handle)return new Xe(s.byName.get(n.name).handle);throw new It(t.location,"references to particles by local name not yet supported");case"tag":return new Ye(n.tags);default:throw new It(t.location,`endpoint ${n.targetType} not supported`)}};for(const e of s.connections){const n=r(e,e.from),s=r(e,e.to);t.newConnectionConstraint(n,s,e.direction)}s.search&&(t.search=new rt(s.search.phrase,s.search.tokens));for(const e of s.slots){const n=t.newSlot(void 0);e.ref=e.ref||{},e.ref.id&&(n.id=e.ref.id),e.ref.tags&&(n.tags=e.ref.tags),e.name&&(d()(!s.byName.has(e.name),`Duplicate slot local name ${e.name}`),n.localName=e.name,s.byName.set(e.name,n)),s.bySlot.set(n,e)}for(const n of s.particles){const i=t.newParticle(n.ref.name);if(i.tags=n.ref.tags,i.verbs=n.ref.verbs,!(t instanceof ct)&&n.ref.name){const t=e.findParticleByName(n.ref.name);if(!t)throw new It(n.location,`could not find particle ${n.ref.name}`);i.spec=t.clone()}n.name&&(d()(!s.byName.has(n.name)),i.localName=n.name,s.byName.set(n.name,{item:n,particle:i})),s.byParticle.set(i,n);for(const e of n.slotConnections){if("provide"===e.direction)throw new It(n.location,"invalid slot connection: provide slot must be dependent");let r=i.consumedSlotConnections[e.param];if(!r){if(void 0!==i.spec){if(!i.spec.slotConnections.has(e.param))throw new It(e.location,`Consumed slot '${e.param}' is not defined by '${i.name}'`);e.dependentSlotConnections.forEach(e=>{if(!i.getSlotSpecByName(e.param))throw new It(e.location,`Provided slot '${e.param}' is not defined by '${i.name}'`)})}r=i.addSlotConnection(e.param)}r.tags=e.tags||[],e.dependentSlotConnections.forEach(e=>{if("consume"===e.direction)throw new It(n.location,"invalid slot connection: consume slot must not be dependent");if(0!==e.dependentSlotConnections.length)throw new It(n.location,"invalid slot connection: provide slot must not have dependencies");if(t instanceof ct){const n=t.parent.slots.find(t=>t.localName===e.name);void 0!==n&&(r.providedSlots[e.param]=n,n.sourceConnection=r,n.name=e.param)}let i=r.providedSlots[e.param];if(i){if(e.name)if(s.byName.has(e.name)){const n=s.byName.get(e.name);d()(n!==i),d()(!n.name&&i),d()(!n.sourceConnection&&i.sourceConnection),i.id=n.id,i.tags=n.tags,s.byName.set(e.name,i),t.removeSlot(n)}else s.byName.set(e.name,i);s.bySlot.set(i,e)}else i=s.byName.get(e.name);i||((i=t.newSlot(e.param)).localName=e.name,i.sourceConnection=r,e.name&&(d()(!s.byName.has(e.name)),s.byName.set(e.name,i)),s.bySlot.set(i,e)),r.providedSlots[e.param]||(r.providedSlots[e.param]=i),i.localName=e.name})}}for(const[n,i]of s.byParticle){for(const r of i.connections){let i;"*"===r.param?i=n.addUnnamedConnection():(i=n.connections[r.param])||(i=n.addConnectionName(r.param)),i.tags=r.target?r.target.tags:[];const o={"->":"out","<-":"in","=":"inout",consume:"`consume",provide:"`provide"}[r.dir];if(i.direction){if(!(i.direction===o||"inout"===o||"host"===i.direction&&"in"===o||"`consume"===i.direction&&"in"===o||"`provide"===i.direction&&"out"===o))throw new It(r.location,`'${r.dir}' not compatible with '${i.direction}' param of '${n.name}'`)}else{if("*"!==r.param&&void 0!==n.spec)throw new It(r.location,`param '${r.param}' is not defined by '${n.name}'`);i.direction=o}let a,c;if(r.target&&r.target.name){let e=s.byName.get(r.target.name);if(e){if(!e.item)throw new It(r.location,`did not expect ${e} expected handle or particle`)}else{const n=t.newHandle();n.tags=[],n.localName=r.target.name,n.fate="create",n.item={kind:"handle"},e={item:n.item,handle:n},s.byName.set(n.localName,e),s.byHandle.set(n,n.item)}if("handle"===e.item.kind||"requireHandle"===e.item.kind)a=e.handle;else{if("particle"!==e.item.kind)throw new It(r.location,`did not expect ${e.item.kind}`);c=e.particle}}if(r.target&&r.target.particle){const t=e.findParticleByName(r.target.particle);if(!t)throw new It(r.target.location,`Could not find hosted particle '${r.target.particle}'`);if(!(a=ht.constructImmediateValueHandle(i,t,e.generateID())))throw new It(r.target.location,`Hosted particle '${t.name}' does not match interface '${i.name}'`)}if(c){let e;r.target.param?(e=c.connections[r.target.param])||(e=c.addConnectionName(r.target.param)):e=c.addUnnamedConnection(),(a=e.handle)||(a=t.newHandle(),e.connectToHandle(a))}a&&i.connectToHandle(a)}for(const e of i.slotConnections){let i=s.byName.get(e.name);i?(d()(s.bySlot.has(i)),i.name||(i.name=e.param),d()(i===s.byName.get(e.name),`Target slot ${i.name} doesn't match slot connection ${e.param}`)):e.name&&(t instanceof ct&&void 0!==(i=t.parent.slots.find(t=>t.localName===e.name))&&(s.bySlot.set(i,e),e.name&&s.byName.set(e.name,i)),null==i&&((i=t.newSlot(e.param)).localName=e.name,s.byName.set(e.name,i),s.bySlot.set(i,e))),i&&n.consumedSlotConnections[e.param].connectToSlot(i)}}if(s.description&&s.description.description&&(t.description=s.description.description),s.require)for(const n of s.require){const s=t.newRequireSection();this._buildRecipe(e,s,n)}}resolveTypeName(e){const t=this.findSchemaByName(e);if(t)return{schema:t};const n=this.findInterfaceByName(e);return n?{iface:n}:null}static async _processStore(e,t,n){const s=t.name;let i=t.id;const r=t.originalId,o=t.type.model;null==i&&(i=`${e._id}store${e._stores.length}`);let a,c,l,h,u=t.tags;if(null==u&&(u=[]),"storage"===t.origin)return void e.newStorageStub(o,s,i,t.source,u,r);if("file"===t.origin)t.source=n.join(e.fileName,t.source),a=await n.loadResource(t.source);else if("resource"===t.origin&&(c=t.source,null==(a=e.resources[c])))throw new It(t.location,`Resource '${c}' referenced by store '${i}' is not defined in this manifest`);try{l=JSON.parse(a)}catch(e){throw new It(t.location,`Error parsing JSON from '${c}' (${e.message})'`)}if(o instanceof se)h=o.collectionType;else if(o instanceof ie)h=o.bigCollectionType;else{if(0===l.length)return void await At._createStore(e,o,s,i,u,t,r);l=l.slice(l.length-1),h=o}if(h instanceof te){let n=!1;if(l=l.map(t=>{if(null==t)return null;n=n||t.$id;const s=t.$id||e.generateID().toString();return delete t.$id,{id:s,rawData:t}}),!t.id&&!n){i=`${i}:${await Ve(JSON.stringify(l.map(e=>e.rawData)))}`}}const d=t.version||0,p=await At._createStore(e,o,s,i,u,t,r);if(l.length>0&&l[0].rawData&&l[0].rawData.storageKey){let t=l[0].rawData.storageKey;t=e.findStoreByName(t).storageKey,l=l.map(({id:e,rawData:n})=>({id:e,storageKey:t}))}else l.length>0&&(p.referenceMode=!1);let f;f=o instanceof se?l.map(e=>({id:e.id,value:e,keys:new Set([e.id])})):o instanceof ie?l.map(e=>{const t=e.rawData.$index;return delete e.rawData.$index,{id:e.id,index:t,value:e,keys:new Set([e.id])}}):l.map(e=>({id:e.id,value:e})),await p.fromLiteral({version:d,model:f})}static async _createStore(e,t,n,s,i,r,o){const a=await e.createStore(t,n,s,i);return a.source=r.source,a.description=r.description,a.originalId=o,a}_newRecipe(e){const t=new at(e);return this._recipes.push(t),t}toString(e){e=e||{};const t=[];return this._imports.forEach(n=>{if(e.recursive){t.push(`// import '${n.fileName}'`);n.toString(e);t.push(`${n.toString(e)}`)}else t.push(`import '${n.fileName}'`)}),Object.values(this._schemas).forEach(e=>{t.push(e.toManifestString())}),Object.values(this._particles).forEach(e=>{t.push(e.toString())}),this._recipes.forEach(n=>{t.push(n.toString(e))}),[...this.stores].sort(Je).forEach(e=>{t.push(e.toString(this.storeTags.get(e).map(e=>`#${e}`)))}),t.join("\n")}get idGeneratorForTesting(){return this._idGenerator}}
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const jt=i()(process.argv.slice(2),{string:["output"],boolean:["verbose","help"],alias:{o:"output",v:"verbose"},default:{output:"bundle.zip",verbose:!1}});(jt.help||0===jt._.length)&&(console.log("Usage\n  $ bundle [-options] [file ...]\n\nDescription\n  Creates a zip bundle containing all transitive dependencies of an Arcs manifest.\n\nOptions\n  --output, -o   name of the created bundle, bundle.zip by default\n  --verbose, -v  list bundled files\n  --help         usage info\n\nExamples\n  $ bundle feature.recipes\n  $ bundle -v -o mybundle.zip recipes/feature.recipes recipes/extra_stuff.manifest"),process.exit()),async function(e,t,n){const s=await async function(...e){e=e.map(e=>c.a.isAbsolute(e)?e:c.a.resolve(process.cwd(),e).split(c.a.sep).join("/"));const t=new Pe,n=await Promise.all(e.map(e=>At.load(e,t))),s=new Set;n.forEach(e=>(function e(t,n){n.add(t.fileName);for(const e of t.particles)n.add(e.implFile);for(const e of t.stores)e instanceof mt&&e.source&&n.add(e.source);for(const s of t.imports)e(s,n)})(e,s));const i=[...s].sort(),r=function(e){const t=e[0],n=e[e.length-1];let s=0;for(let e=0;e<Math.min(t.length,n.length)&&t[e]===n[e];e++)"/"===t[e]&&(s=e+1);return s}(i),o=n.map(e=>e.fileName);return i.map(e=>({filePath:e,bundlePath:e.substr(r),entryPoint:o.includes(e)}))}(...e);n&&(console.log("Bundled files:"),s.forEach(e=>console.log(e.filePath))),new Promise(e=>{o.a.mkdirSync(c.a.dirname(t),{recursive:!0});const n=new h.a;for(const e of s)n.file(e.bundlePath,o.a.readFileSync(e.filePath));n.file("bundle-manifest.mf",s.filter(e=>e.entryPoint).map(e=>`entry-point: ${e.bundlePath}\n`).join("")),n.generateNodeStream({streamFiles:!0}).pipe(o.a.createWriteStream(t)).on("finish",()=>e())})}(jt._,Array.isArray(jt.o)?jt.o[0]:jt.o,jt.verbose)}]);