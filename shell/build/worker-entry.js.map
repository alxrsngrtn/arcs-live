{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./shell/source/worker-entry.js","webpack:///./runtime/ts-build/particle-execution-context.js","webpack:///(webpack)/buildin/global.js","webpack:///./runtime/ts-build/handle.js","webpack:///./runtime/ts-build/reference.js","webpack:///./platform/assert-web.js","webpack:///./runtime/ts-build/type.js","webpack:///./runtime/ts-build/schema.js","webpack:///./runtime/ts-build/recipe/type-checker.js","webpack:///./runtime/ts-build/type-variable.js","webpack:///./runtime/ts-build/entity.js","webpack:///./runtime/ts-build/symbols.js","webpack:///./runtime/ts-build/shape.js","webpack:///./runtime/ts-build/particle-spec.js","webpack:///./runtime/api-channel.js","webpack:///./runtime/ts-build/debug/outer-port-attachment.js","webpack:///./platform/sourcemapped-stacktrace-web.js","webpack:///./node_modules/sourcemapped-stacktrace/sourcemapped-stacktrace.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/source-map-consumer.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/util.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/binary-search.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/array-set.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/base64-vlq.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/base64.js","webpack:///./node_modules/sourcemapped-stacktrace/node_modules/source-map/lib/quick-sort.js","webpack:///./runtime/ts-build/debug/devtools-connection.js","webpack:///./platform/devtools-channel-web.js","webpack:///./runtime/ts-build/debug/abstract-devtools-channel.js","webpack:///./runtime/ts-build/debug/testing/devtools-channel-stub.js","webpack:///./devtools/shared/devtools-broker.js","webpack:///./runtime/ts-build/storage-proxy.js","webpack:///./runtime/ts-build/storage/crdt-collection-model.js","webpack:///./shell/source/browser-loader.js","webpack:///./runtime/ts-build/loader.js","webpack:///./platform/fs-web.js","webpack:///./platform/vm-web.js","webpack:///./platform/fetch-web.js","webpack:///./runtime/ts-build/particle.js","webpack:///./runtime/dom-particle.js","webpack:///./modalities/dom/components/xen/xen-state.js","webpack:///./runtime/ts-build/dom-particle-base.js","webpack:///./runtime/multiplexer-dom-particle.js","webpack:///./runtime/transformation-dom-particle.js","webpack:///./runtime/ts-build/converters/jsonldToManifest.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_runtime_ts_build_particle_execution_context_js__WEBPACK_IMPORTED_MODULE_0__","_browser_loader_js__WEBPACK_IMPORTED_MODULE_1__","console","log","self","onmessage","e","id","base","data","ports","global","ParticleExecutionContext","_handle_js__WEBPACK_IMPORTED_MODULE_0__","_platform_assert_web_js__WEBPACK_IMPORTED_MODULE_1__","_api_channel_js__WEBPACK_IMPORTED_MODULE_2__","_storage_proxy_js__WEBPACK_IMPORTED_MODULE_3__","[object Object]","port","idBase","loader","this","particles","_nextLocalID","pendingLoads","scheduler","keyedProxies","apiPort","setParticleExecutionContext","onDefineHandle","type","identifier","newProxy","onGetBackingStoreCallback","callback","storageKey","proxy","onCreateHandleCallback","onMapHandleCallback","onCreateSlotCallback","hostedSlotId","onInnerArcRender","transformationParticle","transformationSlotName","content","renderHostedSlot","onStop","onInstantiateParticle","spec","handles","_instantiateParticle","onSimpleCallback","onConstructArcCallback","arc","onAwaitIdle","version","idle","then","a","setTimeout","Idle","relevance","onUIEvent","particle","slotName","event","fireEvent","onStartRender","providedSlots","contentTypes","_slotByName","set","pec","handlers","Map","requestedContentTypes","Set","_isRendered","isRendered","template","size","assign","substituteSlotNamesForIds","entries","reduce","templateDictionary","templateName","templateValue","Render","keys","forEach","delete","length","slotId","replace","RegExp","f","has","push","handler","renderSlot","onStopRender","component","arcId","particleId","createHandle","hostParticle","Promise","resolve","reject","ArcCreateHandle","handle","register","mapHandle","ArcMapHandle","createSlot","hostedParticleName","hostedSlotName","handleId","ArcCreateSlot","loadRecipe","recipe","ArcLoadRecipe","undefined","GetBackingStore","constructInnerArc","ConstructInnerArc","innerArcHandle","proxies","res","clazz","loadParticleClass","capabilities","defaultCapabilitySet","handleMap","registerList","connSpec","connectionMap","isInput","isOutput","async","setHandles","idx","indexOf","splice","rMap","relevances","busy","filter","busyParticlePromises","map","all","g","Function","eval","window","Handle","Collection","Variable","BigCollection","handleFor","_reference_js__WEBPACK_IMPORTED_MODULE_0__","_symbols_js__WEBPACK_IMPORTED_MODULE_1__","_platform_assert_web_js__WEBPACK_IMPORTED_MODULE_2__","_particle_spec_js__WEBPACK_IMPORTED_MODULE_3__","_type_js__WEBPACK_IMPORTED_MODULE_4__","restore","entry","entityClass","rawData","entity","cloneData","identify","canRead","canWrite","_proxy","_particleId","options","keepSynced","notifySync","notifyUpdate","notifyDesync","exception","method","raiseSystemException","badKeys","includes","Error","isIdentified","createIdentity","generateIDComponents","dataClone","_id","kind","details","onHandleSync","_restore","update","added","add","removed","remove","originator","originatorId","onHandleUpdate","onHandleDesync","toList","list","serialization","_serialize","generateID","store","clear","model","fromLiteral","Cursor","parent","cursorId","_parent","_cursorId","cursorNext","done","cursorClose","pageSize","forward","isNaN","stream","getContainedType","entitySchema","Reference","ReferenceMode","_platform_assert_web_js__WEBPACK_IMPORTED_MODULE_0__","_type_js__WEBPACK_IMPORTED_MODULE_1__","_handle_js__WEBPACK_IMPORTED_MODULE_2__","context","storageProxy","getStorageProxy","referredType","ensureStorageProxy","super","constructor","Unstored","stored","storeReference","Stored","dereference","assert","test","message","Type","EntityType","VariableType","CollectionType","BigCollectionType","RelationType","InterfaceType","SlotType","ReferenceType","ArcInfoType","HandleInfoType","_schema_js__WEBPACK_IMPORTED_MODULE_0__","_type_variable_js__WEBPACK_IMPORTED_MODULE_1__","_shape_js__WEBPACK_IMPORTED_MODULE_2__","_recipe_type_checker_js__WEBPACK_IMPORTED_MODULE_3__","tag","variable","collection","bigCollection","relation","iface","slot","reference","literal","type1","type2","contained1","unwrapPair","_canMergeCanReadSubset","_canMergeCanWriteSuperset","canReadSubset","intersect","canWriteSuperset","union","compareTypes","hasUnresolvedVariable","variableMap","hasVariable","_applyExistenceTypeTest","isResolved","_canEnsureResolved","_isMoreSpecificThan","resolvedType","newTypeVariable","toLiteral","_hasProperty","schema","isEntity","isMoreSpecificThan","toInlineSchemaString","description","pattern","trim","JSON","stringify","isVariable","hasConstraint","maybeMergeConstraints","resolution","canEnsureResolved","maybeEnsureResolved","toLiteralIgnoringResolutions","_cloneWithResolutions","_canReadSubset","_canWriteSuperset","getEntitySchema","toPrettyString","collectionType","isCollection","primitiveType","result","mergeTypeVariablesByName","collectionOf","resolvedPrimitiveType","hasProperty","toString","plural","bigCollectionType","isBigCollection","bigCollectionOf","relationEntities","isRelation","interfaceShape","isInterface","shape","clone","isSlot","fields","fieldsString","join","isReference","isArcInfo","isHandleInfo","Schema","_recipe_type_checker_js__WEBPACK_IMPORTED_MODULE_2__","_entity_js__WEBPACK_IMPORTED_MODULE_3__","_reference_js__WEBPACK_IMPORTED_MODULE_4__","_model","desc","patterns","updateField","field","names","fieldType1","fieldType2","_typeString","types","schema1","schema2","typesEqual","otherType","otherSchema","newEntity","className","classJunk","convertToJsType","fieldType","fieldTypes","validateFieldAndTypes","op","_validateFieldAndTypes","innerType","TypeError","Array","isArray","newReference","element","userIDComponent","Proxy","target","sanitizedData","sanitizeData","sanitizeEntry","v","hideFields","results","TypeChecker","_type_js__WEBPACK_IMPORTED_MODULE_0__","baseType","newBaseTypeVariable","newVariable","concreteTypes","item","_tryMergeTypeVariable","_tryMergeConstraints","getResolution","candidate","onto","primitiveBase","primitiveOnto","tryMergeTypeVariablesWith","newInterface","isTypeContainer","handleType","direction","primitiveHandleType","primitiveConnectionType","newVar","newCollection","newBigCollection","unwrap","maybeMergeCanReadSubset","maybeMergeCanWriteSuperset","_writeConstraintsApply","_readConstraintsApply","connectionType","writtenType","readType","left","right","resolvedLeft","resolvedRight","leftType","rightType","canMergeConstraints","equals","leftIsSub","leftIsSuper","superclass","subclass","superDirection","connection","subDirection","TypeVariable","_schema_js__WEBPACK_IMPORTED_MODULE_2__","_resolution","constraint","mergedSchema","elementType","probe","Entity","components","split","Symbols","Shape","_fromLiteral","member","_toLiteral","handleFields","slotFields","slots","typeVars","isTypeVar","_cloneAndUpdate","typeVar","other","thisTypeVar","otherTypeVar","typeRef","isSet","_handlesToManifestString","_slotsToManifestString","isRequired","_equalItems","_equalSlot","otherHandles","sizeCheck","handleMatches","values","match","otherHandle","_equalHandle","handleMatch","handleList","resultType","otherSlot","otherItems","items","compareItem","otherItem","exists","copy","_updateTypeVar","shapeHandle","particleHandle","mustMatch","var","shapeSlot","particleSlot","particleSpec","cloneWithResolutions","restrictType","_restrictThis","connections","handlesMatch","particleSlots","consumedSlot","providedSlot","slotMatches","slotsMatch","matchList","choose","exclusions","thisLevel","pop","newExclusions","slice","constraints","concat","handleOptions","slotOptions","processTypeList","ConnectionSpec","SlotSpec","ProvidedSlotSpec","ParticleSpec","_recipe_type_checker_js__WEBPACK_IMPORTED_MODULE_1__","_platform_assert_web_js__WEBPACK_IMPORTED_MODULE_3__","typeVarMap","parentConnection","isOptional","tags","dependentConnections","dependentArg","dependentConnection","createConnection","slotModel","formFactor","ps","find","verbs","args","arg","inputs","outputs","validateDescription","connectionSpec","implFile","modality","instantiateDependentConnections","param","input","primaryVerb","connectionToLiteral","connectionFromLiteral","_toShape","verb","writeConnection","indent","dependent","consume","provide","cs","APIPort","PECOuterPort","PECInnerPort","_ts_build_particle_spec_js__WEBPACK_IMPORTED_MODULE_1__","_ts_build_type_js__WEBPACK_IMPORTED_MODULE_2__","_ts_build_debug_outer_port_attachment_js__WEBPACK_IMPORTED_MODULE_3__","_ts_build_debug_devtools_connection_js__WEBPACK_IMPORTED_MODULE_4__","ThingMapper","prefix","_prefix","_nextIdentifier","_idMap","_reverseIdMap","thing","requestedId","apiChannelMappingId","_newIdentifier","establishThingMapping","hasMappingForThing","identifierForThing","createMappingForThing","continuation","messagePort","_port","_mapper","_messageMap","_processMessage","_debugAttachment","_attachStack","messageCount","Direct","convert","unconvert","LocalMapped","maybeCreateMappingForThing","thingForIdentifier","Mapped","keyprimitive","valueprimitive","List","primitive","ByLiteral","_testingHook","close","messageType","cnt","_unprocessArguments","messageBody","exc","error","handlerName","handlePecMessage","stack","isInitializer","argumentTypes","argument","_processArguments","postMessage","mappingIdArg","registerInitializer","redundant","registerCall","registerRedundantInitializer","registerHandler","barrier","methodName","onceConnected","devtoolsChannel","DevToolsConnected","registerInitializerHandler","onDevToolsConnected","OuterPortAttachment","_platform_sourcemapped_stacktrace_web_js__WEBPACK_IMPORTED_MODULE_0__","_devtoolsChannel","_arcIdString","_speculative","isSpeculative","pecMsgBody","pecMsgCount","stackString","endsWith","_extractStackFrames","send","timestamp","Date","now","frameString","1","2","location","startsWith","targetClass","mapped","frame","source","sync","cacheGlobally","mapStackTrace","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","source_map_consumer","global_mapForUri","isChromeOrEdge","navigator","userAgent","toLowerCase","isFirefox","isSafari","isIE11Plus","document","documentMode","Semaphore","count","pending","incr","decr","flush","whenReady","fn","Fetcher","opts","sem","mapForUri","ajax","uri","xhr","xmlhttp","XMLHttpFactories","createXMLHTTPObject","that","onreadystatechange","readyState","open","fetchScript","onScriptLoad","absUrlRegex","status","responseText","mapUri","embeddedSourceMap","SourceMapConsumer","atob","origin","lastSlash","lastIndexOf","processSourceMaps","lines","rows","row","line","parseInt","column","origPos","originalPositionFor","formatOriginalPosition","origName","origLine","String","XMLHttpRequest","ActiveXObject","expected_fields","regex","skip_lines","fetcher","apply","util","binarySearch","ArraySet","base64VLQ","quickSort","aSourceMap","sourceMap","parse","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","getArg","sources","sourceRoot","sourcesContent","mappings","file","_version","normalize","isAbsolute","relative","_names","fromArray","_sources","_mappings","Mapping","generatedLine","generatedColumn","originalLine","originalColumn","lastOffset","_sections","url","offset","offsetLine","offsetColumn","generatedOffset","consumer","fromSourceMap","__generatedMappings","_parseMappings","__originalMappings","_charIsMappingSeparator","aStr","index","charAt","aSourceRoot","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","eachMapping","aCallback","aContext","aOrder","_generatedMappings","_originalMappings","mapping","at","allGeneratedPositionsFor","aArgs","needle","_findMapping","compareByOriginalPositions","lastColumn","smc","toArray","_sourceRoot","_generateSourcesContent","_file","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","str","segment","end","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","temp","originalMappings","decode","rest","compareByGeneratedPositionsDeflated","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","hasContentsOfAllSources","some","sc","sourceContentFor","aSource","nullOnMissing","urlParse","fileUriAbsPath","scheme","path","generatedPositionFor","j","sectionIndex","section","cmp","bias","every","generatedPosition","sectionMappings","adjustedMapping","aName","aDefaultValue","arguments","urlRegexp","dataUrlRegexp","aUrl","auth","host","urlGenerate","aParsedUrl","aPath","part","parts","up","aRoot","aPathUrl","aRootUrl","joined","level","substr","supportsNullProto","identity","isProtoString","charCodeAt","strcmp","aStr1","aStr2","toSetString","fromSetString","mappingA","mappingB","onlyCompareOriginal","onlyCompareGenerated","compareByGeneratedPositionsInflated","aHaystack","aCompare","recursiveSearch","aLow","aHigh","mid","Math","floor","_array","_set","aArray","aAllowDuplicates","len","getOwnPropertyNames","sStr","isDuplicate","aIdx","base64","encode","aValue","digit","encoded","vlq","toVLQSigned","VLQ_BASE","aIndex","aOutParam","strLen","shift","shifted","fromVLQSigned","intToCharMap","number","charCode","swap","ary","x","y","doQuickSort","comparator","low","high","round","random","randomIntInRange","pivot","q","DevtoolsConnection","DevtoolsForTests","_platform_devtools_channel_web_js__WEBPACK_IMPORTED_MODULE_1__","_testing_devtools_channel_stub_js__WEBPACK_IMPORTED_MODULE_2__","_devtools_shared_devtools_broker_js__WEBPACK_IMPORTED_MODULE_3__","channel","isConnected","onceConnectedResolve","ensure","DevtoolsChannel","_runtime_ts_build_debug_abstract_devtools_channel_js__WEBPACK_IMPORTED_MODULE_0__","addEventListener","_handleMessage","detail","messages","dispatchEvent","CustomEvent","AbstractDevtoolsChannel","debouncedMessages","debouncing","messageListeners","_flush","arcOrId","listeners","msg","listener","warn","DevtoolsChannelStub","_messages","DevtoolsBroker","root","_arcDebugPromise","_arcDebugPromiseResolve","preExistingArcs","StorageProxy","CollectionProxy","VariableProxy","BigCollectionProxy","StorageProxyScheduler","SyncState","_storage_crdt_collection_model_js__WEBPACK_IMPORTED_MODULE_1__","_type_js__WEBPACK_IMPORTED_MODULE_2__","_platform_sourcemapped_stacktrace_web_js__WEBPACK_IMPORTED_MODULE_3__","localIDComponent","listenerAttached","synchronized","none","observers","updates","baseForNewID","mappedStack","RaiseSystemException","InitializeProxy","_onUpdate","SynchronizeProxy","_onSynchronize","full","syncModel","_getModelForSync","enqueue","_synchronizeModel","_notify","_processUpdates","handleUpdate","_processUpdate","sort","b","predicate","ignored","updateIsNext","effective","localValue","getValue","HandleToList","HandleStore","HandleRemoveMultiple","getKeys","HandleRemove","HandleGet","HandleSet","HandleClear","HandleStream","StreamCursorNext","StreamCursorClose","_scheduled","_queues","_idleResolver","_idle","byHandle","_schedule","_dispatch","queue","_updateIdle","CrdtCollectionModel","newKeys","_equals","value1","value2","Boolean","BrowserLoader","_runtime_ts_build_loader_js__WEBPACK_IMPORTED_MODULE_0__","_runtime_ts_build_particle_js__WEBPACK_IMPORTED_MODULE_1__","_runtime_dom_particle_js__WEBPACK_IMPORTED_MODULE_2__","_runtime_multiplexer_dom_particle_js__WEBPACK_IMPORTED_MODULE_3__","_runtime_transformation_dom_particle_js__WEBPACK_IMPORTED_MODULE_4__","logFactory","preamble","color","html","strings","dumbCache","urlMap","_urlMap","resolved","_resolve","cacheKey","URL","href","_loadURL","macro","k","fileName","mapParticleUrl","defineParticle","particleWrapper","importScripts","logger","unwrapParticle","suffix","folder","resolver","_fetch","fetch","Particle","DomParticle","MultiplexerDomParticle","SimpleParticle","TransformationDomParticle","Loader","_platform_fs_web_js__WEBPACK_IMPORTED_MODULE_0__","_platform_vm_web_js__WEBPACK_IMPORTED_MODULE_1__","_platform_fetch_web_js__WEBPACK_IMPORTED_MODULE_2__","_particle_js__WEBPACK_IMPORTED_MODULE_4__","_dom_particle_js__WEBPACK_IMPORTED_MODULE_5__","_multiplexer_dom_particle_js__WEBPACK_IMPORTED_MODULE_6__","_reference_js__WEBPACK_IMPORTED_MODULE_7__","_transformation_dom_particle_js__WEBPACK_IMPORTED_MODULE_8__","_converters_jsonldToManifest_js__WEBPACK_IMPORTED_MODULE_9__","normalizeDots","norm","_loadFile","readFile","err","text","@id","requireParticle","src","loadResource","script","Script","filename","displayErrors","runInNewContext","newClientReference","fs","vm","local_fetch","_busy","extraData","views","bits","output","exec","bitStr","toManifestString","setDescriptionPattern","connectionName","descriptions","_modalities_dom_components_xen_xen_state_js__WEBPACK_IMPORTED_MODULE_0__","_ts_build_dom_particle_base_js__WEBPACK_IMPORTED_MODULE_1__","state","_state","props","_props","_setState","config","handleNames","slotNames","willReceiveProps","shouldRender","_views","configureHandles","_handlesToSync","_hasProps","_invalidate","_handlesToProps","_debounce","_setProps","func","delay","subkey","startBusy","doneBusy","XenStateMixin","nob","debounce","action","clearTimeout","Base","_pendingProps","_getInitialProps","_lastProps","_getInitialState","_lastState","_validator","_wouldChangeProp","_invalidateProps","_wouldChangeValue","_propsInvalid","dirty","_wouldChangeState","_async","_validate","stateArgs","_getStateArgs","_willReceiveProps","_shouldUpdate","_ensureMount","_doUpdate","_update","_didUpdate","DomParticleBase","_particle_js__WEBPACK_IMPORTED_MODULE_1__","getSlot","currentSlotName","ct","getTemplate","render","getTemplateName","setParticleDescription","handleName","entities","idMap","rawDataArray","raw","box","userid","getUserID","_transformation_dom_particle_js__WEBPACK_IMPORTED_MODULE_2__","_itemSubIdByHostedSlotId","_connByHostedConn","listHandleName","particleHandleName","hostedParticle","otherMappedHandles","otherConnections","skipConnectionNames","hostedOtherConnection","conn","isCompatibleType","handleIds","_mapParticleConnections","setState","getListEntries","resolvedHostedParticle","itemHandlePromise","itemHandle","renderParticleSpec","constructInnerRecipe","subId","renderModel","listIndex","findIndex","hostedConn","forceRenderTemplate","_dom_particle_js__WEBPACK_IMPORTED_MODULE_0__","combineHostedTemplate","combineHostedModel","propsValues","JsonldToManifest","supportedTypes","jsonld","theClass","obj","classes","properties","subClass","subclasses","relevantProperties","domains","superNames","superName"],"mappings":"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","file":"shell/build/worker-entry.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {ParticleExecutionContext} from '../../runtime/ts-build/particle-execution-context.js';\nimport {BrowserLoader} from './browser-loader.js';\n\nconst log = console.log.bind(console, `%cworker-entry`, `background: #12005e; color: white; padding: 1px 6px 2px 7px; border-radius: 6px;`);\n\nself.onmessage = function(e) {\n  self.onmessage = null;\n  const {id, base} = e.data;\n  //log('starting worker', id);\n  new ParticleExecutionContext(e.ports[0], id, new BrowserLoader(base));\n};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { handleFor } from './handle.js';\nimport { assert } from '../../platform/assert-web.js';\nimport { PECInnerPort } from '../api-channel.js';\nimport { StorageProxy, StorageProxyScheduler } from './storage-proxy.js';\nexport class ParticleExecutionContext {\n    constructor(port, idBase, loader) {\n        this.particles = [];\n        this._nextLocalID = 0;\n        this.pendingLoads = [];\n        this.scheduler = new StorageProxyScheduler();\n        this.keyedProxies = {};\n        this.apiPort = new PECInnerPort(port);\n        this.idBase = idBase;\n        this.loader = loader;\n        loader.setParticleExecutionContext(this);\n        /*\n         * This code ensures that the relevant types are known\n         * in the scope object, because otherwise we can't do\n         * particleSpec resolution, which is currently a necessary\n         * part of particle construction.\n         *\n         * Possibly we should eventually consider having particle\n         * specifications separated from particle classes - and\n         * only keeping type information on the arc side.\n         */\n        this.apiPort.onDefineHandle = ({ type, identifier, name }) => {\n            return StorageProxy.newProxy(identifier, type, this.apiPort, this, this.scheduler, name);\n        };\n        this.apiPort.onGetBackingStoreCallback = ({ type, id, name, callback, storageKey }) => {\n            const proxy = StorageProxy.newProxy(id, type, this.apiPort, this, this.scheduler, name);\n            proxy.storageKey = storageKey;\n            return [proxy, () => callback(proxy, storageKey)];\n        };\n        this.apiPort.onCreateHandleCallback = ({ type, id, name, callback }) => {\n            const proxy = StorageProxy.newProxy(id, type, this.apiPort, this, this.scheduler, name);\n            return [proxy, () => callback(proxy)];\n        };\n        this.apiPort.onMapHandleCallback = ({ id, callback }) => {\n            return [id, () => callback(id)];\n        };\n        this.apiPort.onCreateSlotCallback = ({ hostedSlotId, callback }) => {\n            return [hostedSlotId, () => callback(hostedSlotId)];\n        };\n        this.apiPort.onInnerArcRender = ({ transformationParticle, transformationSlotName, hostedSlotId, content }) => {\n            transformationParticle.renderHostedSlot(transformationSlotName, hostedSlotId, content);\n        };\n        this.apiPort.onStop = () => {\n            if (global['close']) {\n                global['close']();\n            }\n        };\n        this.apiPort.onInstantiateParticle =\n            ({ id, spec, handles }) => this._instantiateParticle(id, spec, handles);\n        this.apiPort.onSimpleCallback = ({ callback, data }) => callback(data);\n        this.apiPort.onConstructArcCallback = ({ callback, arc }) => callback(arc);\n        this.apiPort.onAwaitIdle = ({ version }) => this.idle.then(a => {\n            // TODO: dom-particles update is async, this is a workaround to allow dom-particles to\n            // update relevance, after handles are updated. Needs better idle signal.\n            setTimeout(() => { this.apiPort.Idle({ version, relevance: this.relevance }); }, 0);\n        });\n        this.apiPort.onUIEvent = ({ particle, slotName, event }) => particle.fireEvent(slotName, event);\n        this.apiPort.onStartRender = ({ particle, slotName, providedSlots, contentTypes }) => {\n            /**\n             * A representation of a consumed slot. Retrieved from a particle using\n             * particle.getSlot(name)\n             */\n            class Slotlet {\n                constructor(pec, particle, slotName, providedSlots) {\n                    this.handlers = new Map();\n                    this.requestedContentTypes = new Set();\n                    this._isRendered = false;\n                    this.slotName = slotName;\n                    this.particle = particle;\n                    this.pec = pec;\n                    this.providedSlots = providedSlots;\n                }\n                get isRendered() { return this._isRendered; }\n                /**\n                 * renders content to the slot.\n                 */\n                render(content) {\n                    if (content.template && this.providedSlots.size > 0) {\n                        content = Object.assign({}, content);\n                        if (typeof content.template === 'string') {\n                            content.template = this.substituteSlotNamesForIds(content.template);\n                        }\n                        else {\n                            content.template = Object.entries(content.template).reduce((templateDictionary, [templateName, templateValue]) => {\n                                templateDictionary[templateName] = this.substituteSlotNamesForIds(templateValue);\n                                return templateDictionary;\n                            }, {});\n                        }\n                    }\n                    this.pec.apiPort.Render({ particle, slotName, content });\n                    Object.keys(content).forEach(key => { this.requestedContentTypes.delete(key); });\n                    // Slot is considered rendered, if a non-empty content was sent and all requested content types were fullfilled.\n                    this._isRendered = this.requestedContentTypes.size === 0 && (Object.keys(content).length > 0);\n                }\n                substituteSlotNamesForIds(template) {\n                    this.providedSlots.forEach((slotId, slotName) => {\n                        // TODO: This is a simple string replacement right now,\n                        // ensuring that 'slotid' is an attribute on an HTML element would be an improvement.\n                        template = template.replace(new RegExp(`slotid=\\\"${slotName}\\\"`, 'gi'), `slotid=\"${slotId}\"`);\n                    });\n                    return template;\n                }\n                /**\n                 * registers a callback to be invoked when 'name' event happens.\n                 */\n                registerEventHandler(name, f) {\n                    if (!this.handlers.has(name)) {\n                        this.handlers.set(name, []);\n                    }\n                    this.handlers.get(name).push(f);\n                }\n                clearEventHandlers(name) {\n                    this.handlers.set(name, []);\n                }\n                fireEvent(event) {\n                    for (const handler of this.handlers.get(event.handler) || []) {\n                        handler(event);\n                    }\n                }\n            }\n            particle._slotByName.set(slotName, new Slotlet(this, particle, slotName, providedSlots));\n            particle.renderSlot(slotName, contentTypes);\n        };\n        this.apiPort.onStopRender = ({ particle, slotName }) => {\n            assert(particle._slotByName.has(slotName), `Stop render called for particle ${particle.name} slot ${slotName} without start render being called.`);\n            particle._slotByName.delete(slotName);\n        };\n    }\n    generateIDComponents() {\n        return { base: this.idBase, component: () => this._nextLocalID++ };\n    }\n    generateID() {\n        return `${this.idBase}:${this._nextLocalID++}`;\n    }\n    innerArcHandle(arcId, particleId) {\n        const pec = this;\n        return {\n            createHandle(type, name, hostParticle) {\n                return new Promise((resolve, reject) => pec.apiPort.ArcCreateHandle({ arc: arcId, type, name, callback: proxy => {\n                        const handle = handleFor(proxy, name, particleId);\n                        resolve(handle);\n                        if (hostParticle) {\n                            proxy.register(hostParticle, handle);\n                        }\n                    } }));\n            },\n            mapHandle(handle) {\n                return new Promise((resolve, reject) => pec.apiPort.ArcMapHandle({ arc: arcId, handle, callback: id => {\n                        resolve(id);\n                    } }));\n            },\n            createSlot(transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName, handleId) {\n                // handleId: the ID of a handle (returned by `createHandle` above) this slot is rendering; null - if not applicable.\n                // TODO: support multiple handle IDs.\n                return new Promise((resolve, reject) => pec.apiPort.ArcCreateSlot({ arc: arcId, transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName, handleId, callback: hostedSlotId => {\n                        resolve(hostedSlotId);\n                    } }));\n            },\n            loadRecipe(recipe) {\n                // TODO: do we want to return a promise on completion?\n                return new Promise((resolve, reject) => pec.apiPort.ArcLoadRecipe({\n                    arc: arcId,\n                    recipe,\n                    callback: a => {\n                        if (a == undefined) {\n                            resolve();\n                        }\n                        else {\n                            reject(a);\n                        }\n                    }\n                }));\n            }\n        };\n    }\n    getStorageProxy(storageKey, type) {\n        if (!this.keyedProxies[storageKey]) {\n            this.keyedProxies[storageKey] = new Promise((resolve, reject) => {\n                this.apiPort.GetBackingStore({ storageKey, type, callback: (proxy, storageKey) => {\n                        this.keyedProxies[storageKey] = proxy;\n                        resolve(proxy);\n                    } });\n            });\n        }\n        return this.keyedProxies[storageKey];\n    }\n    defaultCapabilitySet() {\n        return {\n            constructInnerArc: particle => {\n                return new Promise((resolve, reject) => this.apiPort.ConstructInnerArc({ callback: arcId => { resolve(this.innerArcHandle(arcId, particle.id)); }, particle }));\n            }\n        };\n    }\n    async _instantiateParticle(id, spec, proxies) {\n        const name = spec.name;\n        let resolve = null;\n        const p = new Promise(res => resolve = res);\n        this.pendingLoads.push(p);\n        const clazz = await this.loader.loadParticleClass(spec);\n        const capabilities = this.defaultCapabilitySet();\n        const particle = new clazz(); // TODO: how can i add an argument to DomParticle ctor?\n        particle.id = id;\n        particle.capabilities = capabilities;\n        this.particles.push(particle);\n        const handleMap = new Map();\n        const registerList = [];\n        proxies.forEach((proxy, name) => {\n            const connSpec = spec.connectionMap.get(name);\n            const handle = handleFor(proxy, name, id, connSpec.isInput, connSpec.isOutput);\n            handleMap.set(name, handle);\n            // Defer registration of handles with proxies until after particles have a chance to\n            // configure them in setHandles.\n            registerList.push({ proxy, particle, handle });\n        });\n        return [particle, async () => {\n                await particle.setHandles(handleMap);\n                registerList.forEach(({ proxy, particle, handle }) => proxy.register(particle, handle));\n                const idx = this.pendingLoads.indexOf(p);\n                this.pendingLoads.splice(idx, 1);\n                resolve();\n            }];\n    }\n    get relevance() {\n        const rMap = new Map();\n        this.particles.forEach(p => {\n            if (p.relevances.length === 0) {\n                return;\n            }\n            rMap.set(p, p.relevances);\n            p.relevances = [];\n        });\n        return rMap;\n    }\n    get busy() {\n        if (this.pendingLoads.length > 0 || this.scheduler.busy) {\n            return true;\n        }\n        if (this.particles.filter(particle => particle.busy).length > 0) {\n            return true;\n        }\n        return false;\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        const busyParticlePromises = this.particles.filter(particle => particle.busy).map(particle => particle.idle);\n        return Promise.all([this.scheduler.idle, ...this.pendingLoads, ...busyParticlePromises]).then(() => this.idle);\n    }\n}\n//# sourceMappingURL=particle-execution-context.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/** @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Reference } from './reference.js';\nimport { Symbols } from './symbols.js';\nimport { assert } from '../../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { EntityType, CollectionType, BigCollectionType, InterfaceType, ReferenceType } from './type.js';\n// TODO: This won't be needed once runtime is transferred between contexts.\nfunction cloneData(data) {\n    return data;\n    //return JSON.parse(JSON.stringify(data));\n}\nfunction restore(entry, entityClass) {\n    assert(entityClass, 'Handles need entity classes for deserialization');\n    const { id, rawData } = entry;\n    const entity = new entityClass(cloneData(rawData));\n    if (entry.id) {\n        entity.identify(entry.id);\n    }\n    // TODO some relation magic, somewhere, at some point.\n    return entity;\n}\n/** @class Handle\n * Base class for Collections and Variables.\n */\nexport class Handle {\n    // TODO type particleId, marked as string, but called with number\n    constructor(proxy, name, particleId, canRead, canWrite) {\n        assert(!(proxy instanceof Handle));\n        this._proxy = proxy;\n        this.name = name || this._proxy.name;\n        this.canRead = canRead;\n        this.canWrite = canWrite;\n        this._particleId = particleId;\n        this.options = {\n            keepSynced: true,\n            notifySync: true,\n            notifyUpdate: true,\n            notifyDesync: false,\n        };\n    }\n    raiseSystemException(exception, method) {\n        this._proxy.raiseSystemException(exception, method, this._particleId);\n    }\n    // `options` may contain any of:\n    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required\n    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received\n    // - notifyUpdate (bool): call onHandleUpdate for every change event received\n    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected\n    configure(options) {\n        assert(this.canRead, 'configure can only be called on readable Handles');\n        try {\n            const keys = Object.keys(this.options);\n            const badKeys = Object.keys(options).filter(o => !keys.includes(o));\n            if (badKeys.length > 0) {\n                throw new Error(`Invalid option in Handle.configure(): ${badKeys}`);\n            }\n            Object.assign(this.options, options);\n        }\n        catch (e) {\n            this.raiseSystemException(e, 'Handle::configure');\n            throw e;\n        }\n    }\n    _serialize(entity) {\n        assert(entity, 'can\\'t serialize a null entity');\n        if (!entity.isIdentified()) {\n            entity.createIdentity(this._proxy.generateIDComponents());\n        }\n        const id = entity[Symbols.identifier];\n        const rawData = entity.dataClone();\n        return {\n            id,\n            rawData\n        };\n    }\n    get type() {\n        return this._proxy.type;\n    }\n    get _id() {\n        return this._proxy.id;\n    }\n    toManifestString() {\n        return `'${this._id}'`;\n    }\n}\n/**\n * A handle on a set of Entity data. Note that, as a set, a Collection can only\n * contain a single version of an Entity for each given ID. Further, no order is\n * implied by the set. A particle's manifest dictates the types of handles that\n * need to be connected to that particle, and the current recipe identifies\n * which handles are connected.\n */\nexport class Collection extends Handle {\n    _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                particle.onHandleSync(this, this._restore(details));\n                return;\n            case 'update': {\n                // tslint:disable-next-line: no-any\n                const update = {};\n                if ('add' in details) {\n                    update.added = this._restore(details.add);\n                }\n                if ('remove' in details) {\n                    update.removed = this._restore(details.remove);\n                }\n                update.originator = details.originatorId === this._particleId;\n                particle.onHandleUpdate(this, update);\n                return;\n            }\n            case 'desync':\n                particle.onHandleDesync(this);\n                return;\n            default:\n                throw new Error('unsupported');\n        }\n    }\n    /**\n     * Returns the Entity specified by id contained by the handle, or null if this id is not\n     * contained by the handle.\n     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async get(id) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        return this._restore([await this._proxy.get(id, this._particleId)])[0];\n    }\n    /**\n     * @returns a list of the Entities contained by the handle.\n     * @throws {Error} if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async toList() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        return this._restore(await this._proxy.toList());\n    }\n    _restore(list) {\n        return (list !== null) ? list.map(a => restore(a, this.entityClass)) : null;\n    }\n    /**\n     * Stores a new entity into the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async store(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        const keys = [this._proxy.generateID() + 'key'];\n        return this._proxy.store(serialization, keys, this._particleId);\n    }\n    /**\n     * Removes all known entities from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        return this._proxy.clear(this._particleId);\n    }\n    /**\n     * Removes an entity from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        // Remove the keys that exist at storage/proxy.\n        const keys = [];\n        this._proxy.remove(serialization.id, keys, this._particleId);\n    }\n}\n/**\n * A handle on a single entity. A particle's manifest dictates\n * the types of handles that need to be connected to that particle, and\n * the current recipe identifies which handles are connected.\n */\nexport class Variable extends Handle {\n    // Called by StorageProxy.\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                try {\n                    await particle.onHandleSync(this, this._restore(details));\n                }\n                catch (e) {\n                    this.raiseSystemException(e, `${particle.spec.name}::onHandleSync`);\n                }\n                return;\n            case 'update': {\n                try {\n                    await particle.onHandleUpdate(this, { data: this._restore(details.data) });\n                }\n                catch (e) {\n                    this.raiseSystemException(e, `${particle.spec.name}::onHandleUpdate`);\n                }\n                return;\n            }\n            case 'desync':\n                try {\n                    await particle.onHandleDesync(this);\n                }\n                catch (e) {\n                    this.raiseSystemException(e, `${particle.spec.name}::onHandleDesync`);\n                }\n                return;\n            default:\n                throw new Error('unsupported');\n        }\n    }\n    /**\n     * @returns the Entity contained by the Variable, or undefined if the Variable\n     * is cleared.\n     * @throws {Error} if this variable is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async get() {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        const model = await this._proxy.get();\n        return this._restore(model);\n    }\n    _restore(model) {\n        if (model === null) {\n            return null;\n        }\n        if (this.type instanceof EntityType) {\n            return restore(model, this.entityClass);\n        }\n        if (this.type instanceof InterfaceType) {\n            return ParticleSpec.fromLiteral(model);\n        }\n        if (this.type instanceof ReferenceType) {\n            return new Reference(model, this.type, this._proxy.pec);\n        }\n        assert(false, `Don't know how to deliver handle data of type ${this.type}`);\n    }\n    /**\n     * Stores a new entity into the Variable, replacing any existing entity.\n     * @throws {Error} if this variable is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async set(entity) {\n        try {\n            if (!this.canWrite) {\n                throw new Error('Handle not writeable');\n            }\n            return this._proxy.set(this._serialize(entity), this._particleId);\n        }\n        catch (e) {\n            this.raiseSystemException(e, 'Handle::set');\n            throw e;\n        }\n    }\n    /**\n     * Clears any entity currently in the Variable.\n     * @throws {Error} if this variable is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async clear() {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        return this._proxy.clear(this._particleId);\n    }\n}\n/**\n * Provides paginated read access to a BigCollection. Conforms to the javascript iterator protocol\n * but is not marked as iterable because next() is async, which is currently not supported by\n * implicit iteration in Javascript.\n */\nclass Cursor {\n    constructor(parent, cursorId) {\n        this._parent = parent;\n        this._cursorId = cursorId;\n    }\n    /**\n     * Returns {value: [items], done: false} while there are items still available, or {done: true}\n     * when the cursor has completed reading the collection.\n     */\n    async next() {\n        const data = await this._parent._proxy.cursorNext(this._cursorId);\n        if (!data.done) {\n            data.value = data.value.map(a => restore(a, this._parent.entityClass));\n        }\n        return data;\n    }\n    /**\n     * Terminates the streamed read. This must be called if a cursor is no longer needed but has not\n     * yet completed streaming (i.e. next() hasn't returned {done: true}).\n     */\n    close() {\n        this._parent._proxy.cursorClose(this._cursorId);\n    }\n}\n/**\n * A handle on a large set of Entity data. Similar to Collection, except the complete set of\n * entities is not available directly; use stream() to read the full set. Particles wanting to\n * operate on BigCollections should do so in the setHandles() call, since BigCollections do not\n * trigger onHandleSync() or onHandleUpdate().\n */\nexport class BigCollection extends Handle {\n    configure(options) {\n        throw new Error('BigCollections do not support sync/update configuration');\n    }\n    async _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        assert(kind === 'sync', 'BigCollection._notify only supports sync events');\n        await particle.onHandleSync(this, []);\n    }\n    /**\n     * Stores a new entity into the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async store(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        const keys = [this._proxy.generateID() + 'key'];\n        return this._proxy.store(serialization, keys, this._particleId);\n    }\n    /**\n     * Removes an entity from the Handle.\n     * @throws {Error} if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n     * in the particle's manifest.\n     */\n    async remove(entity) {\n        if (!this.canWrite) {\n            throw new Error('Handle not writeable');\n        }\n        const serialization = this._serialize(entity);\n        this._proxy.remove(serialization.id, this._particleId);\n    }\n    /**\n     * @returns a Cursor instance that iterates over the full set of entities, reading `pageSize`\n     * entities at a time. The cursor views a snapshot of the collection, locked to the version\n     * at which the cursor is created.\n     *\n     * By default items are returned in order of original insertion into the collection (with the\n     * caveat that items removed during a streamed read may be returned at the end). Set `forward`\n     * to false to return items in reverse insertion order.\n     *\n     * @throws {Error} if this variable is not configured as a readable handle (i.e. 'in' or 'inout')\n     * in the particle's manifest.\n     */\n    async stream({ pageSize, forward = true }) {\n        if (!this.canRead) {\n            throw new Error('Handle not readable');\n        }\n        if (isNaN(pageSize) || pageSize < 1) {\n            throw new Error('Streamed reads require a positive pageSize');\n        }\n        const cursorId = await this._proxy.stream(pageSize, forward);\n        return new Cursor(this, cursorId);\n    }\n}\nexport function handleFor(proxy, name = null, particleId = 0, canRead = true, canWrite = true) {\n    let handle;\n    if (proxy.type instanceof CollectionType) {\n        handle = new Collection(proxy, name, particleId, canRead, canWrite);\n    }\n    else if (proxy.type instanceof BigCollectionType) {\n        handle = new BigCollection(proxy, name, particleId, canRead, canWrite);\n    }\n    else {\n        handle = new Variable(proxy, name, particleId, canRead, canWrite);\n    }\n    const type = proxy.type.getContainedType() || proxy.type;\n    if (type instanceof EntityType) {\n        handle.entityClass = type.entitySchema.entityClass(proxy.pec);\n    }\n    return handle;\n}\n//# sourceMappingURL=handle.js.map","/** @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nimport { ReferenceType } from './type.js';\nimport { handleFor } from './handle.js';\nvar ReferenceMode;\n(function (ReferenceMode) {\n    ReferenceMode[ReferenceMode[\"Unstored\"] = 0] = \"Unstored\";\n    ReferenceMode[ReferenceMode[\"Stored\"] = 1] = \"Stored\";\n})(ReferenceMode || (ReferenceMode = {}));\nexport class Reference {\n    constructor(data, type, context) {\n        this.entity = null;\n        this.storageProxy = null;\n        this.handle = null;\n        this.id = data.id;\n        this.storageKey = data.storageKey;\n        this.context = context;\n        this.type = type;\n    }\n    async ensureStorageProxy() {\n        if (this.storageProxy == null) {\n            this.storageProxy = await this.context.getStorageProxy(this.storageKey, this.type.referredType);\n            this.handle = handleFor(this.storageProxy);\n            if (this.storageKey) {\n                assert(this.storageKey === this.storageProxy.storageKey);\n            }\n            else {\n                this.storageKey = this.storageProxy.storageKey;\n            }\n        }\n    }\n    async dereference() {\n        assert(this.context, \"Must have context to dereference\");\n        if (this.entity) {\n            return this.entity;\n        }\n        await this.ensureStorageProxy();\n        this.entity = await this.handle.get(this.id);\n        return this.entity;\n    }\n    dataClone() {\n        return { storageKey: this.storageKey, id: this.id };\n    }\n    static newClientReference(context) {\n        return class extends Reference {\n            constructor(entity) {\n                // TODO(shans): start carrying storageKey information around on Entity objects\n                super({ id: entity.id, storageKey: null }, new ReferenceType(entity.constructor.type), context);\n                this.mode = ReferenceMode.Unstored;\n                this.entity = entity;\n                this.stored = new Promise(async (resolve, reject) => {\n                    await this.storeReference(entity);\n                    resolve();\n                });\n            }\n            async storeReference(entity) {\n                await this.ensureStorageProxy();\n                await this.handle.store(entity);\n                this.mode = ReferenceMode.Stored;\n            }\n            async dereference() {\n                if (this.mode === ReferenceMode.Unstored) {\n                    return null;\n                }\n                return super.dereference();\n            }\n            isIdentified() {\n                return this.entity.isIdentified();\n            }\n        };\n    }\n}\n//# sourceMappingURL=reference.js.map","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport function assert(test, message) {\n  if (!test) {\n    debugger; // eslint-disable-line no-debugger\n    throw new Error(message);\n  }\n}\n","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { Schema } from './schema.js';\nimport { TypeVariable } from './type-variable.js';\nimport { Shape } from './shape.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nexport class Type {\n    constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n    }\n    // TODO: remove these; callers can directly construct the classes now\n    static newEntity(entity) {\n        return new EntityType(entity);\n    }\n    static newVariable(variable) {\n        return new VariableType(variable);\n    }\n    static newCollection(collection) {\n        return new CollectionType(collection);\n    }\n    static newBigCollection(bigCollection) {\n        return new BigCollectionType(bigCollection);\n    }\n    static newRelation(relation) {\n        return new RelationType(relation);\n    }\n    static newInterface(iface) {\n        return new InterfaceType(iface);\n    }\n    static newSlot(slot) {\n        return new SlotType(slot);\n    }\n    static newReference(reference) {\n        return new ReferenceType(reference);\n    }\n    static newArcInfo() {\n        return new ArcInfoType();\n    }\n    static newHandleInfo() {\n        return new HandleInfoType();\n    }\n    static fromLiteral(literal) {\n        switch (literal.tag) {\n            case 'Entity':\n                return new EntityType(Schema.fromLiteral(literal.data));\n            case 'Variable':\n                return new VariableType(TypeVariable.fromLiteral(literal.data));\n            case 'Collection':\n                return new CollectionType(Type.fromLiteral(literal.data));\n            case 'BigCollection':\n                return new BigCollectionType(Type.fromLiteral(literal.data));\n            case 'Relation':\n                return new RelationType(literal.data);\n            case 'Interface':\n                return new InterfaceType(Shape.fromLiteral(literal.data));\n            case 'Slot':\n                return new SlotType(literal.data);\n            case 'Reference':\n                return new ReferenceType(Type.fromLiteral(literal.data));\n            case 'ArcInfo':\n                return new ArcInfoType();\n            case 'HandleInfo':\n                return new HandleInfoType();\n            default:\n                throw new Error(`fromLiteral: unknown type ${literal}`);\n        }\n    }\n    static unwrapPair(type1, type2) {\n        if (type1.tag === type2.tag) {\n            const contained1 = type1.getContainedType();\n            if (contained1 !== null) {\n                return Type.unwrapPair(contained1, type2.getContainedType());\n            }\n        }\n        return [type1, type2];\n    }\n    /** Tests whether two types' constraints are compatible with each other. */\n    static canMergeConstraints(type1, type2) {\n        return Type._canMergeCanReadSubset(type1, type2) && Type._canMergeCanWriteSuperset(type1, type2);\n    }\n    static _canMergeCanReadSubset(type1, type2) {\n        if (type1.canReadSubset && type2.canReadSubset) {\n            if (type1.canReadSubset.tag !== type2.canReadSubset.tag) {\n                return false;\n            }\n            if (type1.canReadSubset instanceof EntityType) {\n                return Schema.intersect(type1.canReadSubset.entitySchema, type2.canReadSubset.entitySchema) !== null;\n            }\n            throw new Error(`_canMergeCanReadSubset not implemented for types tagged with ${type1.canReadSubset.tag}`);\n        }\n        return true;\n    }\n    static _canMergeCanWriteSuperset(type1, type2) {\n        if (type1.canWriteSuperset && type2.canWriteSuperset) {\n            if (type1.canWriteSuperset.tag !== type2.canWriteSuperset.tag) {\n                return false;\n            }\n            if (type1.canWriteSuperset instanceof EntityType) {\n                return Schema.union(type1.canWriteSuperset.entitySchema, type2.canWriteSuperset.entitySchema) !== null;\n            }\n        }\n        return true;\n    }\n    // TODO: update call sites to use the type checker instead (since they will\n    // have additional information about direction etc.)\n    equals(type) {\n        return TypeChecker.compareTypes({ type: this }, { type });\n    }\n    isResolved() {\n        // TODO: one of these should not exist.\n        return !this.hasUnresolvedVariable;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        return this;\n    }\n    _applyExistenceTypeTest(test) {\n        return test(this);\n    }\n    get hasVariable() {\n        return this._applyExistenceTypeTest(type => type instanceof VariableType);\n    }\n    get hasUnresolvedVariable() {\n        return this._applyExistenceTypeTest(type => type instanceof VariableType && !type.variable.isResolved());\n    }\n    primitiveType() {\n        return null;\n    }\n    getContainedType() {\n        return null;\n    }\n    isTypeContainer() {\n        return false;\n    }\n    collectionOf() {\n        return new CollectionType(this);\n    }\n    bigCollectionOf() {\n        return new BigCollectionType(this);\n    }\n    resolvedType() {\n        return this;\n    }\n    canEnsureResolved() {\n        return this.isResolved() || this._canEnsureResolved();\n    }\n    _canEnsureResolved() {\n        return true;\n    }\n    maybeEnsureResolved() {\n        return true;\n    }\n    get canWriteSuperset() {\n        throw new Error(`canWriteSuperset not implemented for ${this}`);\n    }\n    get canReadSubset() {\n        throw new Error(`canReadSubset not implemented for ${this}`);\n    }\n    isMoreSpecificThan(type) {\n        return this.tag === type.tag && this._isMoreSpecificThan(type);\n    }\n    _isMoreSpecificThan(type) {\n        throw new Error(`isMoreSpecificThan not implemented for ${this}`);\n    }\n    /**\n     * Clone a type object.\n     * When cloning multiple types, variables that were associated with the same name\n     * before cloning should still be associated after cloning. To maintain this\n     * property, create a Map() and pass it into all clone calls in the group.\n     */\n    clone(variableMap) {\n        // TODO: clean this up\n        const type = this.resolvedType();\n        if (type instanceof VariableType) {\n            if (variableMap.has(type.variable)) {\n                return new VariableType(variableMap.get(type.variable));\n            }\n            else {\n                const newTypeVariable = TypeVariable.fromLiteral(type.variable.toLiteral());\n                variableMap.set(type.variable, newTypeVariable);\n                return new VariableType(newTypeVariable);\n            }\n        }\n        if (type.data['clone']) {\n            return Type.fromLiteral({ tag: type.tag, data: type.data['clone'](variableMap) });\n        }\n        return Type.fromLiteral(type.toLiteral());\n    }\n    /**\n     * Clone a type object, maintaining resolution information.\n     * This function SHOULD NOT BE USED at the type level. In order for type variable\n     * information to be maintained correctly, an entire context root needs to be\n     * cloned.\n     */\n    _cloneWithResolutions(variableMap) {\n        return Type.fromLiteral(this.toLiteral());\n    }\n    // tslint:disable-next-line: no-any\n    toLiteral() {\n        return this;\n    }\n    // TODO: is this the same as _applyExistenceTypeTest\n    hasProperty(property) {\n        return property(this) || this._hasProperty(property);\n    }\n    _hasProperty(property) {\n        return false;\n    }\n    toString(options = undefined) {\n        return this.tag;\n    }\n    getEntitySchema() {\n        return null;\n    }\n    toPrettyString() {\n        return null;\n    }\n}\nexport class EntityType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get entitySchema() { return this.data; }\n    constructor(schema) {\n        super('Entity', schema);\n    }\n    // These type identifier methods are being left in place for non-runtime code.\n    get isEntity() {\n        return true;\n    }\n    get canWriteSuperset() {\n        return this;\n    }\n    get canReadSubset() {\n        return this;\n    }\n    _isMoreSpecificThan(type) {\n        return this.entitySchema.isMoreSpecificThan(type.entitySchema);\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.entitySchema.toLiteral() };\n    }\n    toString(options = undefined) {\n        return this.entitySchema.toInlineSchemaString(options);\n    }\n    getEntitySchema() {\n        return this.entitySchema;\n    }\n    toPrettyString() {\n        if (this.entitySchema.description.pattern) {\n            return this.entitySchema.description.pattern;\n        }\n        // Spit MyTypeFOO to My Type FOO\n        if (this.entitySchema.name) {\n            return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2')\n                .replace(/([A-Z][^A-Z])/g, ' $1')\n                .replace(/[\\s]+/g, ' ')\n                .trim();\n        }\n        return JSON.stringify(this.entitySchema.toLiteral());\n    }\n}\n// Yes, these names need fixing.\nexport class VariableType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get variable() { return this.data; }\n    constructor(variable) {\n        super('Variable', variable);\n    }\n    get isVariable() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const name = this.variable.name;\n        let variable = variableMap.get(name);\n        if (!variable) {\n            variable = this;\n            variableMap.set(name, this);\n        }\n        else if (variable instanceof VariableType) {\n            if (variable.variable.hasConstraint || this.variable.hasConstraint) {\n                const mergedConstraint = variable.variable.maybeMergeConstraints(this.variable);\n                if (!mergedConstraint) {\n                    throw new Error('could not merge type variables');\n                }\n            }\n        }\n        return variable;\n    }\n    resolvedType() {\n        return this.variable.resolution || this;\n    }\n    _canEnsureResolved() {\n        return this.variable.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.variable.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return this.variable.canWriteSuperset;\n    }\n    get canReadSubset() {\n        return this.variable.canReadSubset;\n    }\n    _cloneWithResolutions(variableMap) {\n        if (variableMap.has(this.variable)) {\n            return new VariableType(variableMap.get(this.variable));\n        }\n        else {\n            const newTypeVariable = TypeVariable.fromLiteral(this.variable.toLiteralIgnoringResolutions());\n            if (this.variable.resolution) {\n                newTypeVariable.resolution = this.variable.resolution._cloneWithResolutions(variableMap);\n            }\n            if (this.variable._canReadSubset) {\n                newTypeVariable.canReadSubset = this.variable.canReadSubset._cloneWithResolutions(variableMap);\n            }\n            if (this.variable._canWriteSuperset) {\n                newTypeVariable.canWriteSuperset = this.variable.canWriteSuperset._cloneWithResolutions(variableMap);\n            }\n            variableMap.set(this.variable, newTypeVariable);\n            return new VariableType(newTypeVariable);\n        }\n    }\n    toLiteral() {\n        return this.variable.resolution ? this.variable.resolution.toLiteral()\n            : { tag: this.tag, data: this.variable.toLiteral() };\n    }\n    toString(options = undefined) {\n        return `~${this.variable.name}`;\n    }\n    getEntitySchema() {\n        return this.variable.isResolved() ? this.resolvedType().getEntitySchema() : null;\n    }\n    toPrettyString() {\n        return this.variable.isResolved() ? this.resolvedType().toPrettyString() : `[~${this.variable.name}]`;\n    }\n}\nexport class CollectionType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get collectionType() { return this.data; }\n    constructor(collectionType) {\n        super('Collection', collectionType);\n    }\n    get isCollection() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const primitiveType = this.collectionType;\n        const result = primitiveType.mergeTypeVariablesByName(variableMap);\n        return (result === primitiveType) ? this : result.collectionOf();\n    }\n    _applyExistenceTypeTest(test) {\n        return this.collectionType._applyExistenceTypeTest(test);\n    }\n    // TODO: remove this in favor of a renamed collectionType\n    primitiveType() {\n        return this.collectionType;\n    }\n    getContainedType() {\n        return this.collectionType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const primitiveType = this.collectionType;\n        const resolvedPrimitiveType = primitiveType.resolvedType();\n        return (primitiveType !== resolvedPrimitiveType) ? resolvedPrimitiveType.collectionOf() : this;\n    }\n    _canEnsureResolved() {\n        return this.collectionType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.collectionType.maybeEnsureResolved();\n    }\n    _cloneWithResolutions(variableMap) {\n        return new CollectionType(this.collectionType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.collectionType.toLiteral() };\n    }\n    _hasProperty(property) {\n        return this.collectionType.hasProperty(property);\n    }\n    toString(options = undefined) {\n        return `[${this.collectionType.toString(options)}]`;\n    }\n    getEntitySchema() {\n        return this.collectionType.getEntitySchema();\n    }\n    toPrettyString() {\n        const entitySchema = this.getEntitySchema();\n        if (entitySchema && entitySchema.description.plural) {\n            return entitySchema.description.plural;\n        }\n        return `${this.collectionType.toPrettyString()} List`;\n    }\n}\nexport class BigCollectionType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get bigCollectionType() { return this.data; }\n    constructor(bigCollectionType) {\n        super('BigCollection', bigCollectionType);\n    }\n    get isBigCollection() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const primitiveType = this.bigCollectionType;\n        const result = primitiveType.mergeTypeVariablesByName(variableMap);\n        return (result === primitiveType) ? this : result.bigCollectionOf();\n    }\n    _applyExistenceTypeTest(test) {\n        return this.bigCollectionType._applyExistenceTypeTest(test);\n    }\n    getContainedType() {\n        return this.bigCollectionType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const primitiveType = this.bigCollectionType;\n        const resolvedPrimitiveType = primitiveType.resolvedType();\n        return (primitiveType !== resolvedPrimitiveType) ? resolvedPrimitiveType.bigCollectionOf() : this;\n    }\n    _canEnsureResolved() {\n        return this.bigCollectionType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.bigCollectionType.maybeEnsureResolved();\n    }\n    _cloneWithResolutions(variableMap) {\n        return new BigCollectionType(this.bigCollectionType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.bigCollectionType.toLiteral() };\n    }\n    _hasProperty(property) {\n        return this.bigCollectionType.hasProperty(property);\n    }\n    toString(options = undefined) {\n        return `BigCollection<${this.bigCollectionType.toString(options)}>`;\n    }\n    getEntitySchema() {\n        return this.bigCollectionType.getEntitySchema();\n    }\n    toPrettyString() {\n        const entitySchema = this.getEntitySchema();\n        if (entitySchema && entitySchema.description.plural) {\n            return entitySchema.description.plural;\n        }\n        return `Collection of ${this.bigCollectionType.toPrettyString()}`;\n    }\n}\nexport class RelationType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get relationEntities() { return this.data; }\n    constructor(relation) {\n        super('Relation', relation);\n    }\n    get isRelation() {\n        return true;\n    }\n    toPrettyString() {\n        return JSON.stringify(this.relationEntities);\n    }\n}\nexport class InterfaceType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get interfaceShape() { return this.data; }\n    constructor(iface) {\n        super('Interface', iface);\n    }\n    get isInterface() {\n        return true;\n    }\n    mergeTypeVariablesByName(variableMap) {\n        const shape = this.interfaceShape.clone(new Map());\n        shape.mergeTypeVariablesByName(variableMap);\n        // TODO: only build a new type when a variable is modified\n        return new InterfaceType(shape);\n    }\n    _applyExistenceTypeTest(test) {\n        return this.interfaceShape._applyExistenceTypeTest(test);\n    }\n    resolvedType() {\n        return new InterfaceType(this.interfaceShape.resolvedType());\n    }\n    _canEnsureResolved() {\n        return this.interfaceShape.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.interfaceShape.maybeEnsureResolved();\n    }\n    get canWriteSuperset() {\n        return new InterfaceType(this.interfaceShape.canWriteSuperset);\n    }\n    get canReadSubset() {\n        return new InterfaceType(this.interfaceShape.canReadSubset);\n    }\n    _isMoreSpecificThan(type) {\n        return this.interfaceShape.isMoreSpecificThan(type.interfaceShape);\n    }\n    _cloneWithResolutions(variableMap) {\n        return new InterfaceType(this.interfaceShape._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.interfaceShape.toLiteral() };\n    }\n    toString(options = undefined) {\n        return this.interfaceShape.name;\n    }\n    toPrettyString() {\n        return this.interfaceShape.toPrettyString();\n    }\n}\nexport class SlotType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get slot() { return this.data; }\n    constructor(slot) {\n        super('Slot', slot);\n    }\n    get isSlot() {\n        return true;\n    }\n    get canWriteSuperset() {\n        return this;\n    }\n    get canReadSubset() {\n        return this;\n    }\n    _isMoreSpecificThan(type) {\n        // TODO: formFactor checking, etc.\n        return true;\n    }\n    toString(options = undefined) {\n        const fields = [];\n        for (const key of Object.keys(this.slot)) {\n            if (this.slot[key] !== undefined) {\n                fields.push(`${key}:${this.slot[key]}`);\n            }\n        }\n        let fieldsString = '';\n        if (fields.length !== 0) {\n            fieldsString = ` {${fields.join(', ')}}`;\n        }\n        return `Slot${fieldsString}`;\n    }\n    toPrettyString() {\n        const fields = [];\n        for (const key of Object.keys(this.slot)) {\n            if (this.slot[key] !== undefined) {\n                fields.push(`${key}:${this.slot[key]}`);\n            }\n        }\n        let fieldsString = '';\n        if (fields.length !== 0) {\n            fieldsString = ` {${fields.join(', ')}}`;\n        }\n        return `Slot${fieldsString}`;\n    }\n}\nexport class ReferenceType extends Type {\n    // TODO: replace with a member var once data has been removed\n    get referredType() { return this.data; }\n    constructor(reference) {\n        super('Reference', reference);\n    }\n    get isReference() {\n        return true;\n    }\n    getContainedType() {\n        return this.referredType;\n    }\n    isTypeContainer() {\n        return true;\n    }\n    resolvedType() {\n        const primitiveType = this.referredType;\n        const resolvedPrimitiveType = primitiveType.resolvedType();\n        return (primitiveType !== resolvedPrimitiveType) ? new ReferenceType(resolvedPrimitiveType) : this;\n    }\n    _canEnsureResolved() {\n        return this.referredType.canEnsureResolved();\n    }\n    maybeEnsureResolved() {\n        return this.referredType.maybeEnsureResolved();\n    }\n    get canReadSubset() {\n        return this.referredType.canReadSubset;\n    }\n    _cloneWithResolutions(variableMap) {\n        return new ReferenceType(this.referredType._cloneWithResolutions(variableMap));\n    }\n    toLiteral() {\n        return { tag: this.tag, data: this.referredType.toLiteral() };\n    }\n    toString(options = undefined) {\n        return 'Reference<' + this.referredType.toString() + '>';\n    }\n}\nexport class ArcInfoType extends Type {\n    constructor() {\n        super('ArcInfo', null);\n    }\n    get isArcInfo() {\n        return true;\n    }\n}\nexport class HandleInfoType extends Type {\n    constructor() {\n        super('HandleInfo', null);\n    }\n    get isHandleInfo() {\n        return true;\n    }\n}\n//# sourceMappingURL=type.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nimport { Type } from './type.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Entity } from './entity.js';\nimport { Reference } from './reference.js';\nexport class Schema {\n    constructor(model) {\n        assert(model.fields);\n        this._model = model;\n        this.description = {};\n        if (model.description) {\n            model.description.description.forEach(desc => this.description[desc.name] = desc.pattern || desc.patterns[0]);\n        }\n    }\n    toLiteral() {\n        const fields = {};\n        const updateField = field => {\n            if (field.kind === 'schema-reference') {\n                const schema = field.schema;\n                return { kind: 'schema-reference', schema: { kind: schema.kind, model: schema.model.toLiteral() } };\n            }\n            else if (field.kind === 'schema-collection') {\n                return { kind: 'schema-collection', schema: updateField(field.schema) };\n            }\n            else {\n                return field;\n            }\n        };\n        for (const key of Object.keys(this._model.fields)) {\n            fields[key] = updateField(this._model.fields[key]);\n        }\n        return { names: this._model.names, fields, description: this.description };\n    }\n    static fromLiteral(data = { fields: {}, names: [], description: {} }) {\n        const fields = {};\n        const updateField = field => {\n            if (field.kind === 'schema-reference') {\n                const schema = field.schema;\n                return { kind: 'schema-reference', schema: { kind: schema.kind, model: Type.fromLiteral(schema.model) } };\n            }\n            else if (field.kind === 'schema-collection') {\n                return { kind: 'schema-collection', schema: updateField(field.schema) };\n            }\n            else {\n                return field;\n            }\n        };\n        for (const key of Object.keys(data.fields)) {\n            fields[key] = updateField(data.fields[key]);\n        }\n        const result = new Schema({ names: data.names, fields });\n        result.description = data.description || {};\n        return result;\n    }\n    get fields() {\n        return this._model.fields;\n    }\n    get names() {\n        return this._model.names;\n    }\n    // TODO: This should only be an ident used in manifest parsing.\n    get name() {\n        return this.names[0];\n    }\n    static typesEqual(fieldType1, fieldType2) {\n        // TODO: structural check instead of stringification.\n        return Schema._typeString(fieldType1) === Schema._typeString(fieldType2);\n    }\n    static _typeString(type) {\n        if (typeof (type) !== 'object') {\n            assert(typeof type === 'string');\n            return type;\n        }\n        switch (type.kind) {\n            case 'schema-union':\n                return `(${type.types.join(' or ')})`;\n            case 'schema-tuple':\n                return `(${type.types.join(', ')})`;\n            case 'schema-reference':\n                return `Reference<${Schema._typeString(type.schema)}>`;\n            case 'type-name':\n            case 'schema-inline':\n                return type.model.entitySchema.toInlineSchemaString();\n            case 'schema-collection':\n                return `[${Schema._typeString(type.schema)}]`;\n            default:\n                throw new Error(`Unknown type kind ${type.kind} in schema ${this.name}`);\n        }\n    }\n    static union(schema1, schema2) {\n        const names = [...new Set([...schema1.names, ...schema2.names])];\n        const fields = {};\n        for (const [field, type] of [...Object.entries(schema1.fields), ...Object.entries(schema2.fields)]) {\n            if (fields[field]) {\n                if (!Schema.typesEqual(fields[field], type)) {\n                    return null;\n                }\n            }\n            else {\n                fields[field] = type;\n            }\n        }\n        return new Schema({\n            names,\n            fields,\n        });\n    }\n    static intersect(schema1, schema2) {\n        const names = [...schema1.names].filter(name => schema2.names.includes(name));\n        const fields = {};\n        for (const [field, type] of Object.entries(schema1.fields)) {\n            const otherType = schema2.fields[field];\n            if (otherType && Schema.typesEqual(type, otherType)) {\n                fields[field] = type;\n            }\n        }\n        return new Schema({\n            names,\n            fields,\n        });\n    }\n    equals(otherSchema) {\n        return this === otherSchema || (this.name === otherSchema.name\n            // TODO: Check equality without calling contains.\n            && this.isMoreSpecificThan(otherSchema)\n            && otherSchema.isMoreSpecificThan(this));\n    }\n    isMoreSpecificThan(otherSchema) {\n        const names = new Set(this.names);\n        for (const name of otherSchema.names) {\n            if (!names.has(name)) {\n                return false;\n            }\n        }\n        const fields = {};\n        for (const [name, type] of Object.entries(this.fields)) {\n            fields[name] = type;\n        }\n        for (const [name, type] of Object.entries(otherSchema.fields)) {\n            if (fields[name] == undefined) {\n                return false;\n            }\n            if (!Schema.typesEqual(fields[name], type)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    get type() {\n        return Type.newEntity(this);\n    }\n    entityClass(context = null) {\n        const schema = this;\n        const className = this.name;\n        const classJunk = ['toJSON', 'prototype', 'toString', 'inspect'];\n        const convertToJsType = fieldType => {\n            switch (fieldType) {\n                case 'Text':\n                    return 'string';\n                case 'URL':\n                    return 'string';\n                case 'Number':\n                    return 'number';\n                case 'Boolean':\n                    return 'boolean';\n                case 'Object':\n                    return 'object';\n                default:\n                    throw new Error(`Unknown field type ${fieldType} in schema ${className}`);\n            }\n        };\n        const fieldTypes = this.fields;\n        const validateFieldAndTypes = (op, name, value) => _validateFieldAndTypes(op, name, fieldTypes[name], value);\n        const _validateFieldAndTypes = (op, name, fieldType, value) => {\n            if (fieldType === undefined) {\n                throw new Error(`Can't ${op} field ${name}; not in schema ${className}`);\n            }\n            if (value === undefined || value === null) {\n                return;\n            }\n            if (typeof (fieldType) !== 'object') {\n                // Primitive fields.\n                if (typeof (value) !== convertToJsType(fieldType)) {\n                    throw new TypeError(`Type mismatch ${op}ting field ${name} (type ${fieldType}); ` +\n                        `value '${value}' is type ${typeof (value)}`);\n                }\n                return;\n            }\n            switch (fieldType.kind) {\n                case 'schema-union':\n                    // Value must be a primitive that matches one of the union types.\n                    for (const innerType of fieldType.types) {\n                        if (typeof (value) === convertToJsType(innerType)) {\n                            return;\n                        }\n                    }\n                    throw new TypeError(`Type mismatch ${op}ting field ${name} (union [${fieldType.types}]); ` +\n                        `value '${value}' is type ${typeof (value)}`);\n                case 'schema-tuple':\n                    // Value must be an array whose contents match each of the tuple types.\n                    if (!Array.isArray(value)) {\n                        throw new TypeError(`Cannot ${op} tuple ${name} with non-array value '${value}'`);\n                    }\n                    if (value.length !== fieldType.types.length) {\n                        throw new TypeError(`Length mismatch ${op}ting tuple ${name} ` +\n                            `[${fieldType.types}] with value '${value}'`);\n                    }\n                    fieldType.types.map((innerType, i) => {\n                        if (value[i] !== undefined && value[i] !== null &&\n                            typeof (value[i]) !== convertToJsType(innerType)) {\n                            throw new TypeError(`Type mismatch ${op}ting field ${name} (tuple [${fieldType.types}]); ` +\n                                `value '${value}' has type ${typeof (value[i])} at index ${i}`);\n                        }\n                    });\n                    break;\n                case 'schema-reference':\n                    if (!(value instanceof Reference)) {\n                        throw new TypeError(`Cannot ${op} reference ${name} with non-reference '${value}'`);\n                    }\n                    if (!TypeChecker.compareTypes({ type: value.type }, { type: Type.newReference(fieldType.schema.model) })) {\n                        throw new TypeError(`Cannot ${op} reference ${name} with value '${value}' of mismatched type`);\n                    }\n                    break;\n                case 'schema-collection':\n                    // WTF?! value instanceof Set is returning false sometimes here because the Set in\n                    // this environment (a native code constructor) isn't equal to the Set that the value\n                    // has been constructed with (another native code constructor)...\n                    if (value.constructor.name !== 'Set') {\n                        throw new TypeError(`Cannot ${op} collection ${name} with non-Set '${value}'`);\n                    }\n                    for (const element of value) {\n                        _validateFieldAndTypes(op, name, fieldType.schema, element);\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown kind ${fieldType.kind} in schema ${className}`);\n            }\n        };\n        const clazz = class extends Entity {\n            constructor(data, userIDComponent) {\n                super(userIDComponent);\n                this.rawData = new Proxy({}, {\n                    get: (target, name) => {\n                        if (classJunk.includes(name) || name.constructor === Symbol) {\n                            return undefined;\n                        }\n                        const value = target[name];\n                        validateFieldAndTypes('get', name, value);\n                        return value;\n                    },\n                    set: (target, name, value) => {\n                        validateFieldAndTypes('set', name, value);\n                        target[name] = value;\n                        return true;\n                    }\n                });\n                assert(data, `can't construct entity with null data`);\n                // TODO: figure out how to do this only on wire-created entities.\n                const sanitizedData = this.sanitizeData(data);\n                for (const [name, value] of Object.entries(sanitizedData)) {\n                    this.rawData[name] = value;\n                }\n            }\n            sanitizeData(data) {\n                const sanitizedData = {};\n                for (const [name, value] of Object.entries(data)) {\n                    sanitizedData[name] = this.sanitizeEntry(fieldTypes[name], value, name);\n                }\n                return sanitizedData;\n            }\n            sanitizeEntry(type, value, name) {\n                if (!type) {\n                    // If there isn't a field type for this, the proxy will pick up\n                    // that fact and report a meaningful error.\n                    return value;\n                }\n                if (type.kind === 'schema-reference' && value) {\n                    if (value instanceof Reference) {\n                        // Setting value as Reference (Particle side). This will enforce that the type provided for\n                        // the handle matches the type of the reference.\n                        return value;\n                    }\n                    else if (value.id && value.storageKey) {\n                        // Setting value from raw data (Channel side).\n                        // TODO(shans): This can't enforce type safety here as there isn't any type data available.\n                        // Maybe this is OK because there's type checking on the other side of the channel?\n                        return new Reference(value, Type.newReference(type.schema.model), context);\n                    }\n                    else {\n                        throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);\n                    }\n                }\n                else if (type.kind === 'schema-collection' && value) {\n                    // WTF?! value instanceof Set is returning false sometimes here because the Set in\n                    // this environment (a native code constructor) isn't equal to the Set that the value\n                    // has been constructed with (another native code constructor)...\n                    if (value.constructor.name === 'Set') {\n                        return value;\n                    }\n                    else if (value.length && value instanceof Object) {\n                        return new Set(value.map(v => this.sanitizeEntry(type.schema, v, name)));\n                    }\n                    else {\n                        throw new TypeError(`Cannot set collection ${name} with non-collection '${value}'`);\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n            dataClone() {\n                const clone = {};\n                for (const name of Object.keys(schema.fields)) {\n                    if (this.rawData[name] !== undefined) {\n                        if (fieldTypes[name] && fieldTypes[name].kind === 'schema-reference') {\n                            clone[name] = this.rawData[name].dataClone();\n                        }\n                        else if (fieldTypes[name] && fieldTypes[name].kind === 'schema-collection') {\n                            clone[name] = [...this.rawData[name]].map(a => a.dataClone());\n                        }\n                        else {\n                            clone[name] = this.rawData[name];\n                        }\n                    }\n                }\n                return clone;\n            }\n            static get type() {\n                // TODO: should the entity's key just be its type?\n                // Should it just be called type in that case?\n                return Type.newEntity(this.key.schema);\n            }\n            static get key() {\n                return {\n                    tag: 'entity',\n                    schema,\n                };\n            }\n        };\n        Object.defineProperty(clazz, 'type', { value: this.type });\n        Object.defineProperty(clazz, 'name', { value: this.name });\n        // TODO: add query / getter functions for user properties\n        for (const name of Object.keys(this.fields)) {\n            Object.defineProperty(clazz.prototype, name, {\n                get() {\n                    return this.rawData[name];\n                },\n                set(v) {\n                    this.rawData[name] = v;\n                }\n            });\n        }\n        return clazz;\n    }\n    toInlineSchemaString(options) {\n        const names = this.names.join(' ') || '*';\n        const fields = Object.entries(this.fields).map(([name, type]) => `${Schema._typeString(type)} ${name}`).join(', ');\n        return `${names} {${fields.length > 0 && options && options.hideFields ? '...' : fields}}`;\n    }\n    toManifestString() {\n        const results = [];\n        results.push(`schema ${this.names.join(' ')}`);\n        results.push(...Object.entries(this.fields).map(([name, type]) => `  ${Schema._typeString(type)} ${name}`));\n        if (Object.keys(this.description).length > 0) {\n            results.push(`  description \\`${this.description.pattern}\\``);\n            for (const name of Object.keys(this.description)) {\n                if (name !== 'pattern') {\n                    results.push(`    ${name} \\`${this.description[name]}\\``);\n                }\n            }\n        }\n        return results.join('\\n');\n    }\n}\n//# sourceMappingURL=schema.js.map","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { Type, EntityType, VariableType, CollectionType, BigCollectionType, InterfaceType, SlotType } from '../type.js';\nimport { TypeVariable } from '../type-variable.js';\nexport class TypeChecker {\n    // resolve a list of handleConnection types against a handle\n    // base type. This is the core type resolution mechanism, but should only\n    // be used when types can actually be associated with each other / constrained.\n    //\n    // By design this function is called exactly once per handle in a recipe during\n    // normalization, and should provide the same final answers regardless of the\n    // ordering of handles within that recipe\n    //\n    // NOTE: you probably don't want to call this function, if you think you\n    // do, talk to shans@.\n    static processTypeList(baseType, list) {\n        const newBaseTypeVariable = new TypeVariable('', null, null);\n        if (baseType) {\n            newBaseTypeVariable.resolution = baseType;\n        }\n        const newBaseType = Type.newVariable(newBaseTypeVariable);\n        baseType = newBaseType;\n        const concreteTypes = [];\n        // baseType might be a variable (and is definitely a variable if no baseType was available).\n        // Some of the list might contain variables too.\n        // First attempt to merge all the variables into the baseType\n        //\n        // If the baseType is a variable then this results in a single place to manipulate the constraints\n        // of all the other connected variables at the same time.\n        for (const item of list) {\n            if (item.type.resolvedType().hasVariable) {\n                baseType = TypeChecker._tryMergeTypeVariable(baseType, item.type);\n                if (baseType == null) {\n                    return null;\n                }\n            }\n            else {\n                concreteTypes.push(item);\n            }\n        }\n        for (const item of concreteTypes) {\n            if (!TypeChecker._tryMergeConstraints(baseType, item)) {\n                return null;\n            }\n        }\n        const getResolution = candidate => {\n            if (!(candidate instanceof VariableType)) {\n                return candidate;\n            }\n            if (candidate.canReadSubset == null || candidate.canWriteSuperset == null) {\n                return candidate;\n            }\n            if (candidate.canReadSubset.isMoreSpecificThan(candidate.canWriteSuperset)) {\n                if (candidate.canWriteSuperset.isMoreSpecificThan(candidate.canReadSubset)) {\n                    candidate.variable.resolution = candidate.canReadSubset;\n                }\n                return candidate;\n            }\n            return null;\n        };\n        const candidate = baseType.resolvedType();\n        if (candidate instanceof CollectionType) {\n            const resolution = getResolution(candidate.collectionType);\n            return (resolution !== null) ? resolution.collectionOf() : null;\n        }\n        if (candidate instanceof BigCollectionType) {\n            const resolution = getResolution(candidate.bigCollectionType);\n            return (resolution !== null) ? resolution.bigCollectionOf() : null;\n        }\n        return getResolution(candidate);\n    }\n    static _tryMergeTypeVariable(base, onto) {\n        const [primitiveBase, primitiveOnto] = Type.unwrapPair(base.resolvedType(), onto.resolvedType());\n        if (primitiveBase instanceof VariableType) {\n            if (primitiveOnto instanceof VariableType) {\n                // base, onto both variables.\n                const result = primitiveBase.variable.maybeMergeConstraints(primitiveOnto.variable);\n                if (result === false) {\n                    return null;\n                }\n                // Here onto grows, one level at a time,\n                // as we assign new resolution to primitiveOnto, which is a leaf.\n                primitiveOnto.variable.resolution = primitiveBase;\n            }\n            else {\n                // base variable, onto not.\n                primitiveBase.variable.resolution = primitiveOnto;\n            }\n            return base;\n        }\n        else if (primitiveOnto instanceof VariableType) {\n            // onto variable, base not.\n            primitiveOnto.variable.resolution = primitiveBase;\n            return onto;\n        }\n        else if (primitiveBase instanceof InterfaceType && primitiveOnto instanceof InterfaceType) {\n            const result = primitiveBase.interfaceShape.tryMergeTypeVariablesWith(primitiveOnto.interfaceShape);\n            if (result == null) {\n                return null;\n            }\n            return Type.newInterface(result);\n        }\n        else if ((primitiveBase.isTypeContainer() && primitiveBase.hasVariable)\n            || (primitiveOnto.isTypeContainer() && primitiveOnto.hasVariable)) {\n            // Cannot merge [~a] with a type that is not a variable and not a collection.\n            return null;\n        }\n        throw new Error('tryMergeTypeVariable shouldn\\'t be called on two types without any type variables');\n    }\n    static _tryMergeConstraints(handleType, { type, direction }) {\n        let [primitiveHandleType, primitiveConnectionType] = Type.unwrapPair(handleType.resolvedType(), type.resolvedType());\n        if (primitiveHandleType instanceof VariableType) {\n            while (primitiveConnectionType.isTypeContainer()) {\n                if (primitiveHandleType.variable.resolution != null\n                    || primitiveHandleType.variable.canReadSubset != null\n                    || primitiveHandleType.variable.canWriteSuperset != null) {\n                    // Resolved and/or constrained variables can only represent Entities, not sets.\n                    return false;\n                }\n                // If this is an undifferentiated variable then we need to create structure to match against. That's\n                // allowed because this variable could represent anything, and it needs to represent this structure\n                // in order for type resolution to succeed.\n                const newVar = Type.newVariable(new TypeVariable('a', null, null));\n                if (primitiveConnectionType instanceof CollectionType) {\n                    primitiveHandleType.variable.resolution = Type.newCollection(newVar);\n                }\n                else if (primitiveConnectionType instanceof BigCollectionType) {\n                    primitiveHandleType.variable.resolution = Type.newBigCollection(newVar);\n                }\n                else {\n                    primitiveHandleType.variable.resolution = Type.newReference(newVar);\n                }\n                const unwrap = Type.unwrapPair(primitiveHandleType.resolvedType(), primitiveConnectionType);\n                [primitiveHandleType, primitiveConnectionType] = unwrap;\n            }\n            if (direction === 'out' || direction === 'inout' || direction === '`provide') {\n                // the canReadSubset of the handle represents the maximal type that can be read from the\n                // handle, so we need to intersect out any type that is more specific than the maximal type\n                // that could be written.\n                if (!primitiveHandleType.variable.maybeMergeCanReadSubset(primitiveConnectionType.canWriteSuperset)) {\n                    return false;\n                }\n            }\n            if (direction === 'in' || direction === 'inout' || direction === '`consume') {\n                // the canWriteSuperset of the handle represents the maximum lower-bound type that is read from the handle,\n                // so we need to union it with the type that wants to be read here.\n                if (!primitiveHandleType.variable.maybeMergeCanWriteSuperset(primitiveConnectionType.canReadSubset)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (primitiveConnectionType.tag !== primitiveHandleType.tag) {\n                return false;\n            }\n            if (direction === 'out' || direction === 'inout') {\n                if (!TypeChecker._writeConstraintsApply(primitiveHandleType, primitiveConnectionType)) {\n                    return false;\n                }\n            }\n            if (direction === 'in' || direction === 'inout') {\n                if (!TypeChecker._readConstraintsApply(primitiveHandleType, primitiveConnectionType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _writeConstraintsApply(handleType, connectionType) {\n        // this connection wants to write to this handle. If the written type is\n        // more specific than the canReadSubset then it isn't violating the maximal type\n        // that can be read.\n        const writtenType = connectionType.canWriteSuperset;\n        if (writtenType == null || handleType.canReadSubset == null) {\n            return true;\n        }\n        if (writtenType.isMoreSpecificThan(handleType.canReadSubset)) {\n            return true;\n        }\n        return false;\n    }\n    static _readConstraintsApply(handleType, connectionType) {\n        // this connection wants to read from this handle. If the read type\n        // is less specific than the canWriteSuperset, then it isn't violating\n        // the maximum lower-bound read type.\n        const readType = connectionType.canReadSubset;\n        if (readType == null || handleType.canWriteSuperset == null) {\n            return true;\n        }\n        if (handleType.canWriteSuperset.isMoreSpecificThan(readType)) {\n            return true;\n        }\n        return false;\n    }\n    // Compare two types to see if they could be potentially resolved (in the absence of other\n    // information). This is used as a filter when selecting compatible handles or checking\n    // validity of recipes. This function returning true never implies that full type resolution\n    // will succeed, but if the function returns false for a pair of types that are associated\n    // then type resolution is guaranteed to fail.\n    //\n    // left, right: {type, direction, connection}\n    static compareTypes(left, right) {\n        const resolvedLeft = left.type.resolvedType();\n        const resolvedRight = right.type.resolvedType();\n        const [leftType, rightType] = Type.unwrapPair(resolvedLeft, resolvedRight);\n        // a variable is compatible with a set only if it is unconstrained.\n        if (leftType instanceof VariableType && rightType.isTypeContainer()) {\n            return !(leftType.variable.canReadSubset || leftType.variable.canWriteSuperset);\n        }\n        if (rightType instanceof VariableType && leftType.isTypeContainer()) {\n            return !(rightType.variable.canReadSubset || rightType.variable.canWriteSuperset);\n        }\n        if (leftType instanceof VariableType || rightType instanceof VariableType) {\n            // TODO: everything should use this, eventually. Need to implement the\n            // right functionality in Shapes first, though.\n            return Type.canMergeConstraints(leftType, rightType);\n        }\n        if ((leftType === undefined) !== (rightType === undefined)) {\n            return false;\n        }\n        if (leftType === rightType) {\n            return true;\n        }\n        if (leftType.tag !== rightType.tag) {\n            return false;\n        }\n        if (leftType instanceof SlotType) {\n            return true;\n        }\n        // TODO: we need a generic way to evaluate type compatibility\n        //       shapes + entities + etc\n        if (leftType instanceof InterfaceType && rightType instanceof InterfaceType) {\n            if (leftType.interfaceShape.equals(rightType.interfaceShape)) {\n                return true;\n            }\n        }\n        if (!(leftType instanceof EntityType) || !(rightType instanceof EntityType)) {\n            return false;\n        }\n        const leftIsSub = leftType.entitySchema.isMoreSpecificThan(rightType.entitySchema);\n        const leftIsSuper = rightType.entitySchema.isMoreSpecificThan(leftType.entitySchema);\n        if (leftIsSuper && leftIsSub) {\n            return true;\n        }\n        if (!leftIsSuper && !leftIsSub) {\n            return false;\n        }\n        const [superclass, subclass] = leftIsSuper ? [left, right] : [right, left];\n        // treat handle types as if they were 'inout' connections. Note that this\n        // guarantees that the handle's type will be preserved, and that the fact\n        // that the type comes from a handle rather than a connection will also\n        // be preserved.\n        const superDirection = superclass.direction || (superclass.connection ? superclass.connection.direction : 'inout');\n        const subDirection = subclass.direction || (subclass.connection ? subclass.connection.direction : 'inout');\n        if (superDirection === 'in') {\n            return true;\n        }\n        if (subDirection === 'out') {\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=type-checker.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { Type, EntityType, VariableType, SlotType } from './type.js';\nimport { assert } from '../../platform/assert-web.js';\nimport { Schema } from './schema.js';\nexport class TypeVariable {\n    constructor(name, canWriteSuperset, canReadSubset) {\n        this.name = name;\n        this._canWriteSuperset = canWriteSuperset;\n        this._canReadSubset = canReadSubset;\n        this._resolution = null;\n    }\n    /**\n     * Merge both the read subset (upper bound) and write superset (lower bound) constraints\n     * of two variables together. Use this when two separate type variables need to resolve\n     * to the same value.\n     */\n    maybeMergeConstraints(variable) {\n        if (!this.maybeMergeCanReadSubset(variable.canReadSubset)) {\n            return false;\n        }\n        return this.maybeMergeCanWriteSuperset(variable.canWriteSuperset);\n    }\n    /**\n     * Merge a type variable's read subset (upper bound) constraints into this variable.\n     * This is used to accumulate read constraints when resolving a handle's type.\n     */\n    maybeMergeCanReadSubset(constraint) {\n        if (constraint == null) {\n            return true;\n        }\n        if (this.canReadSubset == null) {\n            this.canReadSubset = constraint;\n            return true;\n        }\n        if (this.canReadSubset instanceof SlotType && constraint instanceof SlotType) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        const mergedSchema = Schema.intersect(this.canReadSubset.entitySchema, constraint.entitySchema);\n        if (!mergedSchema) {\n            return false;\n        }\n        this.canReadSubset = Type.newEntity(mergedSchema);\n        return true;\n    }\n    /**\n     * merge a type variable's write superset (lower bound) constraints into this variable.\n     * This is used to accumulate write constraints when resolving a handle's type.\n     */\n    maybeMergeCanWriteSuperset(constraint) {\n        if (constraint == null) {\n            return true;\n        }\n        if (this.canWriteSuperset == null) {\n            this.canWriteSuperset = constraint;\n            return true;\n        }\n        if (this.canWriteSuperset instanceof SlotType && constraint instanceof SlotType) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        const mergedSchema = Schema.union(this.canWriteSuperset.entitySchema, constraint.entitySchema);\n        if (!mergedSchema) {\n            return false;\n        }\n        this.canWriteSuperset = Type.newEntity(mergedSchema);\n        return true;\n    }\n    isSatisfiedBy(type) {\n        const constraint = this._canWriteSuperset;\n        if (!constraint) {\n            return true;\n        }\n        if (!(constraint instanceof EntityType) || !(type instanceof EntityType)) {\n            throw new Error(`constraint checking not implemented for ${this} and ${type}`);\n        }\n        return type.getEntitySchema().isMoreSpecificThan(constraint.getEntitySchema());\n    }\n    get resolution() {\n        if (this._resolution) {\n            return this._resolution.resolvedType();\n        }\n        return null;\n    }\n    set resolution(value) {\n        assert(!this._resolution);\n        const elementType = value.resolvedType().getContainedType();\n        if (elementType instanceof VariableType) {\n            assert(elementType.variable !== this, 'variable cannot resolve to collection of itself');\n        }\n        let probe = value;\n        while (probe) {\n            if (!(probe instanceof VariableType)) {\n                break;\n            }\n            if (probe.variable === this) {\n                return;\n            }\n            probe = probe.variable.resolution;\n        }\n        this._resolution = value;\n        this._canWriteSuperset = null;\n        this._canReadSubset = null;\n    }\n    get canWriteSuperset() {\n        if (this._resolution) {\n            assert(!this._canWriteSuperset);\n            if (this._resolution instanceof VariableType) {\n                return this._resolution.variable.canWriteSuperset;\n            }\n            return null;\n        }\n        return this._canWriteSuperset;\n    }\n    set canWriteSuperset(value) {\n        assert(!this._resolution);\n        this._canWriteSuperset = value;\n    }\n    get canReadSubset() {\n        if (this._resolution) {\n            assert(!this._canReadSubset);\n            if (this._resolution instanceof VariableType) {\n                return this._resolution.variable.canReadSubset;\n            }\n            return null;\n        }\n        return this._canReadSubset;\n    }\n    set canReadSubset(value) {\n        assert(!this._resolution);\n        this._canReadSubset = value;\n    }\n    get hasConstraint() {\n        return this._canReadSubset !== null || this._canWriteSuperset !== null;\n    }\n    canEnsureResolved() {\n        if (this._resolution) {\n            return this._resolution.canEnsureResolved();\n        }\n        if (this._canWriteSuperset || this._canReadSubset) {\n            return true;\n        }\n        return false;\n    }\n    maybeEnsureResolved() {\n        if (this._resolution) {\n            return this._resolution.maybeEnsureResolved();\n        }\n        if (this._canWriteSuperset) {\n            this.resolution = this._canWriteSuperset;\n            return true;\n        }\n        if (this._canReadSubset) {\n            this.resolution = this._canReadSubset;\n            return true;\n        }\n        return false;\n    }\n    toLiteral() {\n        assert(this.resolution == null);\n        return this.toLiteralIgnoringResolutions();\n    }\n    toLiteralIgnoringResolutions() {\n        return {\n            name: this.name,\n            canWriteSuperset: this._canWriteSuperset && this._canWriteSuperset.toLiteral(),\n            canReadSubset: this._canReadSubset && this._canReadSubset.toLiteral()\n        };\n    }\n    static fromLiteral(data) {\n        return new TypeVariable(data.name, data.canWriteSuperset ? Type.fromLiteral(data.canWriteSuperset) : null, data.canReadSubset ? Type.fromLiteral(data.canReadSubset) : null);\n    }\n    isResolved() {\n        return (this._resolution && this._resolution.isResolved());\n    }\n}\n//# sourceMappingURL=type-variable.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { assert } from '../../platform/assert-web.js';\nimport { Symbols } from './symbols.js';\nexport class Entity {\n    constructor(userIDComponent) {\n        assert(!userIDComponent || userIDComponent.indexOf(':') === -1, 'user IDs must not contain the \\':\\' character');\n        this[Symbols.identifier] = undefined;\n        this.userIDComponent = userIDComponent;\n    }\n    get data() {\n        return undefined;\n    }\n    getUserID() {\n        return this.userIDComponent;\n    }\n    isIdentified() {\n        return this[Symbols.identifier] !== undefined;\n    }\n    // TODO: entity should not be exposing its IDs.\n    get id() {\n        assert(!!this.isIdentified());\n        return this[Symbols.identifier];\n    }\n    identify(identifier) {\n        assert(!this.isIdentified());\n        this[Symbols.identifier] = identifier;\n        const components = identifier.split(':');\n        if (components[components.length - 2] === 'uid') {\n            this.userIDComponent = components[components.length - 1];\n        }\n    }\n    createIdentity(components) {\n        assert(!this.isIdentified());\n        let id;\n        if (this.userIDComponent) {\n            id = `${components.base}:uid:${this.userIDComponent}`;\n        }\n        else {\n            id = `${components.base}:${components.component()}`;\n        }\n        this[Symbols.identifier] = id;\n    }\n    toLiteral() {\n        return this.rawData;\n    }\n}\n//# sourceMappingURL=entity.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n// tslint:disable-next-line: variable-name\nexport const Symbols = { identifier: Symbol('id') };\n//# sourceMappingURL=symbols.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nimport { VariableType } from './type.js';\n// ShapeHandle {name, direction, type}\n// Slot {name, direction, isRequired, isSet}\nfunction _fromLiteral(member) {\n    if (!!member && typeof member === 'object') {\n        return Type.fromLiteral(member);\n    }\n    return member;\n}\nfunction _toLiteral(member) {\n    if (!!member && member.toLiteral) {\n        return member.toLiteral();\n    }\n    return member;\n}\nconst handleFields = ['type', 'name', 'direction'];\nconst slotFields = ['name', 'direction', 'isRequired', 'isSet'];\nexport class Shape {\n    constructor(name, handles, slots) {\n        assert(name);\n        assert(handles !== undefined);\n        assert(slots !== undefined);\n        this.name = name;\n        this.handles = handles;\n        this.slots = slots;\n        this.typeVars = [];\n        for (const handle of handles) {\n            for (const field of handleFields) {\n                if (Shape.isTypeVar(handle[field])) {\n                    this.typeVars.push({ object: handle, field });\n                }\n            }\n        }\n        for (const slot of slots) {\n            for (const field of slotFields) {\n                if (Shape.isTypeVar(slot[field])) {\n                    this.typeVars.push({ object: slot, field });\n                }\n            }\n        }\n    }\n    toPrettyString() {\n        return 'SHAAAAPE';\n    }\n    mergeTypeVariablesByName(variableMap) {\n        this.typeVars.map(({ object, field }) => object[field] = object[field].mergeTypeVariablesByName(variableMap));\n    }\n    get canReadSubset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canReadSubset);\n    }\n    get canWriteSuperset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canWriteSuperset);\n    }\n    isMoreSpecificThan(other) {\n        if (this.handles.length !== other.handles.length ||\n            this.slots.length !== other.slots.length) {\n            return false;\n        }\n        // TODO: should probably confirm that handles and slots actually match.\n        for (let i = 0; i < this.typeVars.length; i++) {\n            const thisTypeVar = this.typeVars[i];\n            const otherTypeVar = other.typeVars[i];\n            if (!thisTypeVar.object[thisTypeVar.field].isMoreSpecificThan(otherTypeVar.object[otherTypeVar.field])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _applyExistenceTypeTest(test) {\n        for (const typeRef of this.typeVars) {\n            if (test(typeRef.object[typeRef.field])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _handlesToManifestString() {\n        return this.handles\n            .map(handle => {\n            const type = handle.type.resolvedType();\n            return `  ${handle.direction ? handle.direction + ' ' : ''}${type.toString()} ${handle.name ? handle.name : '*'}`;\n        }).join('\\n');\n    }\n    _slotsToManifestString() {\n        // TODO deal with isRequired\n        return this.slots\n            .map(slot => `  ${slot.direction} ${slot.isSet ? 'set of ' : ''}${slot.name ? slot.name + ' ' : ''}`)\n            .join('\\n');\n    }\n    // TODO: Include name as a property of the shape and normalize this to just\n    // toString().\n    toString() {\n        return `shape ${this.name}\n${this._handlesToManifestString()}\n${this._slotsToManifestString()}\n`;\n    }\n    static fromLiteral(data) {\n        const handles = data.handles.map(handle => ({ type: _fromLiteral(handle.type), name: _fromLiteral(handle.name), direction: _fromLiteral(handle.direction) }));\n        const slots = data.slots.map(slot => ({ name: _fromLiteral(slot.name), direction: _fromLiteral(slot.direction), isRequired: _fromLiteral(slot.isRequired), isSet: _fromLiteral(slot.isSet) }));\n        return new Shape(data.name, handles, slots);\n    }\n    toLiteral() {\n        const handles = this.handles.map(handle => ({ type: _toLiteral(handle.type), name: _toLiteral(handle.name), direction: _toLiteral(handle.direction) }));\n        const slots = this.slots.map(slot => ({ name: _toLiteral(slot.name), direction: _toLiteral(slot.direction), isRequired: _toLiteral(slot.isRequired), isSet: _toLiteral(slot.isSet) }));\n        return { name: this.name, handles, slots };\n    }\n    clone(variableMap) {\n        const handles = this.handles.map(({ name, direction, type }) => ({ name, direction, type: type ? type.clone(variableMap) : undefined }));\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new Shape(this.name, handles, slots);\n    }\n    cloneWithResolutions(variableMap) {\n        return this._cloneWithResolutions(variableMap);\n    }\n    _cloneWithResolutions(variableMap) {\n        const handles = this.handles.map(({ name, direction, type }) => ({ name, direction, type: type ? type._cloneWithResolutions(variableMap) : undefined }));\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new Shape(this.name, handles, slots);\n    }\n    canEnsureResolved() {\n        for (const typeVar of this.typeVars) {\n            if (!typeVar.object[typeVar.field].canEnsureResolved()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    maybeEnsureResolved() {\n        for (const typeVar of this.typeVars) {\n            let variable = typeVar.object[typeVar.field];\n            variable = variable.clone(new Map());\n            if (!variable.maybeEnsureResolved())\n                return false;\n        }\n        for (const typeVar of this.typeVars) {\n            typeVar.object[typeVar.field].maybeEnsureResolved();\n        }\n        return true;\n    }\n    tryMergeTypeVariablesWith(other) {\n        // Type variable enabled slot matching will Just Work when we\n        // unify slots and handles.\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return null;\n        }\n        if (other.handles.length !== this.handles.length) {\n            return null;\n        }\n        const handles = new Set(this.handles);\n        const otherHandles = new Set(other.handles);\n        const handleMap = new Map();\n        let sizeCheck = handles.size;\n        while (handles.size > 0) {\n            const handleMatches = [...handles.values()].map(handle => ({ handle, match: [...otherHandles.values()].filter(otherHandle => this._equalHandle(handle, otherHandle)) }));\n            for (const handleMatch of handleMatches) {\n                // no match!\n                if (handleMatch.match.length === 0) {\n                    return null;\n                }\n                if (handleMatch.match.length === 1) {\n                    handleMap.set(handleMatch.handle, handleMatch.match[0]);\n                    otherHandles.delete(handleMatch.match[0]);\n                    handles.delete(handleMatch.handle);\n                }\n            }\n            // no progress!\n            if (handles.size === sizeCheck) {\n                return null;\n            }\n            sizeCheck = handles.size;\n        }\n        const handleList = [];\n        for (const handle of this.handles) {\n            const otherHandle = handleMap.get(handle);\n            let resultType;\n            if (handle.type.hasVariable || otherHandle.type.hasVariable) {\n                resultType = TypeChecker._tryMergeTypeVariable(handle.type, otherHandle.type);\n                if (!resultType) {\n                    return null;\n                }\n            }\n            else {\n                resultType = handle.type || otherHandle.type;\n            }\n            handleList.push({ name: handle.name || otherHandle.name, direction: handle.direction || otherHandle.direction, type: resultType });\n        }\n        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new Shape(this.name, handleList, slots);\n    }\n    resolvedType() {\n        return this._cloneAndUpdate(typeVar => typeVar.resolvedType());\n    }\n    equals(other) {\n        if (this.handles.length !== other.handles.length) {\n            return false;\n        }\n        // TODO: this isn't quite right as it doesn't deal with duplicates properly\n        if (!this._equalItems(other.handles, this.handles, this._equalHandle)) {\n            return false;\n        }\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return false;\n        }\n        return true;\n    }\n    _equalHandle(handle, otherHandle) {\n        return handle.name === otherHandle.name && handle.direction === otherHandle.direction && handle.type.equals(otherHandle.type);\n    }\n    _equalSlot(slot, otherSlot) {\n        return slot.name === otherSlot.name && slot.direction === otherSlot.direction && slot.isRequired === otherSlot.isRequired && slot.isSet === otherSlot.isSet;\n    }\n    _equalItems(otherItems, items, compareItem) {\n        for (const otherItem of otherItems) {\n            let exists = false;\n            for (const item of items) {\n                if (compareItem(item, otherItem)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _cloneAndUpdate(update) {\n        const copy = this.clone(new Map());\n        copy.typeVars.forEach(typeVar => Shape._updateTypeVar(typeVar, update));\n        return copy;\n    }\n    static _updateTypeVar(typeVar, update) {\n        typeVar.object[typeVar.field] = update(typeVar.object[typeVar.field]);\n    }\n    static isTypeVar(reference) {\n        return (reference instanceof Type) && reference.hasProperty(r => r instanceof VariableType);\n    }\n    static mustMatch(reference) {\n        return !(reference == undefined || Shape.isTypeVar(reference));\n    }\n    static handlesMatch(shapeHandle, particleHandle) {\n        if (Shape.mustMatch(shapeHandle.name) &&\n            shapeHandle.name !== particleHandle.name) {\n            return false;\n        }\n        // TODO: direction subsetting?\n        if (Shape.mustMatch(shapeHandle.direction) &&\n            shapeHandle.direction !== particleHandle.direction) {\n            return false;\n        }\n        if (shapeHandle.type == undefined) {\n            return true;\n        }\n        const [left, right] = Type.unwrapPair(shapeHandle.type, particleHandle.type);\n        if (left instanceof VariableType) {\n            return [{ var: left, value: right, direction: shapeHandle.direction }];\n        }\n        else {\n            return left.equals(right);\n        }\n    }\n    static slotsMatch(shapeSlot, particleSlot) {\n        if (Shape.mustMatch(shapeSlot.name) &&\n            shapeSlot.name !== particleSlot.name) {\n            return false;\n        }\n        if (Shape.mustMatch(shapeSlot.direction) &&\n            shapeSlot.direction !== particleSlot.direction) {\n            return false;\n        }\n        if (Shape.mustMatch(shapeSlot.isRequired) &&\n            shapeSlot.isRequired !== particleSlot.isRequired) {\n            return false;\n        }\n        if (Shape.mustMatch(shapeSlot.isSet) &&\n            shapeSlot.isSet !== particleSlot.isSet) {\n            return false;\n        }\n        return true;\n    }\n    particleMatches(particleSpec) {\n        const shape = this.cloneWithResolutions(new Map());\n        return shape.restrictType(particleSpec) !== false;\n    }\n    restrictType(particleSpec) {\n        return this._restrictThis(particleSpec);\n    }\n    _restrictThis(particleSpec) {\n        const handleMatches = this.handles.map(handle => particleSpec.connections.map(connection => ({ match: connection, result: Shape.handlesMatch(handle, connection) }))\n            .filter(a => a.result !== false));\n        const particleSlots = [];\n        particleSpec.slots.forEach(consumedSlot => {\n            particleSlots.push({ name: consumedSlot.name, direction: 'consume', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet });\n            consumedSlot.providedSlots.forEach(providedSlot => {\n                particleSlots.push({ name: providedSlot.name, direction: 'provide', isRequired: false, isSet: providedSlot.isSet });\n            });\n        });\n        let slotMatches = this.slots.map(slot => particleSlots.filter(particleSlot => Shape.slotsMatch(slot, particleSlot)));\n        slotMatches = slotMatches.map(matchList => matchList.map(slot => ({ match: slot, result: true })));\n        const exclusions = [];\n        // TODO: this probably doesn't deal with multiple match options.\n        function choose(list, exclusions) {\n            if (list.length === 0) {\n                return [];\n            }\n            const thisLevel = list.pop();\n            for (const connection of thisLevel) {\n                if (exclusions.includes(connection.match)) {\n                    continue;\n                }\n                const newExclusions = exclusions.slice();\n                newExclusions.push(connection.match);\n                const constraints = choose(list, newExclusions);\n                if (constraints !== false) {\n                    return connection.result.length ? constraints.concat(connection.result) : constraints;\n                }\n            }\n            return false;\n        }\n        const handleOptions = choose(handleMatches, []);\n        const slotOptions = choose(slotMatches, []);\n        if (handleOptions === false || slotOptions === false) {\n            return false;\n        }\n        for (const constraint of handleOptions) {\n            if (!constraint.var.variable.resolution) {\n                constraint.var.variable.resolution = constraint.value;\n            }\n            else if (constraint.var.variable.resolution instanceof VariableType) {\n                // TODO(shans): revisit how this should be done,\n                // consider reusing tryMergeTypeVariablesWith(other).\n                if (!TypeChecker.processTypeList(constraint.var, [{\n                        type: constraint.value, direction: constraint.direction\n                    }]))\n                    return false;\n            }\n            else {\n                if (!constraint.var.variable.resolution.equals(constraint.value))\n                    return false;\n            }\n        }\n        return this;\n    }\n}\nimport { Type } from './type.js';\nimport { TypeChecker } from './recipe/type-checker.js';\n//# sourceMappingURL=shape.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Type } from './type.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Shape } from './shape.js';\nimport { assert } from '../../platform/assert-web.js';\nexport class ConnectionSpec {\n    constructor(rawData, typeVarMap) {\n        this.parentConnection = null;\n        this.rawData = rawData;\n        this.direction = rawData.direction;\n        this.name = rawData.name;\n        this.type = rawData.type.mergeTypeVariablesByName(typeVarMap);\n        this.isOptional = rawData.isOptional;\n        this.tags = rawData.tags || [];\n        this.dependentConnections = [];\n    }\n    instantiateDependentConnections(particle, typeVarMap) {\n        for (const dependentArg of this.rawData.dependentConnections) {\n            const dependentConnection = particle.createConnection(dependentArg, typeVarMap);\n            dependentConnection.parentConnection = this;\n            this.dependentConnections.push(dependentConnection);\n        }\n    }\n    get isInput() {\n        // TODO: we probably don't really want host to be here.\n        return this.direction === 'in' || this.direction === 'inout' || this.direction === 'host';\n    }\n    get isOutput() {\n        return this.direction === 'out' || this.direction === 'inout';\n    }\n    isCompatibleType(type) {\n        return TypeChecker.compareTypes({ type }, { type: this.type, direction: this.direction });\n    }\n}\nexport class SlotSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired;\n        this.isSet = slotModel.isSet;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.providedSlots = [];\n        if (!slotModel.providedSlots) {\n            return;\n        }\n        slotModel.providedSlots.forEach(ps => {\n            this.providedSlots.push(new ProvidedSlotSpec(ps));\n        });\n    }\n    getProvidedSlotSpec(name) {\n        return this.providedSlots.find(ps => ps.name === name);\n    }\n}\nexport class ProvidedSlotSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired || false;\n        this.isSet = slotModel.isSet || false;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.handles = slotModel.handles || [];\n    }\n}\nexport class ParticleSpec {\n    constructor(model) {\n        this.model = model;\n        this.name = model.name;\n        this.verbs = model.verbs;\n        const typeVarMap = new Map();\n        this.connections = [];\n        model.args.forEach(arg => this.createConnection(arg, typeVarMap));\n        this.connectionMap = new Map();\n        this.connections.forEach(a => this.connectionMap.set(a.name, a));\n        this.inputs = this.connections.filter(a => a.isInput);\n        this.outputs = this.connections.filter(a => a.isOutput);\n        // initialize descriptions patterns.\n        model.description = model.description || {};\n        this.validateDescription(model.description);\n        this.pattern = model.description['pattern'];\n        this.connections.forEach(connectionSpec => {\n            connectionSpec.pattern = model.description[connectionSpec.name];\n        });\n        this.implFile = model.implFile;\n        this.modality = model.modality;\n        this.slots = new Map();\n        if (model.slots) {\n            model.slots.forEach(s => this.slots.set(s.name, new SlotSpec(s)));\n        }\n        // Verify provided slots use valid handle connection names.\n        this.slots.forEach(slot => {\n            slot.providedSlots.forEach(ps => {\n                ps.handles.forEach(v => assert(this.connectionMap.has(v), 'Cannot provide slot for nonexistent handle constraint ', v));\n            });\n        });\n    }\n    createConnection(arg, typeVarMap) {\n        const connection = new ConnectionSpec(arg, typeVarMap);\n        this.connections.push(connection);\n        connection.instantiateDependentConnections(this, typeVarMap);\n        return connection;\n    }\n    isInput(param) {\n        for (const input of this.inputs)\n            if (input.name === param)\n                return true;\n        return false;\n    }\n    isOutput(param) {\n        for (const outputs of this.outputs)\n            if (outputs.name === param)\n                return true;\n        return false;\n    }\n    getSlotSpec(slotName) {\n        return this.slots.get(slotName);\n    }\n    get primaryVerb() {\n        return (this.verbs.length > 0) ? this.verbs[0] : undefined;\n    }\n    matchModality(modality) {\n        return this.slots.size <= 0 || this.modality.includes(modality);\n    }\n    toLiteral() {\n        const { args, name, verbs, description, implFile, modality, slots } = this.model;\n        const connectionToLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: type.toLiteral(), direction, name, isOptional, dependentConnections: dependentConnections.map(connectionToLiteral) });\n        const argsLiteral = args.map(a => connectionToLiteral(a));\n        return { args: argsLiteral, name, verbs, description, implFile, modality, slots };\n    }\n    static fromLiteral(literal) {\n        let { args, name, verbs, description, implFile, modality, slots } = literal;\n        const connectionFromLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: Type.fromLiteral(type), direction, name, isOptional, dependentConnections: dependentConnections ? dependentConnections.map(connectionFromLiteral) : [] });\n        args = args.map(connectionFromLiteral);\n        return new ParticleSpec({ args, name, verbs: verbs || [], description, implFile, modality, slots });\n    }\n    clone() {\n        return ParticleSpec.fromLiteral(this.toLiteral());\n    }\n    equals(other) {\n        return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());\n    }\n    validateDescription(description) {\n        Object.keys(description || []).forEach(d => {\n            assert(['kind', 'location', 'pattern'].includes(d) || this.connectionMap.has(d), `Unexpected description for ${d}`);\n        });\n    }\n    toInterface() {\n        return Type.newInterface(this._toShape());\n    }\n    _toShape() {\n        const handles = this.model.args;\n        // TODO: wat do?\n        assert(!this.slots.size, 'please implement slots toShape');\n        const slots = [];\n        return new Shape(this.name, handles, slots);\n    }\n    toString() {\n        const results = [];\n        let verbs = '';\n        if (this.verbs.length > 0) {\n            verbs = ' ' + this.verbs.map(verb => `&${verb}`).join(' ');\n        }\n        results.push(`particle ${this.name}${verbs} in '${this.implFile}'`.trim());\n        const indent = '  ';\n        const writeConnection = (connection, indent) => {\n            const tags = connection.tags.map((tag) => ` #${tag}`).join('');\n            results.push(`${indent}${connection.direction}${connection.isOptional ? '?' : ''} ${connection.type.toString()} ${connection.name}${tags}`);\n            for (const dependent of connection.dependentConnections) {\n                writeConnection(dependent, indent + '  ');\n            }\n        };\n        for (const connection of this.connections) {\n            if (connection.parentConnection) {\n                continue;\n            }\n            writeConnection(connection, indent);\n        }\n        this.modality.filter(a => a !== 'mock').forEach(a => results.push(`  modality ${a}`));\n        this.slots.forEach(s => {\n            // Consume slot.\n            const consume = [];\n            if (s.isRequired) {\n                consume.push('must');\n            }\n            consume.push('consume');\n            if (s.isSet) {\n                consume.push('set of');\n            }\n            consume.push(s.name);\n            if (s.tags.length > 0) {\n                consume.push(s.tags.map(a => `#${a}`).join(' '));\n            }\n            results.push(`  ${consume.join(' ')}`);\n            if (s.formFactor) {\n                results.push(`    formFactor ${s.formFactor}`);\n            }\n            // Provided slots.\n            s.providedSlots.forEach(ps => {\n                const provide = [];\n                if (ps.isRequired) {\n                    provide.push('must');\n                }\n                provide.push('provide');\n                if (ps.isSet) {\n                    provide.push('set of');\n                }\n                provide.push(ps.name);\n                if (ps.tags.length > 0) {\n                    provide.push(ps.tags.map(a => `#${a}`).join(' '));\n                }\n                results.push(`    ${provide.join(' ')}`);\n                if (ps.formFactor) {\n                    results.push(`      formFactor ${ps.formFactor}`);\n                }\n                ps.handles.forEach(handle => results.push(`      handle ${handle}`));\n            });\n        });\n        // Description\n        if (this.pattern) {\n            results.push(`  description \\`${this.pattern}\\``);\n            this.connections.forEach(cs => {\n                if (cs.pattern) {\n                    results.push(`    ${cs.name} \\`${cs.pattern}\\``);\n                }\n            });\n        }\n        return results.join('\\n');\n    }\n    toManifestString() {\n        return this.toString();\n    }\n}\n//# sourceMappingURL=particle-spec.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {assert} from '../platform/assert-web.js';\nimport {ParticleSpec} from './ts-build/particle-spec.js';\nimport {Type} from './ts-build/type.js';\nimport {OuterPortAttachment} from './ts-build/debug/outer-port-attachment.js';\nimport {DevtoolsConnection} from './ts-build/debug/devtools-connection.js';\n\nclass ThingMapper {\n  constructor(prefix) {\n    this._prefix = prefix;\n    this._nextIdentifier = 0;\n    this._idMap = new Map();\n    this._reverseIdMap = new Map();\n  }\n\n  _newIdentifier() {\n    return this._prefix + (this._nextIdentifier++);\n  }\n\n  createMappingForThing(thing, requestedId) {\n    assert(!this._reverseIdMap.has(thing));\n    let id;\n    if (requestedId) {\n      id = requestedId;\n    } else if (thing.apiChannelMappingId) {\n      id = thing.apiChannelMappingId;\n    } else {\n      id = this._newIdentifier();\n    }\n    assert(!this._idMap.has(id), `${requestedId ? 'requestedId' : (thing.apiChannelMappingId ? 'apiChannelMappingId' : 'newIdentifier()')} ${id} already in use`);\n    this.establishThingMapping(id, thing);\n    return id;\n  }\n\n  maybeCreateMappingForThing(thing) {\n    if (this.hasMappingForThing(thing)) {\n      return this.identifierForThing(thing);\n    }\n    return this.createMappingForThing(thing);\n  }\n\n  async establishThingMapping(id, thing) {\n    let continuation;\n    if (Array.isArray(thing)) {\n      [thing, continuation] = thing;\n    }\n    this._idMap.set(id, thing);\n    if (thing instanceof Promise) {\n      assert(continuation == null);\n      await this.establishThingMapping(id, await thing);\n    } else {\n      this._reverseIdMap.set(thing, id);\n      if (continuation) {\n        await continuation();\n      }\n    }\n  }\n\n  hasMappingForThing(thing) {\n    return this._reverseIdMap.has(thing);\n  }\n\n  identifierForThing(thing) {\n    assert(this._reverseIdMap.has(thing), `Missing thing [${thing}]`);\n    return this._reverseIdMap.get(thing);\n  }\n\n  thingForIdentifier(id) {\n    assert(this._idMap.has(id), `Missing id: ${id}`);\n    return this._idMap.get(id);\n  }\n}\n\n\nexport class APIPort {\n  constructor(messagePort, prefix) {\n    this._port = messagePort;\n    this._mapper = new ThingMapper(prefix);\n    this._messageMap = new Map();\n    this._port.onmessage = async e => this._processMessage(e);\n    this._debugAttachment = null;\n    this._attachStack = false;\n    this.messageCount = 0;\n\n    this.Direct = {\n      convert: a => a,\n      unconvert: a => a\n    };\n\n    this.LocalMapped = {\n      convert: a => this._mapper.maybeCreateMappingForThing(a),\n      unconvert: a => this._mapper.thingForIdentifier(a)\n    };\n\n    this.Mapped = {\n      convert: a => this._mapper.identifierForThing(a),\n      unconvert: a => this._mapper.thingForIdentifier(a)\n    };\n\n    this.Map = function(keyprimitive, valueprimitive) {\n      return {\n        convert: a => {\n          const r = {};\n          a.forEach((value, key) => r[keyprimitive.convert(key)] = valueprimitive.convert(value));\n          return r;\n        },\n        unconvert: a => {\n          const r = new Map();\n          for (const key in a) {\n            r.set(\n                keyprimitive.unconvert(key), valueprimitive.unconvert(a[key]));\n          }\n          return r;\n        }\n      };\n    };\n\n    this.List = function(primitive) {\n      return {\n        convert: a => a.map(v => primitive.convert(v)),\n        unconvert: a => a.map(v => primitive.unconvert(v))\n      };\n    };\n\n    this.ByLiteral = function(clazz) {\n      return {\n        convert: a => a.toLiteral(),\n        unconvert: a => clazz.fromLiteral(a)\n      };\n    };\n\n    this._testingHook();\n  }\n\n  // Overridden by unit tests.\n  _testingHook() {\n  }\n\n  close() {\n    this._port.close();\n  }\n\n  async _processMessage(e) {\n    assert(this._messageMap.has(e.data.messageType));\n\n    const cnt = this.messageCount++;\n\n    const handler = this._messageMap.get(e.data.messageType);\n    let args;\n    try {\n      args = this._unprocessArguments(handler.args, e.data.messageBody);\n    } catch (exc) {\n      console.error(`Exception during unmarshaling for ${e.data.messageType}`);\n      throw exc;\n    }\n    // If any of the converted arguments are still pending promises\n    // wait for them to complete before processing the message.\n    for (const arg of Object.values(args)) {\n      if (arg instanceof Promise) {\n        arg.then(() => this._processMessage(e));\n        return;\n      }\n    }\n    const handlerName = 'on' + e.data.messageType;\n    assert(this[handlerName], `no handler named ${handlerName}`);\n    if (this._debugAttachment) {\n      this._debugAttachment.handlePecMessage(handlerName, e.data.messageBody, cnt, e.data.stack);\n    }\n    const result = this[handlerName](args);\n    if (handler.isInitializer) {\n      assert(args.identifier);\n      await this._mapper.establishThingMapping(args.identifier, result);\n    }\n  }\n\n  _processArguments(argumentTypes, args) {\n    const messageBody = {};\n    for (const argument in argumentTypes) {\n      messageBody[argument] = argumentTypes[argument].convert(args[argument]);\n    }\n    return messageBody;\n  }\n\n  _unprocessArguments(argumentTypes, args) {\n    const messageBody = {};\n    for (const argument in argumentTypes) {\n      messageBody[argument] = argumentTypes[argument].unconvert(args[argument]);\n    }\n    return messageBody;\n  }\n\n  registerCall(name, argumentTypes) {\n    this[name] = args => {\n      const call = {messageType: name, messageBody: this._processArguments(argumentTypes, args)};\n      if (this._attachStack) call.stack = new Error().stack;\n      const cnt = this.messageCount++;\n      this._port.postMessage(call);\n      if (this._debugAttachment) {\n        this._debugAttachment.handlePecMessage(name, call.messageBody, cnt, new Error().stack);\n      }\n    };\n  }\n\n  registerHandler(name, argumentTypes) {\n    this._messageMap.set(name, {args: argumentTypes});\n  }\n\n  registerInitializerHandler(name, argumentTypes) {\n    argumentTypes.identifier = this.Direct;\n    this._messageMap.set(name, {\n      isInitializer: true,\n      args: argumentTypes,\n    });\n  }\n\n  registerRedundantInitializer(name, argumentTypes, mappingIdArg) {\n    this.registerInitializer(name, argumentTypes, mappingIdArg, true /* redundant */);\n  }\n\n  registerInitializer(name, argumentTypes, mappingIdArg = null, redundant = false) {\n    this[name] = (thing, args) => {\n      if (redundant && this._mapper.hasMappingForThing(thing)) return;\n      const call = {messageType: name, messageBody: this._processArguments(argumentTypes, args)};\n      if (this._attachStack) call.stack = new Error().stack;\n      const requestedId = mappingIdArg && args[mappingIdArg];\n      call.messageBody.identifier = this._mapper.createMappingForThing(thing, requestedId);\n      const cnt = this.messageCount++;\n      this._port.postMessage(call);\n      if (this._debugAttachment) {\n        this._debugAttachment.handlePecMessage(name, call.messageBody, cnt, new Error().stack);\n      }\n    };\n  }\n}\n\nexport class PECOuterPort extends APIPort {\n  constructor(messagePort, arc) {\n    super(messagePort, 'o');\n\n    this.registerCall('Stop', {});\n    this.registerRedundantInitializer('DefineHandle', {type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializer('InstantiateParticle',\n      {id: this.Direct, spec: this.ByLiteral(ParticleSpec), handles: this.Map(this.Direct, this.Mapped)}, 'id');\n\n    this.registerCall('UIEvent', {particle: this.Mapped, slotName: this.Direct, event: this.Direct});\n    this.registerCall('SimpleCallback', {callback: this.Direct, data: this.Direct});\n    this.registerCall('AwaitIdle', {version: this.Direct});\n    this.registerCall('StartRender', {particle: this.Mapped, slotName: this.Direct, providedSlots: this.Map(this.Direct, this.Direct), contentTypes: this.List(this.Direct)});\n    this.registerCall('StopRender', {particle: this.Mapped, slotName: this.Direct});\n\n    this.registerHandler('Render', {particle: this.Mapped, slotName: this.Direct, content: this.Direct});\n    this.registerHandler('InitializeProxy', {handle: this.Mapped, callback: this.Direct});\n    this.registerHandler('SynchronizeProxy', {handle: this.Mapped, callback: this.Direct});\n    this.registerHandler('HandleGet', {handle: this.Mapped, callback: this.Direct});\n    this.registerHandler('HandleToList', {handle: this.Mapped, callback: this.Direct});\n    this.registerHandler('HandleSet', {handle: this.Mapped, data: this.Direct, particleId: this.Direct, barrier: this.Direct});\n    this.registerHandler('HandleClear', {handle: this.Mapped, particleId: this.Direct, barrier: this.Direct});\n    this.registerHandler('HandleStore', {handle: this.Mapped, callback: this.Direct, data: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleRemove', {handle: this.Mapped, callback: this.Direct, data: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleRemoveMultiple', {handle: this.Mapped, callback: this.Direct, data: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleStream', {handle: this.Mapped, callback: this.Direct, pageSize: this.Direct, forward: this.Direct});\n    this.registerHandler('StreamCursorNext', {handle: this.Mapped, callback: this.Direct, cursorId: this.Direct});\n    this.registerHandler('StreamCursorClose', {handle: this.Mapped, cursorId: this.Direct});\n\n    this.registerHandler('Idle', {version: this.Direct, relevance: this.Map(this.Mapped, this.Direct)});\n\n    this.registerHandler('GetBackingStore', {callback: this.Direct, storageKey: this.Direct, type: this.ByLiteral(Type)});\n    this.registerInitializer('GetBackingStoreCallback', {callback: this.Direct, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct, storageKey: this.Direct});\n\n    this.registerHandler('ConstructInnerArc', {callback: this.Direct, particle: this.Mapped});\n    this.registerCall('ConstructArcCallback', {callback: this.Direct, arc: this.LocalMapped});\n\n    this.registerHandler('ArcCreateHandle', {callback: this.Direct, arc: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializer('CreateHandleCallback', {callback: this.Direct, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct});\n    this.registerHandler('ArcMapHandle', {callback: this.Direct, arc: this.LocalMapped, handle: this.Mapped});\n    this.registerInitializer('MapHandleCallback', {callback: this.Direct, id: this.Direct});\n    this.registerHandler('ArcCreateSlot',\n      {callback: this.Direct, arc: this.LocalMapped, transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedParticleName: this.Direct, hostedSlotName: this.Direct, handleId: this.Direct});\n    this.registerInitializer('CreateSlotCallback', {callback: this.Direct, hostedSlotId: this.Direct});\n    this.registerCall('InnerArcRender', {transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedSlotId: this.Direct, content: this.Direct});\n\n    this.registerHandler('ArcLoadRecipe', {arc: this.LocalMapped, recipe: this.Direct, callback: this.Direct});\n\n    this.registerHandler('RaiseSystemException', {exception: this.Direct, methodName: this.Direct, particleId: this.Direct});\n\n    // We need an API call to tell the context side that DevTools has been connected, so it can start sending\n    // stack traces attached to the API calls made from that side.\n    this.registerCall('DevToolsConnected', {});\n    DevtoolsConnection.onceConnected.then(devtoolsChannel => {\n      this.DevToolsConnected();\n      this._debugAttachment = new OuterPortAttachment(arc, devtoolsChannel);\n    });\n  }\n}\n\nexport class PECInnerPort extends APIPort {\n  constructor(messagePort) {\n    super(messagePort, 'i');\n\n    this.registerHandler('Stop', {});\n    this.registerInitializerHandler('DefineHandle', {type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializerHandler('InstantiateParticle',\n      {id: this.Direct, spec: this.ByLiteral(ParticleSpec), handles: this.Map(this.Direct, this.Mapped)});\n\n    this.registerHandler('UIEvent', {particle: this.Mapped, slotName: this.Direct, event: this.Direct});\n    this.registerHandler('SimpleCallback', {callback: this.LocalMapped, data: this.Direct});\n    this.registerHandler('AwaitIdle', {version: this.Direct});\n    this.registerHandler('StartRender', {particle: this.Mapped, slotName: this.Direct, providedSlots: this.Map(this.Direct, this.Direct), contentTypes: this.List(this.Direct)});\n    this.registerHandler('StopRender', {particle: this.Mapped, slotName: this.Direct});\n\n    this.registerCall('Render', {particle: this.Mapped, slotName: this.Direct, content: this.Direct});\n    this.registerCall('InitializeProxy', {handle: this.Mapped, callback: this.LocalMapped});\n    this.registerCall('SynchronizeProxy', {handle: this.Mapped, callback: this.LocalMapped});\n    this.registerCall('HandleGet', {handle: this.Mapped, callback: this.LocalMapped});\n    this.registerCall('HandleToList', {handle: this.Mapped, callback: this.LocalMapped});\n    this.registerCall('HandleSet', {handle: this.Mapped, data: this.Direct, particleId: this.Direct, barrier: this.Direct});\n    this.registerCall('HandleClear', {handle: this.Mapped, particleId: this.Direct, barrier: this.Direct});\n    this.registerCall('HandleStore', {handle: this.Mapped, callback: this.LocalMapped, data: this.Direct, particleId: this.Direct});\n    this.registerCall('HandleRemove', {handle: this.Mapped, callback: this.LocalMapped, data: this.Direct, particleId: this.Direct});\n    this.registerCall('HandleRemoveMultiple', {handle: this.Mapped, callback: this.LocalMapped, data: this.Direct, particleId: this.Direct});\n    this.registerCall('HandleStream', {handle: this.Mapped, callback: this.LocalMapped, pageSize: this.Direct, forward: this.Direct});\n    this.registerCall('StreamCursorNext', {handle: this.Mapped, callback: this.LocalMapped, cursorId: this.Direct});\n    this.registerCall('StreamCursorClose', {handle: this.Mapped, cursorId: this.Direct});\n\n    this.registerCall('Idle', {version: this.Direct, relevance: this.Map(this.Mapped, this.Direct)});\n\n    this.registerCall('GetBackingStore', {callback: this.LocalMapped, storageKey: this.Direct, type: this.ByLiteral(Type)});\n    this.registerInitializerHandler('GetBackingStoreCallback', {callback: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct, storageKey: this.Direct});\n\n    this.registerCall('ConstructInnerArc', {callback: this.LocalMapped, particle: this.Mapped});\n    this.registerHandler('ConstructArcCallback', {callback: this.LocalMapped, arc: this.Direct});\n\n    this.registerCall('ArcCreateHandle', {callback: this.LocalMapped, arc: this.Direct, type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializerHandler('CreateHandleCallback', {callback: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct});\n    this.registerCall('ArcMapHandle', {callback: this.LocalMapped, arc: this.Direct, handle: this.Mapped});\n    this.registerInitializerHandler('MapHandleCallback', {callback: this.LocalMapped, id: this.Direct});\n    this.registerCall('ArcCreateSlot',\n      {callback: this.LocalMapped, arc: this.Direct, transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedParticleName: this.Direct, hostedSlotName: this.Direct, handleId: this.Direct});\n    this.registerInitializerHandler('CreateSlotCallback', {callback: this.LocalMapped, hostedSlotId: this.Direct});\n    this.registerHandler('InnerArcRender', {transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedSlotId: this.Direct, content: this.Direct});\n\n    this.registerCall('ArcLoadRecipe', {arc: this.Direct, recipe: this.Direct, callback: this.LocalMapped});\n\n    this.registerCall('RaiseSystemException', {exception: this.Direct, methodName: this.Direct, particleId: this.Direct});\n\n    // To show stack traces for calls made inside the context, we need to capture the trace at the call point and\n    // send it along with the message. We only want to do this after a DevTools connection has been detected, which\n    // we can't directly detect inside a worker context, so the PECOuterPort will send an API message instead.\n    this.registerHandler('DevToolsConnected', {});\n    this.onDevToolsConnected = () => this._attachStack = true;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { mapStackTrace } from '../../../platform/sourcemapped-stacktrace-web.js';\nexport class OuterPortAttachment {\n    constructor(arc, devtoolsChannel) {\n        this._devtoolsChannel = devtoolsChannel;\n        this._arcIdString = arc.id.toString();\n        this._speculative = arc.isSpeculative;\n    }\n    handlePecMessage(name, pecMsgBody, pecMsgCount, stackString) {\n        // Skip speculative and pipes arcs for now.\n        if (this._arcIdString.endsWith('-pipes') || this._speculative)\n            return;\n        const stack = this._extractStackFrames(stackString);\n        this._devtoolsChannel.send({\n            messageType: 'PecLog',\n            messageBody: { name, pecMsgBody, pecMsgCount, timestamp: Date.now(), stack },\n        });\n    }\n    _extractStackFrames(stackString) {\n        const stack = [];\n        if (!stackString)\n            return stack;\n        // File refs should appear only in stack traces generated by tests run with\n        // --explore set.\n        if (stackString.includes('(file:///')) {\n            // The slice discards the 'Error' text and the the stack frame\n            // corresponding to the API channel function, which is already being\n            // displayed in the log entry.\n            for (const frameString of stackString.split('\\n    at ').slice(2)) {\n                let match = frameString.match(/^(.*) \\((.*)\\)$/);\n                if (match === null) {\n                    match = { 1: '<unknown>', 2: frameString };\n                }\n                let location = match[2].replace(/:[0-9]+$/, '');\n                if (location.startsWith('file')) {\n                    // 'file:///<path>/arcs.*/runtime/file.js:84'\n                    // -> location: 'runtime/file.js:150'\n                    location = location.replace(/^.*\\/arcs[^/]*\\//, '');\n                }\n                stack.push({ method: match[1], location, target: null, targetClass: 'noLink' });\n            }\n            return stack;\n        }\n        // The slice discards the stack frame corresponding to the API channel\n        // function, which is already being displayed in the log entry.\n        mapStackTrace(stackString, mapped => mapped.slice(1).map(frameString => {\n            // Each frame has the form '    at function (source:line:column)'.\n            // Extract the function name and source:line:column text, then set up\n            // a frame object with the following fields:\n            //   location: text to display as the source in devtools Arcs panel\n            //   target: URL to open in devtools Sources panel\n            //   targetClass: CSS class specifier to attach to the location text\n            let match = frameString.match(/^ {4}at (.*) \\((.*)\\)$/);\n            if (match === null) {\n                match = { 1: '<unknown>', 2: frameString.replace(/^ *at */, '') };\n            }\n            const frame = { method: match[1] };\n            const source = match[2].replace(/:[0-9]+$/, '');\n            if (source.startsWith('http')) {\n                // 'http://<url>/arcs.*/shell/file.js:150'\n                // -> location: 'shell/file.js:150', target: same as source\n                frame.location = source.replace(/^.*\\/arcs[^/]*\\//, '');\n                frame.target = source;\n                frame.targetClass = 'link';\n            }\n            else if (source.startsWith('webpack')) {\n                // 'webpack:///runtime/sub/file.js:18'\n                // -> location: 'runtime/sub/file.js:18', target: 'webpack:///./runtime/sub/file.js:18'\n                frame.location = source.slice(11);\n                frame.target = `webpack:///./${frame.location}`;\n                frame.targetClass = 'link';\n            }\n            else {\n                // '<anonymous>' (or similar)\n                frame.location = source;\n                frame.target = null;\n                frame.targetClass = 'noLink';\n            }\n            stack.push(frame);\n        }), { sync: true, cacheGlobally: true });\n        return stack;\n    }\n}\n//# sourceMappingURL=outer-port-attachment.js.map","// Copyright (c) 2018 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n// \"Convert\" old-style module to ES6.\nconst smst = require('sourcemapped-stacktrace/sourcemapped-stacktrace.js');\nexport const mapStackTrace = smst.mapStackTrace;\n","/*\n * sourcemapped-stacktrace.js\n * created by James Salter <iteration@gmail.com> (2014)\n *\n * https://github.com/novocaine/sourcemapped-stacktrace\n *\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/*global define */\n\n// note we only include source-map-consumer, not the whole source-map library,\n// which includes gear for generating source maps that we don't need\ndefine(['source-map/lib/source-map-consumer'],\nfunction(source_map_consumer) {\n\n  var global_mapForUri = {};\n\n  /**\n   * Re-map entries in a stacktrace using sourcemaps if available.\n   *\n   * @param {Array} stack - Array of strings from the browser's stack\n   *                        representation. Currently only Chrome\n   *                        format is supported.\n   * @param {function} done - Callback invoked with the transformed stacktrace\n   *                          (an Array of Strings) passed as the first\n   *                          argument\n   * @param {Object} [opts] - Optional options object.\n   * @param {Function} [opts.filter] - Filter function applied to each stackTrace line.\n   *                                   Lines which do not pass the filter won't be processesd.\n   * @param {boolean} [opts.cacheGlobally] - Whether to cache sourcemaps globally across multiple calls.\n   * @param {boolean} [opts.sync] - Whether to use synchronous ajax to load the sourcemaps.\n   */\n  var mapStackTrace = function(stack, done, opts) {\n    var lines;\n    var line;\n    var mapForUri = {};\n    var rows = {};\n    var fields;\n    var uri;\n    var expected_fields;\n    var regex;\n    var skip_lines;\n\n    var fetcher = new Fetcher(opts);\n\n    if (isChromeOrEdge() || isIE11Plus()) {\n      regex = /^ +at.+\\((.*):([0-9]+):([0-9]+)/;\n      expected_fields = 4;\n      // (skip first line containing exception message)\n      skip_lines = 1;\n    } else if (isFirefox() || isSafari()) {\n      regex = /@(.*):([0-9]+):([0-9]+)/;\n      expected_fields = 4;\n      skip_lines = 0;\n    } else {\n      throw new Error(\"unknown browser :(\");\n    }\n\n    lines = stack.split(\"\\n\").slice(skip_lines);\n\n    for (var i=0; i < lines.length; i++) {\n      line = lines[i];\n      if ( opts && opts.filter && !opts.filter(line) ) continue;\n      \n      fields = line.match(regex);\n      if (fields && fields.length === expected_fields) {\n        rows[i] = fields;\n        uri = fields[1];\n        if (!uri.match(/<anonymous>/)) {\n          fetcher.fetchScript(uri);\n        }\n      }\n    }\n\n    fetcher.sem.whenReady(function() {\n      var result = processSourceMaps(lines, rows, fetcher.mapForUri);\n      done(result);\n    });\n  };\n\n  var isChromeOrEdge = function() {\n    return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;\n  };\n\n  var isFirefox = function() {\n    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n  };  \n\n  var isSafari = function() {\n    return navigator.userAgent.toLowerCase().indexOf('safari') > -1;\n  };\n\t\t\n  var isIE11Plus = function() {\n   \treturn document.documentMode && document.documentMode >= 11;\n  };\n\n\n  var Semaphore = function() {\n    this.count = 0;\n    this.pending = [];\n  };\n\n  Semaphore.prototype.incr = function() {\n    this.count++;\n  };\n\n  Semaphore.prototype.decr = function() {\n    this.count--;\n    this.flush();\n  };\n\n  Semaphore.prototype.whenReady = function(fn) {\n    this.pending.push(fn);\n    this.flush();\n  };\n\n  Semaphore.prototype.flush = function() {\n    if (this.count === 0) {\n        this.pending.forEach(function(fn) { fn(); });\n        this.pending = [];\n    }\n  };\n\n\n  var Fetcher = function(opts) {\n    this.sem = new Semaphore();\n    this.sync = opts && opts.sync;\n    this.mapForUri = opts && opts.cacheGlobally ? global_mapForUri : {};\n  };\n\n  Fetcher.prototype.ajax = function(uri, callback) {\n    var xhr = createXMLHTTPObject();\n    var that = this;\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState == 4) {\n        callback.call(that, xhr, uri);\n      }\n    };\n    xhr.open(\"GET\", uri, !this.sync);\n    xhr.send();\n  }\n\n  Fetcher.prototype.fetchScript = function(uri) {\n    if (!(uri in this.mapForUri)) {\n      this.sem.incr();\n      this.mapForUri[uri] = null;\n    } else {\n      return;\n    }\n\n    this.ajax(uri, this.onScriptLoad);\n  };\n\n  var absUrlRegex = new RegExp('^(?:[a-z]+:)?//', 'i');\n\n  Fetcher.prototype.onScriptLoad = function(xhr, uri) {\n    if (xhr.status === 200 || (uri.slice(0, 7) === \"file://\" && xhr.status === 0)) {\n      // find .map in file.\n      //\n      // attempt to find it at the very end of the file, but tolerate trailing\n      // whitespace inserted by some packers.\n      var match = xhr.responseText.match(\"//# [s]ourceMappingURL=(.*)[\\\\s]*$\", \"m\");\n      if (match && match.length === 2) {\n        // get the map\n        var mapUri = match[1];\n\n        var embeddedSourceMap = mapUri.match(\"data:application/json;(charset=[^;]+;)?base64,(.*)\");\n\n        if (embeddedSourceMap && embeddedSourceMap[2]) {\n          this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(atob(embeddedSourceMap[2]));\n          this.sem.decr();\n        } else {\n          if (!absUrlRegex.test(mapUri)) {\n            // relative url; according to sourcemaps spec is 'source origin'\n            var origin;\n            var lastSlash = uri.lastIndexOf('/');\n            if (lastSlash !== -1) {\n              origin = uri.slice(0, lastSlash + 1);\n              mapUri = origin + mapUri;\n              // note if lastSlash === -1, actual script uri has no slash\n              // somehow, so no way to use it as a prefix... we give up and try\n              // as absolute\n            }\n          }\n\n          this.ajax(mapUri, function(xhr) {\n            if (xhr.status === 200 || (mapUri.slice(0, 7) === \"file://\" && xhr.status === 0)) {\n              this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(xhr.responseText);\n            }\n            this.sem.decr();\n          });\n        }\n      } else {\n        // no map\n        this.sem.decr();\n      }\n    } else {\n      // HTTP error fetching uri of the script\n      this.sem.decr();\n    }\n  };\n\n  var processSourceMaps = function(lines, rows, mapForUri) {\n    var result = [];\n    var map;\n    for (var i=0; i < lines.length; i++) {\n      var row = rows[i];\n      if (row) {\n        var uri = row[1];\n        var line = parseInt(row[2], 10);\n        var column = parseInt(row[3], 10);\n        map = mapForUri[uri];\n\n        if (map) {\n          // we think we have a map for that uri. call source-map library\n          var origPos = map.originalPositionFor(\n            { line: line, column: column });\n          result.push(formatOriginalPosition(origPos.source,\n            origPos.line, origPos.column, origPos.name || origName(lines[i])));\n        } else {\n          // we can't find a map for that url, but we parsed the row.\n          // reformat unchanged line for consistency with the sourcemapped\n          // lines.\n          result.push(formatOriginalPosition(uri, line, column, origName(lines[i])));\n        }\n      } else {\n        // we weren't able to parse the row, push back what we were given\n        result.push(lines[i]);\n      }\n    }\n\n    return result;\n  };\n\n  function origName(origLine) {\n    var match = String(origLine).match((isChromeOrEdge() || isIE11Plus()) ?\n      / +at +([^ ]*).*/ :\n      /([^@]*)@.*/);\n    return match && match[1];\n  }\n\n  var formatOriginalPosition = function(source, line, column, name) {\n    // mimic chrome's format\n    return \"    at \" + (name ? name : \"(unknown)\") +\n      \" (\" + source + \":\" + line + \":\" + column + \")\";\n  };\n\n  // xmlhttprequest boilerplate\n  var XMLHttpFactories = [\n\tfunction () {return new XMLHttpRequest();},\n\tfunction () {return new ActiveXObject(\"Msxml2.XMLHTTP\");},\n\tfunction () {return new ActiveXObject(\"Msxml3.XMLHTTP\");},\n\tfunction () {return new ActiveXObject(\"Microsoft.XMLHTTP\");}\n  ];\n\n  function createXMLHTTPObject() {\n      var xmlhttp = false;\n      for (var i=0;i<XMLHttpFactories.length;i++) {\n          try {\n              xmlhttp = XMLHttpFactories[i]();\n          }\n          catch (e) {\n              continue;\n          }\n          break;\n      }\n      return xmlhttp;\n  }\n\n  return {\n    mapStackTrace: mapStackTrace\n  }\n});\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = util.toSetString(aStr);\n  var isDuplicate = has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    this._set[sStr] = idx;\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  var sStr = util.toSetString(aStr);\n  return has.call(this._set, sStr);\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  var sStr = util.toSetString(aStr);\n  if (has.call(this._set, sStr)) {\n    return this._set[sStr];\n  }\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../../platform/assert-web.js';\nimport { DevtoolsChannel } from '../../../platform/devtools-channel-web.js';\nimport { DevtoolsChannelStub } from './testing/devtools-channel-stub.js';\nimport { DevtoolsBroker } from '../../../devtools/shared/devtools-broker.js';\nlet channel = null;\nlet isConnected = false;\nlet onceConnectedResolve = null;\nlet onceConnected = new Promise(resolve => onceConnectedResolve = resolve);\nDevtoolsBroker.onceConnected.then(() => {\n    DevtoolsConnection.ensure();\n    onceConnectedResolve(channel);\n    isConnected = true;\n});\nexport class DevtoolsConnection {\n    static get isConnected() {\n        return isConnected;\n    }\n    static get onceConnected() {\n        return onceConnected;\n    }\n    static get() {\n        return channel;\n    }\n    static ensure() {\n        if (!channel)\n            channel = new DevtoolsChannel();\n    }\n}\nexport class DevtoolsForTests {\n    static get channel() {\n        return channel;\n    }\n    static ensureStub() {\n        assert(!channel);\n        channel = new DevtoolsChannelStub();\n        onceConnectedResolve(channel);\n        isConnected = true;\n    }\n    static reset() {\n        assert(channel);\n        isConnected = false;\n        onceConnectedResolve = null;\n        onceConnected = new Promise(resolve => onceConnectedResolve = resolve);\n        channel = null;\n    }\n}\n//# sourceMappingURL=devtools-connection.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {AbstractDevtoolsChannel} from '../runtime/ts-build/debug/abstract-devtools-channel.js';\n\nexport class DevtoolsChannel extends AbstractDevtoolsChannel {\n  constructor() {\n    super();\n    document.addEventListener('arcs-debug-in', e => this._handleMessage(e.detail));\n  }\n\n  _flush(messages) {\n    document.dispatchEvent(new CustomEvent('arcs-debug-out', {detail: messages}));\n  }\n}\n","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../../platform/assert-web.js';\nexport class AbstractDevtoolsChannel {\n    constructor() {\n        this.debouncedMessages = [];\n        this.debouncing = false;\n        this.messageListeners = new Map();\n    }\n    send(message) {\n        this.debouncedMessages.push(message);\n        if (!this.debouncing) {\n            this.debouncing = true;\n            setTimeout(() => {\n                this._flush(this.debouncedMessages);\n                this.debouncedMessages = [];\n                this.debouncing = false;\n            }, 100);\n        }\n    }\n    listen(arcOrId, messageType, callback) {\n        assert(messageType);\n        assert(arcOrId);\n        const arcId = typeof arcOrId === 'string' ? arcOrId : arcOrId.id.toString();\n        const key = `${arcId}/${messageType}`;\n        let listeners = this.messageListeners.get(key);\n        if (!listeners)\n            this.messageListeners.set(key, listeners = []);\n        listeners.push(callback);\n    }\n    _handleMessage(msg) {\n        const listeners = this.messageListeners.get(`${msg.arcId}/${msg.messageType}`);\n        if (!listeners) {\n            console.warn(`No one is listening to ${msg.messageType} message`);\n        }\n        else {\n            for (const listener of listeners)\n                listener(msg);\n        }\n    }\n    _flush(messages) {\n        throw new Error('Not implemented in an abstract class');\n    }\n}\n//# sourceMappingURL=abstract-devtools-channel.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class DevtoolsChannelStub {\n    constructor() {\n        this._messages = [];\n    }\n    get messages() {\n        return this._messages;\n    }\n    send(message) {\n        this._messages.push(JSON.parse(JSON.stringify(message)));\n    }\n    listen(arcOrId, messageType, callback) { }\n    clear() {\n        this._messages.length = 0;\n    }\n}\n//# sourceMappingURL=devtools-channel-stub.js.map","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// Debugging is initialized either by /devtools/src/run-mark-connected.js, which is\n// injected by the devtools extension content script in the browser env,\n// or used directly when debugging nodeJS.\n\n// Data needs to be referenced via a global object, otherwise extension and\n// Arcs have different instances.\nconst root = typeof window === 'object' ? window : global;\n\nif (!root._arcDebugPromise) {\n  root._arcDebugPromise = new Promise(resolve => {\n    root._arcDebugPromiseResolve = resolve;\n  });\n}\n\nexport class DevtoolsBroker {\n  static get onceConnected() {\n    return root._arcDebugPromise;\n  }\n  static markConnected() {\n    root._arcDebugPromiseResolve();\n    return {preExistingArcs: !!root.arc};\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { assert } from '../../platform/assert-web.js';\nimport { CrdtCollectionModel } from './storage/crdt-collection-model.js';\nimport { CollectionType, BigCollectionType } from './type.js';\nimport { mapStackTrace } from '../../platform/sourcemapped-stacktrace-web.js';\nvar SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"none\"] = 0] = \"none\";\n    SyncState[SyncState[\"pending\"] = 1] = \"pending\";\n    SyncState[SyncState[\"full\"] = 2] = \"full\";\n})(SyncState || (SyncState = {}));\n/** @class StorageProxy\n * Mediates between one or more Handles and the backing store outside the PEC.\n *\n * This can operate in two modes, based on how observing handles are configured:\n * - synchronized: the proxy maintains a copy of the full data held by the backing store, keeping\n *                 it in sync by listening to change events from the store.\n * - unsynchronized: the proxy simply passes through calls from Handles to the backing store.\n *\n * In synchronized mode we maintain a queue of sorted update events received from the backing store.\n * While events are received correctly - each update is one version ahead of our stored model - they\n * are processed immediately and observing handles are notified accordingly. If we receive an update\n * with a \"future\" version, the proxy is desynchronized:\n * - a request for the full data is sent to the backing store;\n * - any update events received after that (and before the response) are added to the queue;\n * - any new updates that can be applied will be (which may cause the proxy to \"catch up\" and resync\n *   before the full data response arrives);\n * - once the resync response is received, stale queued updates are discarded and any remaining ones\n *   are applied.\n */\nexport class StorageProxy {\n    constructor(id, type, port, pec, scheduler, name) {\n        this.localIDComponent = 0;\n        this.version = undefined;\n        this.listenerAttached = false;\n        this.keepSynced = false;\n        this.synchronized = SyncState.none;\n        this.observers = [];\n        this.updates = [];\n        this.barrier = null;\n        this.id = id;\n        this.type = type;\n        this.port = port;\n        this.scheduler = scheduler;\n        this.name = name;\n        this.baseForNewID = pec.generateID();\n        this.updates = [];\n        this.pec = pec;\n    }\n    static newProxy(id, type, port, pec, scheduler, name) {\n        if (type instanceof CollectionType) {\n            return new CollectionProxy(id, type, port, pec, scheduler, name);\n        }\n        if (type instanceof BigCollectionType) {\n            return new BigCollectionProxy(id, type, port, pec, scheduler, name);\n        }\n        return new VariableProxy(id, type, port, pec, scheduler, name);\n    }\n    raiseSystemException(exception, methodName, particleId) {\n        // TODO: Encapsulate source-mapping of the stack trace once there are more users of the port.RaiseSystemException() call.\n        mapStackTrace(exception.stack, mappedStack => this.port.RaiseSystemException({ exception: { message: exception.message, stack: mappedStack.join('\\n'), name: exception.name }, methodName, particleId }));\n    }\n    /**\n     *  Called by ParticleExecutionContext to associate (potentially multiple) particle/handle pairs with this proxy.\n     */\n    register(particle, handle) {\n        if (!handle.canRead) {\n            return;\n        }\n        this.observers.push({ particle, handle });\n        // Attach an event listener to the backing store when the first readable handle is registered.\n        if (!this.listenerAttached) {\n            this.port.InitializeProxy({ handle: this, callback: x => this._onUpdate(x) });\n            this.listenerAttached = true;\n        }\n        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send\n        // a request to get the full model (once).\n        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced\n        if (handle.options.keepSynced) {\n            if (!this.keepSynced) {\n                this.port.SynchronizeProxy({ handle: this, callback: x => this._onSynchronize(x) });\n                this.keepSynced = true;\n            }\n            // If a handle configured for sync notifications registers after we've received the full\n            // model, notify it immediately.\n            if (handle.options.notifySync && this.synchronized === SyncState.full) {\n                const syncModel = this._getModelForSync();\n                this.scheduler.enqueue(particle, handle, ['sync', particle, syncModel]);\n            }\n        }\n    }\n    _onSynchronize({ version, model }) {\n        if (this.version !== undefined && version <= this.version) {\n            console.warn(`StorageProxy '${this.id}' received stale model version ${version}; ` +\n                `current is ${this.version}`);\n            return;\n        }\n        // Replace the stored data with the new one and notify handles that are configured for it.\n        if (!this._synchronizeModel(version, model)) {\n            return;\n        }\n        // We may have queued updates that were received after a desync; discard any that are stale\n        // with respect to the received model.\n        this.synchronized = SyncState.full;\n        while (this.updates.length > 0 && this.updates[0].version <= version) {\n            this.updates.shift();\n        }\n        const syncModel = this._getModelForSync();\n        this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n        this._processUpdates();\n    }\n    _onUpdate(update) {\n        // Immediately notify any handles that are not configured with keepSynced but do want updates.\n        if (this.observers.find(({ handle }) => !handle.options.keepSynced && handle.options.notifyUpdate)) {\n            const handleUpdate = this._processUpdate(update, false);\n            this._notify('update', handleUpdate, options => !options.keepSynced && options.notifyUpdate);\n        }\n        // Bail if we're not in synchronized mode or this is a stale event.\n        if (!this.keepSynced) {\n            return;\n        }\n        if (update.version <= this.version) {\n            console.warn(`StorageProxy '${this.id}' received stale update version ${update.version}; ` +\n                `current is ${this.version}`);\n            return;\n        }\n        // Add the update to the queue and process. Most of the time the queue should be empty and\n        // _processUpdates will consume this event immediately.\n        this.updates.push(update);\n        this.updates.sort((a, b) => a.version - b.version);\n        this._processUpdates();\n    }\n    _notify(kind, details, predicate = (ignored) => true) {\n        for (const { handle, particle } of this.observers) {\n            if (predicate(handle.options)) {\n                this.scheduler.enqueue(particle, handle, [kind, particle, details]);\n            }\n        }\n    }\n    _processUpdates() {\n        const updateIsNext = update => {\n            if (update.version === this.version + 1) {\n                return true;\n            }\n            // Holy Layering Violation Batman\n            // \n            // If we are a variable waiting for a barriered set response\n            // then that set response *is* the next thing we're waiting for,\n            // regardless of version numbers.\n            //\n            // TODO(shans): refactor this code so we don't need to layer-violate. \n            if (this.barrier && update.barrier === this.barrier) {\n                return true;\n            }\n            return false;\n        };\n        // Consume all queued updates whose versions are monotonically increasing from our stored one.\n        while (this.updates.length > 0 && updateIsNext(this.updates[0])) {\n            const update = this.updates.shift();\n            // Fold the update into our stored model.\n            const handleUpdate = this._processUpdate(update);\n            this.version = update.version;\n            // Notify handles configured with keepSynced and notifyUpdates (non-keepSynced handles are\n            // notified as updates are received).\n            if (handleUpdate) {\n                this._notify('update', handleUpdate, options => options.keepSynced && options.notifyUpdate);\n            }\n        }\n        // If we still have update events queued, we must have received a future version are are now\n        // desynchronized. Send a request for the full model and notify handles configured for it.\n        if (this.updates.length > 0) {\n            if (this.synchronized !== SyncState.none) {\n                this.synchronized = SyncState.none;\n                this.port.SynchronizeProxy({ handle: this, callback: x => this._onSynchronize(x) });\n                for (const { handle, particle } of this.observers) {\n                    if (handle.options.notifyDesync) {\n                        this.scheduler.enqueue(particle, handle, ['desync', particle]);\n                    }\n                }\n            }\n        }\n        else if (this.synchronized !== SyncState.full) {\n            // If we were desynced but have now consumed all update events, we've caught up.\n            this.synchronized = SyncState.full;\n        }\n    }\n    generateID() {\n        return `${this.baseForNewID}:${this.localIDComponent++}`;\n    }\n    generateIDComponents() {\n        return { base: this.baseForNewID, component: () => this.localIDComponent++ };\n    }\n}\n/**\n * Collections are synchronized in a CRDT Observed/Removed scheme.\n * Each value is identified by an ID and a set of membership keys.\n * Concurrent adds of the same value will specify the same ID but different\n * keys. A value is removed by removing all of the observed keys. A value\n * is considered to be removed if all of it's keys have been removed.\n *\n * In synchronized mode mutation takes place synchronously inside the proxy.\n * The proxy uses the originatorId to skip over redundant events sent back\n * by the storage object.\n *\n * In unsynchronized mode removal is not based on the keys observed at the\n * proxy, since the proxy does not remember the state, but instead the set\n * of keys that exist at the storage object at the time it receives the\n * request.\n */\nexport class CollectionProxy extends StorageProxy {\n    constructor() {\n        super(...arguments);\n        this.model = new CrdtCollectionModel();\n    }\n    _getModelForSync() {\n        return this.model.toList();\n    }\n    _synchronizeModel(version, model) {\n        this.version = version;\n        this.model = new CrdtCollectionModel(model);\n        return true;\n    }\n    _processUpdate(update, apply = true) {\n        if (this.synchronized === SyncState.full) {\n            // If we're synchronized, then any updates we sent have\n            // already been applied/notified.\n            for (const { handle } of this.observers) {\n                if (update.originatorId === handle._particleId) {\n                    return null;\n                }\n            }\n        }\n        const added = [];\n        const removed = [];\n        if ('add' in update) {\n            for (const { value, keys, effective } of update.add) {\n                if (apply && this.model.add(value.id, value, keys) || !apply && effective) {\n                    added.push(value);\n                }\n            }\n        }\n        else if ('remove' in update) {\n            for (const { value, keys, effective } of update.remove) {\n                const localValue = this.model.getValue(value.id);\n                if (apply && this.model.remove(value.id, keys) || !apply && effective) {\n                    removed.push(localValue);\n                }\n            }\n        }\n        else {\n            throw new Error(`StorageProxy received invalid update event: ${JSON.stringify(update)}`);\n        }\n        if (added.length || removed.length) {\n            const result = { originatorId: update.originatorId };\n            if (added.length)\n                result.add = added;\n            if (removed.length)\n                result.remove = removed;\n            return result;\n        }\n        return null;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    toList() {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model.toList());\n        }\n        else {\n            // TODO: in synchronized mode, this should integrate with SynchronizeProxy rather than\n            //       sending a parallel request\n            return new Promise(resolve => this.port.HandleToList({ callback: resolve, handle: this }));\n        }\n    }\n    get(id, particleId) {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model.getValue(id));\n        }\n        else {\n            return new Promise((resolve, reject) => this.port.HandleToList({ callback: r => resolve(r.find(entity => entity.id === id)), handle: this, particleId }));\n        }\n    }\n    store(value, keys, particleId) {\n        const id = value.id;\n        const data = { value, keys };\n        this.port.HandleStore({ handle: this, callback: () => { }, data, particleId });\n        if (this.synchronized !== SyncState.full) {\n            return;\n        }\n        if (!this.model.add(id, value, keys)) {\n            return;\n        }\n        const update = { originatorId: particleId, add: [value] };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n    clear(particleId) {\n        if (this.synchronized !== SyncState.full) {\n            this.port.HandleRemoveMultiple({ handle: this, callback: () => { }, data: [], particleId });\n        }\n        let items = this.model.toList().map(item => ({ id: item.id, keys: this.model.getKeys(item.id) }));\n        this.port.HandleRemoveMultiple({ handle: this, callback: () => { }, data: items, particleId });\n        items = items.map(({ id, keys }) => ({ rawData: this.model.getValue(id).rawData, id, keys }));\n        items = items.filter(item => this.model.remove(item.id, item.keys));\n        if (items.length > 0) {\n            this._notify('update', { originatorId: particleId, remove: items }, options => options.notifyUpdate);\n        }\n    }\n    remove(id, keys, particleId) {\n        if (this.synchronized !== SyncState.full) {\n            const data = { id, keys: [] };\n            this.port.HandleRemove({ handle: this, callback: () => { }, data, particleId });\n            return;\n        }\n        const value = this.model.getValue(id);\n        if (!value) {\n            return;\n        }\n        if (keys.length === 0) {\n            keys = this.model.getKeys(id);\n        }\n        const data = { id, keys };\n        this.port.HandleRemove({ handle: this, callback: () => { }, data, particleId });\n        if (!this.model.remove(id, keys)) {\n            return;\n        }\n        const update = { originatorId: particleId, remove: [value] };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n}\n/**\n * Variables are synchronized in a 'last-writer-wins' scheme. When the\n * VariableProxy mutates the model, it sets a barrier and expects to\n * receive the barrier value echoed back in a subsequent update event.\n * Between those two points in time updates are not applied or\n * notified about as these reflect concurrent writes that did not 'win'.\n */\nexport class VariableProxy extends StorageProxy {\n    constructor() {\n        super(...arguments);\n        this.model = null;\n    }\n    _getModelForSync() {\n        return this.model;\n    }\n    _synchronizeModel(version, model) {\n        // If there's an active barrier then we shouldn't apply the model here, because\n        // there is a more recent write from the particle side that is still in flight.\n        if (this.barrier != null) {\n            return false;\n        }\n        this.version = version;\n        this.model = model.length === 0 ? null : model[0].value;\n        assert(this.model !== undefined);\n        return true;\n    }\n    _processUpdate(update, apply = true) {\n        assert('data' in update);\n        if (!apply) {\n            return update;\n        }\n        // If we have set a barrier, suppress updates until after\n        // we have seen the barrier return via an update.\n        if (this.barrier != null) {\n            if (update.barrier === this.barrier) {\n                this.barrier = null;\n                // HOLY LAYERING VIOLATION BATMAN\n                //\n                // We just cleared a barrier which means we are now synchronized. If we weren't\n                // synchronized already, then we need to tell the handles.\n                //\n                // TODO(shans): refactor this code so we don't need to layer-violate. \n                if (this.synchronized !== SyncState.full) {\n                    this.synchronized = SyncState.full;\n                    const syncModel = this._getModelForSync();\n                    this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n                }\n            }\n            return null;\n        }\n        this.model = update.data;\n        return update;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    // TODO: in synchronized mode, these should integrate with SynchronizeProxy rather than\n    //       sending a parallel request\n    get() {\n        if (this.synchronized === SyncState.full) {\n            return Promise.resolve(this.model);\n        }\n        else {\n            return new Promise(resolve => this.port.HandleGet({ callback: resolve, handle: this }));\n        }\n    }\n    set(entity, particleId) {\n        assert(entity !== undefined);\n        if (JSON.stringify(this.model) === JSON.stringify(entity)) {\n            return;\n        }\n        let barrier;\n        // If we're setting to this handle but we aren't listening to firebase, \n        // then there's no point creating a barrier. In fact, if the response \n        // to the set comes back before a listener is registered then this proxy will\n        // end up locked waiting for a barrier that will never arrive.\n        if (this.listenerAttached) {\n            // TODO(shans): this.generateID() used to take a parameter. Is this the\n            // cause of some of the key collisions we're seeing?\n            barrier = this.generateID( /* 'barrier' */);\n        }\n        else {\n            barrier = null;\n        }\n        // TODO: is this already a clone?\n        this.model = JSON.parse(JSON.stringify(entity));\n        this.barrier = barrier;\n        this.port.HandleSet({ data: entity, handle: this, particleId, barrier });\n        const update = { originatorId: particleId, data: entity };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n    clear(particleId) {\n        if (this.model == null) {\n            return;\n        }\n        const barrier = this.generateID( /* 'barrier' */);\n        this.model = null;\n        this.barrier = barrier;\n        this.port.HandleClear({ handle: this, particleId, barrier });\n        const update = { originatorId: particleId, data: null };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n}\n// BigCollections are never synchronized. No local state is held and all operations are passed\n// directly through to the backing store.\nexport class BigCollectionProxy extends StorageProxy {\n    register(particle, handle) {\n        if (handle.canRead) {\n            this.scheduler.enqueue(particle, handle, ['sync', particle, {}]);\n        }\n    }\n    // tslint:disable-next-line: no-any\n    _getModelForSync() {\n        throw new Error(\"_getModelForSync not implemented for BigCollectionProxy\");\n    }\n    _processUpdate() {\n        throw new Error(\"_processUpdate not implemented for BigCollectionProxy\");\n    }\n    _synchronizeModel() {\n        throw new Error(\"_synchronizeModel not implemented for BigCollectionProxy\");\n    }\n    // TODO: surface get()\n    async store(value, keys, particleId) {\n        return new Promise(resolve => this.port.HandleStore({ handle: this, callback: resolve, data: { value, keys }, particleId }));\n    }\n    async remove(id, particleId) {\n        return new Promise(resolve => this.port.HandleRemove({ handle: this, callback: resolve, data: { id, keys: [] }, particleId }));\n    }\n    async stream(pageSize, forward) {\n        return new Promise(resolve => this.port.HandleStream({ handle: this, callback: resolve, pageSize, forward }));\n    }\n    async cursorNext(cursorId) {\n        return new Promise(resolve => this.port.StreamCursorNext({ handle: this, callback: resolve, cursorId }));\n    }\n    cursorClose(cursorId) {\n        this.port.StreamCursorClose({ handle: this, cursorId });\n    }\n}\nexport class StorageProxyScheduler {\n    constructor() {\n        this._scheduled = false;\n        this._queues = new Map();\n        this._idleResolver = null;\n        this._idle = null;\n        this._scheduled = false;\n        // Particle -> {Handle -> [Queue of events]}\n        this._queues = new Map();\n    }\n    // TODO: break apart args here, sync events should flush the queue.\n    enqueue(particle, handle, args) {\n        if (!this._queues.has(particle)) {\n            this._queues.set(particle, new Map());\n        }\n        const byHandle = this._queues.get(particle);\n        if (!byHandle.has(handle)) {\n            byHandle.set(handle, []);\n        }\n        const queue = byHandle.get(handle);\n        queue.push(args);\n        this._schedule();\n    }\n    get busy() {\n        return this._queues.size > 0;\n    }\n    _updateIdle() {\n        if (this._idleResolver && !this.busy) {\n            this._idleResolver();\n            this._idle = null;\n            this._idleResolver = null;\n        }\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        if (!this._idle) {\n            this._idle = new Promise(resolve => this._idleResolver = resolve);\n        }\n        return this._idle;\n    }\n    _schedule() {\n        if (this._scheduled) {\n            return;\n        }\n        this._scheduled = true;\n        setTimeout(() => {\n            this._scheduled = false;\n            this._dispatch();\n        }, 0);\n    }\n    _dispatch() {\n        // TODO: should we process just one particle per task?\n        while (this._queues.size > 0) {\n            const particle = [...this._queues.keys()][0];\n            const byHandle = this._queues.get(particle);\n            this._queues.delete(particle);\n            for (const [handle, queue] of byHandle.entries()) {\n                for (const args of queue) {\n                    try {\n                        handle._notify(...args);\n                    }\n                    catch (e) {\n                        console.error('Error dispatching to particle', e);\n                        handle._proxy.raiseSystemException(e, 'StorageProxyScheduler::_dispatch', handle._particleId);\n                    }\n                }\n            }\n        }\n        this._updateIdle();\n    }\n}\n//# sourceMappingURL=storage-proxy.js.map","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { assert } from '../../../platform/assert-web.js';\nexport class CrdtCollectionModel {\n    constructor(model = undefined) {\n        // id => {value, Set[keys]}\n        this.items = new Map();\n        if (model) {\n            for (let { id, value, keys } of model) {\n                if (!keys) {\n                    keys = [];\n                }\n                this.items.set(id, { value, keys: new Set(keys) });\n            }\n        }\n    }\n    /**\n     * Adds membership, `keys`, of `value` indexed by `id` to this collection.\n     * Returns whether the change is effective (`id` is new to the collection,\n     * or `value` is different to the value previously stored).\n     */\n    add(id, value, keys) {\n        // Ensure that keys is actually an array, not a single string.\n        // TODO(shans): remove this when all callers are implemented in typeScript.\n        assert(keys.length > 0 && typeof keys === 'object', 'add requires a list of keys');\n        let item = this.items.get(id);\n        let effective = false;\n        if (!item) {\n            item = { value, keys: new Set(keys) };\n            this.items.set(id, item);\n            effective = true;\n        }\n        else {\n            let newKeys = false;\n            for (const key of keys) {\n                if (!item.keys.has(key)) {\n                    newKeys = true;\n                }\n                item.keys.add(key);\n            }\n            if (!this._equals(item.value, value)) {\n                assert(newKeys, 'cannot add without new keys. incoming=' + keys.join(',') + ' existing=' + [...item.keys].join(','));\n                item.value = value;\n                effective = true;\n            }\n        }\n        return effective;\n    }\n    _equals(value1, value2) {\n        if (Boolean(value1) !== Boolean(value2)) {\n            return false;\n        }\n        if (!value1) {\n            return true;\n        }\n        const type1 = typeof (value1);\n        if (type1 !== typeof (value2)) {\n            return false;\n        }\n        if (type1 === 'object') {\n            const keys = Object.keys(value1);\n            if (keys.length !== Object.keys(value2).length) {\n                return false;\n            }\n            return keys.every(key => this._equals(value1[key], value2[key]));\n        }\n        return JSON.stringify(value1) === JSON.stringify(value2);\n    }\n    /**\n     * Removes the membership, `keys`, of the value indexed by `id` from this collection.\n     * Returns whether the change is effective (the value is no longer present\n     * in the collection because all of the keys have been removed).\n     */\n    remove(id, keys) {\n        const item = this.items.get(id);\n        if (!item) {\n            return false;\n        }\n        for (const key of keys) {\n            item.keys.delete(key);\n        }\n        const effective = item.keys.size === 0;\n        if (effective) {\n            this.items.delete(id);\n        }\n        return effective;\n    }\n    // [{id, value, keys: []}]\n    toLiteral() {\n        const result = [];\n        for (const [id, { value, keys }] of this.items.entries()) {\n            result.push({ id, value, keys: [...keys] });\n        }\n        return result;\n    }\n    toList() {\n        return [...this.items.values()].map(item => item.value);\n    }\n    has(id) {\n        return this.items.has(id);\n    }\n    getKeys(id) {\n        const item = this.items.get(id);\n        return item ? [...item.keys] : [];\n    }\n    getValue(id) {\n        const item = this.items.get(id);\n        return item ? item.value : null;\n    }\n    get size() {\n        return this.items.size;\n    }\n}\n//# sourceMappingURL=crdt-collection-model.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {Loader} from '../../runtime/ts-build/loader.js';\nimport {Particle} from '../../runtime/ts-build/particle.js';\nimport {DomParticle} from '../../runtime/dom-particle.js';\nimport {MultiplexerDomParticle} from '../../runtime/multiplexer-dom-particle.js';\nimport {TransformationDomParticle} from '../../runtime/transformation-dom-particle.js';\n\nconst logFactory = (preamble, color, log='log') => console[log].bind(console, `%c${preamble} [Particle]`, `background: ${color}; color: white; padding: 1px 6px 2px 7px; border-radius: 4px;`);\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\n\nconst dumbCache = {};\n\nexport class BrowserLoader extends Loader {\n  constructor(urlMap) {\n    super();\n    this._urlMap = urlMap;\n  }\n  _loadURL(url) {\n    const resolved = this._resolve(url);\n    // use URL to normalize the path for deduping\n    const cacheKey = new URL(resolved, document.URL).href;\n    // console.log(`browser-loader::_loadURL`);\n    // console.log(`    ${url}`);\n    // console.log(`    ${resolved}`);\n    // console.log(`    ${cacheKey}`);\n    const resource = dumbCache[cacheKey];\n    return resource || (dumbCache[cacheKey] = super._loadURL(resolved));\n  }\n  loadResource(name) {\n    // subclass impl differentiates paths and URLs,\n    // for browser env we can feed both kinds into _loadURL\n    return this._loadURL(name);\n  }\n  _resolve(path) {\n    //return new URL(path, this._base).href;\n    let url = this._urlMap[path];\n    if (!url && path) {\n      // TODO(sjmiles): inefficient!\n      const macro = Object.keys(this._urlMap).sort((a, b) => b.length - a.length).find(k => path.slice(0, k.length) == k);\n      if (macro) {\n        url = this._urlMap[macro] + path.slice(macro.length);\n      }\n    }\n    url = url || path;\n    //console.log(`browser-loader: resolve(${path}) = ${url}`);\n    return url;\n  }\n  requireParticle(fileName) {\n    const path = this._resolve(fileName);\n    //console.log(`requireParticle [${path}]`);\n    // inject path to this particle into the UrlMap,\n    // allows \"foo.js\" particle to invoke `importScripts(resolver('foo/othermodule.js'))`\n    this.mapParticleUrl(path);\n    const result = [];\n    self.defineParticle = function(particleWrapper) {\n      result.push(particleWrapper);\n    };\n    importScripts(path);\n    delete self.defineParticle;\n    const logger = logFactory(fileName.split('/').pop(), '#1faa00');\n    return this.unwrapParticle(result[0], logger);\n  }\n  mapParticleUrl(path) {\n    const parts = path.split('/');\n    const suffix = parts.pop();\n    const folder = parts.join('/');\n    const name = suffix.split('.').shift();\n    this._urlMap[name] = folder;\n  }\n  unwrapParticle(particleWrapper, log) {\n    // TODO(sjmiles): regarding `resolver`:\n    //  _resolve method allows particles to request remapping of assets paths\n    //  for use in DOM\n    const resolver = this._resolve.bind(this);\n    // TODO(sjmiles): hack to plumb `fetch` into Particle space under node\n    const _fetch = BrowserLoader.fetch || fetch;\n    return particleWrapper({\n      Particle,\n      DomParticle,\n      MultiplexerDomParticle,\n      SimpleParticle: DomParticle,\n      TransformationDomParticle,\n      resolver,\n      log,\n      html,\n      _fetch\n    });\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { fs } from '../../platform/fs-web.js';\nimport { vm } from '../../platform/vm-web.js';\nimport { fetch } from '../../platform/fetch-web.js';\nimport { assert } from '../../platform/assert-web.js';\nimport { Particle } from './particle.js';\nimport { DomParticle } from '../dom-particle.js';\nimport { MultiplexerDomParticle } from '../multiplexer-dom-particle.js';\nimport { Reference } from './reference.js';\nimport { TransformationDomParticle } from '../transformation-dom-particle.js';\nimport { JsonldToManifest } from './converters/jsonldToManifest.js';\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\nfunction schemaLocationFor(name) {\n    return `../entities/${name}.schema`;\n}\nexport class Loader {\n    path(fileName) {\n        const path = fileName.replace(/[/][^/]+$/, '/');\n        return path;\n    }\n    join(prefix, path) {\n        if (/^https?:\\/\\//.test(path)) {\n            return path;\n        }\n        // TODO: replace this with something that isn't hacky\n        if (path[0] === '/' || path[1] === ':') {\n            return path;\n        }\n        prefix = this.path(prefix);\n        path = this.normalizeDots(`${prefix}${path}`);\n        return path;\n    }\n    // convert `././foo/bar/../baz` to `./foo/baz`\n    normalizeDots(path) {\n        // only unix slashes\n        path = path.replace(/\\\\/g, '/');\n        // remove './'\n        path = path.replace(/\\/\\.\\//g, '/');\n        // remove 'foo/..'\n        const norm = s => s.replace(/(?:^|\\/)[^./]*\\/\\.\\./g, '');\n        for (let n = norm(path); n !== path; path = n, n = norm(path))\n            ;\n        return path;\n    }\n    loadResource(file) {\n        if (/^https?:\\/\\//.test(file)) {\n            return this._loadURL(file);\n        }\n        return this._loadFile(file);\n    }\n    _loadFile(file) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(file, (err, data) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data.toString('utf-8'));\n                }\n            });\n        });\n    }\n    _loadURL(url) {\n        if (/\\/\\/schema.org\\//.test(url)) {\n            if (url.endsWith('/Thing')) {\n                return fetch('https://schema.org/Product.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data, { '@id': 'schema:Thing' }));\n            }\n            return fetch(url + '.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data));\n        }\n        return fetch(url).then(res => res.text());\n    }\n    async loadParticleClass(spec) {\n        const clazz = await this.requireParticle(spec.implFile);\n        clazz.spec = spec;\n        return clazz;\n    }\n    async requireParticle(fileName) {\n        if (fileName === null)\n            fileName = '';\n        const src = await this.loadResource(fileName);\n        // Note. This is not real isolation.\n        const script = new vm.Script(src, { filename: fileName, displayErrors: true });\n        const result = [];\n        const self = {\n            defineParticle(particleWrapper) {\n                result.push(particleWrapper);\n            },\n            console,\n            fetch,\n            setTimeout,\n            importScripts: s => null //console.log(`(skipping browser-space import for [${s}])`)\n        };\n        script.runInNewContext(self, { filename: fileName, displayErrors: true });\n        assert(result.length > 0 && typeof result[0] === 'function', `Error while instantiating particle implementation from ${fileName}`);\n        return this.unwrapParticle(result[0]);\n    }\n    setParticleExecutionContext(pec) {\n        this.pec = pec;\n    }\n    unwrapParticle(particleWrapper) {\n        assert(this.pec);\n        return particleWrapper({ Particle, DomParticle, TransformationDomParticle, MultiplexerDomParticle, Reference: Reference.newClientReference(this.pec), html });\n    }\n}\n//# sourceMappingURL=loader.js.map","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport const fs = {};\n","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport const vm = {};\n","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n// 'export default fetch' works because 'fetch' is evaluated as an expression, which finds the\n// appropriate global definition - but we don't want to use default exports.\n// 'export {fetch}' doesn't work because 'fetch' is just a name in that context and is not defined.\n// So we need to use an expression to find the global fetch function then map that for export.\n\nconst local_fetch = fetch;\nexport {local_fetch as fetch};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { BigCollection } from './handle.js';\nimport { Collection } from './handle.js';\n/**\n * A basic particle. For particles that provide UI, you may like to\n * instead use DOMParticle.\n */\nexport class Particle {\n    constructor(capabilities) {\n        this.relevances = [];\n        this._idle = Promise.resolve();\n        this._busy = 0;\n        // Only used by a Slotlet class in particle-execution-context\n        // tslint:disable-next-line: no-any\n        this._slotByName = new Map();\n        // Typescript only sees this.constructor as a Function type.\n        // TODO(shans): move spec off the constructor\n        this.spec = this.constructor['spec'];\n        if (this.spec.inputs.length === 0) {\n            this.extraData = true;\n        }\n        this.capabilities = capabilities || {};\n    }\n    /**\n     * This method is invoked with a handle for each store this particle\n     * is registered to interact with, once those handles are ready for\n     * interaction. Override the method to register for events from\n     * the handles.\n     *\n     * @param handles a map from handle names to store handles.\n     */\n    setHandles(handles) {\n    }\n    /**\n     * This method is deprecated. Use setHandles instead.\n     */\n    setViews(views) {\n    }\n    /**\n     * Called for handles that are configured with both keepSynced and notifySync, when they are\n     * updated with the full model of their data. This will occur once after setHandles() and any time\n     * thereafter if the handle is resynchronized.\n     *\n     * @param handle The Handle instance that was updated.\n     * @param model For Variable-backed Handles, the Entity data or null if the Variable is not set.\n     *        For Collection-backed Handles, the Array of Entities, which may be empty.\n     */\n    onHandleSync(handle, model) {\n    }\n    /**\n     * Called for handles that are configued with notifyUpdate, when change events are received from\n     * the backing store. For handles also configured with keepSynced these events will be correctly\n     * ordered, with some potential skips if a desync occurs. For handles not configured with\n     * keepSynced, all change events will be passed through as they are received.\n     *\n     * @param handle The Handle instance that was updated.\n     * @param update An object containing one of the following fields:\n     *  - data: The full Entity for a Variable-backed Handle.\n     *  - added: An Array of Entities added to a Collection-backed Handle.\n     *  - removed: An Array of Entities removed from a Collection-backed Handle.\n     */\n    // tslint:disable-next-line: no-any\n    onHandleUpdate(handle, update) {\n    }\n    /**\n     * Called for handles that are configured with both keepSynced and notifyDesync, when they are\n     * detected as being out-of-date against the backing store. For Variables, the event that triggers\n     * this will also resync the data and thus this call may usually be ignored. For Collections, the\n     * underlying proxy will automatically request a full copy of the stored data to resynchronize.\n     * onHandleSync will be invoked when that is received.\n     *\n     * @param handle The Handle instance that was desynchronized.\n     */\n    onHandleDesync(handle) {\n    }\n    constructInnerArc() {\n        if (!this.capabilities.constructInnerArc) {\n            throw new Error('This particle is not allowed to construct inner arcs');\n        }\n        return this.capabilities.constructInnerArc(this);\n    }\n    get busy() {\n        return this._busy > 0;\n    }\n    get idle() {\n        return this._idle;\n    }\n    set relevance(r) {\n        this.relevances.push(r);\n    }\n    startBusy() {\n        if (this._busy === 0) {\n            this._idle = new Promise(resolve => this._idleResolver = resolve);\n        }\n        this._busy++;\n    }\n    doneBusy() {\n        this._busy--;\n        if (this._busy === 0) {\n            this._idleResolver();\n        }\n    }\n    inputs() {\n        return this.spec.inputs;\n    }\n    outputs() {\n        return this.spec.outputs;\n    }\n    /**\n     * Returns the slot with provided name.\n     */\n    getSlot(name) {\n        return this._slotByName.get(name);\n    }\n    static buildManifest(strings, ...bits) {\n        const output = [];\n        for (let i = 0; i < bits.length; i++) {\n            const str = strings[i];\n            const indent = / *$/.exec(str)[0];\n            let bitStr;\n            if (typeof bits[i] === 'string') {\n                bitStr = bits[i];\n            }\n            else {\n                bitStr = bits[i].toManifestString();\n            }\n            bitStr = bitStr.replace(/(\\n)/g, '$1' + indent);\n            output.push(str);\n            output.push(bitStr);\n        }\n        if (strings.length > bits.length) {\n            output.push(strings[strings.length - 1]);\n        }\n        return output.join('');\n    }\n    setParticleDescription(pattern) {\n        return this.setDescriptionPattern('pattern', pattern);\n    }\n    setDescriptionPattern(connectionName, pattern) {\n        const descriptions = this.handles.get('descriptions');\n        if (descriptions) {\n            // Typescript can't infer the type here and fails with TS2351\n            // tslint:disable-next-line: no-any\n            const entityClass = descriptions.entityClass;\n            if (descriptions instanceof Collection || descriptions instanceof BigCollection) {\n                descriptions.store(new entityClass({ key: connectionName, value: pattern }, this.spec.name + '-' + connectionName));\n            }\n            return true;\n        }\n        throw new Error('A particle needs a description handle to set a decription pattern');\n    }\n}\n//# sourceMappingURL=particle.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {XenStateMixin} from '../modalities/dom/components/xen/xen-state.js';\nimport {DomParticleBase} from './ts-build/dom-particle-base.js';\n\n/** @class DomParticle\n * Particle that interoperates with DOM and uses a simple state system\n * to handle updates.\n */\nexport class DomParticle extends XenStateMixin(DomParticleBase) {\n  constructor() {\n    super();\n    // alias properties to remove `_`\n    this.state = this._state;\n    this.props = this._props;\n  }\n  /** @method willReceiveProps(props, state, oldProps, oldState)\n   * Override if necessary, to do things when props change.\n   */\n  willReceiveProps() {\n  }\n  /** @method update(props, state, oldProps, oldState)\n   * Override if necessary, to modify superclass config.\n   */\n  update() {\n  }\n  /** @method shouldRender(props, state, oldProps, oldState)\n   * Override to return false if the Particle won't use\n   * it's slot.\n   */\n  shouldRender() {\n    return true;\n  }\n  /** @method render(props, state, oldProps, oldState)\n   * Override to return a dictionary to map into the template.\n   */\n  render() {\n    return {};\n  }\n  /** @method setState(state)\n   * Copy values from `state` into the particle's internal state,\n   * triggering an update cycle unless currently updating.\n   */\n  setState(state) {\n    return this._setState(state);\n  }\n  // TODO(sjmiles): deprecated, just use setState\n  setIfDirty(state) {\n    console.warn('DomParticle: `setIfDirty` is deprecated, please use `setState` instead');\n    return this._setState(state);\n  }\n  /** @method configureHandles(handles)\n   * This is called once during particle setup. Override to control sync and update\n   * configuration on specific handles (via their configure() method).\n   * `handles` is a map from names to handle instances.\n   */\n  configureHandles(handles) {\n    // Example: handles.get('foo').configure({keepSynced: false});\n  }\n  /** @method get config()\n   * Override if necessary, to modify superclass config.\n   */\n  get config() {\n    // TODO(sjmiles): getter that does work is a bad idea, this is temporary\n    return {\n      handleNames: this.spec.inputs.map(i => i.name),\n      // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from\n      // .manifest files, instead of .ptcl ones.\n      slotNames: [...this.spec.slots.values()].map(s => s.name)\n    };\n  }\n  // affordances for aliasing methods to remove `_`\n  _willReceiveProps(...args) {\n    this.willReceiveProps(...args);\n  }\n  _update(...args) {\n    this.update(...args);\n    if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?\n      this.relevance = 1; // TODO: improve relevance signal.\n    }\n    this.config.slotNames.forEach(s => this.renderSlot(s, ['model']));\n  }\n  //\n  // deprecated\n  get _views() {\n    console.warn(`Particle ${this.spec.name} uses deprecated _views getter.`);\n    return this.handles;\n  }\n  async setViews(views) {\n    console.warn(`Particle ${this.spec.name} uses deprecated setViews method.`);\n    return this.setHandles(views);\n  }\n  // end deprecated\n  //\n  async setHandles(handles) {\n    this.configureHandles(handles);\n    this.handles = handles;\n    this._handlesToSync = new Set();\n    for (const name of this.config.handleNames) {\n      const handle = handles.get(name);\n      if (handle && handle.options.keepSynced && handle.options.notifySync) {\n        this._handlesToSync.add(name);\n      }\n    }\n    // make sure we invalidate once, even if there are no incoming handles\n    setTimeout(() => !this._hasProps && this._invalidate(), 200);\n    //this._invalidate();\n  }\n  async onHandleSync(handle, model) {\n    this._handlesToSync.delete(handle.name);\n    if (this._handlesToSync.size == 0) {\n      await this._handlesToProps();\n    }\n  }\n  async onHandleUpdate(handle, update) {\n    // TODO(sjmiles): debounce handles updates\n    const work = () => {\n      //console.warn(handle, update);\n      this._handlesToProps();\n    };\n    this._debounce('handleUpdateDebounce', work, 100);\n  }\n  async _handlesToProps() {\n    const config = this.config;\n    // acquire (async) list data from handles; BigCollections map to the handle itself\n    const data = await Promise.all(\n      config.handleNames\n      .map(name => this.handles.get(name))\n      .map(handle => {\n        if (handle.toList) return handle.toList();\n        if (handle.get) return handle.get();\n        return handle;\n      })\n    );\n    // convert handle data (array) into props (dictionary)\n    const props = Object.create(null);\n    config.handleNames.forEach((name, i) => {\n      props[name] = data[i];\n    });\n    this._hasProps = true;\n    this._setProps(props);\n  }\n  fireEvent(slotName, {handler, data}) {\n    if (this[handler]) {\n      // TODO(sjmiles): remove `this._state` parameter\n      this[handler]({data}, this._state);\n    }\n  }\n  _debounce(key, func, delay) {\n    const subkey = `_debounce_${key}`;\n    if (!this._state[subkey]) {\n      this.startBusy();\n    }\n    const idleThenFunc = () => {\n      this.doneBusy();\n      func();\n      this._state[subkey] = null;\n    };\n    super._debounce(key, idleThenFunc, delay);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst nob = () => Object.create(null);\n\nconst debounce = (key, action, delay) => {\n  if (key) {\n    clearTimeout(key);\n  }\n  if (action && delay) {\n    return setTimeout(action, delay);\n  }\n};\n\nconst XenStateMixin = Base => class extends Base {\n  constructor() {\n    super();\n    this._pendingProps = nob();\n    this._props = this._getInitialProps() || nob();\n    this._lastProps = nob();\n    this._state = this._getInitialState() || nob();\n    this._lastState = nob();\n  }\n  _getInitialProps() {\n  }\n  _getInitialState() {\n  }\n  _getProperty(name) {\n    return this._pendingProps[name] || this._props[name];\n  }\n  _setProperty(name, value) {\n    // dirty checking opportunity\n    if (this._validator || this._wouldChangeProp(name, value)) {\n      this._pendingProps[name] = value;\n      this._invalidateProps();\n    }\n  }\n  _wouldChangeValue(map, name, value) {\n    // TODO(sjmiles): fundamental dirty-checking issue here. Can be overridden to change\n    // behavior, but the default implementation will use strict reference checking.\n    // To modify structured values one must create a new Object with the new values.\n    // See `_setImmutableState`.\n    return (map[name] !== value);\n    // TODO(sjmiles): an example of dirty-checking that instead simply punts on structured data\n    //return (typeof value === 'object') || (map[name] !== value);\n  }\n  _wouldChangeProp(name, value) {\n    return this._wouldChangeValue(this._props, name, value);\n  }\n  _wouldChangeState(name, value) {\n    return this._wouldChangeValue(this._state, name, value);\n  }\n  _setProps(props) {\n    // TODO(sjmiles): should be a replace instead of a merge?\n    Object.assign(this._pendingProps, props);\n    this._invalidateProps();\n  }\n  _invalidateProps() {\n    this._propsInvalid = true;\n    this._invalidate();\n  }\n  _setImmutableState(name, value) {\n    if (typeof name === 'object') {\n      console.warn('Xen:: _setImmutableState takes name and value args for a single property, dictionaries not supported.');\n      value = Object.values(name)[0];\n      name = Object.names(name)[0];\n    }\n    if (typeof value === 'object') {\n      value = Object.assign(Object.create(null), value);\n    }\n    this._state[name] = value;\n    this._invalidate();\n  }\n  _setState(object) {\n    let dirty = false;\n    const state = this._state;\n    for (const property in object) {\n      const value = object[property];\n      if (this._wouldChangeState(property, value)) {\n        dirty = true;\n        state[property] = value;\n      }\n    }\n    if (dirty) {\n      this._invalidate();\n      return true;\n    }\n  }\n  // TODO(sjmiles): deprecated\n  _setIfDirty(object) {\n    return this._setState(object);\n  }\n  _async(fn) {\n    return Promise.resolve().then(fn.bind(this));\n    //return setTimeout(fn.bind(this), 10);\n  }\n  _invalidate() {\n    if (!this._validator) {\n      this._validator = this._async(this._validate);\n    }\n  }\n  _getStateArgs() {\n    return [this._props, this._state, this._lastProps, this._lastState];\n  }\n  _validate() {\n    const stateArgs = this._getStateArgs();\n    // try..catch to ensure we nullify `validator` before return\n    try {\n      // TODO(sjmiles): should be a replace instead of a merge\n      Object.assign(this._props, this._pendingProps);\n      if (this._propsInvalid) {\n        // TODO(sjmiles): should/can have different timing from rendering?\n        this._willReceiveProps(...stateArgs);\n        this._propsInvalid = false;\n      }\n      if (this._shouldUpdate(...stateArgs)) {\n        // TODO(sjmiles): consider throttling update to rAF\n        this._ensureMount();\n        this._doUpdate(...stateArgs);\n      }\n    } catch (x) {\n      console.error(x);\n    }\n    // nullify validator _after_ methods so state changes don't reschedule validation\n    this._validator = null;\n    // save the old props and state\n    this._lastProps = Object.assign(nob(), this._props);\n    this._lastState = Object.assign(nob(), this._state);\n  }\n  _doUpdate(...stateArgs) {\n    this._update(...stateArgs);\n    this._didUpdate(...stateArgs);\n  }\n  _ensureMount() {\n  }\n  _willReceiveProps() {\n  }\n  _shouldUpdate() {\n    return true;\n  }\n  _update() {\n  }\n  _didUpdate() {\n  }\n  _debounce(key, func, delay) {\n    key = `_debounce_${key}`;\n    this._state[key] = debounce(this._state[key], func, delay != null ? delay : 16);\n  }\n};\n\nexport {XenStateMixin, nob, debounce};\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { assert } from '../../platform/assert-web.js';\nimport { Particle } from './particle.js';\nimport { BigCollection } from './handle.js';\nimport { Collection } from './handle.js';\nimport { Variable } from './handle.js';\n/**\n * Particle that interoperates with DOM.\n */\nexport class DomParticleBase extends Particle {\n    constructor() {\n        super();\n    }\n    /**\n     * Override to return a String defining primary markup.\n     */\n    get template() {\n        return '';\n    }\n    /**\n     * Override to return a String defining primary markup for the given slot name.\n     */\n    getTemplate(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return this.template;\n    }\n    /**\n     * Override to return a String defining the name of the template for the given slot name.\n     */\n    getTemplateName(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return `default`;\n    }\n    /**\n     * Override to return false if the Particle won't use it's slot.\n     */\n    shouldRender(stateArgs) {\n        return true;\n    }\n    /**\n     * Override to return a dictionary to map into the template.\n     */\n    render(stateArgs) {\n        return {};\n    }\n    renderSlot(slotName, contentTypes) {\n        const stateArgs = this._getStateArgs();\n        const slot = this.getSlot(slotName);\n        if (!slot) {\n            return; // didn't receive StartRender.\n        }\n        // Set this to support multiple slots consumed by a particle, without needing\n        // to pass slotName to particle's render method, where it useless in most cases.\n        this.currentSlotName = slotName;\n        contentTypes.forEach(ct => slot.requestedContentTypes.add(ct));\n        // TODO(sjmiles): redundant, same answer for every slot\n        if (this.shouldRender(...stateArgs)) {\n            const content = {};\n            if (slot.requestedContentTypes.has('template')) {\n                content.template = this.getTemplate(slot.slotName);\n            }\n            if (slot.requestedContentTypes.has('model')) {\n                content.model = this.render(...stateArgs);\n            }\n            content.templateName = this.getTemplateName(slot.slotName);\n            slot.render(content);\n        }\n        else if (slot.isRendered) {\n            // Send empty object, to clear rendered slot contents.\n            slot.render({});\n        }\n        this.currentSlotName = undefined;\n    }\n    _getStateArgs() {\n        return [];\n    }\n    forceRenderTemplate(slotName) {\n        this._slotByName.forEach((slot, name) => {\n            if (!slotName || (name === slotName)) {\n                slot.requestedContentTypes.add('template');\n            }\n        });\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            this[handler]({ data });\n        }\n    }\n    setParticleDescription(pattern) {\n        if (typeof pattern === 'string') {\n            return super.setParticleDescription(pattern);\n        }\n        assert(!!pattern.template && !!pattern.model, 'Description pattern must either be string or have template and model');\n        super.setDescriptionPattern('_template_', pattern.template);\n        super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));\n        return undefined;\n    }\n    /**\n     * Remove entities from named handle.\n     */\n    async clearHandle(handleName) {\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Variable || handle instanceof Collection) {\n            handle.clear();\n        }\n        else {\n            throw new Error('Variable/Collection required');\n        }\n    }\n    /**\n     * Merge entities from Array into named handle.\n     */\n    async mergeEntitiesToHandle(handleName, entities) {\n        const idMap = {};\n        const handle = this.handles.get(handleName);\n        if (handle instanceof Collection) {\n            const handleEntities = await handle.toList();\n            handleEntities.forEach(entity => idMap[entity.id] = entity);\n            for (const entity of entities) {\n                if (!idMap[entity.id]) {\n                    handle.store(entity);\n                }\n            }\n        }\n        else {\n            throw new Error('Collection required');\n        }\n    }\n    /**\n     * Append entities from Array to named handle.\n     */\n    async appendEntitiesToHandle(handleName, entities) {\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                Promise.all(entities.map(entity => handle.store(entity)));\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Create an entity from each rawData, and append to named handle.\n     */\n    async appendRawDataToHandle(handleName, rawDataArray) {\n        const handle = this.handles.get(handleName);\n        if (handle && handle.entityClass) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                // Typescript can't infer the type here and fails with TS2351\n                // tslint:disable-next-line: no-any\n                const entityClass = handle.entityClass;\n                Promise.all(rawDataArray.map(raw => handle.store(new entityClass(raw))));\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Modify value of named handle. A new entity is created\n     * from `rawData` (`new [EntityClass](rawData)`).\n     */\n    updateVariable(handleName, rawData) {\n        const handle = this.handles.get(handleName);\n        if (handle && handle.entityClass) {\n            if (handle instanceof Variable) {\n                // Typescript can't infer the type here and fails with TS2351\n                // tslint:disable-next-line: no-any\n                const entityClass = handle.entityClass;\n                const entity = new entityClass(rawData);\n                handle.set(entity);\n                return entity;\n            }\n            else {\n                throw new Error('Variable required');\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Modify or insert `entity` into named handle.\n     * Modification is done by removing the old entity and reinserting the new one.\n     */\n    async updateSet(handleName, entity) {\n        // Set the entity into the right place in the set. If we find it\n        // already present replace it, otherwise, add it.\n        // TODO(dstockwell): Replace this with happy entity mutation approach.\n        const handle = this.handles.get(handleName);\n        if (handle) {\n            if (handle instanceof Collection || handle instanceof BigCollection) {\n                await handle.remove(entity);\n                await handle.store(entity);\n            }\n            else {\n                throw new Error('Collection required');\n            }\n        }\n    }\n    /**\n     * Returns array of Entities found in BOXED data `box` that are owned by `userid`\n     */\n    boxQuery(box, userid) {\n        return box.filter(item => userid === item.getUserID().split('|')[0]);\n    }\n}\n//# sourceMappingURL=dom-particle-base.js.map","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {assert} from '../platform/assert-web.js';\nimport {ParticleSpec} from './ts-build/particle-spec.js';\nimport {TransformationDomParticle} from './transformation-dom-particle.js';\n\nexport class MultiplexerDomParticle extends TransformationDomParticle {\n  constructor() {\n    super();\n    this._itemSubIdByHostedSlotId = new Map();\n    this._connByHostedConn = new Map();\n  }\n\n  async _mapParticleConnections(\n      listHandleName,\n      particleHandleName,\n      hostedParticle,\n      handles,\n      arc) {\n    const otherMappedHandles = [];\n    const otherConnections = [];\n    let index = 2;\n    const skipConnectionNames = [listHandleName, particleHandleName];\n    for (const [connectionName, otherHandle] of handles) {\n      if (skipConnectionNames.includes(connectionName)) {\n        continue;\n      }\n      // TODO(wkorman): For items with embedded recipes we may need a map\n      // (perhaps id to index) to make sure we don't map a handle into the inner\n      // arc multiple times unnecessarily.\n      otherMappedHandles.push(\n          `use '${await arc.mapHandle(otherHandle._proxy)}' as v${index}`);\n      const hostedOtherConnection = hostedParticle.connections.find(\n          conn => conn.isCompatibleType(otherHandle.type));\n      if (hostedOtherConnection) {\n        otherConnections.push(`${hostedOtherConnection.name} = v${index++}`);\n        // TODO(wkorman): For items with embedded recipes where we may have a\n        // different particle rendering each item, we need to track\n        // |connByHostedConn| keyed on the particle type.\n        this._connByHostedConn.set(hostedOtherConnection.name, connectionName);\n      }\n    }\n    return [otherMappedHandles, otherConnections];\n  }\n\n  async setHandles(handles) {\n    this.handleIds = {};\n    const arc = await this.constructInnerArc();\n    const listHandleName = 'list';\n    const particleHandleName = 'hostedParticle';\n    const particleHandle = handles.get(particleHandleName);\n    let hostedParticle = null;\n    let otherMappedHandles = [];\n    let otherConnections = [];\n    if (particleHandle) {\n      hostedParticle = await particleHandle.get();\n      if (hostedParticle) {\n        [otherMappedHandles, otherConnections] =\n            await this._mapParticleConnections(\n                listHandleName, particleHandleName, hostedParticle, handles, arc);\n      }\n    }\n    this.setState({\n      arc,\n      type: handles.get(listHandleName).type,\n      hostedParticle,\n      otherMappedHandles,\n      otherConnections\n    });\n\n    super.setHandles(handles);\n  }\n\n  async willReceiveProps(\n      {list},\n      {arc, type, hostedParticle, otherMappedHandles, otherConnections}) {\n    if (list.length > 0) {\n      this.relevance = 0.1;\n    }\n\n    for (const [index, item] of this.getListEntries(list)) {\n      let resolvedHostedParticle = hostedParticle;\n      if (this.handleIds[item.id]) {\n        const itemHandle = await this.handleIds[item.id];\n        itemHandle.set(item);\n        continue;\n      }\n\n      const itemHandlePromise =\n          arc.createHandle(type.primitiveType(), 'item' + index);\n      this.handleIds[item.id] = itemHandlePromise;\n\n      const itemHandle = await itemHandlePromise;\n\n      if (!resolvedHostedParticle) {\n        // If we're muxing on behalf of an item with an embedded recipe, the\n        // hosted particle should be retrievable from the item itself. Else we\n        // just skip this item.\n        if (!item.renderParticleSpec) {\n          continue;\n        }\n        resolvedHostedParticle =\n            ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));\n        // Re-map compatible handles and compute the connections specific\n        // to this item's render particle.\n        const listHandleName = 'list';\n        const particleHandleName = 'renderParticle';\n        [otherMappedHandles, otherConnections] =\n            await this._mapParticleConnections(\n                listHandleName,\n                particleHandleName,\n                resolvedHostedParticle,\n                this.handles,\n                arc);\n      }\n      const hostedSlotName = [...resolvedHostedParticle.slots.keys()][0];\n      const slotName = [...this.spec.slots.values()][0].name;\n      const slotId = await arc.createSlot(\n          this, slotName, resolvedHostedParticle.name, hostedSlotName, itemHandle._id);\n\n      if (!slotId) {\n        continue;\n      }\n\n      this._itemSubIdByHostedSlotId.set(slotId, item.id);\n\n      try {\n        const recipe = this.constructInnerRecipe(\n          resolvedHostedParticle,\n          item,\n          itemHandle,\n          {name: hostedSlotName, id: slotId},\n          {connections: otherConnections, handles: otherMappedHandles}\n        );\n        await arc.loadRecipe(recipe, this);\n        itemHandle.set(item);\n      } catch (e) {\n        console.log(e);\n      }\n    }\n  }\n\n  combineHostedModel(slotName, hostedSlotId, content) {\n    const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n    if (!subId) {\n      return;\n    }\n    const items = this._state.renderModel ? this._state.renderModel.items : [];\n    const listIndex = items.findIndex(item => item.subId == subId);\n    const item = Object.assign({}, content.model, {subId});\n    if (listIndex >= 0 && listIndex < items.length) {\n      items[listIndex] = item;\n    } else {\n      items.push(item);\n    }\n    this._setState({renderModel: {items}});\n  }\n\n  combineHostedTemplate(slotName, hostedSlotId, content) {\n    const subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n    if (!subId) {\n      return;\n    }\n    assert(content.templateName, `Template name is missing for slot '${slotName}' (hosted slot ID: '${hostedSlotId}')`);\n    this._setState({templateName: Object.assign(this._state.templateName || {}, {[subId]: `${content.templateName}`})});\n\n    if (content.template) {\n      let template = content.template;\n      // Append subid$={{subid}} attribute to all provided slots, to make it usable for the transformation particle.\n      template = template.replace(new RegExp('slotid=\"[a-z]+\"', 'gi'), '$& subid$=\"{{subId}}\"');\n\n      // Replace hosted particle connection in template with the corresponding particle connection names.\n      // TODO: make this generic!\n      this._connByHostedConn.forEach((conn, hostedConn) => {\n        template = template.replace(\n            new RegExp(`{{${hostedConn}.description}}`, 'g'),\n            `{{${conn}.description}}`);\n      });\n      this._setState({template: Object.assign(this._state.template || {}, {[content.templateName]: template})});\n\n      this.forceRenderTemplate();\n    }\n  }\n\n  // Abstract methods below.\n\n  // Called to produce a full interpolated recipe for loading into an inner\n  // arc for each item. Subclasses should override this method as by default\n  // it does nothing and so no recipe will be returned and content will not\n  // be loaded successfully into the inner arc.\n  constructInnerRecipe(hostedParticle, item, itemHandle, slot, other) {}\n\n  // Called with the list of items and by default returns the direct result of\n  // `Array.entries()`. Subclasses can override this method to alter the item\n  // order or otherwise permute the items as desired before their slots are\n  // created and contents are rendered.\n  getListEntries(list) {\n    return list.entries();\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport {DomParticle} from './dom-particle.js';\n\n// Regex to separate style and template.\nconst re = /<style>((?:.|[\\r\\n])*)<\\/style>((?:.|[\\r\\n])*)/;\n\n/** @class TransformationDomParticle\n * Particle that does transformation stuff with DOM.\n */\nexport class TransformationDomParticle extends DomParticle {\n  getTemplate(slotName) {\n    // TODO: add support for multiple slots.\n    return this._state.template;\n  }\n  getTemplateName(slotName) {\n    // TODO: add support for multiple slots.\n    return this._state.templateName;\n  }\n  render(props, state) {\n    return state.renderModel;\n  }\n  shouldRender(props, state) {\n    return Boolean((state.template || state.templateName) && state.renderModel);\n  }\n\n  renderHostedSlot(slotName, hostedSlotId, content) {\n    this.combineHostedTemplate(slotName, hostedSlotId, content);\n    this.combineHostedModel(slotName, hostedSlotId, content);\n  }\n\n  // abstract\n  combineHostedTemplate(slotName, hostedSlotId, content) {}\n  combineHostedModel(slotName, hostedSlotId, content) {}\n\n  // Helper methods that may be reused in transformation particles to combine hosted content.\n  static propsToItems(propsValues) {\n    return propsValues ? propsValues.map(({rawData, id}) => Object.assign({}, rawData, {subId: id})) : [];\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];\nexport class JsonldToManifest {\n    static convert(jsonld, theClass = undefined) {\n        const obj = JSON.parse(jsonld);\n        const classes = {};\n        const properties = {};\n        if (!obj['@graph']) {\n            obj['@graph'] = [obj];\n        }\n        for (const item of obj['@graph']) {\n            if (item['@type'] === 'rdf:Property') {\n                properties[item['@id']] = item;\n            }\n            else if (item['@type'] === 'rdfs:Class') {\n                classes[item['@id']] = item;\n                item['subclasses'] = [];\n                item['superclass'] = null;\n            }\n        }\n        for (const clazz of Object.values(classes)) {\n            if (clazz['rdfs:subClassOf'] !== undefined) {\n                if (clazz['rdfs:subClassOf'].length == undefined) {\n                    clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];\n                }\n                for (const subClass of clazz['rdfs:subClassOf']) {\n                    const superclass = subClass['@id'];\n                    if (clazz['superclass'] == undefined) {\n                        clazz['superclass'] = [];\n                    }\n                    if (classes[superclass]) {\n                        classes[superclass].subclasses.push(clazz);\n                        clazz['superclass'].push(classes[superclass]);\n                    }\n                    else {\n                        clazz['superclass'].push({ '@id': superclass });\n                    }\n                }\n            }\n        }\n        for (const clazz of Object.values(classes)) {\n            if (clazz['subclasses'].length === 0 && theClass == undefined) {\n                theClass = clazz;\n            }\n        }\n        const relevantProperties = [];\n        for (const property of Object.values(properties)) {\n            let domains = property['schema:domainIncludes'];\n            if (!domains) {\n                domains = { '@id': theClass['@id'] };\n            }\n            if (!domains.length) {\n                domains = [domains];\n            }\n            domains = domains.map(a => a['@id']);\n            if (domains.includes(theClass['@id'])) {\n                const name = property['@id'].split(':')[1];\n                let type = property['schema:rangeIncludes'];\n                if (!type) {\n                    console.log(property);\n                }\n                if (!type.length) {\n                    type = [type];\n                }\n                type = type.map(a => a['@id'].split(':')[1]);\n                type = type.filter(type => supportedTypes.includes(type));\n                if (type.length > 0) {\n                    relevantProperties.push({ name, type });\n                }\n            }\n        }\n        const className = theClass['@id'].split(':')[1];\n        const superNames = theClass && theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];\n        let s = '';\n        for (const superName of superNames) {\n            s += `import 'https://schema.org/${superName}'\\n\\n`;\n        }\n        s += `schema ${className}`;\n        if (superNames.length > 0) {\n            s += ` extends ${superNames.join(', ')}`;\n        }\n        if (relevantProperties.length > 0) {\n            for (const property of relevantProperties) {\n                let type;\n                if (property.type.length > 1) {\n                    type = '(' + property.type.join(' or ') + ')';\n                }\n                else {\n                    type = property.type[0];\n                }\n                s += `\\n  ${type} ${property.name}`;\n            }\n        }\n        s += '\\n';\n        return s;\n    }\n}\n//# sourceMappingURL=jsonldToManifest.js.map"],"sourceRoot":""}