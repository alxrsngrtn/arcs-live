{"version":3,"sources":["webpack:///webpack/bootstrap 971cab55d60df1d9fb45","webpack:///./intermediate/platform/assert-web.js","webpack:///./intermediate/runtime/type.js","webpack:///./intermediate/runtime/dom-particle.js","webpack:///./intermediate/runtime/particle-spec.js","webpack:///./intermediate/runtime/particle.js","webpack:///./intermediate/runtime/recipe/type-checker.js","webpack:///./intermediate/runtime/transformation-dom-particle.js","webpack:///./intermediate/runtime/multiplexer-dom-particle.js","webpack:///./intermediate/runtime/schema.js","webpack:///./intermediate/runtime/shape.js","webpack:///./intermediate/runtime/symbols.js","webpack:///./intermediate/runtime/type-variable.js","webpack:///(webpack)/buildin/global.js","webpack:///./intermediate/runtime/particle-execution-context.js","webpack:///./shell/source/browser-loader.js","webpack:///./intermediate/devtools/shared/devtools-broker.js","webpack:///./intermediate/platform/devtools-channel-web.js","webpack:///./intermediate/platform/fs-web.js","webpack:///./intermediate/platform/vm-web.js","webpack:///./intermediate/runtime/api-channel.js","webpack:///./intermediate/runtime/converters/jsonldToManifest.js","webpack:///./intermediate/runtime/debug/abstract-devtools-channel.js","webpack:///./intermediate/runtime/debug/devtools-connection.js","webpack:///./intermediate/runtime/debug/outer-port-attachment.js","webpack:///./intermediate/runtime/debug/testing/devtools-channel-stub.js","webpack:///./intermediate/runtime/dom-particle-base.js","webpack:///./intermediate/runtime/entity.js","webpack:///./intermediate/runtime/fetch-web.js","webpack:///./intermediate/runtime/handle.js","webpack:///./intermediate/runtime/loader.js","webpack:///./intermediate/runtime/storage-proxy.js","webpack:///./intermediate/runtime/storage/crdt-collection-model.js","webpack:///./intermediate/runtime/tuple-fields.js","webpack:///./intermediate/shell/components/xen/xen-state.js","webpack:///./shell/source/worker-entry.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACjB;AACA;AACA;AACA,6CAA6C,UAAU,EAAE,SAAS;AAClE;AACA,2BAA2B,KAAK;AAChC,yHAAiC,KAAK,MAAM,EAAE,SAAS,IAAI,WAAW,kBAAkB,KAAK;AAC7F;AACA;AACA,KAAK;AACL,+CAA+C,KAAK;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAAyC,aAAa,GAAG,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sJAA8D,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mJAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8IAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kLAA0F,wBAAwB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,kJAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sCAAsC;AAC5D;AACA;AACA,4FAA4F,mBAAmB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgB;AACC;AACM;AACD;AACA;;;;;;;;;ACjYtB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACwB;AACE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AAAA;AAAA;;;;;;;;;;;ACjJA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACO;AACN;AACC;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAAyC,OAAO,GAAG,6CAA6C;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAA8D;AAC3E,oCAAoC,0DAA0D,OAAO,2HAA2H;AAChO;AACA,gBAAgB;AAChB;AACA;AACA,aAAa,8DAA8D;AAC3E,sCAAsC,0DAA0D,OAAO,iNAA+J;AACtQ;AACA,iCAAiC,2EAA2E;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mNAA2H,EAAE;AAC7H,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D,iCAAiC,UAAU,EAAE,MAAM,OAAO,cAAc;AACxE;AACA;AACA,4BAA4B,OAAO,EAAE,qBAAqB,GAAG,2BAA2B,EAAE,iCAAiC,GAAG,gBAAgB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA,8BAA8B,kBAAkB;AAChD;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA,oCAAoC,kBAAkB;AACtD;AACA,qDAAqD,cAAc;AACnE;AACA,0EAA0E,OAAO;AACjF,aAAa;AACb,SAAS;AACT;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,wCAAwC,QAAQ,KAAK,WAAW;AAChE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,sCAAsC;AACnG;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;ACnIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACe;AACQ;AACN;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;AC5OA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,yDAAyD;AACzD;AACA;AACA,+CAA+C,cAAc,qBAAqB,YAAY,YAAY;AAC1G;AACA;AAAA;AAAA;;;;;;;;;;AC1CA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACiB;AACM;AACa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wCAAwC,QAAQ,MAAM;AACtG;AACA;AACA,6CAA6C,2BAA2B,OAAO,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,sBAAsB,OAAO,GAAG,kEAAkE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,mCAAmC,GAAG,6DAA6D;AAC3M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe,QAAQ,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,mKAA2E,SAAS,sBAAsB,aAAa;AACvH,wBAAwB,2DAA2D,GAAG,aAAa,qBAAqB,GAAG,GAAG;AAC9H;AACA;AACA,8BAA8B,OAAO;AACrC,0FAA0F,OAAO;AACjG;AACA;AACA;AACA,0DAA0D,EAAE,WAAW,cAAc,YAAY,EAAE,KAAK,cAAc;AACtH,aAAa;AACb,4BAA4B,mDAAmD,GAAG,mCAAmC,GAAG;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;ACnLA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACF;AACE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB,sCAAsC,kBAAkB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,2BAA2B,sBAAsB;AACjD;AACA,qDAAqD,UAAU,aAAa,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,aAAa,UAAU;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG,SAAS,MAAM,iBAAiB,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG,aAAa,KAAK,SAAS,UAAU,EAAE;AACnG,kCAAkC,MAAM,YAAY,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG,aAAa,KAAK,WAAW,gBAAgB,GAAG;AAC5G,kCAAkC,MAAM,YAAY,eAAe;AACnE;AACA;AACA;AACA,sDAAsD,GAAG,SAAS,KAAK,yBAAyB,MAAM;AACtG;AACA;AACA,+DAA+D,GAAG,aAAa,KAAK;AACpF,gCAAgC,gBAAgB,gBAAgB,MAAM;AACtE;AACA;AACA;AACA;AACA,iEAAiE,GAAG,aAAa,KAAK,WAAW,gBAAgB,GAAG;AACpH,0CAA0C,MAAM,aAAa,kBAAkB,YAAY,EAAE;AAC7F;AACA,qBAAqB;AACrB;AACA;AACA,oDAAoD,eAAe,aAAa,UAAU;AAC1F;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mBAAmB;AACjE,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0EAA0E,yBAAyB,GAAG,KAAK;AAC3G,kBAAkB,MAAM,EAAE,EAAE,qEAAqE;AACjG;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,+EAA+E,yBAAyB,GAAG,KAAK;AAChH;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA,wCAAwC,KAAK,KAAK,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;AC5RA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACjB,gBAAgB;AAChB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wBAAwB;AACjE;AACA;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C,EAAE,gBAAgB,GAAG,gCAAgC;AAC5H,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,eAAe,GAAG,4BAA4B,EAAE,iCAAiC;AAC/G;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,EAAE;AACF,EAAE;AACF;AACA;AACA;AACA,mDAAmD,8GAA8G;AACjK,6CAA6C,qJAAqJ;AAClM;AACA;AACA;AACA,mDAAmD,wGAAwG;AAC3J,6CAA6C,6IAA6I;AAC1L,gBAAgB;AAChB;AACA;AACA,yCAAyC,wBAAwB,OAAO,oEAAoE;AAC5I,qCAAqC,qCAAqC,OAAO,qCAAqC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wBAAwB,OAAO,oFAAoF;AAC5J,qCAAqC,qCAAqC,OAAO,qCAAqC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0GAA0G;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gHAAgH;AAC1I;AACA,qCAAqC,qCAAqC,OAAO,qCAAqC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAA4D;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,oEAAoE;AACxK;AACA;AACA;AACA,gCAAgC,gHAAgH;AAChJ;AACA,oCAAoC,8FAA8F;AAClI,aAAa;AACb,SAAS;AACT;AACA,2EAA2E,4BAA4B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACe;AACO;;;;;;;;AC5TtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAwB;AAAA;AAAA;;;;;;;;;;ACRxB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACE;AACA;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,OAAO,KAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;AC3KA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;ACpBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACoB;AACH;AACM;AACuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA,2CAA2C,wEAAwE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,2CAA2C,iBAAiB;AAC5D,iDAAiD,gBAAgB;AACjE,sCAAsC,UAAU;AAChD;AACA;AACA,8BAA8B,qBAAqB,qCAAqC,EAAE,EAAE;AAC5F,SAAS;AACT,oCAAoC,4BAA4B;AAChE,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD,gCAAgC,uBAAuB;AACvD,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E,yDAAyD,yCAAyC,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,kLAA0F,cAAc,QAAQ,SAAS;AACzH;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,aAAa,GAAG,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE;AACvB,aAAa;AACb;AACA,mFAAmF;AACnF;AACA,qBAAqB,EAAE;AACvB,aAAa;AACb;AACA,0GAA0G;AAC1G;AACA,oFAAoF;AACpF;AACA,qBAAqB,EAAE;AACvB,aAAa;AACb;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA,qBAAqB,EAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,qBAAqB,kDAAkD,EAAE,YAAY;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;ACpOA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACE;AACG;AACW;AACG;;AAElC,mFAAmF,SAAS,6BAA6B,OAAO,cAAc,0BAA0B,oBAAoB;AAC5L;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK,MAAM,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AAAA;AAAA;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AAAA;AAAA;;;;;;;;;AC5BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AAAA;AAAA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;ACNA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACiB;AACM;AACR;AACe;AACD;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gIAAwC,sGAAsG,GAAG,GAAG;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uJAA+D,MAAM;AACrE;AACA;AACA;AACA,2IAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,wBAAwB,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,2DAA2D,kGAAgD;AAC3G,yDAAyD,8JAAmG;AAC5J,sCAAsC,mEAAmE;AACzG,6CAA6C,2CAA2C;AACxF,wCAAwC,uBAAuB;AAC/D,0CAA0C,qFAAqF;AAC/H,yCAAyC,+CAA+C;AACxF,wCAAwC,qEAAqE;AAC7G,iDAAiD,6CAA6C;AAC9F,kDAAkD,6CAA6C;AAC/F,2CAA2C,sEAAsE;AACjH,8CAA8C,sEAAsE;AACpH,2CAA2C,kEAAkE;AAC7G,6CAA6C,kEAAkE;AAC/G,8CAA8C,yCAAyC;AACvF,6CAA6C,+CAA+C;AAC5F,sCAAsC,sEAAsE;AAC5G,mDAAmD,+CAA+C;AAClG,mDAAmD,+CAA+C;AAClG,iDAAiD,gJAA8F;AAC/I,0DAA0D,0IAAwF;AAClJ,8CAA8C,oEAAoE;AAClH,uDAAuD,yCAAyC;AAChG,+CAA+C,8MAA8M;AAC7P,wDAAwD,mDAAmD;AAC3G,6CAA6C,4HAA4H;AACzK,+CAA+C,oEAAoE;AACnH,sDAAsD,2EAA2E;AACjI;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,yDAAyD,kGAAgD;AACzG,gEAAgE,8JAAmG;AACnK,yCAAyC,mEAAmE;AAC5G,gDAAgD,gDAAgD;AAChG,2CAA2C,uBAAuB;AAClE,6CAA6C,0EAA0E;AACvH,4CAA4C,+CAA+C;AAC3F,qCAAqC,qEAAqE;AAC1G,8CAA8C,kDAAkD;AAChG,+CAA+C,kDAAkD;AACjG,wCAAwC,2EAA2E;AACnH,2CAA2C,2EAA2E;AACtH,wCAAwC,wFAAwF;AAChI,0CAA0C,kEAAkE;AAC5G,2CAA2C,yCAAyC;AACpF,0CAA0C,qEAAqE;AAC/G,mCAAmC,sEAAsE;AACzG,gDAAgD,oDAAoD;AACpG,sDAAsD,+CAA+C;AACrG,8CAA8C,gJAA8F;AAC5I,iEAAiE,+IAA6F;AAC9J,2CAA2C,oEAAoE;AAC/G,8DAA8D,8CAA8C;AAC5G,4CAA4C,8MAA8M;AAC1P,+DAA+D,wDAAwD;AACvH,gDAAgD,4HAA4H;AAC5K,4CAA4C,oEAAoE;AAChH,mDAAmD,2EAA2E;AAC9H;AACA;AAAA;AAAA;;;;;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD,uBAAuB,UAAU;AACjC;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK,GAAG,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;AC5FA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM,GAAG,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU,GAAG,gBAAgB;AAClF;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;ACnDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACS;AACI;AACL;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,uBAAuB,mBAAmB;AAC1C,qEAAqE,iCAAiC;AACtG;AACA,wBAAwB,mBAAmB;AAC3C,qEAAqE,kCAAkC;AACvG;AACA,iBAAiB,+BAA+B;AAChD,qEAAqE,uCAAuC;AAC5G;AACA,oBAAoB,+BAA+B;AACnD,qEAAqE,0CAA0C;AAC/G;AACA,iBAAiB,2BAA2B;AAC5C,6BAA6B,6CAA6C;AAC1E;AACA,mBAAmB,2BAA2B;AAC9C,6BAA6B,+CAA+C;AAC5E;AACA,mBAAmB,qBAAqB;AACxC,6BAA6B,yCAAyC;AACtE;AACA,oBAAoB,2BAA2B;AAC/C,6BAA6B,gDAAgD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uCAAuC;AAC3E;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA,uCAAuC,eAAe,GAAG,0CAA0C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;ACvBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,gBAAgB;AACzC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;ACtIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACC;AACH;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB,OAAO,sBAAsB;AACjE;AACA,oBAAoB,gBAAgB,GAAG,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACvDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACQ;;;;;;;;;;;ACXR;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACkB;AACD;AACM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtQA;AAAA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACA;AACG;AACC;AACE;AACG;AACW;AACG;AACT;AAC3B;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,8RAAuI,wBAAwB;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA6C,0CAA0C;AACvF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8FAA8F,EAAE;AAChG;AACA,0CAA0C,0CAA0C;AACpF,0NAAkI,SAAS;AAC3I;AACA,SAAS;AACT;AACA;AACA,gCAAgC,0ZAAiF;AACjH;AACA;AAAA;AAAA;;;;;;;;;AClGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACa;AAC9B,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,2EAA2E,0BAA0B;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA,wCAAwC,iDAAiD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sDAAsD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS,iCAAiC,eAAe;AACnG,8BAA8B,cAAc;AAC5C;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS,kCAAkC,gBAAgB;AACrG,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sDAAsD;AACnG,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iKAAyE,uBAAuB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,sDAAsD;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iCAAiC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iCAAiC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8CAA8C;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAkD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACjcA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA,uBAAuB,cAAc;AACrC,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACnGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;AChCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACQ;;;;;;;;;;AC1JR;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;AACX;;AAEtB,6EAA6E,cAAc,0BAA0B,oBAAoB;;AAEzI;AACA;AACA,OAAO,SAAS;AAChB;AACA;AACA","file":"shell/build/worker-entry.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 34);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 971cab55d60df1d9fb45","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nexport function assert(test, message) {\n    if (!test) {\n        debugger; // eslint-disable-line no-debugger\n        throw new Error(message);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/platform/assert-web.js\n// module id = 0\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\nimport { assert } from '../platform/assert-web.js';\nfunction addType(name, arg = undefined) {\n    let lowerName = name[0].toLowerCase() + name.substring(1);\n    let upperArg = arg ? arg[0].toUpperCase() + arg.substring(1) : '';\n    Object.defineProperty(Type.prototype, `${lowerName}${upperArg}`, {\n        get: function () {\n            if (!this[`is${name}`])\n                assert(this[`is${name}`], `{${this.tag}, ${this.data}} is not of type ${name}`);\n            return this.data;\n        }\n    });\n    Object.defineProperty(Type.prototype, `is${name}`, {\n        get: function () {\n            return this.tag == name;\n        }\n    });\n}\nexport class Type {\n    constructor(tag, data) {\n        assert(typeof tag == 'string');\n        assert(data);\n        if (tag == 'Entity') {\n            assert(data instanceof Schema);\n        }\n        if (tag == 'Collection') {\n            if (!(data instanceof Type) && data.tag && data.data) {\n                data = new Type(data.tag, data.data);\n            }\n        }\n        if (tag == 'Variable') {\n            if (!(data instanceof TypeVariable)) {\n                data = new TypeVariable(data.name, data.constraint);\n            }\n        }\n        this.tag = tag;\n        this.data = data;\n    }\n    static newEntity(entity) {\n        return new Type('Entity', entity);\n    }\n    static newVariable(variable) {\n        return new Type('Variable', variable);\n    }\n    static newCollection(collection) {\n        return new Type('Collection', collection);\n    }\n    static newRelation(relation) {\n        return new Type('Relation', relation);\n    }\n    static newInterface(iface) {\n        return new Type('Interface', iface);\n    }\n    static newSlot(slot) {\n        return new Type('Slot', slot);\n    }\n    static newReference(reference) {\n        return new Type('Reference', reference);\n    }\n    mergeTypeVariablesByName(variableMap) {\n        if (this.isVariable) {\n            let name = this.variable.name;\n            let variable = variableMap.get(name);\n            if (!variable) {\n                variable = this;\n                variableMap.set(name, this);\n            }\n            else {\n                if (variable.variable.hasConstraint || this.variable.hasConstraint) {\n                    let mergedConstraint = variable.variable.maybeMergeConstraints(this.variable);\n                    if (!mergedConstraint) {\n                        throw new Error('could not merge type variables');\n                    }\n                }\n            }\n            return variable;\n        }\n        if (this.isCollection) {\n            let primitiveType = this.primitiveType();\n            let result = primitiveType.mergeTypeVariablesByName(variableMap);\n            if (result === primitiveType) {\n                return this;\n            }\n            return result.collectionOf();\n        }\n        if (this.isInterface) {\n            let shape = this.interfaceShape.clone(new Map());\n            shape._typeVars.map(({ object, field }) => object[field] = object[field].mergeTypeVariablesByName(variableMap));\n            // TODO: only build a new type when a variable is modified\n            return Type.newInterface(shape);\n        }\n        return this;\n    }\n    static unwrapPair(type1, type2) {\n        assert(type1 instanceof Type);\n        assert(type2 instanceof Type);\n        if (type1.isCollection && type2.isCollection)\n            return Type.unwrapPair(type1.primitiveType(), type2.primitiveType());\n        return [type1, type2];\n    }\n    // TODO: update call sites to use the type checker instead (since they will\n    // have additional information about direction etc.)\n    equals(type) {\n        return TypeChecker.compareTypes({ type: this }, { type });\n    }\n    _applyExistenceTypeTest(test) {\n        if (this.isCollection)\n            return this.primitiveType()._applyExistenceTypeTest(test);\n        if (this.isInterface)\n            return this.interfaceShape._applyExistenceTypeTest(test);\n        return test(this);\n    }\n    get hasVariable() {\n        return this._applyExistenceTypeTest(type => type.isVariable);\n    }\n    get hasUnresolvedVariable() {\n        return this._applyExistenceTypeTest(type => type.isVariable && !type.variable.isResolved());\n    }\n    get hasVariableReference() {\n        return this._applyExistenceTypeTest(type => type.isVariableReference);\n    }\n    // TODO: remove this in favor of a renamed collectionType\n    primitiveType() {\n        return this.collectionType;\n    }\n    collectionOf() {\n        return Type.newCollection(this);\n    }\n    resolvedType() {\n        if (this.isCollection) {\n            let primitiveType = this.primitiveType();\n            let resolvedPrimitiveType = primitiveType.resolvedType();\n            return primitiveType !== resolvedPrimitiveType ? resolvedPrimitiveType.collectionOf() : this;\n        }\n        if (this.isVariable) {\n            let resolution = this.variable.resolution;\n            if (resolution)\n                return resolution;\n        }\n        if (this.isInterface) {\n            return Type.newInterface(this.interfaceShape.resolvedType());\n        }\n        return this;\n    }\n    isResolved() {\n        // TODO: one of these should not exist.\n        return !this.hasUnresolvedVariable;\n    }\n    canEnsureResolved() {\n        if (this.isResolved())\n            return true;\n        if (this.isInterface)\n            return this.interfaceShape.canEnsureResolved();\n        if (this.isVariable)\n            return this.variable.canEnsureResolved();\n        if (this.isCollection)\n            return this.primitiveType().canEnsureResolved();\n        return true;\n    }\n    maybeEnsureResolved() {\n        if (this.isInterface)\n            return this.interfaceShape.maybeEnsureResolved();\n        if (this.isVariable)\n            return this.variable.maybeEnsureResolved();\n        if (this.isCollection)\n            return this.primitiveType().maybeEnsureResolved();\n        return true;\n    }\n    get canWriteSuperset() {\n        if (this.isVariable)\n            return this.variable.canWriteSuperset;\n        if (this.isEntity || this.isSlot)\n            return this;\n        if (this.isInterface)\n            return Type.newInterface(this.interfaceShape.canWriteSuperset);\n        assert(false, `canWriteSuperset not implemented for ${this}`);\n        return undefined;\n    }\n    get canReadSubset() {\n        if (this.isVariable)\n            return this.variable.canReadSubset;\n        if (this.isEntity || this.isSlot)\n            return this;\n        if (this.isInterface)\n            return Type.newInterface(this.interfaceShape.canReadSubset);\n        assert(false, `canReadSubset not implemented for ${this}`);\n        return undefined;\n    }\n    isMoreSpecificThan(type) {\n        if (this.tag !== type.tag)\n            return false;\n        if (this.isEntity)\n            return this.entitySchema.isMoreSpecificThan(type.entitySchema);\n        if (this.isInterface)\n            return this.interfaceShape.isMoreSpecificThan(type.interfaceShape);\n        if (this.isSlot) {\n            // TODO: formFactor checking, etc.\n            return true;\n        }\n        assert(false, `contains not implemented for ${this}`);\n    }\n    static _canMergeCanReadSubset(type1, type2) {\n        if (type1.canReadSubset && type2.canReadSubset) {\n            if (type1.canReadSubset.tag !== type2.canReadSubset.tag)\n                return false;\n            if (type1.canReadSubset.isEntity)\n                return Schema.intersect(type1.canReadSubset.entitySchema, type2.canReadSubset.entitySchema) !== null;\n            assert(false, `_canMergeCanReadSubset not implemented for types tagged with ${type1.canReadSubset.tag}`);\n        }\n        return true;\n    }\n    static _canMergeCanWriteSuperset(type1, type2) {\n        if (type1.canWriteSuperset && type2.canWriteSuperset) {\n            if (type1.canWriteSuperset.tag !== type2.canWriteSuperset.tag)\n                return false;\n            if (type1.canWriteSuperset.isEntity)\n                return Schema.union(type1.canWriteSuperset.entitySchema, type2.canWriteSuperset.entitySchema) !== null;\n        }\n        return true;\n    }\n    // Tests whether two types' constraints are compatible with each other\n    static canMergeConstraints(type1, type2) {\n        return Type._canMergeCanReadSubset(type1, type2) && Type._canMergeCanWriteSuperset(type1, type2);\n    }\n    // Clone a type object.\n    // When cloning multiple types, variables that were associated with the same name\n    // before cloning should still be associated after cloning. To maintain this \n    // property, create a Map() and pass it into all clone calls in the group.\n    clone(variableMap) {\n        let type = this.resolvedType();\n        if (type.isVariable) {\n            if (variableMap.has(type.variable)) {\n                return new Type('Variable', variableMap.get(type.variable));\n            }\n            else {\n                let newTypeVariable = TypeVariable.fromLiteral(type.variable.toLiteral());\n                variableMap.set(type.variable, newTypeVariable);\n                return new Type('Variable', newTypeVariable);\n            }\n        }\n        if (type.data.clone) {\n            return new Type(type.tag, type.data.clone(variableMap));\n        }\n        return Type.fromLiteral(type.toLiteral());\n    }\n    // Clone a type object, maintaining resolution information.\n    // This function SHOULD NOT BE USED at the type level. In order for type variable\n    // information to be maintained correctly, an entire context root needs to be\n    // cloned.\n    _cloneWithResolutions(variableMap) {\n        if (this.isVariable) {\n            if (variableMap.has(this.variable)) {\n                return new Type('Variable', variableMap.get(this.variable));\n            }\n            else {\n                let newTypeVariable = TypeVariable.fromLiteral(this.variable.toLiteralIgnoringResolutions());\n                if (this.variable.resolution)\n                    newTypeVariable.resolution = this.variable.resolution._cloneWithResolutions(variableMap);\n                if (this.variable._canReadSubset)\n                    newTypeVariable.canReadSubset = this.variable.canReadSubset._cloneWithResolutions(variableMap);\n                if (this.variable._canWriteSuperset)\n                    newTypeVariable.canWriteSuperset = this.variable.canWriteSuperset._cloneWithResolutions(variableMap);\n                variableMap.set(this.variable, newTypeVariable);\n                return new Type('Variable', newTypeVariable);\n            }\n        }\n        if (this.data instanceof Shape || this.data instanceof Type) {\n            return new Type(this.tag, this.data._cloneWithResolutions(variableMap));\n        }\n        return Type.fromLiteral(this.toLiteral());\n    }\n    toLiteral() {\n        if (this.isVariable && this.variable.resolution) {\n            return this.variable.resolution.toLiteral();\n        }\n        if (this.data instanceof Type || this.data instanceof Shape || this.data instanceof Schema ||\n            this.data instanceof TypeVariable)\n            return { tag: this.tag, data: this.data.toLiteral() };\n        return this;\n    }\n    static _deliteralizer(tag) {\n        switch (tag) {\n            case 'Interface':\n                return Shape.fromLiteral;\n            case 'Entity':\n                return Schema.fromLiteral;\n            case 'Collection':\n                return Type.fromLiteral;\n            case 'Tuple':\n                return TupleFields.fromLiteral;\n            case 'Variable':\n                return TypeVariable.fromLiteral;\n            default:\n                return a => a;\n        }\n    }\n    static fromLiteral(literal) {\n        if (literal.tag == 'SetView') {\n            // TODO: SetView is deprecated, remove when possible.\n            literal.tag = 'Collection';\n        }\n        return new Type(literal.tag, Type._deliteralizer(literal.tag)(literal.data));\n    }\n    // TODO: is this the same as _applyExistenceTypeTest\n    hasProperty(property) {\n        if (property(this))\n            return true;\n        if (this.isCollection)\n            return this.collectionType.hasProperty(property);\n        return false;\n    }\n    toString(options) {\n        if (this.isCollection)\n            return `[${this.primitiveType().toString(options)}]`;\n        if (this.isEntity)\n            return this.entitySchema.toInlineSchemaString(options);\n        if (this.isInterface)\n            return this.interfaceShape.name;\n        if (this.isVariable)\n            return `~${this.variable.name}`;\n        if (this.isSlot)\n            return 'Slot';\n        assert(false, `Add support to serializing type: ${JSON.stringify(this)}`);\n    }\n    getEntitySchema() {\n        if (this.isCollection) {\n            return this.primitiveType().getEntitySchema();\n        }\n        if (this.isEntity) {\n            return this.entitySchema;\n        }\n        if (this.isVariable) {\n            if (this.variable.isResolved()) {\n                return this.resolvedType().getEntitySchema();\n            }\n        }\n    }\n    toPrettyString() {\n        // Try extract the description from schema spec.\n        let entitySchema = this.getEntitySchema();\n        if (entitySchema) {\n            if (this.isCollection && entitySchema.description.plural) {\n                return entitySchema.description.plural;\n            }\n            if (this.isEntity && entitySchema.description.pattern) {\n                return entitySchema.description.pattern;\n            }\n        }\n        if (this.isRelation) {\n            return JSON.stringify(this.data);\n        }\n        if (this.isCollection) {\n            return `${this.primitiveType().toPrettyString()} List`;\n        }\n        if (this.isVariable)\n            return this.variable.isResolved() ? this.resolvedType().toPrettyString() : `[~${this.variable.name}]`;\n        if (this.isEntity) {\n            // Spit MyTypeFOO to My Type FOO\n            if (this.entitySchema.name) {\n                return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2').replace(/([A-Z][^A-Z])/g, ' $1').replace(/[\\s]+/g, ' ').trim();\n            }\n            return JSON.stringify(this.entitySchema._model);\n        }\n        if (this.isInterface)\n            return this.interfaceShape.toPrettyString();\n    }\n}\naddType('Entity', 'schema');\naddType('Variable');\naddType('Collection', 'type');\naddType('Relation', 'entities');\naddType('Interface', 'shape');\naddType('Slot');\naddType('Reference', 'referredType');\nimport { Shape } from './shape.js';\nimport { Schema } from './schema.js';\nimport { TypeVariable } from './type-variable.js';\nimport { TupleFields } from './tuple-fields.js';\nimport { TypeChecker } from './recipe/type-checker.js';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/type.js\n// module id = 1\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { XenStateMixin } from '../shell/components/xen/xen-state.js';\nimport { DomParticleBase } from './dom-particle-base.js';\n/** @class DomParticle\n * Particle that interoperates with DOM and uses a simple state system\n * to handle updates.\n */\nexport class DomParticle extends XenStateMixin(DomParticleBase) {\n    constructor() {\n        super();\n        // alias properties to remove `_`\n        this.state = this._state;\n        this.props = this._props;\n    }\n    /** @method willReceiveProps(props, state, oldProps, oldState)\n     * Override if necessary, to do things when props change.\n     */\n    willReceiveProps() {\n    }\n    /** @method update(props, state, oldProps, oldState)\n     * Override if necessary, to modify superclass config.\n     */\n    update() {\n    }\n    /** @method shouldRender(props, state, oldProps, oldState)\n     * Override to return false if the Particle won't use\n     * it's slot.\n     */\n    shouldRender() {\n        return true;\n    }\n    /** @method render(props, state, oldProps, oldState)\n     * Override to return a dictionary to map into the template.\n     */\n    render() {\n        return {};\n    }\n    /** @method setState(state)\n     * Copy values from `state` into the particle's internal state,\n     * triggering an update cycle unless currently updating.\n     */\n    setState(state) {\n        return this._setState(state);\n    }\n    // TODO(sjmiles): deprecated, just use setState\n    setIfDirty(state) {\n        console.warn('DomParticle: `setIfDirty` is deprecated, please use `setState` instead');\n        return this._setState(state);\n    }\n    /** @method get config()\n     * Override if necessary, to modify superclass config.\n     */\n    get config() {\n        // TODO(sjmiles): getter that does work is a bad idea, this is temporary\n        return {\n            handleNames: this.spec.inputs.map(i => i.name),\n            // TODO(mmandlis): this.spec needs to be replaced with a particle-spec loaded from\n            // .manifest files, instead of .ptcl ones.\n            slotNames: [...this.spec.slots.values()].map(s => s.name)\n        };\n    }\n    // affordances for aliasing methods to remove `_`\n    _willReceiveProps(...args) {\n        this.willReceiveProps(...args);\n    }\n    _update(...args) {\n        this.update(...args);\n        if (this.shouldRender(...args)) { // TODO: should shouldRender be slot specific?\n            this.relevance = 1; // TODO: improve relevance signal.\n        }\n        this.config.slotNames.forEach(s => this.renderSlot(s, ['model']));\n    }\n    //\n    // deprecated\n    get _views() {\n        console.warn(`Particle ${this.spec.name} uses deprecated _views getter.`);\n        return this.handles;\n    }\n    setViews(views) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.warn(`Particle ${this.spec.name} uses deprecated setViews method.`);\n            return this.setHandles(views);\n        });\n    }\n    // end deprecated\n    //\n    setHandles(handles) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.handles = handles;\n            this._handlesToSync = new Set(this.config.handleNames);\n            // make sure we invalidate once, even if there are no incoming handles\n            this._invalidate();\n        });\n    }\n    onHandleSync(handle, model) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._handlesToSync.delete(handle.name);\n            if (this._handlesToSync.size == 0) {\n                yield this._handlesToProps();\n            }\n        });\n    }\n    onHandleUpdate(handle, update) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._handlesToProps();\n        });\n    }\n    _handlesToProps() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let config = this.config;\n            // acquire (async) list data from handles\n            let data = yield Promise.all(config.handleNames\n                .map(name => this.handles.get(name))\n                .map(handle => handle.toList ? handle.toList() : handle.get()));\n            // convert handle data (array) into props (dictionary)\n            let props = Object.create(null);\n            config.handleNames.forEach((name, i) => {\n                props[name] = data[i];\n            });\n            this._setProps(props);\n        });\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            // TODO(sjmiles): remove `this._state` parameter\n            this[handler]({ data }, this._state);\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/dom-particle.js\n// module id = 2\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Type } from './type.js';\nimport { TypeChecker } from './recipe/type-checker.js';\nimport { Shape } from './shape.js';\nimport { assert } from '../platform/assert-web.js';\nclass ConnectionSpec {\n    constructor(rawData, typeVarMap) {\n        this.rawData = rawData;\n        this.direction = rawData.direction;\n        this.name = rawData.name;\n        this.type = rawData.type.mergeTypeVariablesByName(typeVarMap);\n        this.isOptional = rawData.isOptional;\n        this.tags = rawData.tags || [];\n        this.dependentConnections = [];\n    }\n    instantiateDependentConnections(particle, typeVarMap) {\n        for (let dependentArg of this.rawData.dependentConnections) {\n            let dependentConnection = particle.createConnection(dependentArg, typeVarMap);\n            dependentConnection.parentConnection = this;\n            this.dependentConnections.push(dependentConnection);\n        }\n    }\n    get isInput() {\n        // TODO: we probably don't really want host to be here.\n        return this.direction == 'in' || this.direction == 'inout' || this.direction == 'host';\n    }\n    get isOutput() {\n        return this.direction == 'out' || this.direction == 'inout';\n    }\n    isCompatibleType(type) {\n        return TypeChecker.compareTypes({ type }, { type: this.type, direction: this.direction });\n    }\n}\nclass SlotSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired;\n        this.isSet = slotModel.isSet;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.providedSlots = [];\n        if (!slotModel.providedSlots)\n            return;\n        slotModel.providedSlots.forEach(ps => {\n            this.providedSlots.push(new ProvidedSlotSpec(ps));\n        });\n    }\n    getProvidedSlotSpec(name) {\n        return this.providedSlots.find(ps => ps.name == name);\n    }\n}\nexport class ProvidedSlotSpec {\n    constructor(slotModel) {\n        this.name = slotModel.name;\n        this.isRequired = slotModel.isRequired || false;\n        this.isSet = slotModel.isSet || false;\n        this.tags = slotModel.tags || [];\n        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?\n        this.handles = slotModel.handles || [];\n    }\n}\nexport class ParticleSpec {\n    constructor(model) {\n        this._model = model;\n        this.name = model.name;\n        this.verbs = model.verbs;\n        let typeVarMap = new Map();\n        this.connections = [];\n        model.args.forEach(arg => this.createConnection(arg, typeVarMap));\n        this.connectionMap = new Map();\n        this.connections.forEach(a => this.connectionMap.set(a.name, a));\n        this.inputs = this.connections.filter(a => a.isInput);\n        this.outputs = this.connections.filter(a => a.isOutput);\n        // initialize descriptions patterns.\n        model.description = model.description || {};\n        this.validateDescription(model.description);\n        this.pattern = model.description['pattern'];\n        this.connections.forEach(connectionSpec => {\n            connectionSpec.pattern = model.description[connectionSpec.name];\n        });\n        this.implFile = model.implFile;\n        this.affordance = model.affordance;\n        this.slots = new Map();\n        if (model.slots)\n            model.slots.forEach(s => this.slots.set(s.name, new SlotSpec(s)));\n        // Verify provided slots use valid handle connection names.\n        this.slots.forEach(slot => {\n            slot.providedSlots.forEach(ps => {\n                ps.handles.forEach(v => assert(this.connectionMap.has(v), 'Cannot provide slot for nonexistent handle constraint ', v));\n            });\n        });\n    }\n    createConnection(arg, typeVarMap) {\n        let connection = new ConnectionSpec(arg, typeVarMap);\n        this.connections.push(connection);\n        connection.instantiateDependentConnections(this, typeVarMap);\n        return connection;\n    }\n    isInput(param) {\n        for (let input of this.inputs)\n            if (input.name == param)\n                return true;\n    }\n    isOutput(param) {\n        for (let outputs of this.outputs)\n            if (outputs.name == param)\n                return true;\n    }\n    getSlotSpec(slotName) {\n        return this.slots.get(slotName);\n    }\n    get primaryVerb() {\n        return (this.verbs.length > 0) ? this.verbs[0] : undefined;\n    }\n    matchAffordance(affordance) {\n        return this.slots.size <= 0 || this.affordance.includes(affordance);\n    }\n    toLiteral() {\n        let { args, name, verbs, description, implFile, affordance, slots } = this._model;\n        let connectionToLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: type.toLiteral(), direction, name, isOptional, dependentConnections: dependentConnections.map(connectionToLiteral) });\n        args = args.map(a => connectionToLiteral(a));\n        return { args, name, verbs, description, implFile, affordance, slots };\n    }\n    static fromLiteral(literal) {\n        let { args, name, verbs, description, implFile, affordance, slots } = literal;\n        let connectionFromLiteral = ({ type, direction, name, isOptional, dependentConnections }) => ({ type: Type.fromLiteral(type), direction, name, isOptional, dependentConnections: dependentConnections ? dependentConnections.map(connectionFromLiteral) : [] });\n        args = args.map(connectionFromLiteral);\n        return new ParticleSpec({ args, name, verbs: verbs || [], description, implFile, affordance, slots });\n    }\n    clone() {\n        return ParticleSpec.fromLiteral(this.toLiteral());\n    }\n    equals(other) {\n        return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());\n    }\n    validateDescription(description) {\n        Object.keys(description || []).forEach(d => {\n            assert(['kind', 'location', 'pattern'].includes(d) || this.connectionMap.has(d), `Unexpected description for ${d}`);\n        });\n    }\n    toInterface() {\n        return Type.newInterface(this._toShape());\n    }\n    _toShape() {\n        const handles = this._model.args;\n        // TODO: wat do?\n        assert(!this.slots.length, 'please implement slots toShape');\n        const slots = [];\n        return new Shape(handles, slots);\n    }\n    toString() {\n        let results = [];\n        let verbs = '';\n        if (this.verbs.length > 0)\n            verbs = ' ' + this.verbs.map(verb => `&${verb}`).join(' ');\n        results.push(`particle ${this.name}${verbs} in '${this.implFile}'`.trim());\n        let indent = '  ';\n        let writeConnection = (connection, indent) => {\n            results.push(`${indent}${connection.direction} ${connection.type.toString()}${connection.isOptional ? '?' : ''} ${connection.name}`);\n            for (let dependent of connection.dependentConnections) {\n                writeConnection(dependent, indent + '  ');\n            }\n        };\n        for (let connection of this.connections) {\n            if (connection.parentConnection)\n                continue;\n            writeConnection(connection, indent);\n        }\n        this.affordance.filter(a => a != 'mock').forEach(a => results.push(`  affordance ${a}`));\n        this.slots.forEach(s => {\n            // Consume slot.\n            let consume = [];\n            if (s.isRequired) {\n                consume.push('must');\n            }\n            consume.push('consume');\n            if (s.isSet) {\n                consume.push('set of');\n            }\n            consume.push(s.name);\n            if (s.tags.length > 0) {\n                consume.push(s.tags.map(a => `#${a}`).join(' '));\n            }\n            results.push(`  ${consume.join(' ')}`);\n            if (s.formFactor) {\n                results.push(`    formFactor ${s.formFactor}`);\n            }\n            // Provided slots.\n            s.providedSlots.forEach(ps => {\n                let provide = [];\n                if (ps.isRequired) {\n                    provide.push('must');\n                }\n                provide.push('provide');\n                if (ps.isSet) {\n                    provide.push('set of');\n                }\n                provide.push(ps.name);\n                if (ps.tags.length > 0) {\n                    provide.push(ps.tags.map(a => `#${a}`).join(' '));\n                }\n                results.push(`    ${provide.join(' ')}`);\n                if (ps.formFactor) {\n                    results.push(`      formFactor ${ps.formFactor}`);\n                }\n                ps.handles.forEach(handle => results.push(`      handle ${handle}`));\n            });\n        });\n        // Description\n        if (this.pattern) {\n            results.push(`  description \\`${this.pattern}\\``);\n            this.connections.forEach(cs => {\n                if (cs.pattern) {\n                    results.push(`    ${cs.name} \\`${cs.pattern}\\``);\n                }\n            });\n        }\n        return results.join('\\n');\n    }\n    toManifestString() {\n        return this.toString();\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/particle-spec.js\n// module id = 3\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n/** @class Particle\n * A basic particle. For particles that provide UI, you may like to\n * instead use DOMParticle.\n */\nexport class Particle {\n    constructor(capabilities) {\n        this.spec = this.constructor.spec;\n        if (this.spec.inputs.length == 0)\n            this.extraData = true;\n        this.relevances = [];\n        this._idle = Promise.resolve();\n        this._busy = 0;\n        this._slotByName = new Map();\n        this.capabilities = capabilities || {};\n    }\n    /** @method setHandles(handles)\n     * This method is invoked with a handle for each store this particle\n     * is registered to interact with, once those handles are ready for\n     * interaction. Override the method to register for events from\n     * the handles.\n     *\n     * Handles is a map from handle names to store handles.\n     */\n    setHandles(handles) {\n    }\n    /** @method setViews(views)\n     * This method is deprecated. Use setHandles instead.\n     */\n    setViews(views) {\n    }\n    /** @method onHandleSync(handle, model)\n     * Called for handles that are configured with both keepSynced and notifySync, when they are\n     * updated with the full model of their data. This will occur once after setHandles() and any time\n     * thereafter if the handle is resynchronized.\n     *\n     * handle: The Handle instance that was updated.\n     * model: For Variable-backed Handles, the Entity data or null if the Variable is not set.\n     *        For Collection-backed Handles, the Array of Entities, which may be empty.\n     */\n    onHandleSync(handle, model) {\n    }\n    /** @method onHandleUpdate(handle, update)\n     * Called for handles that are configued with notifyUpdate, when change events are received from\n     * the backing store. For handles also configured with keepSynced these events will be correctly\n     * ordered, with some potential skips if a desync occurs. For handles not configured with\n     * keepSynced, all change events will be passed through as they are received.\n     *\n     * handle: The Handle instance that was updated.\n     * update: An object containing one of the following fields:\n     *    data: The full Entity for a Variable-backed Handle.\n     *    added: An Array of Entities added to a Collection-backed Handle.\n     *    removed: An Array of Entities removed from a Collection-backed Handle.\n     */\n    onHandleUpdate(handle, update) {\n    }\n    /** @method onHandleDesync(handle)\n     * Called for handles that are configured with both keepSynced and notifyDesync, when they are\n     * detected as being out-of-date against the backing store. For Variables, the event that triggers\n     * this will also resync the data and thus this call may usually be ignored. For Collections, the\n     * underlying proxy will automatically request a full copy of the stored data to resynchronize.\n     * onHandleSync will be invoked when that is received.\n     *\n     * handle: The Handle instance that was desynchronized.\n     */\n    onHandleDesync(handle) {\n    }\n    constructInnerArc() {\n        if (!this.capabilities.constructInnerArc)\n            throw new Error('This particle is not allowed to construct inner arcs');\n        return this.capabilities.constructInnerArc(this);\n    }\n    get busy() {\n        return this._busy > 0;\n    }\n    get idle() {\n        return this._idle;\n    }\n    set relevance(r) {\n        this.relevances.push(r);\n    }\n    inputs() {\n        return this.spec.inputs;\n    }\n    outputs() {\n        return this.spec.outputs;\n    }\n    /** @method getSlot(name)\n     * Returns the slot with provided name.\n     */\n    getSlot(name) {\n        return this._slotByName.get(name);\n    }\n    static buildManifest(strings, ...bits) {\n        let output = [];\n        for (let i = 0; i < bits.length; i++) {\n            let str = strings[i];\n            let indent = / *$/.exec(str)[0];\n            let bitStr;\n            if (typeof bits[i] == 'string')\n                bitStr = bits[i];\n            else\n                bitStr = bits[i].toManifestString();\n            bitStr = bitStr.replace(/(\\n)/g, '$1' + indent);\n            output.push(str);\n            output.push(bitStr);\n        }\n        if (strings.length > bits.length)\n            output.push(strings[strings.length - 1]);\n        return output.join('');\n    }\n    setParticleDescription(pattern) {\n        return this.setDescriptionPattern('_pattern_', pattern);\n    }\n    setDescriptionPattern(connectionName, pattern) {\n        let descriptions = this.handles.get('descriptions');\n        if (descriptions) {\n            descriptions.store(new descriptions.entityClass({ key: connectionName, value: pattern }, connectionName));\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/particle.js\n// module id = 4\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { Type } from '../type.js';\nimport { TypeVariable } from '../type-variable.js';\nimport { assert } from '../../platform/assert-web.js';\nexport class TypeChecker {\n    // resolve a list of handleConnection types against a handle\n    // base type. This is the core type resolution mechanism, but should only\n    // be used when types can actually be associated with each other / constrained.\n    //\n    // By design this function is called exactly once per handle in a recipe during\n    // normalization, and should provide the same final answers regardless of the\n    // ordering of handles within that recipe\n    //\n    // NOTE: you probably don't want to call this function, if you think you\n    // do, talk to shans@.\n    static processTypeList(baseType, list) {\n        let newBaseType = Type.newVariable(new TypeVariable(''));\n        if (baseType)\n            newBaseType.data.resolution = baseType;\n        baseType = newBaseType;\n        let concreteTypes = [];\n        // baseType might be a variable (and is definitely a variable if no baseType was available).\n        // Some of the list might contain variables too.\n        // First attempt to merge all the variables into the baseType\n        //\n        // If the baseType is a variable then this results in a single place to manipulate the constraints\n        // of all the other connected variables at the same time.\n        for (let item of list) {\n            if (item.type.resolvedType().hasVariable) {\n                baseType = TypeChecker._tryMergeTypeVariable(baseType, item.type);\n                if (baseType == null)\n                    return null;\n            }\n            else {\n                concreteTypes.push(item);\n            }\n        }\n        for (let item of concreteTypes) {\n            let success = TypeChecker._tryMergeConstraints(baseType, item);\n            if (!success)\n                return null;\n        }\n        let getResolution = candidate => {\n            if (candidate.isVariable == false)\n                return candidate;\n            if (candidate.canReadSubset == null || candidate.canWriteSuperset == null)\n                return candidate;\n            if (candidate.canReadSubset.isMoreSpecificThan(candidate.canWriteSuperset)) {\n                if (candidate.canWriteSuperset.isMoreSpecificThan(candidate.canReadSubset))\n                    candidate.variable.resolution = candidate.canReadSubset;\n                return candidate;\n            }\n            return null;\n        };\n        let candidate = baseType.resolvedType();\n        if (candidate.isCollection) {\n            candidate = candidate.primitiveType();\n            let resolution = getResolution(candidate);\n            if (resolution == null)\n                return null;\n            return resolution.collectionOf();\n        }\n        return getResolution(candidate);\n    }\n    static _tryMergeTypeVariable(base, onto) {\n        let [primitiveBase, primitiveOnto] = Type.unwrapPair(base.resolvedType(), onto.resolvedType());\n        if (primitiveBase.isVariable) {\n            if (primitiveOnto.isVariable) {\n                // base, onto both variables.\n                let result = primitiveBase.variable.maybeMergeConstraints(primitiveOnto.variable);\n                if (result == false)\n                    return null;\n                // Here onto grows, one level at a time,\n                // as we assign new resolution to primitiveOnto, which is a leaf.\n                primitiveOnto.variable.resolution = primitiveBase;\n            }\n            else {\n                // base variable, onto not.\n                primitiveBase.variable.resolution = primitiveOnto;\n            }\n        }\n        else if (primitiveOnto.isVariable) {\n            // onto variable, base not.\n            primitiveOnto.variable.resolution = primitiveBase;\n            return onto;\n        }\n        else if (primitiveBase.isInterface && primitiveOnto.isInterface) {\n            let result = primitiveBase.interfaceShape.tryMergeTypeVariablesWith(primitiveOnto.interfaceShape);\n            if (result == null)\n                return null;\n            return Type.newInterface(result);\n        }\n        else {\n            if ((primitiveBase.isCollection && primitiveBase.hasVariable)\n                || (primitiveOnto.isCollection && primitiveOnto.hasVariable)) {\n                // Cannot merge [~a] with a type that is not a variable and not a collection.\n                return null;\n            }\n            assert(false, 'tryMergeTypeVariable shouldn\\'t be called on two types without any type variables');\n        }\n        return base;\n    }\n    static _tryMergeConstraints(handleType, { type, direction }) {\n        let [primitiveHandleType, primitiveConnectionType] = Type.unwrapPair(handleType.resolvedType(), type.resolvedType());\n        if (primitiveHandleType.isVariable) {\n            while (primitiveConnectionType.isCollection) {\n                if (primitiveHandleType.variable.resolution != null\n                    || primitiveHandleType.variable.canReadSubset != null\n                    || primitiveHandleType.variable.canWriteSuperset != null) {\n                    // Resolved and/or constrained variables can only represent Entities, not sets.\n                    return false;\n                }\n                // If this is an undifferentiated variable then we need to create structure to match against. That's\n                // allowed because this variable could represent anything, and it needs to represent this structure\n                // in order for type resolution to succeed.\n                primitiveHandleType.variable.resolution = Type.newCollection(Type.newVariable(new TypeVariable('a')));\n                let unwrap = Type.unwrapPair(primitiveHandleType.resolvedType(), primitiveConnectionType);\n                primitiveHandleType = unwrap[0];\n                primitiveConnectionType = unwrap[1];\n            }\n            if (direction == 'out' || direction == 'inout' || direction == '`provide') {\n                // the canReadSubset of the handle represents the maximal type that can be read from the\n                // handle, so we need to intersect out any type that is more specific than the maximal type\n                // that could be written.\n                if (!primitiveHandleType.variable.maybeMergeCanReadSubset(primitiveConnectionType.canWriteSuperset))\n                    return false;\n            }\n            if (direction == 'in' || direction == 'inout' || direction == '`consume') {\n                // the canWriteSuperset of the handle represents the maximum lower-bound type that is read from the handle,\n                // so we need to union it with the type that wants to be read here.\n                if (!primitiveHandleType.variable.maybeMergeCanWriteSuperset(primitiveConnectionType.canReadSubset))\n                    return false;\n            }\n        }\n        else {\n            if (primitiveConnectionType.tag !== primitiveHandleType.tag)\n                return false;\n            if (direction == 'out' || direction == 'inout')\n                if (!TypeChecker._writeConstraintsApply(primitiveHandleType, primitiveConnectionType))\n                    return false;\n            if (direction == 'in' || direction == 'inout')\n                if (!TypeChecker._readConstraintsApply(primitiveHandleType, primitiveConnectionType))\n                    return false;\n        }\n        return true;\n    }\n    static _writeConstraintsApply(handleType, connectionType) {\n        // this connection wants to write to this handle. If the written type is\n        // more specific than the canReadSubset then it isn't violating the maximal type\n        // that can be read.\n        let writtenType = connectionType.canWriteSuperset;\n        if (writtenType == null || handleType.canReadSubset == null)\n            return true;\n        if (writtenType.isMoreSpecificThan(handleType.canReadSubset))\n            return true;\n        return false;\n    }\n    static _readConstraintsApply(handleType, connectionType) {\n        // this connection wants to read from this handle. If the read type\n        // is less specific than the canWriteSuperset, then it isn't violating\n        // the maximum lower-bound read type.\n        let readType = connectionType.canReadSubset;\n        if (readType == null || handleType.canWriteSuperset == null)\n            return true;\n        if (handleType.canWriteSuperset.isMoreSpecificThan(readType))\n            return true;\n        return false;\n    }\n    // Compare two types to see if they could be potentially resolved (in the absence of other\n    // information). This is used as a filter when selecting compatible handles or checking\n    // validity of recipes. This function returning true never implies that full type resolution\n    // will succeed, but if the function returns false for a pair of types that are associated\n    // then type resolution is guaranteed to fail.\n    //\n    // left, right: {type, direction, connection}\n    static compareTypes(left, right) {\n        let resolvedLeft = left.type.resolvedType();\n        let resolvedRight = right.type.resolvedType();\n        let [leftType, rightType] = Type.unwrapPair(resolvedLeft, resolvedRight);\n        // a variable is compatible with a set only if it is unconstrained.\n        if (leftType.isVariable && rightType.isCollection)\n            return !(leftType.variable.canReadSubset || leftType.variable.canWriteSuperset);\n        if (rightType.isVariable && leftType.isCollection)\n            return !(rightType.variable.canReadSubset || rightType.variable.canWriteSuperset);\n        if (leftType.isVariable || rightType.isVariable) {\n            // TODO: everything should use this, eventually. Need to implement the\n            // right functionality in Shapes first, though.\n            return Type.canMergeConstraints(leftType, rightType);\n        }\n        if ((leftType == undefined) !== (rightType == undefined))\n            return false;\n        if (leftType == rightType)\n            return true;\n        if (leftType.tag != rightType.tag) {\n            return false;\n        }\n        if (leftType.isSlot)\n            return true;\n        // TODO: we need a generic way to evaluate type compatibility\n        //       shapes + entities + etc\n        if (leftType.isInterface && rightType.isInterface) {\n            if (leftType.interfaceShape.equals(rightType.interfaceShape)) {\n                return true;\n            }\n        }\n        if (!leftType.isEntity || !rightType.isEntity) {\n            return false;\n        }\n        let leftIsSub = leftType.entitySchema.isMoreSpecificThan(rightType.entitySchema);\n        let leftIsSuper = rightType.entitySchema.isMoreSpecificThan(leftType.entitySchema);\n        if (leftIsSuper && leftIsSub) {\n            return true;\n        }\n        if (!leftIsSuper && !leftIsSub) {\n            return false;\n        }\n        let [superclass, subclass] = leftIsSuper ? [left, right] : [right, left];\n        // treat handle types as if they were 'inout' connections. Note that this\n        // guarantees that the handle's type will be preserved, and that the fact\n        // that the type comes from a handle rather than a connection will also\n        // be preserved.\n        let superDirection = superclass.direction || (superclass.connection ? superclass.connection.direction : 'inout');\n        let subDirection = subclass.direction || (subclass.connection ? subclass.connection.direction : 'inout');\n        if (superDirection == 'in') {\n            return true;\n        }\n        if (subDirection == 'out') {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/recipe/type-checker.js\n// module id = 5\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { DomParticle } from './dom-particle.js';\n// Regex to separate style and template.\nlet re = /<style>((?:.|[\\r\\n])*)<\\/style>((?:.|[\\r\\n])*)/;\n/** @class TransformationDomParticle\n * Particle that does transformation stuff with DOM.\n */\nexport class TransformationDomParticle extends DomParticle {\n    getTemplate(slotName) {\n        // TODO: add support for multiple slots.\n        return this._state.template;\n    }\n    getTemplateName(slotName) {\n        // TODO: add support for multiple slots.\n        return this._state.templateName;\n    }\n    render(props, state) {\n        return state.renderModel;\n    }\n    shouldRender(props, state) {\n        return Boolean((state.template || state.templateName) && state.renderModel);\n    }\n    renderHostedSlot(slotName, hostedSlotId, content) {\n        this.combineHostedTemplate(slotName, hostedSlotId, content);\n        this.combineHostedModel(slotName, hostedSlotId, content);\n    }\n    // abstract\n    combineHostedTemplate(slotName, hostedSlotId, content) { }\n    combineHostedModel(slotName, hostedSlotId, content) { }\n    // Helper methods that may be reused in transformation particles to combine hosted content.\n    static propsToItems(propsValues) {\n        return propsValues ? propsValues.map(({ rawData, id }) => Object.assign({}, rawData, { subId: id })) : [];\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/transformation-dom-particle.js\n// module id = 6\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { assert } from '../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { TransformationDomParticle } from './transformation-dom-particle.js';\nexport class MultiplexerDomParticle extends TransformationDomParticle {\n    constructor() {\n        super();\n        this._itemSubIdByHostedSlotId = new Map();\n        this._connByHostedConn = new Map();\n    }\n    _mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let otherMappedHandles = [];\n            let otherConnections = [];\n            let index = 2;\n            const skipConnectionNames = [listHandleName, particleHandleName];\n            for (let [connectionName, otherHandle] of handles) {\n                if (skipConnectionNames.includes(connectionName)) {\n                    continue;\n                }\n                // TODO(wkorman): For items with embedded recipes we may need a map\n                // (perhaps id to index) to make sure we don't map a handle into the inner\n                // arc multiple times unnecessarily.\n                otherMappedHandles.push(`map '${yield arc.mapHandle(otherHandle._proxy)}' as v${index}`);\n                let hostedOtherConnection = hostedParticle.connections.find(conn => conn.isCompatibleType(otherHandle.type));\n                if (hostedOtherConnection) {\n                    otherConnections.push(`${hostedOtherConnection.name} <- v${index++}`);\n                    // TODO(wkorman): For items with embedded recipes where we may have a\n                    // different particle rendering each item, we need to track\n                    // |connByHostedConn| keyed on the particle type.\n                    this._connByHostedConn.set(hostedOtherConnection.name, connectionName);\n                }\n            }\n            return [otherMappedHandles, otherConnections];\n        });\n    }\n    setHandles(handles) {\n        const _super = name => super[name];\n        return __awaiter(this, void 0, void 0, function* () {\n            this.handleIds = {};\n            let arc = yield this.constructInnerArc();\n            const listHandleName = 'list';\n            const particleHandleName = 'hostedParticle';\n            let particleHandle = handles.get(particleHandleName);\n            let hostedParticle = null;\n            let otherMappedHandles = [];\n            let otherConnections = [];\n            if (particleHandle) {\n                hostedParticle = yield particleHandle.get();\n                if (hostedParticle) {\n                    [otherMappedHandles, otherConnections] =\n                        yield this._mapParticleConnections(listHandleName, particleHandleName, hostedParticle, handles, arc);\n                }\n            }\n            this.setState({\n                arc,\n                type: handles.get(listHandleName).type,\n                hostedParticle,\n                otherMappedHandles,\n                otherConnections\n            });\n            _super(\"setHandles\").call(this, handles);\n        });\n    }\n    willReceiveProps({ list }, { arc, type, hostedParticle, otherMappedHandles, otherConnections }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (list.length > 0) {\n                this.relevance = 0.1;\n            }\n            for (let [index, item] of this.getListEntries(list)) {\n                let resolvedHostedParticle = hostedParticle;\n                if (this.handleIds[item.id]) {\n                    let itemHandle = yield this.handleIds[item.id];\n                    itemHandle.set(item);\n                    continue;\n                }\n                let itemHandlePromise = arc.createHandle(type.primitiveType(), 'item' + index);\n                this.handleIds[item.id] = itemHandlePromise;\n                let itemHandle = yield itemHandlePromise;\n                if (!resolvedHostedParticle) {\n                    // If we're muxing on behalf of an item with an embedded recipe, the\n                    // hosted particle should be retrievable from the item itself. Else we\n                    // just skip this item.\n                    if (!item.renderParticleSpec) {\n                        continue;\n                    }\n                    resolvedHostedParticle =\n                        ParticleSpec.fromLiteral(JSON.parse(item.renderParticleSpec));\n                    // Re-map compatible handles and compute the connections specific\n                    // to this item's render particle.\n                    const listHandleName = 'list';\n                    const particleHandleName = 'renderParticle';\n                    [otherMappedHandles, otherConnections] =\n                        yield this._mapParticleConnections(listHandleName, particleHandleName, resolvedHostedParticle, this.handles, arc);\n                }\n                let hostedSlotName = [...resolvedHostedParticle.slots.keys()][0];\n                let slotName = [...this.spec.slots.values()][0].name;\n                let slotId = yield arc.createSlot(this, slotName, resolvedHostedParticle.name, hostedSlotName, itemHandle._id);\n                if (!slotId) {\n                    continue;\n                }\n                this._itemSubIdByHostedSlotId.set(slotId, item.id);\n                try {\n                    const recipe = this.constructInnerRecipe(resolvedHostedParticle, item, itemHandle, { name: hostedSlotName, id: slotId }, { connections: otherConnections, handles: otherMappedHandles });\n                    yield arc.loadRecipe(recipe, this);\n                    itemHandle.set(item);\n                }\n                catch (e) {\n                    console.log(e);\n                }\n            }\n        });\n    }\n    combineHostedModel(slotName, hostedSlotId, content) {\n        let subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n        if (!subId) {\n            return;\n        }\n        let items = this._state.renderModel ? this._state.renderModel.items : [];\n        let listIndex = items.findIndex(item => item.subId == subId);\n        let item = Object.assign({}, content.model, { subId });\n        if (listIndex >= 0 && listIndex < items.length) {\n            items[listIndex] = item;\n        }\n        else {\n            items.push(item);\n        }\n        this._setState({ renderModel: { items } });\n    }\n    combineHostedTemplate(slotName, hostedSlotId, content) {\n        let subId = this._itemSubIdByHostedSlotId.get(hostedSlotId);\n        if (!subId) {\n            return;\n        }\n        assert(content.templateName, `Template name is missing for slot '${slotName}' (hosted slot ID: '${hostedSlotId}')`);\n        this._setState({ templateName: Object.assign(this._state.templateName || {}, { [subId]: `${content.templateName}` }) });\n        if (content.template) {\n            let template = content.template;\n            // Append subid={{subid}} attribute to all provided slots, to make it usable for the transformation particle.\n            template = template.replace(new RegExp('slotid=\"[a-z]+\"', 'gi'), '$& subid=\"{{subId}}\"');\n            // Replace hosted particle connection in template with the corresponding particle connection names.\n            // TODO: make this generic!\n            this._connByHostedConn.forEach((conn, hostedConn) => {\n                template = template.replace(new RegExp(`{{${hostedConn}.description}}`, 'g'), `{{${conn}.description}}`);\n            });\n            this._setState({ template: Object.assign(this._state.template || {}, { [content.templateName]: template }) });\n            this.forceRenderTemplate();\n        }\n    }\n    // Abstract methods below.\n    // Called to produce a full interpolated recipe for loading into an inner\n    // arc for each item. Subclasses should override this method as by default\n    // it does nothing and so no recipe will be returned and content will not\n    // be loaded successfully into the inner arc.\n    constructInnerRecipe(hostedParticle, item, itemHandle, slot, other) { }\n    // Called with the list of items and by default returns the direct result of\n    // `Array.entries()`. Subclasses can override this method to alter the item\n    // order or otherwise permute the items as desired before their slots are\n    // created and contents are rendered.\n    getListEntries(list) {\n        return list.entries();\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/multiplexer-dom-particle.js\n// module id = 7\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\nimport { Type } from './type.js';\nimport { Entity } from './entity.js';\nexport class Schema {\n    constructor(model) {\n        let legacy = [];\n        // TODO: remove this (remnants of normative/optional)\n        if (model.sections) {\n            legacy.push('sections');\n            assert(!model.fields);\n            model.fields = {};\n            for (let section of model.sections) {\n                Object.assign(model.fields, section.fields);\n            }\n            delete model.sections;\n        }\n        if (model.name) {\n            legacy.push('name');\n            model.names = [model.name];\n            delete model.name;\n        }\n        if (model.parents) {\n            legacy.push('parents');\n            for (let parent of model.parents) {\n                let parentSchema = new Schema(parent);\n                model.names.push(...parent.names);\n                Object.assign(model.fields, parent.fields);\n            }\n            model.names = [...new Set(model.names)];\n        }\n        if (legacy.length > 0) {\n            console.warn(`Schema ${model.names[0] || '*'} was serialized with legacy format (${legacy.join(', ')})`, new Error());\n        }\n        assert(model.fields);\n        this._model = model;\n        this.description = {};\n        if (model.description) {\n            model.description.description.forEach(desc => this.description[desc.name] = desc.pattern);\n        }\n    }\n    toLiteral() {\n        return this._model;\n    }\n    static fromLiteral(data) {\n        return new Schema(data);\n    }\n    get fields() {\n        return this._model.fields;\n    }\n    get names() {\n        return this._model.names;\n    }\n    // TODO: This should only be an ident used in manifest parsing.\n    get name() {\n        return this.names[0];\n    }\n    static typesEqual(fieldType1, fieldType2) {\n        // TODO: structural check instead of stringification.\n        return Schema._typeString(fieldType1) == Schema._typeString(fieldType2);\n    }\n    static _typeString(type) {\n        if (typeof (type) != 'object') {\n            assert(typeof type == 'string');\n            return type;\n        }\n        switch (type.kind) {\n            case 'schema-union':\n                return `(${type.types.join(' or ')})`;\n            case 'schema-tuple':\n                return `(${type.types.join(', ')})`;\n            default:\n                throw new Error(`Unknown type kind ${type.kind} in schema ${this.name}`);\n        }\n    }\n    static union(schema1, schema2) {\n        let names = [...new Set([...schema1.names, ...schema2.names])];\n        let fields = {};\n        for (let [field, type] of [...Object.entries(schema1.fields), ...Object.entries(schema2.fields)]) {\n            if (fields[field]) {\n                if (!Schema.typesEqual(fields[field], type)) {\n                    return null;\n                }\n            }\n            else {\n                fields[field] = type;\n            }\n        }\n        return new Schema({\n            names,\n            fields,\n        });\n    }\n    static intersect(schema1, schema2) {\n        let names = [...schema1.names].filter(name => schema2.names.includes(name));\n        let fields = {};\n        for (let [field, type] of Object.entries(schema1.fields)) {\n            let otherType = schema2.fields[field];\n            if (otherType && Schema.typesEqual(type, otherType)) {\n                fields[field] = type;\n            }\n        }\n        return new Schema({\n            names,\n            fields,\n        });\n    }\n    equals(otherSchema) {\n        return this === otherSchema || (this.name == otherSchema.name\n            // TODO: Check equality without calling contains.\n            && this.isMoreSpecificThan(otherSchema)\n            && otherSchema.isMoreSpecificThan(this));\n    }\n    isMoreSpecificThan(otherSchema) {\n        let names = new Set(this.names);\n        for (let name of otherSchema.names) {\n            if (!names.has(name)) {\n                return false;\n            }\n        }\n        let fields = {};\n        for (let [name, type] of Object.entries(this.fields)) {\n            fields[name] = type;\n        }\n        for (let [name, type] of Object.entries(otherSchema.fields)) {\n            if (fields[name] == undefined)\n                return false;\n            if (!Schema.typesEqual(fields[name], type)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    get type() {\n        return Type.newEntity(this);\n    }\n    entityClass() {\n        let schema = this;\n        let className = this.name;\n        let classJunk = ['toJSON', 'prototype', 'toString', 'inspect'];\n        let convertToJsType = fieldType => {\n            switch (fieldType) {\n                case 'Text':\n                    return 'string';\n                case 'URL':\n                    return 'string';\n                case 'Number':\n                    return 'number';\n                case 'Boolean':\n                    return 'boolean';\n                case 'Object':\n                    return 'object';\n                default:\n                    throw new Error(`Unknown field type ${fieldType} in schema ${className}`);\n            }\n        };\n        const fieldTypes = this.fields;\n        let validateFieldAndTypes = (op, name, value) => {\n            let fieldType = fieldTypes[name];\n            if (fieldType === undefined) {\n                throw new Error(`Can't ${op} field ${name}; not in schema ${className}`);\n            }\n            if (value === undefined || value === null) {\n                return;\n            }\n            if (typeof (fieldType) !== 'object') {\n                // Primitive fields.\n                if (typeof (value) !== convertToJsType(fieldType)) {\n                    throw new TypeError(`Type mismatch ${op}ting field ${name} (type ${fieldType}); ` +\n                        `value '${value}' is type ${typeof (value)}`);\n                }\n                return;\n            }\n            switch (fieldType.kind) {\n                case 'schema-union':\n                    // Value must be a primitive that matches one of the union types.\n                    for (let innerType of fieldType.types) {\n                        if (typeof (value) === convertToJsType(innerType)) {\n                            return;\n                        }\n                    }\n                    throw new TypeError(`Type mismatch ${op}ting field ${name} (union [${fieldType.types}]); ` +\n                        `value '${value}' is type ${typeof (value)}`);\n                case 'schema-tuple':\n                    // Value must be an array whose contents match each of the tuple types.\n                    if (!Array.isArray(value)) {\n                        throw new TypeError(`Cannot ${op} tuple ${name} with non-array value '${value}'`);\n                    }\n                    if (value.length != fieldType.types.length) {\n                        throw new TypeError(`Length mismatch ${op}ting tuple ${name} ` +\n                            `[${fieldType.types}] with value '${value}'`);\n                    }\n                    fieldType.types.map((innerType, i) => {\n                        if (value[i] !== undefined && value[i] !== null &&\n                            typeof (value[i]) !== convertToJsType(innerType)) {\n                            throw new TypeError(`Type mismatch ${op}ting field ${name} (tuple [${fieldType.types}]); ` +\n                                `value '${value}' has type ${typeof (value[i])} at index ${i}`);\n                        }\n                    });\n                    break;\n                default:\n                    throw new Error(`Unknown kind ${fieldType.kind} in schema ${className}`);\n            }\n        };\n        let clazz = class extends Entity {\n            constructor(data, userIDComponent) {\n                super(userIDComponent);\n                this.rawData = new Proxy({}, {\n                    get: (target, name) => {\n                        if (classJunk.includes(name) || name.constructor == Symbol) {\n                            return undefined;\n                        }\n                        let value = target[name];\n                        validateFieldAndTypes('get', name, value);\n                        return value;\n                    },\n                    set: (target, name, value) => {\n                        validateFieldAndTypes('set', name, value);\n                        target[name] = value;\n                        return true;\n                    }\n                });\n                assert(data, `can't construct entity with null data`);\n                for (let [name, value] of Object.entries(data)) {\n                    this.rawData[name] = value;\n                }\n            }\n            dataClone() {\n                let clone = {};\n                for (let name of Object.keys(schema.fields)) {\n                    if (this.rawData[name] !== undefined)\n                        clone[name] = this.rawData[name];\n                }\n                return clone;\n            }\n            static get key() {\n                return {\n                    tag: 'entity',\n                    schema: schema.toLiteral(),\n                };\n            }\n        };\n        Object.defineProperty(clazz, 'type', { value: this.type });\n        Object.defineProperty(clazz, 'name', { value: this.name });\n        // TODO: add query / getter functions for user properties\n        for (let name of Object.keys(this.fields)) {\n            Object.defineProperty(clazz.prototype, name, {\n                get: function () {\n                    return this.rawData[name];\n                },\n                set: function (v) {\n                    this.rawData[name] = v;\n                }\n            });\n        }\n        return clazz;\n    }\n    toInlineSchemaString(options) {\n        let names = (this.names || ['*']).join(' ');\n        let fields = Object.entries(this.fields).map(([name, type]) => `${Schema._typeString(type)} ${name}`).join(', ');\n        return `${names} {${fields.length > 0 && options && options.hideFields ? '...' : fields}}`;\n    }\n    toManifestString() {\n        let results = [];\n        results.push(`schema ${this.names.join(' ')}`);\n        results.push(...Object.entries(this.fields).map(([name, type]) => `  ${Schema._typeString(type)} ${name}`));\n        if (Object.keys(this.description).length > 0) {\n            results.push(`  description \\`${this.description.pattern}\\``);\n            for (let name of Object.keys(this.description)) {\n                if (name != 'pattern') {\n                    results.push(`    ${name} \\`${this.description[name]}\\``);\n                }\n            }\n        }\n        return results.join('\\n');\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/schema.js\n// module id = 8\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../platform/assert-web.js';\n// ShapeHandle {name, direction, type}\n// Slot {name, direction, isRequired, isSet}\nfunction _fromLiteral(member) {\n    if (!!member && typeof member == 'object')\n        return Type.fromLiteral(member);\n    return member;\n}\nfunction _toLiteral(member) {\n    if (!!member && member.toLiteral)\n        return member.toLiteral();\n    return member;\n}\nconst handleFields = ['type', 'name', 'direction'];\nconst slotFields = ['name', 'direction', 'isRequired', 'isSet'];\nexport class Shape {\n    constructor(name, handles, slots) {\n        assert(name);\n        assert(handles !== undefined);\n        assert(slots !== undefined);\n        this.name = name;\n        this.handles = handles;\n        this.slots = slots;\n        this._typeVars = [];\n        for (let handle of handles)\n            for (let field of handleFields)\n                if (Shape.isTypeVar(handle[field]))\n                    this._typeVars.push({ object: handle, field });\n        for (let slot of slots)\n            for (let field of slotFields)\n                if (Shape.isTypeVar(slot[field]))\n                    this._typeVars.push({ object: slot, field });\n    }\n    toPrettyString() {\n        return 'SHAAAAPE';\n    }\n    get canReadSubset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canReadSubset);\n    }\n    get canWriteSuperset() {\n        return this._cloneAndUpdate(typeVar => typeVar.canWriteSuperset);\n    }\n    isMoreSpecificThan(other) {\n        if (this.handles.length !== other.handles.length || this.slots.length !== other.slots.length)\n            return false;\n        // TODO: should probably confirm that handles and slots actually match.\n        for (let i = 0; i < this._typeVars.length; i++) {\n            let thisTypeVar = this._typeVars[i];\n            let otherTypeVar = other._typeVars[i];\n            if (!thistypeVar.object[thistypeVar.field].isMoreSpecificThan(othertypeVar.object[othertypeVar.field]))\n                return false;\n        }\n        return true;\n    }\n    _applyExistenceTypeTest(test) {\n        for (let typeRef of this._typeVars) {\n            if (test(typeRef.object[typeRef.field]))\n                return true;\n        }\n        return false;\n    }\n    _handlesToManifestString() {\n        return this.handles\n            .map(handle => {\n            let type = handle.type.resolvedType();\n            return `  ${handle.direction ? handle.direction + ' ' : ''}${type.toString()} ${handle.name ? handle.name : '*'}`;\n        }).join('\\n');\n    }\n    _slotsToManifestString() {\n        // TODO deal with isRequired\n        return this.slots\n            .map(slot => `  ${slot.direction} ${slot.isSet ? 'set of ' : ''}${slot.name ? slot.name + ' ' : ''}`)\n            .join('\\n');\n    }\n    // TODO: Include name as a property of the shape and normalize this to just\n    // toString().\n    toString() {\n        return `shape ${this.name}\n${this._handlesToManifestString()}\n${this._slotsToManifestString()}\n`;\n    }\n    static fromLiteral(data) {\n        let handles = data.handles.map(handle => ({ type: _fromLiteral(handle.type), name: _fromLiteral(handle.name), direction: _fromLiteral(handle.direction) }));\n        let slots = data.slots.map(slot => ({ name: _fromLiteral(slot.name), direction: _fromLiteral(slot.direction), isRequired: _fromLiteral(slot.isRequired), isSet: _fromLiteral(slot.isSet) }));\n        return new Shape(data.name, handles, slots);\n    }\n    toLiteral() {\n        let handles = this.handles.map(handle => ({ type: _toLiteral(handle.type), name: _toLiteral(handle.name), direction: _toLiteral(handle.direction) }));\n        let slots = this.slots.map(slot => ({ name: _toLiteral(slot.name), direction: _toLiteral(slot.direction), isRequired: _toLiteral(slot.isRequired), isSet: _toLiteral(slot.isSet) }));\n        return { name: this.name, handles, slots };\n    }\n    clone(variableMap) {\n        let handles = this.handles.map(({ name, direction, type }) => ({ name, direction, type: type ? type.clone(variableMap) : undefined }));\n        let slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new Shape(this.name, handles, slots);\n    }\n    cloneWithResolutions(variableMap) {\n        return this._cloneWithResolutions(variableMap);\n    }\n    _cloneWithResolutions(variableMap) {\n        let handles = this.handles.map(({ name, direction, type }) => ({ name, direction, type: type ? type._cloneWithResolutions(variableMap) : undefined }));\n        let slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new Shape(this.name, handles, slots);\n    }\n    canEnsureResolved() {\n        for (let typeVar of this._typeVars)\n            if (!typeVar.object[typeVar.field].canEnsureResolved())\n                return false;\n        return true;\n    }\n    maybeEnsureResolved() {\n        for (let typeVar of this._typeVars) {\n            let variable = typeVar.object[typeVar.field];\n            variable = variable.clone(new Map());\n            if (!variable.maybeEnsureResolved())\n                return false;\n        }\n        for (let typeVar of this._typeVars)\n            typeVar.object[typeVar.field].maybeEnsureResolved();\n        return true;\n    }\n    tryMergeTypeVariablesWith(other) {\n        // Type variable enabled slot matching will Just Work when we\n        // unify slots and handles.\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot))\n            return null;\n        if (other.handles.length !== this.handles.length)\n            return null;\n        let handles = new Set(this.handles);\n        let otherHandles = new Set(other.handles);\n        let handleMap = new Map();\n        let sizeCheck = handles.size;\n        while (handles.size > 0) {\n            let handleMatches = [...handles.values()].map(handle => ({ handle, match: [...otherHandles.values()].filter(otherHandle => this._equalHandle(handle, otherHandle)) }));\n            for (let handleMatch of handleMatches) {\n                // no match!\n                if (handleMatch.match.length == 0)\n                    return null;\n                if (handleMatch.match.length == 1) {\n                    handleMap.set(handleMatch.handle, handleMatch.match[0]);\n                    otherHandles.delete(handleMatch.match[0]);\n                    handles.delete(handleMatch.handle);\n                }\n            }\n            // no progress!\n            if (handles.size == sizeCheck)\n                return null;\n            sizeCheck = handles.size;\n        }\n        handles = [];\n        for (let handle of this.handles) {\n            let otherHandle = handleMap.get(handle);\n            let resultType;\n            if (handle.type.hasVariable || otherHandle.type.hasVariable) {\n                resultType = TypeChecker._tryMergeTypeVariable(handle.type, otherHandle.type);\n                if (!resultType)\n                    return null;\n            }\n            else {\n                resultType = handle.type || otherHandle.type;\n            }\n            handles.push({ name: handle.name || otherHandle.name, direction: handle.direction || otherHandle.direction, type: resultType });\n        }\n        let slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));\n        return new Shape(this.name, handles, slots);\n    }\n    resolvedType() {\n        return this._cloneAndUpdate(typeVar => typeVar.resolvedType());\n    }\n    equals(other) {\n        if (this.handles.length !== other.handles.length)\n            return false;\n        // TODO: this isn't quite right as it doesn't deal with duplicates properly\n        if (!this._equalItems(other.handles, this.handles, this._equalHandle)) {\n            return false;\n        }\n        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n            return false;\n        }\n        return true;\n    }\n    _equalHandle(handle, otherHandle) {\n        return handle.name == otherHandle.name && handle.direction == otherHandle.direction && handle.type.equals(otherHandle.type);\n    }\n    _equalSlot(slot, otherSlot) {\n        return slot.name == otherSlot.name && slot.direction == otherSlot.direction && slot.isRequired == otherSlot.isRequired && slot.isSet == otherSlot.isSet;\n    }\n    _equalItems(otherItems, items, compareItem) {\n        for (let otherItem of otherItems) {\n            let exists = false;\n            for (let item of items) {\n                if (compareItem(item, otherItem)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists)\n                return false;\n        }\n        return true;\n    }\n    _cloneAndUpdate(update) {\n        let copy = this.clone(new Map());\n        copy._typeVars.forEach(typeVar => Shape._updateTypeVar(typeVar, update));\n        return copy;\n    }\n    static _updateTypeVar(typeVar, update) {\n        typeVar.object[typeVar.field] = update(typeVar.object[typeVar.field]);\n    }\n    static isTypeVar(reference) {\n        return (reference instanceof Type) && reference.hasProperty(r => r.isVariable);\n    }\n    static mustMatch(reference) {\n        return !(reference == undefined || Shape.isTypeVar(reference));\n    }\n    static handlesMatch(shapeHandle, particleHandle) {\n        if (Shape.mustMatch(shapeHandle.name) && shapeHandle.name !== particleHandle.name)\n            return false;\n        // TODO: direction subsetting?\n        if (Shape.mustMatch(shapeHandle.direction) && shapeHandle.direction !== particleHandle.direction)\n            return false;\n        if (shapeHandle.type == undefined)\n            return true;\n        if (shapeHandle.type.isVariableReference)\n            return false;\n        let [left, right] = Type.unwrapPair(shapeHandle.type, particleHandle.type);\n        if (left.isVariable) {\n            return [{ var: left, value: right, direction: shapeHandle.direction }];\n        }\n        else {\n            return left.equals(right);\n        }\n    }\n    static slotsMatch(shapeSlot, particleSlot) {\n        if (Shape.mustMatch(shapeSlot.name) && shapeSlot.name !== particleSlot.name)\n            return false;\n        if (Shape.mustMatch(shapeSlot.direction) && shapeSlot.direction !== particleSlot.direction)\n            return false;\n        if (Shape.mustMatch(shapeSlot.isRequired) && shapeSlot.isRequired !== particleSlot.isRequired)\n            return false;\n        if (Shape.mustMatch(shapeSlot.isSet) && shapeSlot.isSet !== particleSlot.isSet)\n            return false;\n        return true;\n    }\n    particleMatches(particleSpec) {\n        let shape = this.cloneWithResolutions(new Map());\n        return shape.restrictType(particleSpec) !== false;\n    }\n    restrictType(particleSpec) {\n        return this._restrictThis(particleSpec);\n    }\n    _restrictThis(particleSpec) {\n        let handleMatches = this.handles.map(handle => particleSpec.connections.map(connection => ({ match: connection, result: Shape.handlesMatch(handle, connection) }))\n            .filter(a => a.result !== false));\n        let particleSlots = [];\n        particleSpec.slots.forEach(consumedSlot => {\n            particleSlots.push({ name: consumedSlot.name, direction: 'consume', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet });\n            consumedSlot.providedSlots.forEach(providedSlot => {\n                particleSlots.push({ name: providedSlot.name, direction: 'provide', isRequired: false, isSet: providedSlot.isSet });\n            });\n        });\n        let slotMatches = this.slots.map(slot => particleSlots.filter(particleSlot => Shape.slotsMatch(slot, particleSlot)));\n        slotMatches = slotMatches.map(matchList => matchList.map(slot => ({ match: slot, result: true })));\n        let exclusions = [];\n        // TODO: this probably doesn't deal with multiple match options.\n        function choose(list, exclusions) {\n            if (list.length == 0)\n                return [];\n            let thisLevel = list.pop();\n            for (let connection of thisLevel) {\n                if (exclusions.includes(connection.match))\n                    continue;\n                let newExclusions = exclusions.slice();\n                newExclusions.push(connection.match);\n                let constraints = choose(list, newExclusions);\n                if (constraints !== false) {\n                    return connection.result.length ? constraints.concat(connection.result) : constraints;\n                }\n            }\n            return false;\n        }\n        let handleOptions = choose(handleMatches, []);\n        let slotOptions = choose(slotMatches, []);\n        if (handleOptions === false || slotOptions === false)\n            return false;\n        for (let constraint of handleOptions) {\n            if (!constraint.var.variable.resolution) {\n                constraint.var.variable.resolution = constraint.value;\n            }\n            else if (constraint.var.variable.resolution.isVariable) {\n                // TODO(shans): revisit how this should be done,\n                // consider reusing tryMergeTypeVariablesWith(other).\n                if (!TypeChecker.processTypeList(constraint.var, [{\n                        type: constraint.value, direction: constraint.direction\n                    }]))\n                    return false;\n            }\n            else {\n                if (!constraint.var.variable.resolution.equals(constraint.value))\n                    return false;\n            }\n        }\n        return this;\n    }\n}\nimport { Type } from './type.js';\nimport { TypeChecker } from './recipe/type-checker.js';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/shape.js\n// module id = 9\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\nexport const Symbols = { identifier: Symbol('id') };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/symbols.js\n// module id = 10\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\nimport { Type } from './type.js';\nimport { assert } from '../platform/assert-web.js';\nimport { Schema } from './schema.js';\nexport class TypeVariable {\n    constructor(name, canWriteSuperset, canReadSubset) {\n        assert(typeof name == 'string');\n        assert(canWriteSuperset == null || canWriteSuperset instanceof Type);\n        assert(canReadSubset == null || canReadSubset instanceof Type);\n        this.name = name;\n        this._canWriteSuperset = canWriteSuperset;\n        this._canReadSubset = canReadSubset;\n        this._resolution = null;\n    }\n    // Merge both the read subset (upper bound) and write superset (lower bound) constraints\n    // of two variables together. Use this when two separate type variables need to resolve\n    // to the same value.\n    maybeMergeConstraints(variable) {\n        assert(variable instanceof TypeVariable);\n        if (!this.maybeMergeCanReadSubset(variable.canReadSubset))\n            return false;\n        return this.maybeMergeCanWriteSuperset(variable.canWriteSuperset);\n    }\n    // merge a type variable's read subset (upper bound) constraints into this variable.\n    // This is used to accumulate read constraints when resolving a handle's type.\n    maybeMergeCanReadSubset(constraint) {\n        if (constraint == null)\n            return true;\n        if (this.canReadSubset == null) {\n            this.canReadSubset = constraint;\n            return true;\n        }\n        if (this.canReadSubset.isSlot && constraint.isSlot) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        let mergedSchema = Schema.intersect(this.canReadSubset.entitySchema, constraint.entitySchema);\n        if (!mergedSchema)\n            return false;\n        this.canReadSubset = Type.newEntity(mergedSchema);\n        return true;\n    }\n    // merge a type variable's write superset (lower bound) constraints into this variable.\n    // This is used to accumulate write constraints when resolving a handle's type.\n    maybeMergeCanWriteSuperset(constraint) {\n        if (constraint == null)\n            return true;\n        if (this.canWriteSuperset == null) {\n            this.canWriteSuperset = constraint;\n            return true;\n        }\n        if (this.canWriteSuperset.isSlot && constraint.isSlot) {\n            // TODO: formFactor compatibility, etc.\n            return true;\n        }\n        let mergedSchema = Schema.union(this.canWriteSuperset.entitySchema, constraint.entitySchema);\n        if (!mergedSchema)\n            return false;\n        this.canWriteSuperset = Type.newEntity(mergedSchema);\n        return true;\n    }\n    isSatisfiedBy(type) {\n        let constraint = this._canWriteSuperset;\n        if (!constraint) {\n            return true;\n        }\n        if (!constraint.isEntity || !type.isEntity) {\n            throw new Error(`constraint checking not implemented for ${this} and ${type}`);\n        }\n        return type.entitySchema.isMoreSpecificThan(constraint.entitySchema);\n    }\n    get resolution() {\n        if (this._resolution) {\n            return this._resolution.resolvedType();\n        }\n        return null;\n    }\n    set resolution(value) {\n        assert(value instanceof Type);\n        assert(!this._resolution);\n        let resolvedValue = value.resolvedType();\n        if (resolvedValue.isCollection && resolvedValue.collectionType.isVariable) {\n            assert(resolvedValue.collectionType.variable != this, 'variable cannot resolve to collection of itself');\n        }\n        let probe = value;\n        while (probe) {\n            if (!probe.isVariable)\n                break;\n            if (probe.variable == this)\n                return;\n            probe = probe.variable.resolution;\n        }\n        this._resolution = value;\n        this._canWriteSuperset = null;\n        this._canReadSubset = null;\n    }\n    get canWriteSuperset() {\n        if (this._resolution) {\n            assert(!this._canWriteSuperset);\n            if (this._resolution.isVariable) {\n                return this._resolution.variable.canWriteSuperset;\n            }\n            return null;\n        }\n        return this._canWriteSuperset;\n    }\n    set canWriteSuperset(value) {\n        assert(!this._resolution);\n        this._canWriteSuperset = value;\n    }\n    get canReadSubset() {\n        if (this._resolution) {\n            assert(!this._canReadSubset);\n            if (this._resolution.isVariable) {\n                return this._resolution.variable.canReadSubset;\n            }\n            return null;\n        }\n        return this._canReadSubset;\n    }\n    set canReadSubset(value) {\n        assert(!this._resolution);\n        this._canReadSubset = value;\n    }\n    get hasConstraint() {\n        return this._canReadSubset !== null || this._canWriteSuperset !== null;\n    }\n    canEnsureResolved() {\n        if (this._resolution)\n            return this._resolution.canEnsureResolved();\n        if (this._canWriteSuperset || this._canReadSubset)\n            return true;\n        return false;\n    }\n    maybeEnsureResolved() {\n        if (this._resolution)\n            return this._resolution.maybeEnsureResolved();\n        if (this._canWriteSuperset) {\n            this.resolution = this._canWriteSuperset;\n            return true;\n        }\n        if (this._canReadSubset) {\n            this.resolution = this._canReadSubset;\n            return true;\n        }\n        return false;\n    }\n    toLiteral() {\n        assert(this.resolution == null);\n        return this.toLiteralIgnoringResolutions();\n    }\n    toLiteralIgnoringResolutions() {\n        return {\n            name: this.name,\n            canWriteSuperset: this._canWriteSuperset && this._canWriteSuperset.toLiteral(),\n            canReadSubset: this._canReadSubset && this._canReadSubset.toLiteral()\n        };\n    }\n    static fromLiteral(data) {\n        return new TypeVariable(data.name, data.canWriteSuperset ? Type.fromLiteral(data.canWriteSuperset) : null, data.canReadSubset ? Type.fromLiteral(data.canReadSubset) : null);\n    }\n    isResolved() {\n        return (this._resolution && this._resolution.isResolved());\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/type-variable.js\n// module id = 11\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 12\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { handleFor } from './handle.js';\nimport { assert } from '../platform/assert-web.js';\nimport { PECInnerPort } from './api-channel.js';\nimport { StorageProxy, StorageProxyScheduler } from './storage-proxy.js';\nexport class ParticleExecutionContext {\n    constructor(port, idBase, loader) {\n        this._apiPort = new PECInnerPort(port);\n        this._particles = [];\n        this._idBase = idBase;\n        this._nextLocalID = 0;\n        this._loader = loader;\n        this._pendingLoads = [];\n        this._scheduler = new StorageProxyScheduler();\n        /*\n         * This code ensures that the relevant types are known\n         * in the scope object, because otherwise we can't do\n         * particleSpec resolution, which is currently a necessary\n         * part of particle construction.\n         *\n         * Possibly we should eventually consider having particle\n         * specifications separated from particle classes - and\n         * only keeping type information on the arc side.\n         */\n        this._apiPort.onDefineHandle = ({ type, identifier, name }) => {\n            return new StorageProxy(identifier, type, this._apiPort, this, this._scheduler, name);\n        };\n        this._apiPort.onCreateHandleCallback = ({ type, id, name, callback }) => {\n            let proxy = new StorageProxy(id, type, this._apiPort, this, this._scheduler, name);\n            return [proxy, () => callback(proxy)];\n        };\n        this._apiPort.onMapHandleCallback = ({ id, callback }) => {\n            return [id, () => callback(id)];\n        };\n        this._apiPort.onCreateSlotCallback = ({ hostedSlotId, callback }) => {\n            return [hostedSlotId, () => callback(hostedSlotId)];\n        };\n        this._apiPort.onInnerArcRender = ({ transformationParticle, transformationSlotName, hostedSlotId, content }) => {\n            transformationParticle.renderHostedSlot(transformationSlotName, hostedSlotId, content);\n        };\n        this._apiPort.onStop = () => {\n            if (global.close) {\n                global.close();\n            }\n        };\n        this._apiPort.onInstantiateParticle =\n            ({ id, spec, handles }) => this._instantiateParticle(id, spec, handles);\n        this._apiPort.onSimpleCallback = ({ callback, data }) => callback(data);\n        this._apiPort.onConstructArcCallback = ({ callback, arc }) => callback(arc);\n        this._apiPort.onAwaitIdle = ({ version }) => this.idle.then(a => {\n            // TODO: dom-particles update is async, this is a workaround to allow dom-particles to\n            // update relevance, after handles are updated. Needs better idle signal.\n            setTimeout(() => { this._apiPort.Idle({ version, relevance: this.relevance }); }, 0);\n        });\n        this._apiPort.onUIEvent = ({ particle, slotName, event }) => particle.fireEvent(slotName, event);\n        this._apiPort.onStartRender = ({ particle, slotName, contentTypes }) => {\n            /** @class Slot\n             * A representation of a consumed slot. Retrieved from a particle using\n             * particle.getSlot(name)\n             */\n            class Slotlet {\n                constructor(pec, particle, slotName) {\n                    this._slotName = slotName;\n                    this._particle = particle;\n                    this._handlers = new Map();\n                    this._pec = pec;\n                    this._requestedContentTypes = new Set();\n                }\n                get particle() { return this._particle; }\n                get slotName() { return this._slotName; }\n                get isRendered() { return this._isRendered; }\n                /** @method render(content)\n                 * renders content to the slot.\n                 */\n                render(content) {\n                    this._pec._apiPort.Render({ particle, slotName, content });\n                    Object.keys(content).forEach(key => { this._requestedContentTypes.delete(key); });\n                    // Slot is considered rendered, if a non-empty content was sent and all requested content types were fullfilled.\n                    this._isRendered = this._requestedContentTypes.size == 0 && (Object.keys(content).length > 0);\n                }\n                /** @method registerEventHandler(name, f)\n                 * registers a callback to be invoked when 'name' event happens.\n                 */\n                registerEventHandler(name, f) {\n                    if (!this._handlers.has(name)) {\n                        this._handlers.set(name, []);\n                    }\n                    this._handlers.get(name).push(f);\n                }\n                clearEventHandlers(name) {\n                    this._handlers.set(name, []);\n                }\n                fireEvent(event) {\n                    for (let handler of this._handlers.get(event.handler) || []) {\n                        handler(event);\n                    }\n                }\n            }\n            particle._slotByName.set(slotName, new Slotlet(this, particle, slotName));\n            particle.renderSlot(slotName, contentTypes);\n        };\n        this._apiPort.onStopRender = ({ particle, slotName }) => {\n            assert(particle._slotByName.has(slotName), `Stop render called for particle ${particle.name} slot ${slotName} without start render being called.`);\n            particle._slotByName.delete(slotName);\n        };\n    }\n    generateIDComponents() {\n        return { base: this._idBase, component: () => this._nextLocalID++ };\n    }\n    generateID() {\n        return `${this._idBase}:${this._nextLocalID++}`;\n    }\n    innerArcHandle(arcId, particleId) {\n        let pec = this;\n        return {\n            createHandle: function (type, name, hostParticle) {\n                return new Promise((resolve, reject) => pec._apiPort.ArcCreateHandle({ arc: arcId, type, name, callback: proxy => {\n                        let handle = handleFor(proxy, proxy.type.isCollection, name, particleId);\n                        handle.entityClass = (proxy.type.isCollection ? proxy.type.primitiveType() : proxy.type).entitySchema.entityClass();\n                        resolve(handle);\n                        if (hostParticle) {\n                            proxy.register(hostParticle, handle);\n                        }\n                    } }));\n            },\n            mapHandle: function (handle) {\n                return new Promise((resolve, reject) => pec._apiPort.ArcMapHandle({ arc: arcId, handle, callback: id => {\n                        resolve(id);\n                    } }));\n            },\n            createSlot: function (transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName, handleId) {\n                // handleId: the ID of a handle (returned by `createHandle` above) this slot is rendering; null - if not applicable.\n                // TODO: support multiple handle IDs.\n                return new Promise((resolve, reject) => pec._apiPort.ArcCreateSlot({ arc: arcId, transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName, handleId, callback: hostedSlotId => {\n                        resolve(hostedSlotId);\n                    } }));\n            },\n            loadRecipe: function (recipe) {\n                // TODO: do we want to return a promise on completion?\n                return new Promise((resolve, reject) => pec._apiPort.ArcLoadRecipe({ arc: arcId, recipe, callback: a => {\n                        if (a == undefined)\n                            resolve();\n                        else\n                            reject(a);\n                    } }));\n            }\n        };\n    }\n    defaultCapabilitySet() {\n        return {\n            constructInnerArc: particle => {\n                return new Promise((resolve, reject) => this._apiPort.ConstructInnerArc({ callback: arcId => { resolve(this.innerArcHandle(arcId, particle.id)); }, particle }));\n            }\n        };\n    }\n    _instantiateParticle(id, spec, proxies) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let name = spec.name;\n            let resolve = null;\n            let p = new Promise((res, rej) => resolve = res);\n            this._pendingLoads.push(p);\n            let clazz = yield this._loader.loadParticleClass(spec);\n            let capabilities = this.defaultCapabilitySet();\n            let particle = new clazz(); // TODO: how can i add an argument to DomParticle ctor?\n            particle.id = id;\n            particle.capabilities = capabilities;\n            this._particles.push(particle);\n            let handleMap = new Map();\n            let registerList = [];\n            proxies.forEach((proxy, name) => {\n                let connSpec = spec.connectionMap.get(name);\n                let handle = handleFor(proxy, proxy.type.isCollection, name, id, connSpec.isInput, connSpec.isOutput);\n                let type = proxy.type.isCollection ? proxy.type.primitiveType() : proxy.type;\n                if (type.isEntity) {\n                    handle.entityClass = type.entitySchema.entityClass();\n                }\n                handleMap.set(name, handle);\n                // Defer registration of handles with proxies until after particles have a chance to\n                // configure them in setHandles.\n                registerList.push({ proxy, particle, handle });\n            });\n            return [particle, () => __awaiter(this, void 0, void 0, function* () {\n                    resolve();\n                    let idx = this._pendingLoads.indexOf(p);\n                    this._pendingLoads.splice(idx, 1);\n                    yield particle.setHandles(handleMap);\n                    registerList.forEach(({ proxy, particle, handle }) => proxy.register(particle, handle));\n                })];\n        });\n    }\n    get relevance() {\n        let rMap = new Map();\n        this._particles.forEach(p => {\n            if (p.relevances.length == 0)\n                return;\n            rMap.set(p, p.relevances);\n            p.relevances = [];\n        });\n        return rMap;\n    }\n    get busy() {\n        if (this._pendingLoads.length > 0 || this._scheduler.busy)\n            return true;\n        return false;\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        return Promise.all([this._scheduler.idle, ...this._pendingLoads]).then(() => this.idle);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/particle-execution-context.js\n// module id = 13\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {Loader} from '../../intermediate/runtime/loader.js';\nimport {Particle} from '../../intermediate/runtime/particle.js';\nimport {DomParticle} from '../../intermediate/runtime/dom-particle.js';\nimport {MultiplexerDomParticle} from '../../intermediate/runtime/multiplexer-dom-particle.js';\nimport {TransformationDomParticle} from '../../intermediate/runtime/transformation-dom-particle.js';\n\nconst logFactory = (preamble, color, log='log') => console[log].bind(console, `%c${preamble} [Particle]`, `background: ${color}; color: white; padding: 1px 6px 2px 7px; border-radius: 4px;`);\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\n\nconst dumbCache = {};\n\nexport class BrowserLoader extends Loader {\n  constructor(urlMap) {\n    super();\n    this._urlMap = urlMap;\n  }\n  _loadURL(url) {\n    // use URL to normalize the path for deduping\n    const cacheKey = new URL(url, document.URL).href;\n    const resource = dumbCache[cacheKey];\n    return resource || (dumbCache[cacheKey] = super._loadURL(url));\n  }\n  _resolve(path) {\n    //return new URL(path, this._base).href;\n    let url = this._urlMap[path];\n    if (!url && path) {\n      // TODO(sjmiles): inefficient!\n      let macro = Object.keys(this._urlMap).sort((a, b) => b.length - a.length).find(k => path.slice(0, k.length) == k);\n      if (macro) {\n        url = this._urlMap[macro] + path.slice(macro.length);\n      }\n    }\n    url = url || path;\n    //console.log(`browser-loader: resolve(${path}) = ${url}`);\n    return url;\n  }\n  loadResource(name) {\n    return this._loadURL(this._resolve(name));\n  }\n  requireParticle(fileName) {\n    const path = this._resolve(fileName);\n    // inject path to this particle into the UrlMap,\n    // allows \"foo.js\" particle to invoke `importScripts(resolver('foo/othermodule.js'))`\n    this.mapParticleUrl(path);\n    const result = [];\n    self.defineParticle = function(particleWrapper) {\n      result.push(particleWrapper);\n    };\n    importScripts(path);\n    delete self.defineParticle;\n    const logger = logFactory(fileName.split('/').pop(), '#1faa00');\n    return this.unwrapParticle(result[0], logger);\n  }\n  mapParticleUrl(path) {\n    let parts = path.split('/');\n    let suffix = parts.pop();\n    let folder = parts.join('/');\n    let name = suffix.split('.').shift();\n    this._urlMap[name] = folder;\n  }\n  unwrapParticle(particleWrapper, log) {\n    // TODO(sjmiles): regarding `resolver`:\n    //  _resolve method allows particles to request remapping of assets paths\n    //  for use in DOM\n    let resolver = this._resolve.bind(this);\n    return particleWrapper({\n      Particle,\n      DomParticle,\n      MultiplexerDomParticle,\n      SimpleParticle: DomParticle,\n      TransformationDomParticle,\n      resolver,\n      log,\n      html\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shell/source/browser-loader.js\n// module id = 14\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// Debugging is initialized either by /devtools/src/run-mark-connected.js, which is\n// injected by the devtools extension content script in the browser env,\n// or used directly when debugging nodeJS.\n// Data needs to be referenced via a global object, otherwise extension and\n// Arcs have different instances.\nlet root = typeof window === 'object' ? window : global;\nif (!root._arcDebugPromise) {\n    root._arcDebugPromise = new Promise(resolve => {\n        root._arcDebugPromiseResolve = resolve;\n    });\n}\nexport class DevtoolsBroker {\n    static get onceConnected() {\n        return root._arcDebugPromise;\n    }\n    static markConnected() {\n        root._arcDebugPromiseResolve();\n        return { preExistingArcs: !!root.arc };\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/devtools/shared/devtools-broker.js\n// module id = 15\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { AbstractDevtoolsChannel } from '../runtime/debug/abstract-devtools-channel.js';\nexport class DevtoolsChannel extends AbstractDevtoolsChannel {\n    constructor() {\n        super();\n        document.addEventListener('arcs-debug-in', e => this._handleMessage(e.detail));\n    }\n    _flush(messages) {\n        document.dispatchEvent(new CustomEvent('arcs-debug-out', { detail: messages }));\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/platform/devtools-channel-web.js\n// module id = 16\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nexport const fs = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/platform/fs-web.js\n// module id = 17\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nexport const vm = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/platform/vm-web.js\n// module id = 18\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { assert } from '../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\nimport { Type } from './type.js';\nimport { OuterPortAttachment } from './debug/outer-port-attachment.js';\nimport { DevtoolsConnection } from './debug/devtools-connection.js';\nclass ThingMapper {\n    constructor(prefix) {\n        this._prefix = prefix;\n        this._nextIdentifier = 0;\n        this._idMap = new Map();\n        this._reverseIdMap = new Map();\n    }\n    _newIdentifier() {\n        return this._prefix + (this._nextIdentifier++);\n    }\n    createMappingForThing(thing, requestedId) {\n        assert(!this._reverseIdMap.has(thing));\n        let id;\n        if (requestedId) {\n            id = requestedId;\n        }\n        else if (thing.apiChannelMappingId) {\n            id = thing.apiChannelMappingId;\n        }\n        else {\n            id = this._newIdentifier();\n        }\n        assert(!this._idMap.has(id), `${requestedId ? 'requestedId' : (thing.apiChannelMappingId ? 'apiChannelMappingId' : 'newIdentifier()')} ${id} already in use`);\n        this.establishThingMapping(id, thing);\n        return id;\n    }\n    maybeCreateMappingForThing(thing) {\n        if (this.hasMappingForThing(thing)) {\n            return this.identifierForThing(thing);\n        }\n        return this.createMappingForThing(thing);\n    }\n    establishThingMapping(id, thing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let continuation;\n            if (Array.isArray(thing)) {\n                [thing, continuation] = thing;\n            }\n            this._idMap.set(id, thing);\n            if (thing instanceof Promise) {\n                assert(continuation == null);\n                yield this.establishThingMapping(id, yield thing);\n            }\n            else {\n                this._reverseIdMap.set(thing, id);\n                if (continuation) {\n                    yield continuation();\n                }\n            }\n        });\n    }\n    hasMappingForThing(thing) {\n        return this._reverseIdMap.has(thing);\n    }\n    identifierForThing(thing) {\n        assert(this._reverseIdMap.has(thing), `Missing thing ${thing}`);\n        return this._reverseIdMap.get(thing);\n    }\n    thingForIdentifier(id) {\n        assert(this._idMap.has(id), `Missing id: ${id}`);\n        return this._idMap.get(id);\n    }\n}\nclass APIPort {\n    constructor(messagePort, prefix) {\n        this._port = messagePort;\n        this._mapper = new ThingMapper(prefix);\n        this._messageMap = new Map();\n        this._port.onmessage = (e) => __awaiter(this, void 0, void 0, function* () { return this._handle(e); });\n        this._debugAttachment = null;\n        this.messageCount = 0;\n        this.Direct = {\n            convert: a => a,\n            unconvert: a => a\n        };\n        this.LocalMapped = {\n            convert: a => this._mapper.maybeCreateMappingForThing(a),\n            unconvert: a => this._mapper.thingForIdentifier(a)\n        };\n        this.Mapped = {\n            convert: a => this._mapper.identifierForThing(a),\n            unconvert: a => this._mapper.thingForIdentifier(a)\n        };\n        this.Dictionary = function (primitive) {\n            return {\n                convert: a => {\n                    let r = {};\n                    for (let key in a) {\n                        r[key] = primitive.convert(a[key]);\n                    }\n                    return r;\n                }\n            };\n        };\n        this.Map = function (keyprimitive, valueprimitive) {\n            return {\n                convert: a => {\n                    let r = {};\n                    a.forEach((value, key) => r[keyprimitive.convert(key)] = valueprimitive.convert(value));\n                    return r;\n                },\n                unconvert: a => {\n                    let r = new Map();\n                    for (let key in a)\n                        r.set(keyprimitive.unconvert(key), valueprimitive.unconvert(a[key]));\n                    return r;\n                }\n            };\n        };\n        this.List = function (primitive) {\n            return {\n                convert: a => a.map(v => primitive.convert(v)),\n                unconvert: a => a.map(v => primitive.unconvert(v))\n            };\n        };\n        this.ByLiteral = function (clazz) {\n            return {\n                convert: a => a.toLiteral(),\n                unconvert: a => clazz.fromLiteral(a)\n            };\n        };\n    }\n    close() {\n        this._port.close();\n    }\n    _handle(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(this._messageMap.has(e.data.messageType));\n            this.messageCount++;\n            let handler = this._messageMap.get(e.data.messageType);\n            let args;\n            try {\n                args = this._unprocessArguments(handler.args, e.data.messageBody);\n            }\n            catch (exc) {\n                console.error(`Exception during unmarshaling for ${e.data.messageType}`);\n                throw exc;\n            }\n            // If any of the converted arguments are still pending promises\n            // wait for them to complete before processing the message.\n            for (let arg of Object.values(args)) {\n                if (arg instanceof Promise) {\n                    arg.then(() => this._handle(e));\n                    return;\n                }\n            }\n            let handlerName = 'on' + e.data.messageType;\n            let result = this[handlerName](args);\n            if (this._debugAttachment && this._debugAttachment[handlerName]) {\n                this._debugAttachment[handlerName](args);\n            }\n            if (handler.isInitializer) {\n                assert(args.identifier);\n                yield this._mapper.establishThingMapping(args.identifier, result);\n            }\n        });\n    }\n    _processArguments(argumentTypes, args) {\n        let messageBody = {};\n        for (let argument in argumentTypes)\n            messageBody[argument] = argumentTypes[argument].convert(args[argument]);\n        return messageBody;\n    }\n    _unprocessArguments(argumentTypes, args) {\n        let messageBody = {};\n        for (let argument in argumentTypes)\n            messageBody[argument] = argumentTypes[argument].unconvert(args[argument]);\n        return messageBody;\n    }\n    registerCall(name, argumentTypes) {\n        this[name] = args => {\n            let call = { messageType: name, messageBody: this._processArguments(argumentTypes, args) };\n            this.messageCount++;\n            this._port.postMessage(call);\n            if (this._debugAttachment && this._debugAttachment[name]) {\n                this._debugAttachment[name](args);\n            }\n        };\n    }\n    registerHandler(name, argumentTypes) {\n        this._messageMap.set(name, { args: argumentTypes });\n    }\n    registerInitializerHandler(name, argumentTypes) {\n        argumentTypes.identifier = this.Direct;\n        this._messageMap.set(name, {\n            isInitializer: true,\n            args: argumentTypes,\n        });\n    }\n    registerRedundantInitializer(name, argumentTypes, mappingIdArg) {\n        this.registerInitializer(name, argumentTypes, mappingIdArg, true /* redundant */);\n    }\n    registerInitializer(name, argumentTypes, mappingIdArg = null, redundant = false) {\n        this[name] = (thing, args) => {\n            if (redundant && this._mapper.hasMappingForThing(thing))\n                return;\n            let call = { messageType: name, messageBody: this._processArguments(argumentTypes, args) };\n            let requestedId = mappingIdArg && args[mappingIdArg];\n            call.messageBody.identifier = this._mapper.createMappingForThing(thing, requestedId);\n            this.messageCount++;\n            this._port.postMessage(call);\n            if (this._debugAttachment && this._debugAttachment[name]) {\n                this._debugAttachment[name](thing, args);\n            }\n        };\n    }\n}\nexport class PECOuterPort extends APIPort {\n    constructor(messagePort, arc) {\n        super(messagePort, 'o');\n        this.registerCall('Stop', {});\n        this.registerRedundantInitializer('DefineHandle', { type: this.ByLiteral(Type), name: this.Direct });\n        this.registerInitializer('InstantiateParticle', { id: this.Direct, spec: this.ByLiteral(ParticleSpec), handles: this.Map(this.Direct, this.Mapped) }, 'id');\n        this.registerCall('UIEvent', { particle: this.Mapped, slotName: this.Direct, event: this.Direct });\n        this.registerCall('SimpleCallback', { callback: this.Direct, data: this.Direct });\n        this.registerCall('AwaitIdle', { version: this.Direct });\n        this.registerCall('StartRender', { particle: this.Mapped, slotName: this.Direct, contentTypes: this.List(this.Direct) });\n        this.registerCall('StopRender', { particle: this.Mapped, slotName: this.Direct });\n        this.registerHandler('Render', { particle: this.Mapped, slotName: this.Direct, content: this.Direct });\n        this.registerHandler('InitializeProxy', { handle: this.Mapped, callback: this.Direct });\n        this.registerHandler('SynchronizeProxy', { handle: this.Mapped, callback: this.Direct });\n        this.registerHandler('HandleGet', { handle: this.Mapped, callback: this.Direct, particleId: this.Direct });\n        this.registerHandler('HandleToList', { handle: this.Mapped, callback: this.Direct, particleId: this.Direct });\n        this.registerHandler('HandleSet', { handle: this.Mapped, data: this.Direct, particleId: this.Direct });\n        this.registerHandler('HandleStore', { handle: this.Mapped, data: this.Direct, particleId: this.Direct });\n        this.registerHandler('HandleRemove', { handle: this.Mapped, data: this.Direct });\n        this.registerHandler('HandleClear', { handle: this.Mapped, particleId: this.Direct });\n        this.registerHandler('Idle', { version: this.Direct, relevance: this.Map(this.Mapped, this.Direct) });\n        this.registerHandler('ConstructInnerArc', { callback: this.Direct, particle: this.Mapped });\n        this.registerCall('ConstructArcCallback', { callback: this.Direct, arc: this.LocalMapped });\n        this.registerHandler('ArcCreateHandle', { callback: this.Direct, arc: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct });\n        this.registerInitializer('CreateHandleCallback', { callback: this.Direct, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct });\n        this.registerHandler('ArcMapHandle', { callback: this.Direct, arc: this.LocalMapped, handle: this.Mapped });\n        this.registerInitializer('MapHandleCallback', { callback: this.Direct, id: this.Direct });\n        this.registerHandler('ArcCreateSlot', { callback: this.Direct, arc: this.LocalMapped, transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedParticleName: this.Direct, hostedSlotName: this.Direct, handleId: this.Direct });\n        this.registerInitializer('CreateSlotCallback', { callback: this.Direct, hostedSlotId: this.Direct });\n        this.registerCall('InnerArcRender', { transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedSlotId: this.Direct, content: this.Direct });\n        this.registerHandler('ArcLoadRecipe', { arc: this.LocalMapped, recipe: this.Direct, callback: this.Direct });\n        this.registerHandler('RaiseSystemException', { exception: this.Direct, methodName: this.Direct, particleId: this.Direct });\n        DevtoolsConnection.onceConnected.then(devtoolsChannel => this._debugAttachment = new OuterPortAttachment(arc, devtoolsChannel));\n    }\n}\nexport class PECInnerPort extends APIPort {\n    constructor(messagePort) {\n        super(messagePort, 'i');\n        this.registerHandler('Stop', {});\n        this.registerInitializerHandler('DefineHandle', { type: this.ByLiteral(Type), name: this.Direct });\n        this.registerInitializerHandler('InstantiateParticle', { id: this.Direct, spec: this.ByLiteral(ParticleSpec), handles: this.Map(this.Direct, this.Mapped) });\n        this.registerHandler('UIEvent', { particle: this.Mapped, slotName: this.Direct, event: this.Direct });\n        this.registerHandler('SimpleCallback', { callback: this.LocalMapped, data: this.Direct });\n        this.registerHandler('AwaitIdle', { version: this.Direct });\n        this.registerHandler('StartRender', { particle: this.Mapped, slotName: this.Direct, contentTypes: this.Direct });\n        this.registerHandler('StopRender', { particle: this.Mapped, slotName: this.Direct });\n        this.registerCall('Render', { particle: this.Mapped, slotName: this.Direct, content: this.Direct });\n        this.registerCall('InitializeProxy', { handle: this.Mapped, callback: this.LocalMapped });\n        this.registerCall('SynchronizeProxy', { handle: this.Mapped, callback: this.LocalMapped });\n        this.registerCall('HandleGet', { handle: this.Mapped, callback: this.LocalMapped, particleId: this.Direct });\n        this.registerCall('HandleToList', { handle: this.Mapped, callback: this.LocalMapped, particleId: this.Direct });\n        this.registerCall('HandleSet', { handle: this.Mapped, data: this.Direct, particleId: this.Direct, barrier: this.Direct });\n        this.registerCall('HandleStore', { handle: this.Mapped, data: this.Direct, particleId: this.Direct });\n        this.registerCall('HandleRemove', { handle: this.Mapped, data: this.Direct });\n        this.registerCall('HandleClear', { handle: this.Mapped, particleId: this.Direct, barrier: this.Direct });\n        this.registerCall('Idle', { version: this.Direct, relevance: this.Map(this.Mapped, this.Direct) });\n        this.registerCall('ConstructInnerArc', { callback: this.LocalMapped, particle: this.Mapped });\n        this.registerHandler('ConstructArcCallback', { callback: this.LocalMapped, arc: this.Direct });\n        this.registerCall('ArcCreateHandle', { callback: this.LocalMapped, arc: this.Direct, type: this.ByLiteral(Type), name: this.Direct });\n        this.registerInitializerHandler('CreateHandleCallback', { callback: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct });\n        this.registerCall('ArcMapHandle', { callback: this.LocalMapped, arc: this.Direct, handle: this.Mapped });\n        this.registerInitializerHandler('MapHandleCallback', { callback: this.LocalMapped, id: this.Direct });\n        this.registerCall('ArcCreateSlot', { callback: this.LocalMapped, arc: this.Direct, transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedParticleName: this.Direct, hostedSlotName: this.Direct, handleId: this.Direct });\n        this.registerInitializerHandler('CreateSlotCallback', { callback: this.LocalMapped, hostedSlotId: this.Direct });\n        this.registerHandler('InnerArcRender', { transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedSlotId: this.Direct, content: this.Direct });\n        this.registerCall('ArcLoadRecipe', { arc: this.Direct, recipe: this.Direct, callback: this.LocalMapped });\n        this.registerCall('RaiseSystemException', { exception: this.Direct, methodName: this.Direct, particleId: this.Direct });\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/api-channel.js\n// module id = 19\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nlet supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];\nexport class JsonldToManifest {\n    static convert(jsonld, theClass) {\n        let obj = JSON.parse(jsonld);\n        let classes = {};\n        let properties = {};\n        if (!obj['@graph']) {\n            obj['@graph'] = [obj];\n        }\n        for (let item of obj['@graph']) {\n            if (item['@type'] == 'rdf:Property')\n                properties[item['@id']] = item;\n            else if (item['@type'] == 'rdfs:Class') {\n                classes[item['@id']] = item;\n                item.subclasses = [];\n                item.superclass = null;\n            }\n        }\n        for (let clazz of Object.values(classes)) {\n            if (clazz['rdfs:subClassOf'] !== undefined) {\n                if (clazz['rdfs:subClassOf'].length == undefined)\n                    clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];\n                for (let subClass of clazz['rdfs:subClassOf']) {\n                    let superclass = subClass['@id'];\n                    if (clazz.superclass == undefined)\n                        clazz.superclass = [];\n                    if (classes[superclass]) {\n                        classes[superclass].subclasses.push(clazz);\n                        clazz.superclass.push(classes[superclass]);\n                    }\n                    else {\n                        clazz.superclass.push({ '@id': superclass });\n                    }\n                }\n            }\n        }\n        for (let clazz of Object.values(classes)) {\n            if (clazz.subclasses.length == 0 && theClass == undefined) {\n                theClass = clazz;\n            }\n        }\n        let relevantProperties = [];\n        for (let property of Object.values(properties)) {\n            let domains = property['schema:domainIncludes'];\n            if (!domains)\n                domains = { '@id': theClass['@id'] };\n            if (!domains.length)\n                domains = [domains];\n            domains = domains.map(a => a['@id']);\n            if (domains.includes(theClass['@id'])) {\n                let name = property['@id'].split(':')[1];\n                let type = property['schema:rangeIncludes'];\n                if (!type)\n                    console.log(property);\n                if (!type.length)\n                    type = [type];\n                type = type.map(a => a['@id'].split(':')[1]);\n                type = type.filter(type => supportedTypes.includes(type));\n                if (type.length > 0)\n                    relevantProperties.push({ name, type });\n            }\n        }\n        let className = theClass['@id'].split(':')[1];\n        let superNames = theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];\n        let s = '';\n        for (let superName of superNames)\n            s += `import 'https://schema.org/${superName}'\\n\\n`;\n        s += `schema ${className}`;\n        if (superNames.length > 0)\n            s += ` extends ${superNames.join(', ')}`;\n        if (relevantProperties.length > 0) {\n            for (let property of relevantProperties) {\n                let type;\n                if (property.type.length > 1)\n                    type = '(' + property.type.join(' or ') + ')';\n                else\n                    type = property.type[0];\n                s += `\\n  ${type} ${property.name}`;\n            }\n        }\n        s += '\\n';\n        return s;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/converters/jsonldToManifest.js\n// module id = 20\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { assert } from '../../platform/assert-web.js';\nexport class AbstractDevtoolsChannel {\n    constructor() {\n        this.debouncedMessages = [];\n        this.debouncing = false;\n        this.messageListeners = new Map();\n    }\n    send(message) {\n        this.debouncedMessages.push(message);\n        if (!this.debouncing) {\n            this.debouncing = true;\n            setTimeout(() => {\n                this._flush(this.debouncedMessages);\n                this.debouncedMessages = [];\n                this.debouncing = false;\n            }, 100);\n        }\n    }\n    listen(arcOrId, messageType, callback) {\n        assert(messageType);\n        assert(arcOrId);\n        const arcId = typeof arcOrId === 'string' ? arcOrId : arcOrId.id.toString();\n        const key = `${arcId}/${messageType}`;\n        let listeners = this.messageListeners.get(key);\n        if (!listeners)\n            this.messageListeners.set(key, listeners = []);\n        listeners.push(callback);\n    }\n    _handleMessage(msg) {\n        let listeners = this.messageListeners.get(`${msg.arcId}/${msg.messageType}`);\n        if (!listeners) {\n            console.warn(`No one is listening to ${msg.messageType} message`);\n        }\n        else {\n            for (let listener of listeners)\n                listener(msg);\n        }\n    }\n    _flush(messages) {\n        throw 'Not implemented in an abstract class';\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/debug/abstract-devtools-channel.js\n// module id = 21\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { assert } from '../../platform/assert-web.js';\nimport { DevtoolsChannel } from '../../platform/devtools-channel-web.js';\nimport { DevtoolsChannelStub } from './testing/devtools-channel-stub.js';\nimport { DevtoolsBroker } from '../../devtools/shared/devtools-broker.js';\nlet channel = null;\nlet isConnected = false;\nlet onceConnectedResolve = null;\nlet onceConnected = new Promise(resolve => onceConnectedResolve = resolve);\nDevtoolsBroker.onceConnected.then(() => {\n    DevtoolsConnection.ensure();\n    onceConnectedResolve(channel);\n    isConnected = true;\n});\nexport class DevtoolsConnection {\n    static get isConnected() {\n        return isConnected;\n    }\n    static get onceConnected() {\n        return onceConnected;\n    }\n    static get() {\n        return channel;\n    }\n    static ensure() {\n        if (!channel)\n            channel = new DevtoolsChannel();\n    }\n}\nexport class DevtoolsForTests {\n    static get channel() {\n        return channel;\n    }\n    static ensureStub() {\n        assert(!channel);\n        channel = new DevtoolsChannelStub();\n        onceConnectedResolve(channel);\n        isConnected = true;\n    }\n    static reset() {\n        assert(channel);\n        isConnected = false;\n        onceConnectedResolve = null;\n        onceConnected = new Promise(resolve => onceConnectedResolve = resolve);\n        channel = null;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/debug/devtools-connection.js\n// module id = 22\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nexport class OuterPortAttachment {\n    constructor(arc, devtoolsChannel) {\n        this._devtoolsChannel = devtoolsChannel;\n        this._arcIdString = arc.id.toString();\n        this._speculative = arc.isSpeculative;\n        this._callbackRegistry = {};\n        this._particleRegistry = {};\n    }\n    InstantiateParticle(particle, { id, spec, handles }) {\n        this._particleRegistry[id] = spec;\n        this._devtoolsChannel.send({\n            messageType: 'InstantiateParticle',\n            messageBody: Object.assign(this._arcMetadata(), this._trimParticleSpec(id, spec, handles))\n        });\n    }\n    SimpleCallback({ callback, data }) {\n        let callbackDetails = this._callbackRegistry[callback];\n        if (callbackDetails) {\n            // Copying callback data, as the callback can be used multiple times.\n            this._sendDataflowMessage(Object.assign({}, callbackDetails), data);\n        }\n    }\n    onInitializeProxy({ handle, callback }) {\n        this._callbackRegistry[callback] = this._describeHandleCall({ operation: 'on-change', handle });\n    }\n    onSynchronizeProxy({ handle, callback }) {\n        this._callbackRegistry[callback] = this._describeHandleCall({ operation: 'sync-model', handle });\n    }\n    onHandleGet({ handle, callback, particleId }) {\n        this._callbackRegistry[callback] = this._describeHandleCall({ operation: 'get', handle, particleId });\n    }\n    onHandleToList({ handle, callback, particleId }) {\n        this._callbackRegistry[callback] = this._describeHandleCall({ operation: 'toList', handle, particleId });\n    }\n    onHandleSet({ handle, data, particleId }) {\n        this._logHandleCall({ operation: 'set', handle, data, particleId });\n    }\n    onHandleStore({ handle, data, particleId }) {\n        this._logHandleCall({ operation: 'store', handle, data, particleId });\n    }\n    onHandleClear({ handle, particleId }) {\n        this._logHandleCall({ operation: 'clear', handle, particleId });\n    }\n    onHandleRemove({ handle, data, particleId }) {\n        this._logHandleCall({ operation: 'remove', handle, data, particleId });\n    }\n    _logHandleCall(args) {\n        this._sendDataflowMessage(this._describeHandleCall(args), args.data);\n    }\n    _sendDataflowMessage(messageBody, data) {\n        messageBody.data = JSON.stringify(data);\n        messageBody.timestamp = Date.now();\n        this._devtoolsChannel.send({ messageType: 'dataflow', messageBody });\n    }\n    _describeHandleCall({ operation, handle, particleId }) {\n        let metadata = Object.assign(this._arcMetadata(), {\n            operation,\n            handle: this._describeHandle(handle)\n        });\n        if (particleId)\n            metadata.particle = this._describeParticle(particleId);\n        return metadata;\n    }\n    _arcMetadata() {\n        return {\n            arcId: this._arcIdString,\n            speculative: this._speculative\n        };\n    }\n    _trimParticleSpec(id, spec, handles) {\n        let connections = {};\n        spec.connectionMap.forEach((value, key) => {\n            connections[key] = Object.assign({\n                direction: value.direction\n            }, this._describeHandle(handles.get(key)));\n        });\n        return {\n            id,\n            name: spec.name,\n            connections,\n            implFile: spec.implFile\n        };\n    }\n    _describeParticle(id) {\n        let particleSpec = this._particleRegistry[id];\n        return {\n            id,\n            name: particleSpec && particleSpec.name\n            // TODO: Send entire spec only once and refer to it by ID in the tool.\n        };\n    }\n    _describeHandle(handle) {\n        return {\n            id: handle.id,\n            storageKey: handle._storageKey,\n            name: handle.name,\n            description: handle.description,\n            type: this._describeHandleType(handle._type)\n        };\n    }\n    // TODO: This is fragile and incomplete. Change this into sending entire\n    //       handle object once and refer back to it via its ID in the tool.\n    _describeHandleType(handleType) {\n        switch (handleType.constructor.name) {\n            case 'Type':\n                switch (handleType.tag) {\n                    case 'Collection': return `[${this._describeHandleType(handleType.data)}]`;\n                    case 'Entity': return this._describeHandleType(handleType.data);\n                    default: return `${handleType.tag} ${this._describeHandleType(handleType.data)}`;\n                }\n            case 'Schema':\n                return handleType.name;\n            case 'Shape':\n                return 'Shape';\n        }\n        return '';\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/debug/outer-port-attachment.js\n// module id = 23\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport class DevtoolsChannelStub {\n    constructor() {\n        this._messages = [];\n    }\n    get messages() {\n        return this._messages;\n    }\n    send(message) {\n        this._messages.push(JSON.parse(JSON.stringify(message)));\n    }\n    listen(arcOrId, messageType, callback) { }\n    clear() {\n        this._messages.length = 0;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/debug/testing/devtools-channel-stub.js\n// module id = 24\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { assert } from '../platform/assert-web.js';\nimport { Particle } from './particle.js';\n/** @class DomParticleBase\n * Particle that interoperates with DOM.\n */\nexport class DomParticleBase extends Particle {\n    constructor() {\n        super();\n    }\n    /** @method get template()\n     * Override to return a String defining primary markup.\n     */\n    get template() {\n        return '';\n    }\n    /** @method getTemplate(slotName)\n     * Override to return a String defining primary markup for the given slot name.\n     */\n    getTemplate(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return this.template;\n    }\n    /** @method getTemplateName(slotName)\n     * Override to return a String defining the name of the template for the given slot name.\n     */\n    getTemplateName(slotName) {\n        // TODO: only supports a single template for now. add multiple templates support.\n        return `default`;\n    }\n    /** @method shouldRender(props, state, oldProps, oldState)\n     * Override to return false if the Particle won't use\n     * it's slot.\n     */\n    shouldRender() {\n        return true;\n    }\n    /** @method render()\n     * Override to return a dictionary to map into the template.\n     */\n    render() {\n        return {};\n    }\n    renderSlot(slotName, contentTypes) {\n        const stateArgs = this._getStateArgs();\n        let slot = this.getSlot(slotName);\n        if (!slot) {\n            return; // didn't receive StartRender.\n        }\n        // Set this to support multiple slots consumed by a particle, without needing\n        // to pass slotName to particle's render method, where it useless in most cases.\n        this.currentSlotName = slotName;\n        contentTypes.forEach(ct => slot._requestedContentTypes.add(ct));\n        // TODO(sjmiles): redundant, same answer for every slot\n        if (this.shouldRender(...stateArgs)) {\n            let content = {};\n            if (slot._requestedContentTypes.has('template')) {\n                content.template = this.getTemplate(slot.slotName);\n            }\n            if (slot._requestedContentTypes.has('model')) {\n                content.model = this.render(...stateArgs);\n            }\n            content.templateName = this.getTemplateName(slot.slotName);\n            slot.render(content);\n        }\n        else if (slot.isRendered) {\n            // Send empty object, to clear rendered slot contents.\n            slot.render({});\n        }\n        this.currentSlotName = undefined;\n    }\n    _getStateArgs() {\n        return [];\n    }\n    forceRenderTemplate(slotName) {\n        this._slotByName.forEach((slot, name) => {\n            if (!slotName || (name == slotName)) {\n                slot._requestedContentTypes.add('template');\n            }\n        });\n    }\n    fireEvent(slotName, { handler, data }) {\n        if (this[handler]) {\n            this[handler]({ data });\n        }\n    }\n    setParticleDescription(pattern) {\n        if (typeof pattern === 'string') {\n            return super.setParticleDescription(pattern);\n        }\n        assert(!!pattern.template && !!pattern.model, 'Description pattern must either be string or have template and model');\n        super.setDescriptionPattern('_template_', pattern.template);\n        super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));\n    }\n    /** @method updateVariable(handleName, record)\n     * Modify value of named handle.\n     */\n    updateVariable(handleName, record) {\n        const handle = this.handles.get(handleName);\n        const newRecord = new (handle.entityClass)(record);\n        handle.set(newRecord);\n        return newRecord;\n    }\n    /** @method updateSet(handleName, record)\n     * Modify or insert `record` into named handle.\n     * Modification is done by removing the old record and reinserting the new one.\n     */\n    updateSet(handleName, record) {\n        // Set the record into the right place in the set. If we find it\n        // already present replace it, otherwise, add it.\n        // TODO(dstockwell): Replace this with happy entity mutation approach.\n        const handle = this.handles.get(handleName);\n        const records = this._props[handleName];\n        const target = records.find(r => r.id === record.id);\n        if (target) {\n            handle.remove(target);\n        }\n        handle.store(record);\n    }\n    /** @method boxQuery(box, userid)\n     * Returns array of Entities found in BOXED data `box` that are owned by `userid`\n     */\n    boxQuery(box, userid) {\n        return box.filter(item => userid === item.getUserID().split('|')[0]);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/dom-particle-base.js\n// module id = 25\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\nimport { assert } from '../platform/assert-web.js';\nimport { Symbols } from './symbols.js';\nimport { Type } from './type.js';\nexport class Entity {\n    constructor(userIDComponent) {\n        assert(!userIDComponent || userIDComponent.indexOf(':') == -1, 'user IDs must not contain the \\':\\' character');\n        this[Symbols.identifier] = undefined;\n        this._userIDComponent = userIDComponent;\n    }\n    get data() {\n        return undefined;\n    }\n    getUserID() {\n        return this._userIDComponent;\n    }\n    isIdentified() {\n        return this[Symbols.identifier] !== undefined;\n    }\n    // TODO: entity should not be exposing its IDs.\n    get id() {\n        assert(!!this.isIdentified());\n        return this[Symbols.identifier];\n    }\n    identify(identifier) {\n        assert(!this.isIdentified());\n        this[Symbols.identifier] = identifier;\n        let components = identifier.split(':');\n        if (components[components.length - 2] == 'uid')\n            this._userIDComponent = components[components.length - 1];\n    }\n    createIdentity(components) {\n        assert(!this.isIdentified());\n        let id;\n        if (this._userIDComponent)\n            id = `${components.base}:uid:${this._userIDComponent}`;\n        else\n            id = `${components.base}:${components.component()}`;\n        this[Symbols.identifier] = id;\n    }\n    toLiteral() {\n        return this.rawData;\n    }\n    static get type() {\n        // TODO: should the entity's key just be its type?\n        // Should it just be called type in that case?\n        return Type.newEntity(this.key.schema);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/entity.js\n// module id = 26\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n// 'export default fetch' works because 'fetch' is evaluated as an expression, which finds the\n// appropriate global definition - but we don't want to use default exports.\n// 'export {fetch}' doesn't work because 'fetch' is just a name in that context and is not defined.\n// So we need to use an expression to find the global fetch function then map that for export.\nconst local_fetch = fetch;\nexport { local_fetch as fetch };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/fetch-web.js\n// module id = 27\n// module chunks = 0","/** @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Symbols } from './symbols.js';\nimport { assert } from '../platform/assert-web.js';\nimport { ParticleSpec } from './particle-spec.js';\n// TODO: This won't be needed once runtime is transferred between contexts.\nfunction cloneData(data) {\n    return data;\n    //return JSON.parse(JSON.stringify(data));\n}\nfunction restore(entry, entityClass) {\n    assert(entityClass, 'Handles need entity classes for deserialization');\n    let { id, rawData } = entry;\n    let entity = new entityClass(cloneData(rawData));\n    if (entry.id) {\n        entity.identify(entry.id);\n    }\n    // TODO some relation magic, somewhere, at some point.\n    return entity;\n}\n/** @class Handle\n * Base class for Collections and Variables.\n */\nclass Handle {\n    constructor(proxy, name, particleId, canRead, canWrite) {\n        assert(!(proxy instanceof Handle));\n        this._proxy = proxy;\n        this.name = name || this._proxy.name;\n        this.canRead = canRead;\n        this.canWrite = canWrite;\n        this._particleId = particleId;\n        this.options = {\n            keepSynced: true,\n            notifySync: true,\n            notifyUpdate: true,\n            notifyDesync: false,\n        };\n    }\n    raiseSystemException(exception, method) {\n        this._proxy.raiseSystemException(exception, method, this._particleId);\n    }\n    // `options` may contain any of:\n    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required\n    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received\n    // - notifyUpdate (bool): call onHandleUpdate for every change event received\n    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected\n    configure(options) {\n        assert(this.canRead, 'configure can only be called on readable Handles');\n        try {\n            let keys = Object.keys(this.options);\n            let badKeys = Object.keys(options).filter(o => !keys.includes(o));\n            if (badKeys.length > 0) {\n                throw new Error(`Invalid option in Handle.configure(): ${badKeys}`);\n            }\n            Object.assign(this.options, options);\n        }\n        catch (e) {\n            this.raiseSystemException(e, 'Handle::configure');\n            throw e;\n        }\n    }\n    _serialize(entity) {\n        assert(entity, 'can\\'t serialize a null entity');\n        if (!entity.isIdentified())\n            entity.createIdentity(this._proxy.generateIDComponents());\n        let id = entity[Symbols.identifier];\n        let rawData = entity.dataClone();\n        return {\n            id,\n            rawData\n        };\n    }\n    get type() {\n        return this._proxy._type;\n    }\n    get _id() {\n        return this._proxy._id;\n    }\n    toManifestString() {\n        return `'${this._id}'`;\n    }\n}\n/** @class Collection\n * A handle on a set of Entity data. Note that, as a set, a Collection can only\n * contain a single version of an Entity for each given ID. Further, no order is\n * implied by the set. A particle's manifest dictates the types of handles that\n * need to be connected to that particle, and the current recipe identifies\n * which handles are connected.\n */\nclass Collection extends Handle {\n    constructor(proxy, name, particleId, canRead, canWrite) {\n        // TODO: this should talk to an API inside the PEC.\n        super(proxy, name, particleId, canRead, canWrite);\n    }\n    query() {\n        // TODO: things\n    }\n    // Called by StorageProxy.\n    _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                particle.onHandleSync(this, this._restore(details));\n                return;\n            case 'update': {\n                let update = {};\n                if ('add' in details)\n                    update.added = this._restore(details.add);\n                if ('remove' in details)\n                    update.removed = this._restore(details.remove);\n                update.originator = details.originatorId == this._particleId;\n                particle.onHandleUpdate(this, update);\n                return;\n            }\n            case 'desync':\n                particle.onHandleDesync(this);\n                return;\n        }\n    }\n    /** @method async toList()\n     * Returns a list of the Entities contained by the handle.\n     * throws: Error if this handle is not configured as a readable handle (i.e. 'in' or 'inout')\n       in the particle's manifest.\n     */\n    toList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: remove this and use query instead\n            if (!this.canRead)\n                throw new Error('Handle not readable');\n            return this._restore(yield this._proxy.toList(this._particleId));\n        });\n    }\n    _restore(list) {\n        return (list !== null) ? list.map(a => restore(a, this.entityClass)) : null;\n    }\n    /** @method store(entity)\n     * Stores a new entity into the Handle.\n     * throws: Error if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n       in the particle's manifest.\n     */\n    store(entity) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.canWrite)\n                throw new Error('Handle not writeable');\n            let serialization = this._serialize(entity);\n            let keys = [this._proxy.generateID('key')];\n            return this._proxy.store(serialization, keys, this._particleId);\n        });\n    }\n    /** @method remove(entity)\n     * Removes an entity from the Handle.\n     * throws: Error if this handle is not configured as a writeable handle (i.e. 'out' or 'inout')\n       in the particle's manifest.\n     */\n    remove(entity) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.canWrite)\n                throw new Error('Handle not writeable');\n            let serialization = this._serialize(entity);\n            // Remove the keys that exist at storage/proxy.\n            let keys = [];\n            return this._proxy.remove(serialization.id, keys, this._particleId);\n        });\n    }\n}\n/** @class Variable\n * A handle on a single entity. A particle's manifest dictates\n * the types of handles that need to be connected to that particle, and\n * the current recipe identifies which handles are connected.\n */\nclass Variable extends Handle {\n    constructor(proxy, name, particleId, canRead, canWrite) {\n        super(proxy, name, particleId, canRead, canWrite);\n    }\n    // Called by StorageProxy.\n    _notify(kind, particle, details) {\n        assert(this.canRead, '_notify should not be called for non-readable handles');\n        switch (kind) {\n            case 'sync':\n                particle.onHandleSync(this, this._restore(details));\n                return;\n            case 'update': {\n                particle.onHandleUpdate(this, { data: this._restore(details.data) });\n                return;\n            }\n            case 'desync':\n                particle.onHandleDesync(this);\n                return;\n        }\n    }\n    /** @method async get()\n    * Returns the Entity contained by the Variable, or undefined if the Variable\n    * is cleared.\n    * throws: Error if this variable is not configured as a readable handle (i.e. 'in' or 'inout')\n      in the particle's manifest.\n     */\n    get() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.canRead)\n                throw new Error('Handle not readable');\n            let model = yield this._proxy.get(this._particleId);\n            return this._restore(model);\n        });\n    }\n    _restore(model) {\n        if (model === null)\n            return null;\n        if (this.type.isEntity) {\n            return restore(model, this.entityClass);\n        }\n        return this.type.isInterface ? ParticleSpec.fromLiteral(model) : model;\n    }\n    /** @method set(entity)\n     * Stores a new entity into the Variable, replacing any existing entity.\n     * throws: Error if this variable is not configured as a writeable handle (i.e. 'out' or 'inout')\n       in the particle's manifest.\n     */\n    set(entity) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!this.canWrite)\n                    throw new Error('Handle not writeable');\n                return this._proxy.set(this._serialize(entity), this._particleId);\n            }\n            catch (e) {\n                this.raiseSystemException(e, 'Handle::set');\n                throw e;\n            }\n        });\n    }\n    /** @method clear()\n     * Clears any entity currently in the Variable.\n     * throws: Error if this variable is not configured as a writeable handle (i.e. 'out' or 'inout')\n       in the particle's manifest.\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.canWrite)\n                throw new Error('Handle not writeable');\n            yield this._proxy.clear(this._particleId);\n        });\n    }\n}\nexport function handleFor(proxy, isSet, name, particleId, canRead = true, canWrite = true) {\n    return (isSet || (isSet == undefined && proxy.type.isCollection))\n        ? new Collection(proxy, name, particleId, canRead, canWrite)\n        : new Variable(proxy, name, particleId, canRead, canWrite);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/handle.js\n// module id = 28\n// module chunks = 0","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { fs } from '../platform/fs-web.js';\nimport { vm } from '../platform/vm-web.js';\nimport { fetch } from './fetch-web.js';\nimport { assert } from '../platform/assert-web.js';\nimport { Particle } from './particle.js';\nimport { DomParticle } from './dom-particle.js';\nimport { MultiplexerDomParticle } from './multiplexer-dom-particle.js';\nimport { TransformationDomParticle } from './transformation-dom-particle.js';\nimport { JsonldToManifest } from './converters/jsonldToManifest.js';\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\nfunction schemaLocationFor(name) {\n    return `../entities/${name}.schema`;\n}\nexport class Loader {\n    path(fileName) {\n        let path = fileName.replace(/[/][^/]+$/, '/');\n        return path;\n    }\n    join(prefix, path) {\n        if (/^https?:\\/\\//.test(path))\n            return path;\n        // TODO: replace this with something that isn't hacky\n        if (path[0] == '/' || path[1] == ':')\n            return path;\n        prefix = this.path(prefix);\n        return prefix + path;\n    }\n    loadResource(file) {\n        if (/^https?:\\/\\//.test(file))\n            return this._loadURL(file);\n        return this._loadFile(file);\n    }\n    _loadFile(file) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(file, (err, data) => {\n                if (err)\n                    reject(err);\n                else\n                    resolve(data.toString('utf-8'));\n            });\n        });\n    }\n    _loadURL(url) {\n        if (/\\/\\/schema.org\\//.test(url)) {\n            if (url.endsWith('/Thing')) {\n                return fetch('https://schema.org/Product.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data, { '@id': 'schema:Thing' }));\n            }\n            return fetch(url + '.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data));\n        }\n        return fetch(url).then(res => res.text());\n    }\n    loadParticleClass(spec) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let clazz = yield this.requireParticle(spec.implFile);\n            clazz.spec = spec;\n            return clazz;\n        });\n    }\n    requireParticle(fileName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (fileName === null)\n                fileName = '';\n            let src = yield this.loadResource(fileName);\n            // Note. This is not real isolation.\n            let script = new vm.Script(src, { filename: fileName, displayErrors: true });\n            let result = [];\n            let self = {\n                defineParticle(particleWrapper) {\n                    result.push(particleWrapper);\n                },\n                console,\n                importScripts: s => null //console.log(`(skipping browser-space import for [${s}])`)\n            };\n            script.runInNewContext(self, { filename: fileName, displayErrors: true });\n            assert(result.length > 0 && typeof result[0] == 'function', `Error while instantiating particle implementation from ${fileName}`);\n            return this.unwrapParticle(result[0]);\n        });\n    }\n    unwrapParticle(particleWrapper) {\n        return particleWrapper({ Particle, DomParticle, TransformationDomParticle, MultiplexerDomParticle, html });\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/loader.js\n// module id = 29\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nimport { assert } from '../platform/assert-web.js';\nimport { CrdtCollectionModel } from './storage/crdt-collection-model.js';\nconst SyncState = { none: 0, pending: 1, full: 2 };\n/** @class StorageProxy\n * Mediates between one or more Handles and the backing store outside the PEC.\n *\n * This can operate in two modes, based on how observing handles are configured:\n * - synchronized: the proxy maintains a copy of the full data held by the backing store, keeping\n *                 it in sync by listening to change events from the store.\n * - unsynchronized: the proxy simply passes through calls from Handles to the backing store.\n *\n * In synchronized mode we maintain a queue of sorted update events received from the backing store.\n * While events are received correctly - each update is one version ahead of our stored model - they\n * are processed immediately and observing handles are notified accordingly. If we receive an update\n * with a \"future\" version, the proxy is desynchronized:\n * - a request for the full data is sent to the backing store;\n * - any update events received after that (and before the response) are added to the queue;\n * - any new updates that can be applied will be (which may cause the proxy to \"catch up\" and resync\n *   before the full data response arrives);\n * - once the resync response is received, stale queued updates are discarded and any remaining ones\n *   are applied.\n */\nexport class StorageProxy {\n    constructor(id, type, port, pec, scheduler, name) {\n        return type.isCollection\n            ? new CollectionProxy(id, type, port, pec, scheduler, name)\n            : new VariableProxy(id, type, port, pec, scheduler, name);\n    }\n}\nclass StorageProxyBase {\n    constructor(id, type, port, pec, scheduler, name) {\n        this._id = id;\n        this._type = type;\n        this._port = port;\n        this._pec = pec;\n        this._scheduler = scheduler;\n        this.name = name;\n        this._version = undefined;\n        this._listenerAttached = false;\n        this._keepSynced = false;\n        this._synchronized = SyncState.none;\n        this._observers = [];\n        this._updates = [];\n    }\n    raiseSystemException(exception, methodName, particleId) {\n        this._port.RaiseSystemException({ exception: { message: exception.message, stack: exception.stack, name: exception.name }, methodName, particleId });\n    }\n    get id() {\n        return this._id;\n    }\n    get type() {\n        return this._type;\n    }\n    // Called by ParticleExecutionContext to associate (potentially multiple) particle/handle pairs with this proxy.\n    register(particle, handle) {\n        if (!handle.canRead)\n            return;\n        this._observers.push({ particle, handle });\n        // Attach an event listener to the backing store when the first readable handle is registered.\n        if (!this._listenerAttached) {\n            this._port.InitializeProxy({ handle: this, callback: x => this._onUpdate(x) });\n            this._listenerAttached = true;\n        }\n        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send\n        // a request to get the full model (once).\n        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced\n        if (handle.options.keepSynced) {\n            if (!this._keepSynced) {\n                this._port.SynchronizeProxy({ handle: this, callback: x => this._onSynchronize(x) });\n                this._keepSynced = true;\n            }\n            // If a handle configured for sync notifications registers after we've received the full\n            // model, notify it immediately.\n            if (handle.options.notifySync && this._synchronized == SyncState.full) {\n                let syncModel = this._getModelForSync();\n                this._scheduler.enqueue(particle, handle, ['sync', particle, syncModel]);\n            }\n        }\n    }\n    // `model` contains 'version' and one of 'data' or 'list'.\n    _onSynchronize(model) {\n        if (this._version !== undefined && model.version <= this._version) {\n            console.warn(`StorageProxy '${this._id}' received stale model version ${model.version}; ` +\n                `current is ${this._version}`);\n            return;\n        }\n        // We may have queued updates that were received after a desync; discard any that are stale\n        // with respect to the received model.\n        this._synchronized = SyncState.full;\n        while (this._updates.length > 0 && this._updates[0].version <= model.version) {\n            this._updates.shift();\n        }\n        // Replace the stored data with the new one and notify handles that are configured for it.\n        this._synchronizeModel(model);\n        let syncModel = this._getModelForSync();\n        this._notify('sync', syncModel, options => options.keepSynced && options.notifySync);\n        this._processUpdates();\n    }\n    // `update` contains 'version' and one of 'data', 'add' or 'remove'.\n    _onUpdate(update) {\n        // Immediately notify any handles that are not configured with keepSynced but do want updates.\n        if (this._observers.find(({ handle }) => !handle.options.keepSynced && handle.options.notifyUpdate)) {\n            let handleUpdate = this._processUpdate(update, false);\n            this._notify('update', handleUpdate, options => !options.keepSynced && options.notifyUpdate);\n        }\n        // Bail if we're not in synchronized mode or this is a stale event.\n        if (!this._keepSynced)\n            return;\n        if (update.version <= this._version) {\n            console.warn(`StorageProxy '${this._id}' received stale update version ${update.version}; ` +\n                `current is ${this._version}`);\n            return;\n        }\n        // Add the update to the queue and process. Most of the time the queue should be empty and\n        // _processUpdates will consume this event immediately.\n        this._updates.push(update);\n        this._updates.sort((a, b) => a.version - b.version);\n        this._processUpdates();\n    }\n    _notify(kind, details, predicate = () => true) {\n        for (let { handle, particle } of this._observers) {\n            if (predicate(handle.options)) {\n                this._scheduler.enqueue(particle, handle, [kind, particle, details]);\n            }\n        }\n    }\n    _processUpdates() {\n        // Consume all queued updates whose versions are monotonically increasing from our stored one.\n        while (this._updates.length > 0 && this._updates[0].version === this._version + 1) {\n            let update = this._updates.shift();\n            // Fold the update into our stored model.\n            let handleUpdate = this._processUpdate(update);\n            this._version = update.version;\n            // Notify handles configured with keepSynced and notifyUpdates (non-keepSynced handles are\n            // notified as updates are received).\n            if (handleUpdate) {\n                this._notify('update', handleUpdate, options => options.keepSynced && options.notifyUpdate);\n            }\n        }\n        // If we still have update events queued, we must have received a future version are are now\n        // desynchronized. Send a request for the full model and notify handles configured for it.\n        if (this._updates.length > 0) {\n            if (this._synchronized != SyncState.none) {\n                this._synchronized = SyncState.none;\n                this._port.SynchronizeProxy({ handle: this, callback: x => this._onSynchronize(x) });\n                for (let { handle, particle } of this._observers) {\n                    if (handle.options.notifyDesync) {\n                        this._scheduler.enqueue(particle, handle, ['desync', particle]);\n                    }\n                }\n            }\n        }\n        else if (this._synchronized != SyncState.full) {\n            // If we were desynced but have now consumed all update events, we've caught up.\n            this._synchronized = SyncState.full;\n        }\n    }\n    generateID(component) {\n        return this._pec.generateID(component);\n    }\n    generateIDComponents() {\n        return this._pec.generateIDComponents();\n    }\n}\n// Collections are synchronized in a CRDT Observed/Removed scheme.\n// Each value is identified by an ID and a set of membership keys.\n// Concurrent adds of the same value will specify the same ID but different\n// keys. A value is removed by removing all of the observed keys. A value\n// is considered to be removed if all of it's keys have been removed.\n//\n// In synchronized mode mutation takes place synchronously inside the proxy.\n// The proxy uses the originatorId to skip over redundant events sent back\n// by the storage object.\n//\n// In unsynchronized mode removal is not based on the keys observed at the\n// proxy, since the proxy does not remember the state, but instead the set\n// of keys that exist at the storage object at the time it receives the\n// request.\nclass CollectionProxy extends StorageProxyBase {\n    constructor(...args) {\n        super(...args);\n        this._model = new CrdtCollectionModel();\n    }\n    _getModelForSync() {\n        return this._model.toList();\n    }\n    _synchronizeModel({ version, model }) {\n        this._version = version;\n        this._model = new CrdtCollectionModel(model);\n    }\n    _processUpdate(update, apply = true) {\n        if (this._synchronized == SyncState.full) {\n            // If we're synchronized, then any updates we sent have\n            // already been applied/notified.\n            for (let { handle } of this._observers) {\n                if (update.originatorId == handle._particleId) {\n                    return null;\n                }\n            }\n        }\n        let added = [];\n        let removed = [];\n        if ('add' in update) {\n            for (let { value, keys, effective } of update.add) {\n                if (apply && this._model.add(value.id, value, keys) || !apply && effective) {\n                    added.push(value);\n                }\n            }\n        }\n        else if ('remove' in update) {\n            for (let { value, keys, effective } of update.remove) {\n                if (apply && this._model.remove(value.id, keys) || !apply && effective) {\n                    removed.push(value);\n                }\n            }\n        }\n        else {\n            assert(false, `StorageProxy received invalid update event: ${JSON.stringify(update)}`);\n        }\n        if (added.length || removed.length) {\n            let result = {};\n            if (added.length)\n                result.add = added;\n            if (removed.length)\n                result.remove = removed;\n            result.originatorId = update.originatorId;\n            return result;\n        }\n        return null;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    toList(particleId) {\n        if (this._synchronized == SyncState.full) {\n            return Promise.resolve(this._model.toList());\n        }\n        else {\n            // TODO: in synchronized mode, this should integrate with SynchronizeProxy rather than\n            //       sending a parallel request\n            return new Promise((resolve, reject) => this._port.HandleToList({ callback: r => resolve(r), handle: this, particleId }));\n        }\n    }\n    store(value, keys, particleId) {\n        let id = value.id;\n        let data = {\n            value,\n            keys,\n        };\n        this._port.HandleStore({ data, handle: this, particleId });\n        if (this._synchronized != SyncState.full) {\n            return;\n        }\n        if (!this._model.add(id, value, keys)) {\n            return;\n        }\n        let update = {\n            originatorId: particleId,\n            add: [value],\n        };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n    remove(id, keys, particleId) {\n        if (this._synchronized != SyncState.full) {\n            let data = {\n                id,\n                keys: [],\n            };\n            this._port.HandleRemove({ data, handle: this, particleId });\n            return;\n        }\n        let value = this._model.getValue(id);\n        if (!value)\n            return;\n        if (keys.length == 0) {\n            keys = this._model.getKeys(id);\n        }\n        let data = {\n            id,\n            keys,\n        };\n        this._port.HandleRemove({ data, handle: this, particleId });\n        if (!this._model.remove(id, keys)) {\n            return;\n        }\n        let update = {\n            originatorId: particleId,\n            remove: [value],\n        };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n}\n// Variables are synchronized in a 'last-writer-wins' scheme. When the\n// VariableProxy mutates the model, it sets a barrier and expects to\n// receive the barrier value echoed back in a subsequent update event.\n// Between those two points in time updates are not applied or\n// notified about as these reflect concurrent writes that did not 'win'.\nclass VariableProxy extends StorageProxyBase {\n    constructor(...args) {\n        super(...args);\n        this._model = null;\n        this._barrier = null;\n    }\n    _getModelForSync() {\n        return this._model;\n    }\n    _synchronizeModel({ version, model }) {\n        this._version = version;\n        this._model = model.length == 0 ? null : model[0].value;\n        assert(this._model !== undefined);\n    }\n    _processUpdate(update, apply = true) {\n        assert('data' in update);\n        if (!apply)\n            return update;\n        // If we have set a barrier, suppress updates until after\n        // we have seen the barrier return via an update.\n        if (this._barrier != null) {\n            if (update.barrier == this._barrier) {\n                this._barrier = null;\n            }\n            return null;\n        }\n        this._model = update.data;\n        return update;\n    }\n    // Read ops: if we're synchronized we can just return the local copy of the data.\n    // Otherwise, send a request to the backing store.\n    // TODO: in synchronized mode, these should integrate with SynchronizeProxy rather than\n    //       sending a parallel request\n    get(particleId) {\n        if (this._synchronized == SyncState.full) {\n            return Promise.resolve(this._model);\n        }\n        else {\n            return new Promise((resolve, reject) => this._port.HandleGet({ callback: resolve, handle: this, particleId }));\n        }\n    }\n    set(entity, particleId) {\n        assert(entity !== undefined);\n        if (JSON.stringify(this._model) == JSON.stringify(entity)) {\n            return;\n        }\n        let barrier = this.generateID('barrier');\n        // TODO: is this already a clone?\n        this._model = JSON.parse(JSON.stringify(entity));\n        this._barrier = barrier;\n        this._port.HandleSet({ data: entity, handle: this, particleId, barrier });\n        let update = {\n            originatorId: particleId,\n            data: entity,\n        };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n    clear(particleId) {\n        if (this._model == null) {\n            return;\n        }\n        let barrier = this.generateID('barrier');\n        this._model = null;\n        this._barrier = barrier;\n        this._port.HandleClear({ handle: this, particleId, barrier });\n        let update = {\n            originatorId: particleId,\n            data: null,\n        };\n        this._notify('update', update, options => options.notifyUpdate);\n    }\n}\nexport class StorageProxyScheduler {\n    constructor() {\n        this._scheduled = false;\n        // Particle -> {Handle -> [Queue of events]}\n        this._queues = new Map();\n    }\n    // TODO: break apart args here, sync events should flush the queue.\n    enqueue(particle, handle, args) {\n        if (!this._queues.has(particle)) {\n            this._queues.set(particle, new Map());\n        }\n        let byHandle = this._queues.get(particle);\n        if (!byHandle.has(handle)) {\n            byHandle.set(handle, []);\n        }\n        let queue = byHandle.get(handle);\n        queue.push(args);\n        this._schedule();\n    }\n    get busy() {\n        return this._queues.size > 0;\n    }\n    _updateIdle() {\n        if (this._idleResolver && !this.busy) {\n            this._idleResolver();\n            this._idle = null;\n            this._idleResolver = null;\n        }\n    }\n    get idle() {\n        if (!this.busy) {\n            return Promise.resolve();\n        }\n        if (this._idle) {\n            return this._idle;\n        }\n        this._idle = new Promise(resolver => {\n            this._idleResolver = resolver;\n        });\n        return this._idle;\n    }\n    _schedule() {\n        if (this._scheduled) {\n            return;\n        }\n        this._scheduled = true;\n        setTimeout(() => {\n            this._scheduled = false;\n            this._dispatch();\n        }, 0);\n    }\n    _dispatch() {\n        // TODO: should we process just one particle per task?\n        while (this._queues.size > 0) {\n            let particle = [...this._queues.keys()][0];\n            let byHandle = this._queues.get(particle);\n            this._queues.delete(particle);\n            for (let [handle, queue] of byHandle.entries()) {\n                for (let args of queue) {\n                    try {\n                        handle._notify(...args);\n                    }\n                    catch (e) {\n                        console.error('Error dispatching to particle', e);\n                        handle._proxy.raiseSystemException(e, 'StorageProxyScheduler::_dispatch', particle.id);\n                    }\n                }\n            }\n        }\n        this._updateIdle();\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/storage-proxy.js\n// module id = 30\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport { assert } from '../../platform/assert-web.js';\n// Bulding block for CRDT collections. Tracks the membership (keys) of\n// values identified by unique IDs. A value is considered to be part\n// of the collection if the set of keys added by calls to\n// `add(id, ..., keys)` minus the set of keys removed by calls to\n// `remove(id, keys)` is non-empty.\n//\n// Note: This implementation does not guard against the case of the\n// same membership key being added more than once. Don't do that.\nexport class CrdtCollectionModel {\n    constructor(model) {\n        // id => {value, Set[keys]}\n        this._items = new Map();\n        if (model) {\n            for (let { id, value, keys } of model) {\n                if (!keys) {\n                    keys = [];\n                }\n                this._items.set(id, { value, keys: new Set(keys) });\n            }\n        }\n    }\n    // Adds membership, `keys`, of `value` indexed by `id` to this collection.\n    // Returns whether the change is effective (`id` is new to the collection,\n    // or `value` is different to the value previously stored).\n    add(id, value, keys) {\n        assert(keys.length > 0, 'add requires keys');\n        let item = this._items.get(id);\n        let effective = false;\n        if (!item) {\n            item = { value, keys: new Set(keys) };\n            this._items.set(id, item);\n            effective = true;\n        }\n        else {\n            let newKeys = false;\n            for (let key of keys) {\n                if (!item.keys.has(key)) {\n                    newKeys = true;\n                }\n                item.keys.add(key);\n            }\n            if (JSON.stringify(item.value) != JSON.stringify(value)) {\n                assert(newKeys, 'cannot add without new keys');\n                item.value = value;\n                effective = true;\n            }\n        }\n        return effective;\n    }\n    // Removes the membership, `keys`, of the value indexed by `id` from this collection.\n    // Returns whether the change is effective (the value is no longer present\n    // in the collection because all of the keys have been removed).\n    remove(id, keys) {\n        let item = this._items.get(id);\n        if (!item) {\n            return false;\n        }\n        for (let key of keys) {\n            item.keys.delete(key);\n        }\n        let effective = item.keys.size == 0;\n        if (effective) {\n            this._items.delete(id);\n        }\n        return effective;\n    }\n    // [{id, value, keys: []}]\n    toLiteral() {\n        let result = [];\n        for (let [id, { value, keys }] of this._items.entries()) {\n            result.push({ id, value, keys: [...keys] });\n        }\n        return result;\n    }\n    toList() {\n        return [...this._items.values()].map(item => item.value);\n    }\n    has(id) {\n        return this._items.has(id);\n    }\n    getKeys(id) {\n        let item = this._items.get(id);\n        return item ? [...item.keys] : [];\n    }\n    getValue(id) {\n        let item = this._items.get(id);\n        return item ? item.value : null;\n    }\n    get size() {\n        return this._items.size;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/storage/crdt-collection-model.js\n// module id = 31\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Type } from './type.js';\nexport class TupleFields {\n    constructor(fieldList) {\n        this.fieldList = fieldList;\n    }\n    static fromLiteral(literal) {\n        return new TupleFields(literal.map(a => Type.fromLiteral(a)));\n    }\n    toLiteral() {\n        return this.fieldList.map(a => a.toLiteral());\n    }\n    clone() {\n        return new TupleFields(this.fieldList.map(a => a.clone()));\n    }\n    equals(other) {\n        if (this.fieldList.length !== other.fieldList.length)\n            return false;\n        for (let i = 0; i < this.fieldList.length; i++) {\n            if (!this.fieldList[i].equals(other.fieldList[i]))\n                return false;\n        }\n        return true;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/runtime/tuple-fields.js\n// module id = 32\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst nob = () => Object.create(null);\nconst debounce = (key, action, delay) => {\n    if (key) {\n        window.clearTimeout(key);\n    }\n    if (action && delay) {\n        return window.setTimeout(action, delay);\n    }\n};\nconst XenStateMixin = Base => class extends Base {\n    constructor() {\n        super();\n        this._pendingProps = nob();\n        this._props = this._getInitialProps() || nob();\n        this._lastProps = nob();\n        this._state = this._getInitialState() || nob();\n        this._lastState = nob();\n    }\n    _getInitialProps() {\n    }\n    _getInitialState() {\n    }\n    _getProperty(name) {\n        return this._pendingProps[name] || this._props[name];\n    }\n    _setProperty(name, value) {\n        // dirty checking opportunity\n        if (this._validator || this._wouldChangeProp(name, value)) {\n            this._pendingProps[name] = value;\n            this._invalidateProps();\n        }\n    }\n    _wouldChangeValue(map, name, value) {\n        // TODO(sjmiles): fundamental dirty-checking issue here. Can be overridden to change\n        // behavior, but the default implementation will use strict reference checking.\n        // To modify structured values one must create a new Object with the new values.\n        // See `_setImmutableState`.\n        return (map[name] !== value);\n        // TODO(sjmiles): an example of dirty-checking that instead simply punts on structured data\n        //return (typeof value === 'object') || (map[name] !== value);\n    }\n    _wouldChangeProp(name, value) {\n        return this._wouldChangeValue(this._props, name, value);\n    }\n    _wouldChangeState(name, value) {\n        return this._wouldChangeValue(this._state, name, value);\n    }\n    _setProps(props) {\n        // TODO(sjmiles): should be a replace instead of a merge?\n        Object.assign(this._pendingProps, props);\n        this._invalidateProps();\n    }\n    _invalidateProps() {\n        this._propsInvalid = true;\n        this._invalidate();\n    }\n    _setImmutableState(name, value) {\n        if (typeof name === 'object') {\n            console.warn('Xen:: _setImmutableState takes name and value args for a single property, dictionaries not supported.');\n            value = Object.values(name)[0];\n            name = Object.names(name)[0];\n        }\n        if (typeof value === 'object') {\n            value = Object.assign(Object.create(null), value);\n        }\n        this._state[name] = value;\n        this._invalidate();\n    }\n    _setState(object) {\n        let dirty = false;\n        const state = this._state;\n        for (const property in object) {\n            const value = object[property];\n            if (this._wouldChangeState(property, value)) {\n                dirty = true;\n                state[property] = value;\n            }\n        }\n        if (dirty) {\n            this._invalidate();\n            return true;\n        }\n    }\n    // TODO(sjmiles): deprecated\n    _setIfDirty(object) {\n        return this._setState(object);\n    }\n    _async(fn) {\n        return Promise.resolve().then(fn.bind(this));\n        //return setTimeout(fn.bind(this), 10);\n    }\n    _invalidate() {\n        if (!this._validator) {\n            this._validator = this._async(this._validate);\n        }\n    }\n    _getStateArgs() {\n        return [this._props, this._state, this._lastProps, this._lastState];\n    }\n    _validate() {\n        const stateArgs = this._getStateArgs();\n        // try..catch to ensure we nullify `validator` before return\n        try {\n            // TODO(sjmiles): should be a replace instead of a merge\n            Object.assign(this._props, this._pendingProps);\n            if (this._propsInvalid) {\n                // TODO(sjmiles): should/can have different timing from rendering?\n                this._willReceiveProps(...stateArgs);\n                this._propsInvalid = false;\n            }\n            if (this._shouldUpdate(...stateArgs)) {\n                // TODO(sjmiles): consider throttling update to rAF\n                this._ensureMount();\n                this._doUpdate(...stateArgs);\n            }\n        }\n        catch (x) {\n            console.error(x);\n        }\n        // nullify validator _after_ methods so state changes don't reschedule validation\n        this._validator = null;\n        // save the old props and state\n        this._lastProps = Object.assign(nob(), this._props);\n        this._lastState = Object.assign(nob(), this._state);\n    }\n    _doUpdate(...stateArgs) {\n        this._update(...stateArgs);\n        this._didUpdate(...stateArgs);\n    }\n    _ensureMount() {\n    }\n    _willReceiveProps() {\n    }\n    _shouldUpdate() {\n        return true;\n    }\n    _update() {\n    }\n    _didUpdate() {\n    }\n    _debounce(key, func, delay) {\n        key = `_debounce_${key}`;\n        this._state[key] = debounce(this._state[key], func, delay != null ? delay : 16);\n    }\n};\nexport { XenStateMixin, nob, debounce };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./intermediate/shell/components/xen/xen-state.js\n// module id = 33\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {ParticleExecutionContext} from '../../intermediate/runtime/particle-execution-context.js';\nimport {BrowserLoader} from './browser-loader.js';\n\nconst log = console.log.bind(console, `%cworker-entry`, `background: #12005e; color: white; padding: 1px 6px 2px 7px; border-radius: 6px;`);\n\nself.onmessage = function(e) {\n  self.onmessage = null;\n  let {id, base} = e.data;\n  //log('starting worker', id);\n  new ParticleExecutionContext(e.ports[0], id, new BrowserLoader(base));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shell/source/worker-entry.js\n// module id = 34\n// module chunks = 0"],"sourceRoot":""}